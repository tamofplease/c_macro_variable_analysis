<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/statistics/mcv.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * mcv.c
 *	  POSTGRES multivariate MCV lists
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/statistics/mcv.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/extended_stats_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/statistics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/bytea.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Computes size of a serialized MCV item, depending on the number of
 * dimensions (columns) the statistic is defined on. The datum values are
 * stored in a separate array (deduplicated, to minimize the size), and
 * so the serialized items only store uint16 indexes into that array.
 *
 * Each serialized item store (in this order):
 *
 * - indexes to values	  (ndim * sizeof(uint16))
 * - null flags			  (ndim * sizeof(bool))
 * - frequency			  (sizeof(double))
 * - base_frequency		  (sizeof(double))
 *
 * So in total each MCV item requires this many bytes:
 *
 *	 ndim * (sizeof(uint16) + sizeof(bool)) + 2 * sizeof(double)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ITEM_SIZE</name><parameter_list>(<parameter><type><name>ndims</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>MAXALIGN((ndims) * (sizeof(uint16) + sizeof(bool)) + 2 * sizeof(double))</cpp:value></cpp:define>

<comment type="block">/*
 * Macros for convenient access to parts of a serialized MCV item.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ITEM_INDEXES</name><parameter_list>(<parameter><type><name>item</name></type></parameter>)</parameter_list></cpp:macro>			<cpp:value>((uint16 *) (item))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ITEM_NULLS</name><parameter_list>(<parameter><type><name>item</name></type></parameter>,<parameter><type><name>ndims</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((bool *) (ITEM_INDEXES(item) + (ndims)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ITEM_FREQUENCY</name><parameter_list>(<parameter><type><name>item</name></type></parameter>,<parameter><type><name>ndims</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((double *) (ITEM_NULLS(item, ndims) + (ndims)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ITEM_BASE_FREQUENCY</name><parameter_list>(<parameter><type><name>item</name></type></parameter>,<parameter><type><name>ndims</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((double *) (ITEM_FREQUENCY(item, ndims) + 1))</cpp:value></cpp:define>

<comment type="block">/*
 * Used to compute size of serialized MCV list representation.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MinSizeOfMCVList</name></cpp:macro>		\
	<cpp:value>(VARHDRSZ + sizeof(uint32) * 3 + sizeof(AttrNumber))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SizeOfMCVList</name><parameter_list>(<parameter><type><name>ndims</name></type></parameter>,<parameter><type><name>nitems</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>(MAXALIGN(MinSizeOfMCVList + sizeof(Oid) * (ndims)) + \
	 MAXALIGN((ndims) * sizeof(DimensionInfo)) + \
	 MAXALIGN((nitems) * ITEM_SIZE(ndims)))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>MultiSortSupport</name></type> <name>build_mss</name><parameter_list>(<parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numattrs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>SortItem</name> <modifier>*</modifier></type><name>build_distinct_groups</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>, <parameter><decl><type><name>SortItem</name> <modifier>*</modifier></type><name>items</name></decl></parameter>,
									   <parameter><decl><type><name>MultiSortSupport</name></type> <name>mss</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ndistinct</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>count_distinct_groups</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>, <parameter><decl><type><name>SortItem</name> <modifier>*</modifier></type><name>items</name></decl></parameter>,
								  <parameter><decl><type><name>MultiSortSupport</name></type> <name>mss</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * get_mincount_for_mcv_list
 * 		Determine the minimum number of times a value needs to appear in
 * 		the sample for it to be included in the MCV list.
 *
 * We want to keep only values that appear sufficiently often in the
 * sample that it is reasonable to extrapolate their sample frequencies to
 * the entire table.  We do this by placing an upper bound on the relative
 * standard error of the sample frequency, so that any estimates the
 * planner generates from the MCV statistics can be expected to be
 * reasonably accurate.
 *
 * Since we are sampling without replacement, the sample frequency of a
 * particular value is described by a hypergeometric distribution.  A
 * common rule of thumb when estimating errors in this situation is to
 * require at least 10 instances of the value in the sample, in which case
 * the distribution can be approximated by a normal distribution, and
 * standard error analysis techniques can be applied.  Given a sample size
 * of n, a population size of N, and a sample frequency of p=cnt/n, the
 * standard error of the proportion p is given by
 *		SE = sqrt(p*(1-p)/n) * sqrt((N-n)/(N-1))
 * where the second term is the finite population correction.  To get
 * reasonably accurate planner estimates, we impose an upper bound on the
 * relative standard error of 20% -- i.e., SE/p &lt; 0.2.  This 20% relative
 * error bound is fairly arbitrary, but has been found empirically to work
 * well.  Rearranging this formula gives a lower bound on the number of
 * instances of the value seen:
 *		cnt &gt; n*(N-n) / (N-n+0.04*n*(N-1))
 * This bound is at most 25, and approaches 0 as n approaches 0 or N. The
 * case where n approaches 0 cannot happen in practice, since the sample
 * size is at least 300.  The case where n approaches N corresponds to
 * sampling the whole the table, in which case it is reasonable to keep
 * the whole MCV list (have no lower bound), so it makes sense to apply
 * this formula for all inputs, even though the above derivation is
 * technically only valid when the right hand side is at least around 10.
 *
 * An alternative way to look at this formula is as follows -- assume that
 * the number of instances of the value seen scales up to the entire
 * table, so that the population count is K=N*cnt/n. Then the distribution
 * in the sample is a hypergeometric distribution parameterised by N, n
 * and K, and the bound above is mathematically equivalent to demanding
 * that the standard deviation of that distribution is less than 20% of
 * its mean.  Thus the relative errors in any planner estimates produced
 * from the MCV statistics are likely to be not too large.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>get_mincount_for_mcv_list</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>n</name> <init>= <expr><name>samplerows</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>N</name> <init>= <expr><name>totalrows</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numer</name></decl>,
				<decl><type ref="prev"/><name>denom</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>numer</name> <operator>=</operator> <name>n</name> <operator>*</operator> <operator>(</operator><name>N</name> <operator>-</operator> <name>n</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>denom</name> <operator>=</operator> <name>N</name> <operator>-</operator> <name>n</name> <operator>+</operator> <literal type="number">0.04</literal> <operator>*</operator> <name>n</name> <operator>*</operator> <operator>(</operator><name>N</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Guard against division by zero (possible if n = N = 1) */</comment>
	<if_stmt><if>if <condition>(<expr><name>denom</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>numer</name> <operator>/</operator> <name>denom</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Builds MCV list from the set of sampled rows.
 *
 * The algorithm is quite simple:
 *
 *	   (1) sort the data (default collation, '&lt;' for the data type)
 *
 *	   (2) count distinct groups, decide how many to keep
 *
 *	   (3) build the MCV list using the threshold determined in (2)
 *
 *	   (4) remove rows represented by the MCV from the sample
 *
 */</comment>
<function><type><name>MCVList</name> <modifier>*</modifier></type>
<name>statext_mcv_build</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>,
				  <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>numattrs</name></decl>,
				<decl><type ref="prev"/><name>ngroups</name></decl>,
				<decl><type ref="prev"/><name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>mincount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortItem</name>   <modifier>*</modifier></type><name>items</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortItem</name>   <modifier>*</modifier></type><name>groups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MCVList</name>    <modifier>*</modifier></type><name>mcvlist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiSortSupport</name></type> <name>mss</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>build_attnums_array</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* comparator for all the columns */</comment>
	<expr_stmt><expr><name>mss</name> <operator>=</operator> <call><name>build_mss</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>numattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sort the rows */</comment>
	<expr_stmt><expr><name>items</name> <operator>=</operator> <call><name>build_sorted_items</name><argument_list>(<argument><expr><name>numrows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name><name>stats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>tupDesc</name></expr></argument>,
							   <argument><expr><name>mss</name></expr></argument>, <argument><expr><name>numattrs</name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>items</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* transform the sorted rows into groups (sorted by frequency) */</comment>
	<expr_stmt><expr><name>groups</name> <operator>=</operator> <call><name>build_distinct_groups</name><argument_list>(<argument><expr><name>nitems</name></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>mss</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ngroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Maximum number of MCV items to store, based on the attribute with the
	 * largest stats target (and the number of groups we have available).
	 */</comment>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <name><name>stats</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>&gt;</operator> <name>nitems</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nitems</name> <operator>=</operator> <name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&gt;</operator> <name>ngroups</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nitems</name> <operator>=</operator> <name>ngroups</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Decide how many items to keep in the MCV list. We can't use the same
	 * algorithm as per-column MCV lists, because that only considers the
	 * actual group frequency - but we're primarily interested in how the
	 * actual frequency differs from the base frequency (product of simple
	 * per-column frequencies, as if the columns were independent).
	 *
	 * Using the same algorithm might exclude items that are close to the
	 * "average" frequency of the sample. But that does not say whether the
	 * observed frequency is close to the base frequency or not. We also need
	 * to consider unexpectedly uncommon items (again, compared to the base
	 * frequency), and the single-column algorithm does not have to.
	 *
	 * We simply decide how many items to keep by computing minimum count
	 * using get_mincount_for_mcv_list() and then keep all items that seem to
	 * be more common than that.
	 */</comment>
	<expr_stmt><expr><name>mincount</name> <operator>=</operator> <call><name>get_mincount_for_mcv_list</name><argument_list>(<argument><expr><name>numrows</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Walk the groups until we find the first group with a count below the
	 * mincount threshold (the index of that group is the number of groups we
	 * want to keep).
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&lt;</operator> <name>mincount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nitems</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * At this point we know the number of items for the MCV list. There might
	 * be none (for uniform distribution with many groups), and in that case
	 * there will be no MCV list. Otherwise construct the MCV list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Allocate the MCV list structure, set the global parameters.
		 */</comment>
		<expr_stmt><expr><name>mcvlist</name> <operator>=</operator> <operator>(</operator><name>MCVList</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MCVList</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call> <operator>+</operator>
									  <sizeof>sizeof<argument_list>(<argument><expr><name>MCVItem</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>STATS_MCV_MAGIC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>STATS_MCV_TYPE_BASIC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>ndimensions</name></name> <operator>=</operator> <name>numattrs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <name>nitems</name></expr>;</expr_stmt>

		<comment type="block">/* store info about data type OIDs */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attrtypid</name></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/* Copy the first chunk of groups into the result. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* just pointer to the proper place in the list */</comment>
			<decl_stmt><decl><type><name>MCVItem</name>    <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>values</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* copy values for the group */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>values</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>, <argument><expr><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* groups should be sorted by frequency in descending order */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>groups</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;=</operator> <name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* group frequency */</comment>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>/</operator> <name>numrows</name></expr>;</expr_stmt>

			<comment type="block">/* base frequency, if the attributes were independent */</comment>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>base_frequency</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>ngroups</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>multi_sort_compare_dim</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>groups</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>mss</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>count</name> <operator>+=</operator> <name><name>groups</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>

				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>base_frequency</name></name> <operator>*=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>count</name> <operator>/</operator> <name>numrows</name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>mcvlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build_mss
 *	build MultiSortSupport for the attributes passed in attrs
 */</comment>
<function><type><specifier>static</specifier> <name>MultiSortSupport</name></type>
<name>build_mss</name><parameter_list>(<parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numattrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Sort by multiple columns (using array of SortSupport) */</comment>
	<decl_stmt><decl><type><name>MultiSortSupport</name></type> <name>mss</name> <init>= <expr><call><name>multi_sort_init</name><argument_list>(<argument><expr><name>numattrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* prepare the sort functions for all the attributes */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>colstat</name> <init>= <expr><name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>colstat</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>, <argument><expr><name>TYPECACHE_LT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>lt_opr</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for ordering operator for type %u"</literal></expr></argument>,
				 <argument><expr><name><name>colstat</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>multi_sort_add_dimension</name><argument_list>(<argument><expr><name>mss</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>lt_opr</name></name></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>typcollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>mss</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * count_distinct_groups
 *	count distinct combinations of SortItems in the array
 *
 * The array is assumed to be sorted according to the MultiSortSupport.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_distinct_groups</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>, <parameter><decl><type><name>SortItem</name> <modifier>*</modifier></type><name>items</name></decl></parameter>, <parameter><decl><type><name>MultiSortSupport</name></type> <name>mss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndistinct</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numrows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* make sure the array really is sorted */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>multi_sort_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>mss</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>multi_sort_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>mss</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ndistinct</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>ndistinct</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compare_sort_item_count
 *	comparator for sorting items by count (frequencies) in descending order
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_sort_item_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortItem</name>   <modifier>*</modifier></type><name>ia</name> <init>= <expr><operator>(</operator><name>SortItem</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortItem</name>   <modifier>*</modifier></type><name>ib</name> <init>= <expr><operator>(</operator><name>SortItem</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ia</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <name><name>ib</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ia</name><operator>-&gt;</operator><name>count</name></name> <operator>&gt;</operator> <name><name>ib</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build_distinct_groups
 *	build an array of SortItems for distinct groups and counts matching items
 *
 * The input array is assumed to be sorted
 */</comment>
<function><type><specifier>static</specifier> <name>SortItem</name> <modifier>*</modifier></type>
<name>build_distinct_groups</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>, <parameter><decl><type><name>SortItem</name> <modifier>*</modifier></type><name>items</name></decl></parameter>, <parameter><decl><type><name>MultiSortSupport</name></type> <name>mss</name></decl></parameter>,
					  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ndistinct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ngroups</name> <init>= <expr><call><name>count_distinct_groups</name><argument_list>(<argument><expr><name>numrows</name></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>mss</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SortItem</name>   <modifier>*</modifier></type><name>groups</name> <init>= <expr><operator>(</operator><name>SortItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ngroups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>groups</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>groups</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numrows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Assume sorted in ascending order. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>multi_sort_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>mss</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* New distinct group detected. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>multi_sort_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>mss</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>groups</name><index>[<expr><operator>++</operator><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>groups</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>groups</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* ensure we filled the expected number of distinct groups */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>ngroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort the distinct groups by frequency (in descending order). */</comment>
	<expr_stmt><expr><call><name>pg_qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>groups</name></expr></argument>, <argument><expr><name>ngroups</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SortItem</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><name>compare_sort_item_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>ndistinct</name> <operator>=</operator> <name>ngroups</name></expr>;</expr_stmt>
	<return>return <expr><name>groups</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * statext_mcv_load
 *		Load the MCV list for the indicated pg_statistic_ext tuple
 */</comment>
<function><type><name>MCVList</name> <modifier>*</modifier></type>
<name>statext_mcv_load</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>mvoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MCVList</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>mcvlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>STATEXTDATASTXOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>mvoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for statistics object %u"</literal></expr></argument>, <argument><expr><name>mvoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>mcvlist</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>STATEXTDATASTXOID</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>,
							  <argument><expr><name>Anum_pg_statistic_ext_data_stxdmcv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"requested statistic kind \"%c\" is not yet built for statistics object %u"</literal></expr></argument>,
			 <argument><expr><name>STATS_EXT_DEPENDENCIES</name></expr></argument>, <argument><expr><name>mvoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>statext_mcv_deserialize</name><argument_list>(<argument><expr><call><name>DatumGetByteaP</name><argument_list>(<argument><expr><name>mcvlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * statext_mcv_serialize
 *		Serialize MCV list into a pg_mcv_list value.
 *
 * The MCV items may include values of various data types, and it's reasonable
 * to expect redundancy (values for a given attribute, repeated for multiple
 * MCV list items). So we deduplicate the values into arrays, and then replace
 * the values by indexes into those arrays.
 *
 * The overall structure of the serialized representation looks like this:
 *
 * +---------------+----------------+---------------------+-------+
 * | header fields | dimension info | deduplicated values | items |
 * +---------------+----------------+---------------------+-------+
 *
 * Where dimension info stores information about type of K-th attribute (e.g.
 * typlen, typbyval and length of deduplicated values).  Deduplicated values
 * store deduplicated values for each attribute.  And items store the actual
 * MCV list items, with values replaced by indexes into the arrays.
 *
 * When serializing the items, we use uint16 indexes. The number of MCV items
 * is limited by the statistics target (which is capped to 10k at the moment).
 * We might increase this to 65k and still fit into uint16, so there's a bit of
 * slack. Furthermore, this limit is on the number of distinct values per column,
 * and we usually have few of those (and various combinations of them for the
 * those MCV list). So uint16 seems fine for now.
 *
 * We don't really expect the serialization to save as much space as for
 * histograms, as we are not doing any bucket splits (which is the source
 * of high redundancy in histograms).
 *
 * TODO: Consider packing boolean flags (NULL) for each item into a single char
 * (or a longer type) instead of using an array of bool items.
 */</comment>
<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>statext_mcv_serialize</name><parameter_list>(<parameter><decl><type><name>MCVList</name> <modifier>*</modifier></type><name>mcvlist</name></decl></parameter>, <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name> <init>= <expr><name><name>mcvlist</name><operator>-&gt;</operator><name>ndimensions</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>itemsize</name> <init>= <expr><call><name>ITEM_SIZE</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DimensionInfo</name> <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Size</name></type>		<name>total_length</name></decl>;</decl_stmt>

	<comment type="block">/* allocate the item just once */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>itemsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* serialized items (indexes into arrays, etc.) */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>raw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<comment type="block">/* values per dimension (and number of non-NULL values) */</comment>
	<decl_stmt><decl><type><name>Datum</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>values</name> <init>= <expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>counts</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We'll include some rudimentary information about the attribute types
	 * (length, by-val flag), so that we don't have to look them up while
	 * deserializating the MCV list (we already have the type OID in the
	 * header).  This is safe, because when changing type of the attribute the
	 * statistics gets dropped automatically.  We need to store the info about
	 * the arrays of deduplicated values anyway.
	 */</comment>
	<expr_stmt><expr><name>info</name> <operator>=</operator> <operator>(</operator><name>DimensionInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DimensionInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sort support data for all attributes included in the MCV list */</comment>
	<expr_stmt><expr><name>ssup</name> <operator>=</operator> <operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SortSupportData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* collect and deduplicate values for each dimension (attribute) */</comment>
	<for>for <control>(<init><expr><name>dim</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dim</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>dim</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndistinct</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Lookup the LT operator (can't get it from stats extra_data, as we
		 * don't know how to interpret that - scalar vs. array etc.).
		 */</comment>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>stats</name><index>[<expr><name>dim</name></expr>]</index></name><operator>-&gt;</operator><name>attrtypid</name></expr></argument>, <argument><expr><name>TYPECACHE_LT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* copy important info about the data type (length, by-value) */</comment>
		<expr_stmt><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name> <operator>=</operator> <name><name>stats</name><index>[<expr><name>dim</name></expr>]</index></name><operator>-&gt;</operator><name><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typbyval</name> <operator>=</operator> <name><name>stats</name><index>[<expr><name>dim</name></expr>]</index></name><operator>-&gt;</operator><name><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>

		<comment type="block">/* allocate space for values in the attribute and collect them */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* skip NULL values - we don't need to deduplicate those */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>mcvlist</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>isnull</name><index>[<expr><name>dim</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* append the value at the end */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name><name>counts</name><index>[<expr><name>dim</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>values</name><index>[<expr><name>dim</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>counts</name><index>[<expr><name>dim</name></expr>]</index></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* if there are just NULL values in this dimension, we're done */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>counts</name><index>[<expr><name>dim</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* sort and deduplicate the data */</comment>
		<expr_stmt><expr><name><name>ssup</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>ssup_cxt</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ssup</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>ssup_collation</name> <operator>=</operator> <name>DEFAULT_COLLATION_OID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ssup</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>ssup_nulls_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PrepareSortSupportFromOrderingOp</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>lt_opr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ssup</name><index>[<expr><name>dim</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>counts</name><index>[<expr><name>dim</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>compare_scalars_simple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ssup</name><index>[<expr><name>dim</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Walk through the array and eliminate duplicate values, but keep the
		 * ordering (so that we can do bsearch later). We know there's at
		 * least one item as (counts[dim] != 0), so we can skip the first
		 * element.
		 */</comment>
		<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>			<comment type="block">/* number of distinct values */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>counts</name><index>[<expr><name>dim</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* expect sorted array */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>compare_datums_simple</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ssup</name><index>[<expr><name>dim</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* if the value is the same as the previous one, we can skip it */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>compare_datums_simple</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ssup</name><index>[<expr><name>dim</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>ndistinct</name></expr>]</index></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ndistinct</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* we must not exceed PG_UINT16_MAX, as we use uint16 indexes */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ndistinct</name> <operator>&lt;=</operator> <name>PG_UINT16_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Store additional info about the attribute - number of deduplicated
		 * values, and also size of the serialized data. For fixed-length data
		 * types this is trivial to compute, for varwidth types we need to
		 * actually walk the array and sum the sizes.
		 */</comment>
		<expr_stmt><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nvalues</name> <operator>=</operator> <name>ndistinct</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* fixed-length data types */</comment>
			<expr_stmt><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name> <operator>=</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nvalues</name> <operator>*</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>	<comment type="block">/* varlena */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nvalues</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>	<comment type="block">/* cstring */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nvalues</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>

				<comment type="block">/* c-strings include terminator, so +1 byte */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* we know (count&gt;0) so there must be some data */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now we can finally compute how much space we'll actually need for the
	 * whole serialized MCV list (varlena header, MCV header, dimension info
	 * for each attribute, deduplicated values and items).
	 *
	 * The header fields are copied one by one, so that we don't need any
	 * explicit alignment (we copy them while deserializing). All fields after
	 * this need to be properly aligned, for direct access.
	 */</comment>
	<expr_stmt><expr><name>total_length</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <operator>(</operator><literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof><operator>)</operator>
							<operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* dimension info */</comment>
	<expr_stmt><expr><name>total_length</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DimensionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add space for the arrays of deduplicated values */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>total_length</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * And finally the items (no additional alignment needed, we start at
	 * proper alignment and the itemsize formula uses MAXALIGN)
	 */</comment>
	<expr_stmt><expr><name>total_length</name> <operator>+=</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name> <operator>*</operator> <name>itemsize</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate space for the whole serialized MCV list (we'll skip bytes, so
	 * we set them to zero to make the result more compressible).
	 */</comment>
	<expr_stmt><expr><name>raw</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>total_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>raw</name></expr></argument>, <argument><expr><name>total_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>raw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy the MCV list header fields, one by one */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>ndimensions</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>types</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* the header may not be exactly aligned, so make sure it is */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>raw</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>ptr</name> <operator>-</operator> <name>raw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* store information about the attributes */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DimensionInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DimensionInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the deduplicated values for all attributes to the output. */</comment>
	<for>for <control>(<init><expr><name>dim</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dim</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>dim</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* remember the starting point for Asserts later */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier><name>start</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nvalues</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name> <init>= <expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typbyval</name></expr>)</condition> <comment type="block">/* passed by value */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>tmp</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * For values passed by value, we need to copy just the
				 * significant bytes - we can't use memcpy directly, as that
				 * assumes little endian behavior.  store_att_byval does
				 * almost what we need, but it requires properly aligned
				 * buffer - the output buffer does not guarantee that. So we
				 * simply use a static Datum variable (which guarantees proper
				 * alignment), and then copy the value from it.
				 */</comment>
				<expr_stmt><expr><call><name>store_att_byval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>	<comment type="block">/* passed by reference */</comment>
			<block>{<block_content>
				<comment type="block">/* no special alignment needed, treated as char array */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>	<comment type="block">/* varlena */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>	<comment type="block">/* cstring */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Size</name></type>		<name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* terminator */</comment>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* no underflows or overflows */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ptr</name> <operator>&gt;</operator> <name>start</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name>start</name><operator>)</operator> <operator>&lt;=</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* we should get exactly nbytes of data for this dimension */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ptr</name> <operator>-</operator> <name>start</name><operator>)</operator> <operator>==</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make sure the pointer is aligned correctly after each dimension */</comment>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>raw</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>ptr</name> <operator>-</operator> <name>raw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Serialize the items, with uint16 indexes instead of the values. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MCVItem</name>    <modifier>*</modifier></type><name>mcvitem</name> <init>= <expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* don't write beyond the allocated space */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>&lt;=</operator> <name>raw</name> <operator>+</operator> <name>total_length</name> <operator>-</operator> <name>itemsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* reset the item (we only allocate it once and reuse it) */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>itemsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>dim</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dim</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>dim</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

			<comment type="block">/* do the lookup only for non-NULL values */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>mcvitem</name><operator>-&gt;</operator><name>isnull</name><index>[<expr><name>dim</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>bsearch_arg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mcvitem</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>dim</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>dim</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nvalues</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										  <argument><expr><name>compare_scalars_simple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ssup</name><index>[<expr><name>dim</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* serialization or deduplication error */</comment>

			<comment type="block">/* compute index within the array */</comment>
			<expr_stmt><expr><call><name>ITEM_INDEXES</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call><index>[<expr><name>dim</name></expr>]</index> <operator>=</operator> <operator>(</operator><name>uint16</name><operator>)</operator> <operator>(</operator><name>value</name> <operator>-</operator> <name><name>values</name><index>[<expr><name>dim</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

			<comment type="block">/* check the index is within expected bounds */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ITEM_INDEXES</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call><index>[<expr><name>dim</name></expr>]</index> <operator>&lt;</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* copy NULL and frequency flags into the item */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ITEM_NULLS</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>ndims</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>mcvitem</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ITEM_FREQUENCY</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>ndims</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mcvitem</name><operator>-&gt;</operator><name>frequency</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ITEM_BASE_FREQUENCY</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>ndims</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mcvitem</name><operator>-&gt;</operator><name>base_frequency</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* copy the serialized item into the array */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>itemsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>itemsize</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* at this point we expect to match the total_length exactly */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ptr</name> <operator>-</operator> <name>raw</name><operator>)</operator> <operator>==</operator> <name>total_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>counts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator> <name>raw</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * statext_mcv_deserialize
 *		Reads serialized MCV list into MCVList structure.
 *
 * All the memory needed by the MCV list is allocated as a single chunk, so
 * it's possible to simply pfree() it at once.
 */</comment>
<function><type><name>MCVList</name> <modifier>*</modifier></type>
<name>statext_mcv_deserialize</name><parameter_list>(<parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dim</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>expected_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MCVList</name>    <modifier>*</modifier></type><name>mcvlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>raw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name></decl>,
				<decl><type ref="prev"/><name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DimensionInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* local allocation buffer (used only for deserialization) */</comment>
	<decl_stmt><decl><type><name>Datum</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* MCV list */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>mcvlen</name></decl>;</decl_stmt>

	<comment type="block">/* buffer used for the result */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>datalen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dataptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>valuesptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>isnullptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We can't possibly deserialize a MCV list if there's not even a complete
	 * header. We need an explicit formula here, because we serialize the
	 * header fields one by one, so we need to ignore struct alignment.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MinSizeOfMCVList</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid MCV size %zd (expected at least %zu)"</literal></expr></argument>,
			 <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MinSizeOfMCVList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* read the MCV list header */</comment>
	<expr_stmt><expr><name>mcvlist</name> <operator>=</operator> <operator>(</operator><name>MCVList</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MCVList</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pointer to the data part (skip the varlena header) */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>raw</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>

	<comment type="block">/* get the header and perform further sanity checks */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>ndimensions</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mcvlist</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>STATS_MCV_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid MCV magic %u (expected %u)"</literal></expr></argument>,
			 <argument><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>, <argument><expr><name>STATS_MCV_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mcvlist</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>STATS_MCV_TYPE_BASIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid MCV type %u (expected %u)"</literal></expr></argument>,
			 <argument><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>STATS_MCV_TYPE_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mcvlist</name><operator>-&gt;</operator><name>ndimensions</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid zero-length dimension array in MCVList"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>ndimensions</name></name> <operator>&gt;</operator> <name>STATS_MAX_DIMENSIONS</name><operator>)</operator> <operator>||</operator>
			 <operator>(</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>ndimensions</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid length (%d) dimension array in MCVList"</literal></expr></argument>,
			 <argument><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>ndimensions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid zero-length item array in MCVList"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name> <operator>&gt;</operator> <name>STATS_MCVLIST_MAX_ITEMS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid length (%u) item array in MCVList"</literal></expr></argument>,
			 <argument><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndims</name> <operator>=</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>ndimensions</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check amount of data including DimensionInfo for all dimensions and
	 * also the serialized items (including uint16 indexes). Also, walk
	 * through the dimension information and add it to the sum.
	 */</comment>
	<expr_stmt><expr><name>expected_size</name> <operator>=</operator> <call><name>SizeOfMCVList</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that we have at least the dimension and info records, along with
	 * the items. We don't know the size of the serialized values yet. We need
	 * to do this check first, before accessing the dimension info.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>expected_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid MCV size %zd (expected %zu)"</literal></expr></argument>,
			 <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expected_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now copy the array of type Oids. */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>types</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* ensure alignment of the pointer (after the header fields) */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>raw</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>ptr</name> <operator>-</operator> <name>raw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now it's safe to access the dimension info. */</comment>
	<expr_stmt><expr><name>info</name> <operator>=</operator> <operator>(</operator><name>DimensionInfo</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DimensionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* account for the value arrays */</comment>
	<for>for <control>(<init><expr><name>dim</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dim</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>dim</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * XXX I wonder if we can/should rely on asserts here. Maybe those
		 * checks should be done every time?
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nvalues</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>expected_size</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now we know the total expected MCV size, including all the pieces
	 * (header, dimension info. items and deduplicated data). So do the final
	 * check on size.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>expected_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid MCV size %zd (expected %zu)"</literal></expr></argument>,
			 <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>expected_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We need an array of Datum values for each dimension, so that we can
	 * easily translate the uint16 indexes later. We also need a top-level
	 * array of pointers to those per-dimension arrays.
	 *
	 * While allocating the arrays for dimensions, compute how much space we
	 * need for a copy of the by-ref data, as we can't simply point to the
	 * original values (it might go away).
	 */</comment>
	<expr_stmt><expr><name>datalen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* space for by-ref data */</comment>
	<expr_stmt><expr><name>map</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>dim</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dim</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>dim</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>map</name><index>[<expr><name>dim</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* space needed for a copy of data for by-ref types */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typbyval</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>datalen</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now resize the MCV list so that the allocation includes all the data
	 * Allocate space for a copy of the data, as we can't simply reference the
	 * original data - it may disappear while we're still using the MCV list,
	 * e.g. due to catcache release. Only needed for by-ref types.
	 */</comment>
	<expr_stmt><expr><name>mcvlen</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MCVList</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>MCVItem</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nitems</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* arrays of values and isnull flags for all MCV items */</comment>
	<expr_stmt><expr><name>mcvlen</name> <operator>+=</operator> <name>nitems</name> <operator>*</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mcvlen</name> <operator>+=</operator> <name>nitems</name> <operator>*</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we don't quite need to align this, but it makes some asserts easier */</comment>
	<expr_stmt><expr><name>mcvlen</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now resize the deserialized MCV list, and compute pointers to parts */</comment>
	<expr_stmt><expr><name>mcvlist</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>mcvlist</name></expr></argument>, <argument><expr><name>mcvlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pointer to the beginning of values/isnull arrays */</comment>
	<expr_stmt><expr><name>valuesptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mcvlist</name>
		<operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MCVList</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>MCVItem</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nitems</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>isnullptr</name> <operator>=</operator> <name>valuesptr</name> <operator>+</operator> <operator>(</operator><name>nitems</name> <operator>*</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>dataptr</name> <operator>=</operator> <name>isnullptr</name> <operator>+</operator> <operator>(</operator><name>nitems</name> <operator>*</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build mapping (index =&gt; value) for translating the serialized data into
	 * the in-memory representation.
	 */</comment>
	<for>for <control>(<init><expr><name>dim</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dim</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>dim</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* remember start position in the input array */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier><name>start</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typbyval</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* for by-val types we simply copy data into the mapping */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nvalues</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>map</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>fetch_att</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* no under/overflow of input array */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>&lt;=</operator> <operator>(</operator><name>start</name> <operator>+</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* for by-ref types we need to also make a copy of the data */</comment>

			<comment type="block">/* passed by reference, but fixed length (name, tid, ...) */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nvalues</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dataptr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name></expr>;</expr_stmt>

					<comment type="block">/* just point into the array */</comment>
					<expr_stmt><expr><name><name>map</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>dataptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dataptr</name> <operator>+=</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* varlena */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nvalues</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Size</name></type>		<name>len</name> <init>= <expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dataptr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* just point into the array */</comment>
					<expr_stmt><expr><name><name>map</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>dataptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dataptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* cstring */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nvalues</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Size</name></type>		<name>len</name> <init>= <expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>	<comment type="block">/* don't forget the \0 */</comment>

					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dataptr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* just point into the array */</comment>
					<expr_stmt><expr><name><name>map</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>dataptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dataptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* no under/overflow of input array */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>&lt;=</operator> <operator>(</operator><name>start</name> <operator>+</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* no overflow of the output mcv value */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dataptr</name> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mcvlist</name> <operator>+</operator> <name>mcvlen</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* check we consumed input data for this dimension exactly */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>==</operator> <operator>(</operator><name>start</name> <operator>+</operator> <name><name>info</name><index>[<expr><name>dim</name></expr>]</index></name><operator>.</operator><name>nbytes</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ensure proper alignment of the data */</comment>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>raw</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>ptr</name> <operator>-</operator> <name>raw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* we should have also filled the MCV list exactly */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dataptr</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>mcvlist</name> <operator>+</operator> <name>mcvlen</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* deserialize the MCV items and translate the indexes to Datums */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint16</name>	   <modifier>*</modifier></type><name>indexes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MCVItem</name>    <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>values</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <name>valuesptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>valuesptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <name>isnullptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnullptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<comment type="block">/* just point to the right place */</comment>
		<expr_stmt><expr><name>indexes</name> <operator>=</operator> <call><name>ITEM_INDEXES</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>, <argument><expr><call><name>ITEM_NULLS</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ndims</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name></expr></argument>, <argument><expr><call><name>ITEM_FREQUENCY</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ndims</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>base_frequency</name></name></expr></argument>, <argument><expr><call><name>ITEM_BASE_FREQUENCY</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ndims</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* translate the values */</comment>
		<for>for <control>(<init><expr><name>dim</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dim</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>dim</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>item</name><operator>-&gt;</operator><name>isnull</name><index>[<expr><name>dim</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>dim</name></expr>]</index></name> <operator>=</operator> <name><name>map</name><index>[<expr><name>dim</name></expr>]</index><index>[<expr><name><name>indexes</name><index>[<expr><name>dim</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>ITEM_SIZE</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check we're not overflowing the input */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>&lt;=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>raw</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* check that we processed all the data */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>==</operator> <name>raw</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* release the buffers used for mapping */</comment>
	<for>for <control>(<init><expr><name>dim</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>dim</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>dim</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>map</name><index>[<expr><name>dim</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>mcvlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SRF with details about buckets of a histogram:
 *
 * - item ID (0...nitems)
 * - values (string array)
 * - nulls only (boolean array)
 * - frequency (double precision)
 * - base_frequency (double precision)
 *
 * The input is the OID of the statistics, and there are no rows returned if
 * the statistics contains no histogram.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_stats_ext_mcvlist_items</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>call_cntr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_calls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>

	<comment type="block">/* stuff done only on the first call of the function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MCVList</name>    <modifier>*</modifier></type><name>mcvlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* switch to memory context appropriate for multiple function calls */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>mcvlist</name> <operator>=</operator> <call><name>statext_mcv_deserialize</name><argument_list>(<argument><expr><call><name>PG_GETARG_BYTEA_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>mcvlist</name></expr>;</expr_stmt>

		<comment type="block">/* total number of tuples to be returned */</comment>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Build a tuple descriptor for our result type */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning record called in context "</literal>
							<literal type="string">"that cannot accept type record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * generate attribute metadata needed later to produce tuples from raw
		 * C strings
		 */</comment>
		<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>attinmeta</name></name> <operator>=</operator> <name>attinmeta</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* stuff done on every call of the function */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>call_cntr</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_calls</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>attinmeta</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>call_cntr</name> <operator>&lt;</operator> <name>max_calls</name></expr>)</condition>	<comment type="block">/* do when there is more left to send */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>itemValues</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>itemNulls</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>outfuncs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>fmgrinfo</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>MCVList</name>    <modifier>*</modifier></type><name>mcvlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MCVItem</name>    <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mcvlist</name> <operator>=</operator> <operator>(</operator><name>MCVList</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>call_cntr</name> <operator>&lt;</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>call_cntr</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Prepare a values array for building the returned tuple. This should
		 * be an array of C strings which will be processed later by the type
		 * input functions.
		 */</comment>
		<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><literal type="number">5</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">64</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* item index */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">64</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* frequency */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">64</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* base frequency */</comment>

		<expr_stmt><expr><name>outfuncs</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>ndimensions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmgrinfo</name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>ndimensions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>ndimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isvarlena</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>outfuncs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>outfuncs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fmgrinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* build the arrays of values / nulls */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itemValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itemNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itemValues</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itemNulls</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>ndimensions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>,
						<decl><type ref="prev"/><name>valout</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itemValues</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itemNulls</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>valout</name> <operator>=</operator> <call><name>CStringGetDatum</name><argument_list>(<argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>valout</name> <operator>=</operator> <call><name>FunctionCall1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fmgrinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itemValues</name></expr></argument>, <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>valout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itemNulls</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>item</name><operator>-&gt;</operator><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">"t"</literal></expr> </then><else>: <expr><literal type="string">"f"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itemValues</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itemNulls</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>call_cntr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%f"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%f"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>base_frequency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>itemValues</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>itemNulls</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

		<comment type="block">/* build a tuple */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name>attinmeta</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make the tuple into a datum */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* clean up (this is not really necessary) */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>itemValues</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>itemNulls</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else						<comment type="block">/* do when there is no more left */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_mcv_list_in		- input routine for type pg_mcv_list.
 *
 * pg_mcv_list is real enough to be a table column, but it has no operations
 * of its own, and disallows input too
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_mcv_list_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * pg_mcv_list stores the data in binary form and parsing text input is
	 * not needed, so disallow this.
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot accept a value of type %s"</literal></expr></argument>, <argument><expr><literal type="string">"pg_mcv_list"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * pg_mcv_list_out		- output routine for type pg_mcv_list.
 *
 * MCV lists are serialized into a bytea value, so we simply call byteaout()
 * to serialize the value into text. But it'd be nice to serialize that into
 * a meaningful representation (e.g. for inspection by people).
 *
 * XXX This should probably return something meaningful, similar to what
 * pg_dependencies_out does. Not sure how to deal with the deduplicated
 * values, though - do we want to expand that or not?
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_mcv_list_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>byteaout</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_mcv_list_recv		- binary input routine for type pg_mcv_list.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_mcv_list_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot accept a value of type %s"</literal></expr></argument>, <argument><expr><literal type="string">"pg_mcv_list"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * pg_mcv_list_send		- binary output routine for type pg_mcv_list.
 *
 * MCV lists are serialized in a bytea value (although the type is named
 * differently), so let's just send that.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_mcv_list_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>byteasend</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * mcv_get_match_bitmap
 *	Evaluate clauses using the MCV list, and update the match bitmap.
 *
 * A match bitmap keeps match/mismatch status for each MCV item, and we
 * update it based on additional clauses. We also use it to skip items
 * that can't possibly match (e.g. item marked as "mismatch" can't change
 * to "match" when evaluating AND clause list).
 *
 * The function also returns a flag indicating whether there was an
 * equality condition for all attributes, the minimum frequency in the MCV
 * list, and a total MCV frequency (sum of frequencies for all items).
 *
 * XXX Currently the match bitmap uses a bool for each MCV item, which is
 * somewhat wasteful as we could do with just a single bit, thus reducing
 * the size to ~1/8. It would also allow us to combine bitmaps simply using
 * &amp; and |, which should be faster than min/max. The bitmaps are fairly
 * small, though (thanks to the cap on the MCV list size).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name> <modifier>*</modifier></type>
<name>mcv_get_match_bitmap</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>,
					 <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>MCVList</name> <modifier>*</modifier></type><name>mcvlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_or</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>matches</name></decl>;</decl_stmt>

	<comment type="block">/* The bitmap may be partially built. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>clauses</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mcvlist</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name> <operator>&lt;=</operator> <name>STATS_MCVLIST_MAX_ITEMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>matches</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>matches</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>is_or</name><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop through the list of clauses, and for each of them evaluate all the
	 * MCV items not yet eliminated by the preceding clauses.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* if it's a RestrictInfo, then extract the clause */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>clause</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Handle the various types of clauses - OpClause, NullTest and
		 * AND/OR/NOT
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>varonleft</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>opproc</name></decl>;</decl_stmt>

			<comment type="block">/* get procedure computing operator selectivity */</comment>
			<decl_stmt><decl><type><name>RegProcedure</name></type> <name>oprrest</name> <init>= <expr><call><name>get_oprrest</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ok</name> <operator>=</operator> <operator>(</operator><call><name>NumRelids</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>(</operator><call><name>is_pseudo_constant_clause</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
				 <operator>(</operator><name>varonleft</name> <operator>=</operator> <name>false</name><operator>,</operator>
				  <call><name>is_pseudo_constant_clause</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>ok</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typecache</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>gtproc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>cst</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>isgt</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>

				<comment type="block">/* extract the var and const from the expression */</comment>
				<expr_stmt><expr><name>var</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>varonleft</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
				<expr_stmt><expr><name>cst</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>varonleft</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
				<expr_stmt><expr><name>isgt</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name>varonleft</name><operator>)</operator></expr>;</expr_stmt>

				<comment type="block">/* strip binary-compatible relabeling */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* match the attribute to a dimension of the statistic */</comment>
				<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>bms_member_index</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* get information about the &gt;= procedure */</comment>
				<expr_stmt><expr><name>typecache</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name>TYPECACHE_GT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name><name>typecache</name><operator>-&gt;</operator><name>gt_opr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>gtproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Walk through the MCV items and evaluate the current clause.
				 * We can skip items that were already ruled out, and
				 * terminate if there are no remaining MCV items that might
				 * possibly match.
				 */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>mismatch</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>MCVItem</name>    <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * For AND-lists, we can also mark NULL items as 'no
					 * match' (and then skip them). For OR-lists this is not
					 * possible.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>is_or</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>item</name><operator>-&gt;</operator><name>isnull</name><index>[<expr><name>idx</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* skip MCV items that were already ruled out */</comment>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>is_or</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>false</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>is_or</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>true</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<switch>switch <condition>(<expr><name>oprrest</name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>F_EQSEL</name></expr>:</case>
						<case>case <expr><name>F_NEQSEL</name></expr>:</case>

							<comment type="block">/*
							 * We don't care about isgt in equality, because
							 * it does not matter whether it's (var op const)
							 * or (const op var).
							 */</comment>
							<expr_stmt><expr><name>mismatch</name> <operator>=</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>,
																	   <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>,
																	   <argument><expr><name><name>cst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
																	   <argument><expr><name><name>item</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<break>break;</break>

						<case>case <expr><name>F_SCALARLTSEL</name></expr>:</case> <comment type="block">/* column &lt; constant */</comment>
						<case>case <expr><name>F_SCALARLESEL</name></expr>:</case> <comment type="block">/* column &lt;= constant */</comment>
						<case>case <expr><name>F_SCALARGTSEL</name></expr>:</case> <comment type="block">/* column &gt; constant */</comment>
						<case>case <expr><name>F_SCALARGESEL</name></expr>:</case> <comment type="block">/* column &gt;= constant */</comment>

							<comment type="block">/*
							 * First check whether the constant is below the
							 * lower boundary (in that case we can skip the
							 * bucket, because there's no overlap).
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name>isgt</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>mismatch</name> <operator>=</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>,
																		   <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>,
																		   <argument><expr><name><name>cst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
																		   <argument><expr><name><name>item</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><name>mismatch</name> <operator>=</operator> <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>,
																		   <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>,
																		   <argument><expr><name><name>item</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>,
																		   <argument><expr><name><name>cst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

							<break>break;</break>
					</block_content>}</block></switch>

					<comment type="block">/*
					 * XXX The conditions on matches[i] are not needed, as we
					 * skip MCV items that can't become true/false, depending
					 * on the current flag. See beginning of the loop over MCV
					 * items.
					 */</comment>

					<if_stmt><if>if <condition>(<expr><operator>(</operator><name>is_or</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>mismatch</name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* OR - was not a match before, matches now */</comment>
						<expr_stmt><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>!</operator><name>is_or</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>mismatch</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* AND - was a match before, does not match anymore */</comment>
						<expr_stmt><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>expr</name><operator>-&gt;</operator><name>arg</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<comment type="block">/* match the attribute to a dimension of the statistic */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>idx</name> <init>= <expr><call><name>bms_member_index</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Walk through the MCV items and evaluate the current clause. We
			 * can skip items that were already ruled out, and terminate if
			 * there are no remaining MCV items that might possibly match.
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* assume mismatch */</comment>
				<decl_stmt><decl><type><name>MCVItem</name>    <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* if the clause mismatches the MCV item, update the bitmap */</comment>
				<switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>IS_NULL</name></expr>:</case>
						<expr_stmt><expr><name>match</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>isnull</name><index>[<expr><name>idx</name></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>match</name></expr></else></ternary></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>IS_NOT_NULL</name></expr>:</case>
						<expr_stmt><expr><name>match</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>!</operator><name><name>item</name><operator>-&gt;</operator><name>isnull</name><index>[<expr><name>idx</name></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>match</name></expr></else></ternary></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>

				<comment type="block">/* now, update the match bitmap, depending on OR/AND type */</comment>
				<if_stmt><if>if <condition>(<expr><name>is_or</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>is_orclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_andclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* AND/OR clause, with all subclauses being compatible */</comment>

			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>bool_clause</name> <init>= <expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>bool_clauses</name> <init>= <expr><name><name>bool_clause</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* match/mismatch bitmap for each MCV item */</comment>
			<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>bool_matches</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bool_clauses</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>bool_clauses</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* build the match bitmap for the OR-clauses */</comment>
			<expr_stmt><expr><name>bool_matches</name> <operator>=</operator> <call><name>mcv_get_match_bitmap</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>bool_clauses</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>,
												<argument><expr><name>mcvlist</name></expr></argument>, <argument><expr><call><name>is_orclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Merge the bitmap produced by mcv_get_match_bitmap into the
			 * current one. We need to consider if we're evaluating AND or OR
			 * condition when merging the results.
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<comment type="block">/* Is this OR or AND clause? */</comment>
				<if_stmt><if>if <condition>(<expr><name>is_or</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bool_matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>bool_matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>bool_matches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>is_notclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* NOT clause, with all subclauses compatible */</comment>

			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>not_clause</name> <init>= <expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>not_args</name> <init>= <expr><name><name>not_clause</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* match/mismatch bitmap for each MCV item */</comment>
			<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>not_matches</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>not_args</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>not_args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* build the match bitmap for the NOT-clause */</comment>
			<expr_stmt><expr><name>not_matches</name> <operator>=</operator> <call><name>mcv_get_match_bitmap</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>not_args</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>,
											   <argument><expr><name>mcvlist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Merge the bitmap produced by mcv_get_match_bitmap into the
			 * current one.
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<comment type="block">/*
				 * When handling a NOT clause, we need to invert the result
				 * before merging it into the global result.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>not_matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>not_matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>not_matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/* Is this OR or AND clause? */</comment>
				<if_stmt><if>if <condition>(<expr><name>is_or</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>not_matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>not_matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>not_matches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Var (has to be a boolean Var, possibly from below NOT) */</comment>

			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>clause</name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<comment type="block">/* match the attribute to a dimension of the statistic */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>idx</name> <init>= <expr><call><name>bms_member_index</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>BOOLOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Walk through the MCV items and evaluate the current clause. We
			 * can skip items that were already ruled out, and terminate if
			 * there are no remaining MCV items that might possibly match.
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mcvlist</name><operator>-&gt;</operator><name>nitems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MCVItem</name>    <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>&amp;</operator><name><name>mcvlist</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* if the item is NULL, it's a mismatch */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>item</name><operator>-&gt;</operator><name>isnull</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* now, update the match bitmap, depending on OR/AND type */</comment>
				<if_stmt><if>if <condition>(<expr><name>is_or</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown clause type: %d"</literal></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>matches</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * mcv_clauselist_selectivity
 *		Return the selectivity estimate computed using an MCV list.
 *
 * First builds a bitmap of MCV items matching the clauses, and then sums
 * the frequencies of matching items.
 *
 * It also produces two additional interesting selectivities - total
 * selectivity of all the MCV items (not just the matching ones), and the
 * base frequency computed on the assumption of independence.
 */</comment>
<function><type><name>Selectivity</name></type>
<name>mcv_clauselist_selectivity</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>StatisticExtInfo</name> <modifier>*</modifier></type><name>stat</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>,
						   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						   <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>basesel</name></decl></parameter>, <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>totalsel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MCVList</name>    <modifier>*</modifier></type><name>mcv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>s</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* match/mismatch bitmap for each MCV item */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>matches</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* load the MCV list stored in the statistics object */</comment>
	<expr_stmt><expr><name>mcv</name> <operator>=</operator> <call><name>statext_mcv_load</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>statOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build a match bitmap for the clauses */</comment>
	<expr_stmt><expr><name>matches</name> <operator>=</operator> <call><name>mcv_get_match_bitmap</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>clauses</name></expr></argument>, <argument><expr><name><name>stat</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>, <argument><expr><name>mcv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sum frequencies for all the matching MCV items */</comment>
	<expr_stmt><expr><operator>*</operator><name>basesel</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>totalsel</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mcv</name><operator>-&gt;</operator><name>nitems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>totalsel</name> <operator>+=</operator> <name><name>mcv</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>frequency</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* XXX Shouldn't the basesel be outside the if condition? */</comment>
			<expr_stmt><expr><operator>*</operator><name>basesel</name> <operator>+=</operator> <name><name>mcv</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base_frequency</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name> <operator>+=</operator> <name><name>mcv</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>frequency</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>
</unit>
