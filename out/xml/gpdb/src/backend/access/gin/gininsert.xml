<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/gin/gininsert.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * gininsert.c
 *	  insert routines for the postgres inverted index access method.
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *			src/backend/access/gin/gininsert.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gin_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/ginxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/indexfsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>GinState</name></type>	<name>ginstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>indtuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinStatsData</name></type> <name>buildStats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>funcCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BuildAccumulator</name></type> <name>accum</name></decl>;</decl_stmt>
}</block></struct></type> <name>GinBuildState</name>;</typedef>


<comment type="block">/*
 * Adds array of item pointers to tuple's posting list, or
 * creates posting tree and tuple pointing to tree in case
 * of not enough space.  Max size of tuple is defined in
 * GinFormTuple().  Returns a new, modified index tuple.
 * items[] must be in sorted order with no duplicates.
 */</comment>
<function><type><specifier>static</specifier> <name>IndexTuple</name></type>
<name>addItemPointersToLeafTuple</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>,
						   <parameter><decl><type><name>IndexTuple</name></type> <name>old</name></decl></parameter>,
						   <parameter><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>items</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>nitem</name></decl></parameter>,
						   <parameter><decl><type><name>GinStatsData</name> <modifier>*</modifier></type><name>buildStats</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinNullCategory</name></type> <name>category</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>newItems</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>oldItems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldNPosting</name></decl>,
				<decl><type ref="prev"/><name>newNPosting</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>compressedList</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinIsPostingTree</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>gintuple_get_attrnum</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>gintuple_get_key</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>old</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>category</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* merge the old and new posting lists */</comment>
	<expr_stmt><expr><name>oldItems</name> <operator>=</operator> <call><name>ginReadTuple</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>old</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldNPosting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newItems</name> <operator>=</operator> <call><name>ginMergeItemPointers</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>nitem</name></expr></argument>,
									<argument><expr><name>oldItems</name></expr></argument>, <argument><expr><name>oldNPosting</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>newNPosting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compress the posting list, and try to a build tuple with room for it */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>compressedList</name> <operator>=</operator> <call><name>ginCompressPostingList</name><argument_list>(<argument><expr><name>newItems</name></expr></argument>, <argument><expr><name>newNPosting</name></expr></argument>, <argument><expr><name>GinMaxItemSize</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newItems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>compressedList</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GinFormTuple</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>category</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>compressedList</name></expr></argument>,
						   <argument><expr><call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name>compressedList</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>newNPosting</name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>compressedList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* posting list would be too big, convert to posting tree */</comment>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>postingRoot</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Initialize posting tree with the old tuple's posting list.  It's
		 * surely small enough to fit on one posting-tree page, and should
		 * already be in order with no duplicates.
		 */</comment>
		<expr_stmt><expr><name>postingRoot</name> <operator>=</operator> <call><name>createPostingTree</name><argument_list>(<argument><expr><name><name>ginstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,
										<argument><expr><name>oldItems</name></expr></argument>,
										<argument><expr><name>oldNPosting</name></expr></argument>,
										<argument><expr><name>buildStats</name></expr></argument>,
										<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now insert the TIDs-to-be-added into the posting tree */</comment>
		<expr_stmt><expr><call><name>ginInsertItemPointers</name><argument_list>(<argument><expr><name><name>ginstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>postingRoot</name></expr></argument>,
							  <argument><expr><name>items</name></expr></argument>, <argument><expr><name>nitem</name></expr></argument>,
							  <argument><expr><name>buildStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And build a new posting-tree-only result tuple */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GinFormTuple</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>category</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinSetPostingTree</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>postingRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldItems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a fresh leaf tuple, either posting-list or posting-tree format
 * depending on whether the given items list will fit.
 * items[] must be in sorted order with no duplicates.
 *
 * This is basically the same logic as in addItemPointersToLeafTuple,
 * but working from slightly different input.
 */</comment>
<function><type><specifier>static</specifier> <name>IndexTuple</name></type>
<name>buildFreshLeafTuple</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>,
					<parameter><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>GinNullCategory</name></type> <name>category</name></decl></parameter>,
					<parameter><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>items</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>nitem</name></decl></parameter>,
					<parameter><decl><type><name>GinStatsData</name> <modifier>*</modifier></type><name>buildStats</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>compressedList</name></decl>;</decl_stmt>

	<comment type="block">/* try to build a posting list tuple with all the items */</comment>
	<expr_stmt><expr><name>compressedList</name> <operator>=</operator> <call><name>ginCompressPostingList</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>nitem</name></expr></argument>, <argument><expr><name>GinMaxItemSize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>compressedList</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GinFormTuple</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>category</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>compressedList</name></expr></argument>,
						   <argument><expr><call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name>compressedList</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>nitem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>compressedList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* posting list would be too big, build posting tree */</comment>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>postingRoot</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Build posting-tree-only result tuple.  We do this first so as to
		 * fail quickly if the key is too big.
		 */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>GinFormTuple</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>category</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize a new posting tree with the TIDs.
		 */</comment>
		<expr_stmt><expr><name>postingRoot</name> <operator>=</operator> <call><name>createPostingTree</name><argument_list>(<argument><expr><name><name>ginstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>nitem</name></expr></argument>,
										<argument><expr><name>buildStats</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And save the root link in the result tuple */</comment>
		<expr_stmt><expr><call><name>GinSetPostingTree</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>postingRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Insert one or more heap TIDs associated with the given key value.
 * This will either add a single key entry, or enlarge a pre-existing entry.
 *
 * During an index build, buildStats is non-null and the counters
 * it contains should be incremented as needed.
 */</comment>
<function><type><name>void</name></type>
<name>ginEntryInsert</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>,
			   <parameter><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>GinNullCategory</name></type> <name>category</name></decl></parameter>,
			   <parameter><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>items</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>nitem</name></decl></parameter>,
			   <parameter><decl><type><name>GinStatsData</name> <modifier>*</modifier></type><name>buildStats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinBtreeData</name></type> <name>btree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinBtreeEntryInsertData</name></type> <name>insertdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>insertdata</name><operator>.</operator><name>isDelete</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* During index build, count the to-be-inserted entry */</comment>
	<if_stmt><if>if <condition>(<expr><name>buildStats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>buildStats</name><operator>-&gt;</operator><name>nEntries</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ginPrepareEntryScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>btree</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>category</name></expr></argument>, <argument><expr><name>ginstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>.</operator><name>isBuild</name></name> <operator>=</operator> <operator>(</operator><name>buildStats</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>ginFindLeafPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>btree</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name><name>btree</name><operator>.</operator><name>findItem</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>btree</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* found pre-existing entry */</comment>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GinIsPostingTree</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* add entries to existing posting tree */</comment>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rootPostingTree</name> <init>= <expr><call><name>GinGetPostingTree</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* release all stack */</comment>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>freeGinBtreeStack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* insert into posting tree */</comment>
			<expr_stmt><expr><call><name>ginInsertItemPointers</name><argument_list>(<argument><expr><name><name>ginstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>rootPostingTree</name></expr></argument>,
								  <argument><expr><name>items</name></expr></argument>, <argument><expr><name>nitem</name></expr></argument>,
								  <argument><expr><name>buildStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name><name>ginstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* modify an existing leaf entry */</comment>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>addItemPointersToLeafTuple</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>,
										  <argument><expr><name>items</name></expr></argument>, <argument><expr><name>nitem</name></expr></argument>, <argument><expr><name>buildStats</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>insertdata</name><operator>.</operator><name>isDelete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name><name>ginstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* no match, so construct a new leaf entry */</comment>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>buildFreshLeafTuple</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>category</name></expr></argument>,
								   <argument><expr><name>items</name></expr></argument>, <argument><expr><name>nitem</name></expr></argument>, <argument><expr><name>buildStats</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Insert the new or modified leaf tuple */</comment>
	<expr_stmt><expr><name><name>insertdata</name><operator>.</operator><name>entry</name></name> <operator>=</operator> <name>itup</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ginInsertValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>btree</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>insertdata</name></expr></argument>, <argument><expr><name>buildStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Extract index entries for a single indexable item, and add them to the
 * BuildAccumulator's state.
 *
 * This function is used only during initial index creation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginHeapTupleBulkInsert</name><parameter_list>(<parameter><decl><type><name>GinBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
					   <parameter><decl><type><name>ItemPointer</name></type> <name>heapptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinNullCategory</name> <modifier>*</modifier></type><name>categories</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nentries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>funcCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entries</name> <operator>=</operator> <call><name>ginExtractEntries</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>accum</name><operator>.</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
								<argument><expr><name>value</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>nentries</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>categories</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ginInsertBAEntries</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>-&gt;</operator><name>accum</name></name></expr></argument>, <argument><expr><name>heapptr</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
					   <argument><expr><name>entries</name></expr></argument>, <argument><expr><name>categories</name></expr></argument>, <argument><expr><name>nentries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>indtuples</name></name> <operator>+=</operator> <name>nentries</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>funcCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>ginBuildCallback</name><argument_list>(<argument><expr><name>Relation</name> <name>index</name></expr></argument>, <argument><expr><name>ItemPointer</name> <name>tupleId</name></expr></argument>, <argument><expr><name>Datum</name> <operator>*</operator><name>values</name></expr></argument>,
				 <argument><expr><name>bool</name> <operator>*</operator><name>isnull</name></expr></argument>, <argument><expr><name>bool</name> <name>tupleIsAlive</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>state</name></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinBuildState</name> <modifier>*</modifier></type><name>buildstate</name> <init>= <expr><operator>(</operator><name>GinBuildState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>tmpCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>ginstate</name><operator>.</operator><name>origTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ginHeapTupleBulkInsert</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
							   <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							   <argument><expr><name>tupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* If we've maxed out our available memory, dump everything to the index */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buildstate</name><operator>-&gt;</operator><name>accum</name><operator>.</operator><name>allocatedMemory</name></name> <operator>&gt;=</operator> <operator>(</operator><name>Size</name><operator>)</operator> <name>maintenance_work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GinNullCategory</name></type> <name>category</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>nlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ginBeginBAScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>-&gt;</operator><name>accum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>list</name> <operator>=</operator> <call><name>ginGetBAEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>-&gt;</operator><name>accum</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>category</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlist</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* there could be many entries, so be willing to abort here */</comment>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ginEntryInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>category</name></expr></argument>,
						   <argument><expr><name>list</name></expr></argument>, <argument><expr><name>nlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>-&gt;</operator><name>buildStats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>tmpCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ginInitBA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>-&gt;</operator><name>accum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>IndexBuildResult</name> <modifier>*</modifier></type>
<name>ginbuild</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexBuildResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinBuildState</name></type> <name>buildstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>RootBuffer</name></decl>,
				<decl><type ref="prev"/><name>MetaBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinNullCategory</name></type> <name>category</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>nlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index \"%s\" already contains data"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initGinState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>.</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>indtuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>.</operator><name>buildStats</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinStatsData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize the meta page */</comment>
	<expr_stmt><expr><name>MetaBuffer</name> <operator>=</operator> <call><name>GinNewBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize the root page */</comment>
	<expr_stmt><expr><name>RootBuffer</name> <operator>=</operator> <call><name>GinNewBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinInitMetabuffer</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinInitBuffer</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>, <argument><expr><name>GIN_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* count the root as first entry page */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>buildStats</name><operator>.</operator><name>nEntryPages</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * create a temporary memory context that is used to hold data not yet
	 * dumped out to the index
	 */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>tmpCtx</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											  <argument><expr><literal type="string">"Gin build temporary context"</literal></expr></argument>,
											  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create a temporary memory context that is used for calling
	 * ginExtractEntries(), and can be reset after each tuple
	 */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>funcCtx</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											   <argument><expr><literal type="string">"Gin build temporary context for user-defined function"</literal></expr></argument>,
											   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>accum</name><operator>.</operator><name>ginstate</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>buildstate</name><operator>.</operator><name>ginstate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ginInitBA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>.</operator><name>accum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do the heap scan.  We disallow sync scan here because dataPlaceToPage
	 * prefers to receive tuples in TID order.
	 */</comment>
	<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <call><name>table_index_build_scan</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									   <argument><expr><name>ginBuildCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buildstate</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* dump remaining entries to the index */</comment>
	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>tmpCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ginBeginBAScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>.</operator><name>accum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>list</name> <operator>=</operator> <call><name>ginGetBAEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>.</operator><name>accum</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>category</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlist</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* there could be many entries, so be willing to abort here */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ginEntryInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>.</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>category</name></expr></argument>,
					   <argument><expr><name>list</name></expr></argument>, <argument><expr><name>nlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>.</operator><name>buildStats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>funcCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>tmpCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update metapage stats
	 */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>buildStats</name><operator>.</operator><name>nTotalPages</name></name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ginUpdateStats</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>.</operator><name>buildStats</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We didn't write WAL records as we built the index, so if WAL-logging is
	 * required, write all pages to the WAL now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_newpage_range</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Return statistics
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>IndexBuildResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBuildResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>heap_tuples</name></name> <operator>=</operator> <name>reltuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>index_tuples</name></name> <operator>=</operator> <name><name>buildstate</name><operator>.</operator><name>indtuples</name></name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	ginbuildempty() -- build an empty gin index in the initialization fork
 */</comment>
<function><type><name>void</name></type>
<name>ginbuildempty</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>RootBuffer</name></decl>,
				<decl><type ref="prev"/><name>MetaBuffer</name></decl>;</decl_stmt>

	<comment type="block">/* An empty GIN index has two pages. */</comment>
	<expr_stmt><expr><name>MetaBuffer</name> <operator>=</operator>
		<call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>RootBuffer</name> <operator>=</operator>
		<call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize and xlog metabuffer and root buffer. */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinInitMetabuffer</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>log_newpage_buffer</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinInitBuffer</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>, <argument><expr><name>GIN_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>log_newpage_buffer</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Unlock and release the buffers. */</comment>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert index entries for a single indexable item during "normal"
 * (non-fast-update) insertion
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginHeapTupleInsert</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
				   <parameter><decl><type><name>ItemPointer</name></type> <name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinNullCategory</name> <modifier>*</modifier></type><name>categories</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name></decl>,
				<decl><type ref="prev"/><name>nentries</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>entries</name> <operator>=</operator> <call><name>ginExtractEntries</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>nentries</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>categories</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nentries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ginEntryInsert</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>categories</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
					   <argument><expr><name>item</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>gininsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
		  <parameter><decl><type><name>ItemPointer</name></type> <name>ht_ctid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>,
		  <parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>,
		  <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinState</name>   <modifier>*</modifier></type><name>ginstate</name> <init>= <expr><operator>(</operator><name>GinState</name> <operator>*</operator><operator>)</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_AmCache</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>insertCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize GinState cache if first call in this statement */</comment>
	<if_stmt><if>if <condition>(<expr><name>ginstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ginstate</name> <operator>=</operator> <operator>(</operator><name>GinState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initGinState</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_AmCache</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ginstate</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>insertCtx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									  <argument><expr><literal type="string">"Gin insert temporary context"</literal></expr></argument>,
									  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>insertCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinGetUseFastUpdate</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GinTupleCollector</name></type> <name>collector</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinTupleCollector</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ginstate</name><operator>-&gt;</operator><name>origTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ginHeapTupleFastCollect</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>,
									<argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
									<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									<argument><expr><name>ht_ctid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><call><name>ginHeapTupleFastInsert</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>collector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ginstate</name><operator>-&gt;</operator><name>origTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ginHeapTupleInsert</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
							   <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							   <argument><expr><name>ht_ctid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>insertCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
