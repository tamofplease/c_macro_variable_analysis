<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/gin/ginfast.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ginfast.c
 *	  Fast insert routines for the Postgres inverted index access method.
 *	  Pending entries are stored in linear list of pages.  Later on
 *	  (typically during VACUUM), ginInsertCleanup() will be invoked to
 *	  transfer pending entries into the regular index structure.  This
 *	  wins because bulk insertion is much more efficient than retail.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *			src/backend/access/gin/ginfast.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gin_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/ginxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/indexfsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<comment type="block">/* GUC parameter */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gin_pending_list_limit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GIN_PAGE_FREESIZE</name></cpp:macro> \
	<cpp:value>( BLCKSZ - MAXALIGN(SizeOfPageHeaderData) - MAXALIGN(sizeof(GinPageOpaqueData)) )</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>KeyArray</name>
<block>{
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>			<comment type="block">/* expansible array */</comment>
	<decl_stmt><decl><type><name>GinNullCategory</name> <modifier>*</modifier></type><name>categories</name></decl>;</decl_stmt>	<comment type="block">/* another expansible array */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nvalues</name></decl>;</decl_stmt>		<comment type="block">/* current number of valid entries */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>maxvalues</name></decl>;</decl_stmt>		<comment type="block">/* allocated size of arrays */</comment>
}</block></struct></type> <name>KeyArray</name>;</typedef>


<comment type="block">/*
 * Build a pending-list page from the given array of tuples, and write it out.
 *
 * Returns amount of free space left on the page.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>writeListPage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
			  <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>ntuples</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>rightlink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name></decl>,
				<decl><type ref="prev"/><name>freesize</name></decl>,
				<decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>l</name></decl>,
				<decl><type ref="prev"/><name>off</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>workspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GinInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>off</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>workspace</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>this_size</name> <init>= <expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>tuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>tuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>this_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>this_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> <operator>+=</operator> <name>this_size</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name><name>tuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>this_size</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to index page in \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size</name> <operator>&lt;=</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else we overran workspace */</comment>

	<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>=</operator> <name>rightlink</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * tail page may contain only whole row(s) or final part of row placed on
	 * previous pages (a "row" here meaning all the index tuples generated for
	 * one heap tuple)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rightlink</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GinPageSetFullRow</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ginxlogInsertListPage</name></type> <name>data</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>data</name><operator>.</operator><name>rightlink</name></name> <operator>=</operator> <name>rightlink</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>data</name><operator>.</operator><name>ntuples</name></name> <operator>=</operator> <name>ntuples</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogInsertListPage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>workspace</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_GIN_ID</name></expr></argument>, <argument><expr><name>XLOG_GIN_INSERT_LISTPAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get free space before releasing buffer */</comment>
	<expr_stmt><expr><name>freesize</name> <operator>=</operator> <call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>freesize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>makeSublist</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>ntuples</name></decl></parameter>,
			<parameter><decl><type><name>GinMetaPageData</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>curBuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>prevBuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>tupsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>startTuple</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ntuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Split tuples into pages
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>curBuffer</name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>curBuffer</name> <operator>=</operator> <call><name>GinNewBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>prevBuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nPendingPages</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>writeListPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>prevBuffer</name></expr></argument>,
							  <argument><expr><name>tuples</name> <operator>+</operator> <name>startTuple</name></expr></argument>,
							  <argument><expr><name>i</name> <operator>-</operator> <name>startTuple</name></expr></argument>,
							  <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>curBuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>curBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>prevBuffer</name> <operator>=</operator> <name>curBuffer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>startTuple</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>tupsize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>tuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>size</name> <operator>+</operator> <name>tupsize</name> <operator>&gt;</operator> <name>GinListPageSize</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* won't fit, force a new page and reprocess */</comment>
			<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>curBuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>size</name> <operator>+=</operator> <name>tupsize</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Write last page
	 */</comment>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>curBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>tailFreeSize</name></name> <operator>=</operator> <call><name>writeListPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>curBuffer</name></expr></argument>,
									  <argument><expr><name>tuples</name> <operator>+</operator> <name>startTuple</name></expr></argument>,
									  <argument><expr><name>ntuples</name> <operator>-</operator> <name>startTuple</name></expr></argument>,
									  <argument><expr><name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nPendingPages</name></name><operator>++</operator></expr>;</expr_stmt>
	<comment type="block">/* that was only one heap tuple */</comment>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nPendingHeapTuples</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write the index tuples contained in *collector into the index's
 * pending list.
 *
 * Function guarantees that all these tuples will be inserted consecutively,
 * preserving order
 */</comment>
<function><type><name>void</name></type>
<name>ginHeapTupleFastInsert</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>, <parameter><decl><type><name>GinTupleCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>index</name> <init>= <expr><name><name>ginstate</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinMetaPageData</name> <modifier>*</modifier></type><name>metadata</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ginxlogUpdateMeta</name></type> <name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>separateList</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needCleanup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cleanupSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needWal</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>collector</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>needWal</name> <operator>=</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>newRightlink</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>prevTail</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>metabuffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>GIN_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * An insertion to the pending list could logically belong anywhere in the
	 * tree, so it conflicts with all serializable scans.  All scans acquire a
	 * predicate lock on the metabuffer to represent that.
	 */</comment>
	<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>collector</name><operator>-&gt;</operator><name>sumsize</name></name> <operator>+</operator> <name><name>collector</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name>GinListPageSize</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Total size is greater than one page =&gt; make sublist
		 */</comment>
		<expr_stmt><expr><name>separateList</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name>GIN_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>metadata</name> <operator>=</operator> <call><name>GinPageGetMeta</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>metadata</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>InvalidBlockNumber</name> <operator>||</operator>
			<name><name>collector</name><operator>-&gt;</operator><name>sumsize</name></name> <operator>+</operator> <name><name>collector</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>metadata</name><operator>-&gt;</operator><name>tailFreeSize</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Pending list is empty or total size is greater than freespace
			 * on tail page =&gt; make sublist
			 *
			 * We unlock metabuffer to keep high concurrency
			 */</comment>
			<expr_stmt><expr><name>separateList</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>separateList</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We should make sublist separately and append it to the tail
		 */</comment>
		<decl_stmt><decl><type><name>GinMetaPageData</name></type> <name>sublist</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sublist</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>makeSublist</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>collector</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>, <argument><expr><name><name>collector</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sublist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>needWal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * metapage was unlocked, see above
		 */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name>GIN_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>metadata</name> <operator>=</operator> <call><name>GinPageGetMeta</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>metadata</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Main list is empty, so just insert sublist as main list
			 */</comment>
			<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>sublist</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name><name>sublist</name><operator>.</operator><name>tail</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>tailFreeSize</name></name> <operator>=</operator> <name><name>sublist</name><operator>.</operator><name>tailFreeSize</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>nPendingPages</name></name> <operator>=</operator> <name><name>sublist</name><operator>.</operator><name>nPendingPages</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>nPendingHeapTuples</name></name> <operator>=</operator> <name><name>sublist</name><operator>.</operator><name>nPendingHeapTuples</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Merge lists
			 */</comment>
			<expr_stmt><expr><name><name>data</name><operator>.</operator><name>prevTail</name></name> <operator>=</operator> <name><name>metadata</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>data</name><operator>.</operator><name>newRightlink</name></name> <operator>=</operator> <name><name>sublist</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>=</operator> <name><name>sublist</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name><name>sublist</name><operator>.</operator><name>tail</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>tailFreeSize</name></name> <operator>=</operator> <name><name>sublist</name><operator>.</operator><name>tailFreeSize</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>nPendingPages</name></name> <operator>+=</operator> <name><name>sublist</name><operator>.</operator><name>nPendingPages</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>nPendingHeapTuples</name></name> <operator>+=</operator> <name><name>sublist</name><operator>.</operator><name>nPendingHeapTuples</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>needWal</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Insert into tail page.  Metapage is already locked
		 */</comment>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>l</name></decl>,
					<decl><type ref="prev"/><name>off</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
					<decl><type ref="prev"/><name>tupsize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collectordata</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>FirstOffsetNumber</name></expr> </then><else>:
			<expr><call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name>collectordata</name> <operator>=</operator> <name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>collector</name><operator>-&gt;</operator><name>sumsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>data</name><operator>.</operator><name>ntuples</name></name> <operator>=</operator> <name><name>collector</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>needWal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Increase counter of heap tuples
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name> <operator>&lt;=</operator> <name><name>metadata</name><operator>-&gt;</operator><name>nPendingHeapTuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>nPendingHeapTuples</name></name><operator>++</operator></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>collector</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>tupsize</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>collector</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name><name>collector</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tupsize</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to index page in \"%s\""</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>collector</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tupsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>tupsize</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>ptr</name> <operator>-</operator> <name>collectordata</name><operator>)</operator> <operator>&lt;=</operator> <name><name>collector</name><operator>-&gt;</operator><name>sumsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>needWal</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>collectordata</name></expr></argument>, <argument><expr><name><name>collector</name><operator>-&gt;</operator><name>sumsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>tailFreeSize</name></name> <operator>=</operator> <call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Set pd_lower just past the end of the metadata.  This is essential,
	 * because without doing so, metadata will be lost if xlog.c compresses
	 * the page.  (We must do this here because pre-v11 versions of PG did not
	 * set the metapage's pd_lower correctly, so a pg_upgraded index might
	 * contain the wrong value.)
	 */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>metapage</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>=</operator>
		<operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>metadata</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GinMetaPageData</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>metapage</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Write metabuffer, make xlog entry
	 */</comment>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>needWal</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>metadata</name></name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogUpdateMeta</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_GIN_ID</name></expr></argument>, <argument><expr><name>XLOG_GIN_UPDATE_META_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Force pending list cleanup when it becomes too long. And,
	 * ginInsertCleanup could take significant amount of time, so we prefer to
	 * call it when it can do all the work in a single collection cycle. In
	 * non-vacuum mode, it shouldn't require maintenance_work_mem, so fire it
	 * while pending list is still small enough to fit into
	 * gin_pending_list_limit.
	 *
	 * ginInsertCleanup() should not be called inside our CRIT_SECTION.
	 */</comment>
	<expr_stmt><expr><name>cleanupSize</name> <operator>=</operator> <call><name>GinGetPendingListCleanupSize</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>metadata</name><operator>-&gt;</operator><name>nPendingPages</name></name> <operator>*</operator> <name>GIN_PAGE_FREESIZE</name> <operator>&gt;</operator> <name>cleanupSize</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>needCleanup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since it could contend with concurrent cleanup process we cleanup
	 * pending list not forcibly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>needCleanup</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ginInsertCleanup</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create temporary index tuples for a single indexable item (one index column
 * for the heap tuple specified by ht_ctid), and append them to the array
 * in *collector.  They will subsequently be written out using
 * ginHeapTupleFastInsert.  Note that to guarantee consistent state, all
 * temp tuples for a given heap tuple must be written in one call to
 * ginHeapTupleFastInsert.
 */</comment>
<function><type><name>void</name></type>
<name>ginHeapTupleFastCollect</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>,
						<parameter><decl><type><name>GinTupleCollector</name> <modifier>*</modifier></type><name>collector</name></decl></parameter>,
						<parameter><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
						<parameter><decl><type><name>ItemPointer</name></type> <name>ht_ctid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinNullCategory</name> <modifier>*</modifier></type><name>categories</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name></decl>,
				<decl><type ref="prev"/><name>nentries</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Extract the key values that need to be inserted in the index
	 */</comment>
	<expr_stmt><expr><name>entries</name> <operator>=</operator> <call><name>ginExtractEntries</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>nentries</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>categories</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Protect against integer overflow in allocation calculations
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nentries</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator>
		<name><name>collector</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>+</operator> <name>nentries</name></expr></argument> &gt;</argument_list></name> <name>MaxAllocSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTuple</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many entries for GIN index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Allocate/reallocate memory for storing collected tuples
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>collector</name><operator>-&gt;</operator><name>tuples</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Determine the number of elements to allocate in the tuples array
		 * initially.  Make it a power of 2 to avoid wasting memory when
		 * resizing (since palloc likes powers of 2).
		 */</comment>
		<expr_stmt><expr><name><name>collector</name><operator>-&gt;</operator><name>lentuples</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name><name>collector</name><operator>-&gt;</operator><name>lentuples</name></name> <operator>&lt;</operator> <name>nentries</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>collector</name><operator>-&gt;</operator><name>lentuples</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><name><name>collector</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>collector</name><operator>-&gt;</operator><name>lentuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>collector</name><operator>-&gt;</operator><name>lentuples</name></name> <operator>&lt;</operator> <name><name>collector</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>+</operator> <name>nentries</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Advance lentuples to the next suitable power of 2.  This won't
		 * overflow, though we could get to a value that exceeds
		 * MaxAllocSize/sizeof(IndexTuple), causing an error in repalloc.
		 */</comment>
		<do>do
		<block>{<block_content>
			<expr_stmt><expr><name><name>collector</name><operator>-&gt;</operator><name>lentuples</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name><name>collector</name><operator>-&gt;</operator><name>lentuples</name></name> <operator>&lt;</operator> <name><name>collector</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>+</operator> <name>nentries</name></expr>)</condition>;</do>

		<expr_stmt><expr><name><name>collector</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>collector</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>,
													<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>collector</name><operator>-&gt;</operator><name>lentuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build an index tuple for each key value, and add to array.  In pending
	 * tuples we just stick the heap TID into t_tid.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nentries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>GinFormTuple</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>categories</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name> <operator>=</operator> <operator>*</operator><name>ht_ctid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collector</name><operator>-&gt;</operator><name>tuples</name><index>[<expr><name><name>collector</name><operator>-&gt;</operator><name>ntuples</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>itup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collector</name><operator>-&gt;</operator><name>sumsize</name></name> <operator>+=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Deletes pending list pages up to (not including) newHead page.
 * If newHead == InvalidBlockNumber then function drops the whole list.
 *
 * metapage is pinned and exclusive-locked throughout this function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shiftList</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>metabuffer</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>newHead</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>fill_fsm</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinMetaPageData</name> <modifier>*</modifier></type><name>metadata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blknoToDelete</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metadata</name> <operator>=</operator> <call><name>GinPageGetMeta</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>blknoToDelete</name> <operator>=</operator> <name><name>metadata</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>nDeletedHeapTuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ginxlogDeleteListPages</name></type> <name>data</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name><name>buffers</name><index>[<expr><name>GIN_NDELETE_AT_ONCE</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name><name>freespace</name><index>[<expr><name>GIN_NDELETE_AT_ONCE</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>data</name><operator>.</operator><name>ndeleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name><name>data</name><operator>.</operator><name>ndeleted</name></name> <operator>&lt;</operator> <name>GIN_NDELETE_AT_ONCE</name> <operator>&amp;&amp;</operator> <name>blknoToDelete</name> <operator>!=</operator> <name>newHead</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>freespace</name><index>[<expr><name><name>data</name><operator>.</operator><name>ndeleted</name></name></expr>]</index></name> <operator>=</operator> <name>blknoToDelete</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buffers</name><index>[<expr><name><name>data</name><operator>.</operator><name>ndeleted</name></name></expr>]</index></name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blknoToDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name><name>data</name><operator>.</operator><name>ndeleted</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>GIN_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name><name>data</name><operator>.</operator><name>ndeleted</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>data</name><operator>.</operator><name>ndeleted</name></name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>nDeletedHeapTuples</name> <operator>+=</operator> <call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>blknoToDelete</name> <operator>=</operator> <call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>stats</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>pages_deleted</name></name> <operator>+=</operator> <name><name>data</name><operator>.</operator><name>ndeleted</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * This operation touches an unusually large number of pages, so
		 * prepare the XLogInsert machinery for that before entering the
		 * critical section.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogEnsureRecordSpace</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>ndeleted</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>blknoToDelete</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>nPendingPages</name></name> <operator>&gt;=</operator> <name><name>data</name><operator>.</operator><name>ndeleted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>nPendingPages</name></name> <operator>-=</operator> <name><name>data</name><operator>.</operator><name>ndeleted</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>metadata</name><operator>-&gt;</operator><name>nPendingHeapTuples</name></name> <operator>&gt;=</operator> <name>nDeletedHeapTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>nPendingHeapTuples</name></name> <operator>-=</operator> <name>nDeletedHeapTuples</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>blknoToDelete</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>tailFreeSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>nPendingPages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>nPendingHeapTuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Set pd_lower just past the end of the metadata.  This is essential,
		 * because without doing so, metadata will be lost if xlog.c
		 * compresses the page.  (We must do this here because pre-v11
		 * versions of PG did not set the metapage's pd_lower correctly, so a
		 * pg_upgraded index might contain the wrong value.)
		 */</comment>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>metapage</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>=</operator>
			<operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>metadata</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GinMetaPageData</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>metapage</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>.</operator><name>ndeleted</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>=</operator> <name>GIN_DELETED</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>metabuffer</name></expr></argument>,
							   <argument><expr><name>REGBUF_WILL_INIT</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>.</operator><name>ndeleted</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>metadata</name></name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>data</name></expr></argument>,
							 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogDeleteListPages</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_GIN_ID</name></expr></argument>, <argument><expr><name>XLOG_GIN_DELETE_LISTPAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>.</operator><name>ndeleted</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>.</operator><name>ndeleted</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>buffers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fill_fsm</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>.</operator><name>ndeleted</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RecordFreeIndexPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>freespace</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	</block_content>}</block> while <condition>(<expr><name>blknoToDelete</name> <operator>!=</operator> <name>newHead</name></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/* Initialize empty KeyArray */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initKeyArray</name><parameter_list>(<parameter><decl><type><name>KeyArray</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>maxvalues</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>keys</name><operator>-&gt;</operator><name>keys</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>maxvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>keys</name><operator>-&gt;</operator><name>categories</name></name> <operator>=</operator> <operator>(</operator><name>GinNullCategory</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinNullCategory</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>maxvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>keys</name><operator>-&gt;</operator><name>nvalues</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>keys</name><operator>-&gt;</operator><name>maxvalues</name></name> <operator>=</operator> <name>maxvalues</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add datum to KeyArray, resizing if needed */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addDatum</name><parameter_list>(<parameter><decl><type><name>KeyArray</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>GinNullCategory</name></type> <name>category</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>keys</name><operator>-&gt;</operator><name>nvalues</name></name> <operator>&gt;=</operator> <name><name>keys</name><operator>-&gt;</operator><name>maxvalues</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>keys</name><operator>-&gt;</operator><name>maxvalues</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keys</name><operator>-&gt;</operator><name>keys</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>keys</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>keys</name><operator>-&gt;</operator><name>maxvalues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>keys</name><operator>-&gt;</operator><name>categories</name></name> <operator>=</operator> <operator>(</operator><name>GinNullCategory</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>keys</name><operator>-&gt;</operator><name>categories</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinNullCategory</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>keys</name><operator>-&gt;</operator><name>maxvalues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>keys</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name><name>keys</name><operator>-&gt;</operator><name>nvalues</name></name></expr>]</index></name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>keys</name><operator>-&gt;</operator><name>categories</name><index>[<expr><name><name>keys</name><operator>-&gt;</operator><name>nvalues</name></name></expr>]</index></name> <operator>=</operator> <name>category</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>keys</name><operator>-&gt;</operator><name>nvalues</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Collect data from a pending-list page in preparation for insertion into
 * the main index.
 *
 * Go through all tuples &gt;= startoff on page and collect values in accum
 *
 * Note that ka is just workspace --- it does not carry any state across
 * calls.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>processPendingPage</name><parameter_list>(<parameter><decl><type><name>BuildAccumulator</name> <modifier>*</modifier></type><name>accum</name></decl></parameter>, <parameter><decl><type><name>KeyArray</name> <modifier>*</modifier></type><name>ka</name></decl></parameter>,
				   <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>startoff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>heapptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>attrnum</name></decl>;</decl_stmt>

	<comment type="block">/* reset *ka to empty */</comment>
	<expr_stmt><expr><name><name>ka</name><operator>-&gt;</operator><name>nvalues</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxoff</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>heapptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attrnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>startoff</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>curattnum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>curkey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GinNullCategory</name></type> <name>curcategory</name></decl>;</decl_stmt>

		<comment type="block">/* Check for change of heap TID or attnum */</comment>
		<expr_stmt><expr><name>curattnum</name> <operator>=</operator> <call><name>gintuple_get_attrnum</name><argument_list>(<argument><expr><name><name>accum</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>heapptr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>heapptr</name> <operator>=</operator> <name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>attrnum</name> <operator>=</operator> <name>curattnum</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name>heapptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				   <name>curattnum</name> <operator>==</operator> <name>attrnum</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ginInsertBAEntries can insert several datums per call, but only
			 * for one heap tuple and one column.  So call it at a boundary,
			 * and reset ka.
			 */</comment>
			<expr_stmt><expr><call><name>ginInsertBAEntries</name><argument_list>(<argument><expr><name>accum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heapptr</name></expr></argument>, <argument><expr><name>attrnum</name></expr></argument>,
							   <argument><expr><name><name>ka</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>, <argument><expr><name><name>ka</name><operator>-&gt;</operator><name>categories</name></name></expr></argument>, <argument><expr><name><name>ka</name><operator>-&gt;</operator><name>nvalues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ka</name><operator>-&gt;</operator><name>nvalues</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>heapptr</name> <operator>=</operator> <name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>attrnum</name> <operator>=</operator> <name>curattnum</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Add key to KeyArray */</comment>
		<expr_stmt><expr><name>curkey</name> <operator>=</operator> <call><name>gintuple_get_key</name><argument_list>(<argument><expr><name><name>accum</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curcategory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addDatum</name><argument_list>(<argument><expr><name>ka</name></expr></argument>, <argument><expr><name>curkey</name></expr></argument>, <argument><expr><name>curcategory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Dump out all remaining keys */</comment>
	<expr_stmt><expr><call><name>ginInsertBAEntries</name><argument_list>(<argument><expr><name>accum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heapptr</name></expr></argument>, <argument><expr><name>attrnum</name></expr></argument>,
					   <argument><expr><name><name>ka</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>, <argument><expr><name><name>ka</name><operator>-&gt;</operator><name>categories</name></name></expr></argument>, <argument><expr><name><name>ka</name><operator>-&gt;</operator><name>nvalues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Move tuples from pending pages into regular GIN structure.
 *
 * On first glance it looks completely not crash-safe. But if we crash
 * after posting entries to the main index and before removing them from the
 * pending list, it's okay because when we redo the posting later on, nothing
 * bad will happen.
 *
 * fill_fsm indicates that ginInsertCleanup should add deleted pages
 * to FSM otherwise caller is responsible to put deleted pages into
 * FSM.
 *
 * If stats isn't null, we count deleted pending pages into the counts.
 */</comment>
<function><type><name>void</name></type>
<name>ginInsertCleanup</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>full_clean</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>fill_fsm</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forceCleanup</name></decl></parameter>,
				 <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>index</name> <init>= <expr><name><name>ginstate</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuffer</name></decl>,
				<decl><type ref="prev"/><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapage</name></decl>,
				<decl><type ref="prev"/><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinMetaPageData</name> <modifier>*</modifier></type><name>metadata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>opCtx</name></decl>,
				<decl><type ref="prev"/><name>oldCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BuildAccumulator</name></type> <name>accum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>KeyArray</name></type>	<name>datums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>,
				<decl><type ref="prev"/><name>blknoFinish</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>cleanupFinish</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fsm_vac</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>workMemory</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We would like to prevent concurrent cleanup process. For that we will
	 * lock metapage in exclusive mode using LockPage() call. Nobody other
	 * will use that lock for metapage, so we keep possibility of concurrent
	 * insertion into pending list
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>forceCleanup</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We are called from [auto]vacuum/analyze or gin_clean_pending_list()
		 * and we would like to wait concurrent cleanup to finish.
		 */</comment>
		<expr_stmt><expr><call><name>LockPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>GIN_METAPAGE_BLKNO</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>workMemory</name> <operator>=</operator>
			<ternary><condition><expr><operator>(</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>autovacuum_work_mem</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then>
			<expr><name>autovacuum_work_mem</name></expr> </then><else>: <expr><name>maintenance_work_mem</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We are called from regular insert and if we see concurrent cleanup
		 * just exit in hope that concurrent process will clean up pending
		 * list.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>GIN_METAPAGE_BLKNO</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>workMemory</name> <operator>=</operator> <name>work_mem</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>metabuffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>GIN_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metadata</name> <operator>=</operator> <call><name>GinPageGetMeta</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>metadata</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Nothing to do */</comment>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>GIN_METAPAGE_BLKNO</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Remember a tail page to prevent infinite cleanup if other backends add
	 * new tuples faster than we can cleanup.
	 */</comment>
	<expr_stmt><expr><name>blknoFinish</name> <operator>=</operator> <name><name>metadata</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read and lock head of pending list
	 */</comment>
	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>metadata</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize.  All temporary space will be in opCtx
	 */</comment>
	<expr_stmt><expr><name>opCtx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"GIN insert cleanup temporary context"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>opCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initKeyArray</name><argument_list>(<argument><expr><operator>&amp;</operator><name>datums</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ginInitBA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accum</name><operator>.</operator><name>ginstate</name></name> <operator>=</operator> <name>ginstate</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * At the top of this loop, we have pin and lock on the current page of
	 * the pending list.  However, we'll release that before exiting the loop.
	 * Note we also have pin but not lock on the metapage.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Are we walk through the page which as we remember was a tail when
		 * we start our cleanup?  But if caller asks us to clean up whole
		 * pending list then ignore old tail, we will work until list becomes
		 * empty.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>blknoFinish</name> <operator>&amp;&amp;</operator> <name>full_clean</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cleanupFinish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * read page's datums into accum
		 */</comment>
		<expr_stmt><expr><call><name>processPendingPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datums</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Is it time to flush memory to disk?	Flush if we are at the end of
		 * the pending list, or if we have a full row and memory is getting
		 * full.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>==</operator> <name>InvalidBlockNumber</name> <operator>||</operator>
			<operator>(</operator><call><name>GinPageHasFullRow</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <operator>(</operator><name><name>accum</name><operator>.</operator><name>allocatedMemory</name></name> <operator>&gt;=</operator> <name>workMemory</name> <operator>*</operator> <literal type="number">1024L</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>nlist</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>key</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GinNullCategory</name></type> <name>category</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>,
						<decl><type ref="prev"/><name>attnum</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Unlock current page to increase performance. Changes of page
			 * will be checked later by comparing maxoff after completion of
			 * memory flush.
			 */</comment>
			<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Moving collected data into regular structure can take
			 * significant amount of time - so, run it without locking pending
			 * list.
			 */</comment>
			<expr_stmt><expr><call><name>ginBeginBAScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><name>list</name> <operator>=</operator> <call><name>ginGetBAEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accum</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>category</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlist</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ginEntryInsert</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>category</name></expr></argument>,
							   <argument><expr><name>list</name></expr></argument>, <argument><expr><name>nlist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>

			<comment type="block">/*
			 * Lock the whole list to remove pages
			 */</comment>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name>GIN_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * While we left the page unlocked, more stuff might have gotten
			 * added to it.  If so, process those entries immediately.  There
			 * shouldn't be very many, so we don't worry about the fact that
			 * we're doing this with exclusive lock. Insertion algorithm
			 * guarantees that inserted row(s) will not continue on next page.
			 * NOTE: intentionally no vacuum_delay_point in this loop.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>maxoff</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ginInitBA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>processPendingPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datums</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>maxoff</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ginBeginBAScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<while>while <condition>(<expr><operator>(</operator><name>list</name> <operator>=</operator> <call><name>ginGetBAEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accum</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>category</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nlist</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ginEntryInsert</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>category</name></expr></argument>,
								   <argument><expr><name>list</name></expr></argument>, <argument><expr><name>nlist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Remember next page - it will become the new list head
			 */</comment>
			<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* shiftList will do exclusive
											 * locking */</comment>

			<comment type="block">/*
			 * remove read pages from pending list, at this point all content
			 * of read pages is in regular structure
			 */</comment>
			<expr_stmt><expr><call><name>shiftList</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>fill_fsm</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* At this point, some pending pages have been freed up */</comment>
			<expr_stmt><expr><name>fsm_vac</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blkno</name> <operator>==</operator> <name><name>metadata</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * if we removed the whole pending list or we cleanup tail (which
			 * we remembered on start our cleanup process) then just exit
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>InvalidBlockNumber</name> <operator>||</operator> <name>cleanupFinish</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * release memory used so far and reinit state
			 */</comment>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>opCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initKeyArray</name><argument_list>(<argument><expr><operator>&amp;</operator><name>datums</name></expr></argument>, <argument><expr><name><name>datums</name><operator>.</operator><name>maxvalues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ginInitBA</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Read next page in pending list
		 */</comment>
		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>UnlockPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>GIN_METAPAGE_BLKNO</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * As pending list pages can have a high churn rate, it is desirable to
	 * recycle them immediately to the FreeSpace Map when ordinary backends
	 * clean the list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fsm_vac</name> <operator>&amp;&amp;</operator> <name>fill_fsm</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>IndexFreeSpaceMapVacuum</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean up temporary space */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>opCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL-callable function to clean the insert pending list
 */</comment>
<function><type><name>Datum</name></type>
<name>gin_clean_pending_list</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexBulkDeleteResult</name></type> <name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinState</name></type>	<name>ginstate</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery is in progress"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"GIN pending list cannot be cleaned up during recovery."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Must be a GIN index */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name><name>indexRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>GIN_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a GIN index"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Reject attempts to read non-local temporary relations; we would be
	 * likely to get wrong data since we have no visibility into the owning
	 * session's local buffers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot access temporary indexes of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* User must own the index (comparable to privileges needed for VACUUM) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_INDEX</name></expr></argument>,
					   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initGinState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ginstate</name></expr></argument>, <argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ginInsertCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ginstate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name><name>stats</name><operator>.</operator><name>pages_deleted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
