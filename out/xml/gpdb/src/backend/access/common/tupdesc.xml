<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/common/tupdesc.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tupdesc.c
 *	  POSTGRES tuple descriptor support code
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/common/tupdesc.c
 *
 * NOTES
 *	  some of the executor utility code such as "ExecTypeFromTL" should be
 *	  moved here.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * CreateTemplateTupleDesc
 *		This function allocates an empty tuple descriptor structure.
 *
 * Tuple type ID information is initially set for an anonymous record type;
 * caller can overwrite this if needed.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>CreateTemplateTupleDesc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>natts</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate enough memory for the tuple descriptor, including the
	 * attribute rows.
	 *
	 * Note: the attribute array stride is sizeof(FormData_pg_attribute),
	 * since we declare the array elements as FormData_pg_attribute for
	 * notational convenience.  However, we only guarantee that the first
	 * ATTRIBUTE_FIXED_PART_SIZE bytes of each entry are valid; most code that
	 * copies tupdesc entries around copies just that much.  In principle that
	 * could be less due to trailing padding, although with the current
	 * definition of pg_attribute there probably isn't any padding.
	 */</comment>
	<expr_stmt><expr><name>desc</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>TupleDescData</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call> <operator>+</operator>
							  <name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FormData_pg_attribute</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize other fields of the tupdesc.
	 */</comment>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>natts</name></name> <operator>=</operator> <name>natts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* assume not reference-counted */</comment>

	<return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateTupleDesc
 *		This function allocates a new TupleDesc by copying a given
 *		Form_pg_attribute array.
 *
 * Tuple type ID information is initially set for an anonymous record type;
 * caller can overwrite this if needed.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>CreateTupleDesc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateTupleDescCopy
 *		This function creates a new TupleDesc by copying from an existing
 *		TupleDesc.
 *
 * !!! Constraints and defaults are not copied !!!
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>CreateTupleDescCopy</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Flat-copy the attribute array */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FormData_pg_attribute</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we're not copying constraints and defaults, clear fields
	 * associated with them.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atthasmissing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* We can copy the tuple type identification, too */</comment>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>

	<return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateTupleDescCopyConstr
 *		This function creates a new TupleDesc by copying from an existing
 *		TupleDesc (including its constraints and defaults).
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>CreateTupleDescCopyConstr</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Flat-copy the attribute array */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FormData_pg_attribute</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the TupleConstr data structure, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>constr</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>cpy</name> <init>= <expr><operator>(</operator><name>TupleConstr</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleConstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>has_not_null</name></name> <operator>=</operator> <name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>has_generated_stored</name></name> <operator>=</operator> <name><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cpy</name><operator>-&gt;</operator><name>num_defval</name></name> <operator>=</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>defval</name></name> <operator>=</operator> <operator>(</operator><name>AttrDefault</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>cpy</name><operator>-&gt;</operator><name>num_defval</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cpy</name><operator>-&gt;</operator><name>defval</name></name></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>defval</name></name></expr></argument>, <argument><expr><name><name>cpy</name><operator>-&gt;</operator><name>num_defval</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>cpy</name><operator>-&gt;</operator><name>num_defval</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>defval</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adbin</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>defval</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adbin</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>defval</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>missing</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>missing</name></name> <operator>=</operator> <operator>(</operator><name>AttrMissing</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrMissing</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cpy</name><operator>-&gt;</operator><name>missing</name></name></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>missing</name></name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrMissing</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>missing</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>am_present</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>missing</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>am_value</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>missing</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>am_value</name></expr></argument>,
														 <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>,
														 <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cpy</name><operator>-&gt;</operator><name>num_check</name></name> <operator>=</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator> <operator>(</operator><name>ConstrCheck</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>cpy</name><operator>-&gt;</operator><name>num_check</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConstrCheck</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cpy</name><operator>-&gt;</operator><name>check</name></name></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>check</name></name></expr></argument>, <argument><expr><name><name>cpy</name><operator>-&gt;</operator><name>num_check</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConstrCheck</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>cpy</name><operator>-&gt;</operator><name>num_check</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccname</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccvalid</name> <operator>=</operator> <name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccvalid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cpy</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccnoinherit</name> <operator>=</operator> <name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccnoinherit</name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <name>cpy</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We can copy the tuple type identification, too */</comment>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>

	<return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TupleDescCopy
 *		Copy a tuple descriptor into caller-supplied memory.
 *		The memory may be shared memory mapped at any address, and must
 *		be sufficient to hold TupleDescSize(src) bytes.
 *
 * !!! Constraints and defaults are not copied !!!
 */</comment>
<function><type><name>void</name></type>
<name>TupleDescCopy</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Flat-copy the header and attribute array */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><call><name>TupleDescSize</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we're not copying constraints and defaults, clear fields
	 * associated with them.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dst</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atthasmissing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also, assume the destination is not to be ref-counted.  (Copying the
	 * source's refcount would be wrong in any case.)
	 */</comment>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TupleDescCopyEntry
 *		This function copies a single attribute structure from one tuple
 *		descriptor to another.
 *
 * !!! Constraints and defaults are not copied !!!
 */</comment>
<function><type><name>void</name></type>
<name>TupleDescCopyEntry</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>dstAttno</name></decl></parameter>,
				   <parameter><decl><type><name>TupleDesc</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>srcAttno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>dstAtt</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstAttno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>srcAtt</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcAttno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>srcAttno</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>srcAttno</name> <operator>&lt;=</operator> <name><name>src</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>dstAttno</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>dstAttno</name> <operator>&lt;=</operator> <name><name>dst</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dstAtt</name></expr></argument>, <argument><expr><name>srcAtt</name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Aside from updating the attno, we'd better reset attcacheoff.
	 *
	 * XXX Actually, to be entirely safe we'd need to reset the attcacheoff of
	 * all following columns in dst as well.  Current usage scenarios don't
	 * require that though, because all following columns will get initialized
	 * by other uses of this function or TupleDescInitEntry.  So we cheat a
	 * bit to avoid a useless O(N^2) penalty.
	 */</comment>
	<expr_stmt><expr><name><name>dstAtt</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>dstAttno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstAtt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* since we're not copying constraints or defaults, clear these */</comment>
	<expr_stmt><expr><name><name>dstAtt</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstAtt</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstAtt</name><operator>-&gt;</operator><name>atthasmissing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstAtt</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dstAtt</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free a TupleDesc including all substructure
 */</comment>
<function><type><name>void</name></type>
<name>FreeTupleDesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Possibly this should assert tdrefcount == 0, to disallow explicit
	 * freeing of un-refcounted tupdescs?
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>attrdef</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>defval</name></name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adbin</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attrdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>missing</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrMissing</name> <modifier>*</modifier></type><name>attrmiss</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>missing</name></name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>attrmiss</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>am_present</name>
					<operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attbyval</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>attrmiss</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>am_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attrmiss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ConstrCheck</name> <modifier>*</modifier></type><name>check</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>check</name></name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccname</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>constr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Increment the reference count of a tupdesc, and log the reference in
 * CurrentResourceOwner.
 *
 * Do not apply this to tupdescs that are not being refcounted.  (Use the
 * macro PinTupleDesc for tupdescs of uncertain status.)
 */</comment>
<function><type><name>void</name></type>
<name>IncrTupleDescRefCount</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResourceOwnerEnlargeTupleDescs</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerRememberTupleDesc</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Decrement the reference count of a tupdesc, remove the corresponding
 * reference from CurrentResourceOwner, and free the tupdesc if no more
 * references remain.
 *
 * Do not apply this to tupdescs that are not being refcounted.  (Use the
 * macro ReleaseTupleDesc for tupdescs of uncertain status.)
 */</comment>
<function><type><name>void</name></type>
<name>DecrTupleDescRefCount</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResourceOwnerForgetTupleDesc</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two TupleDesc structures for logical equality
 *
 * Note: we deliberately do not check the attrelid and tdtypmod fields.
 * This allows typcache.c to use this routine to see if a cached record type
 * matches a requested type, and is harmless for relcache.c's uses.
 * We don't compare tdrefcount, either.
 */</comment>
<function><type><name>bool</name></type>
<name>equalTupleDescs</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc1</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc2</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>strict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tupdesc1</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <name><name>tupdesc2</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>strict</name> <operator>&amp;&amp;</operator> <name><name>tupdesc1</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>!=</operator> <name><name>tupdesc2</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc1</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr1</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr2</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We do not need to check every single field here: we can disregard
		 * attrelid and attnum (which were used to place the row in the attrs
		 * array in the first place).  It might look like we could dispense
		 * with checking attlen/attbyval/attalign, since these are derived
		 * from atttypid; but in the case of dropped columns we must check
		 * them (since atttypid will be zero for all dropped columns) and in
		 * general it seems safer to check them always.
		 *
		 * attcacheoff must NOT be checked since it's possibly not set in both
		 * copies.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr1</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr2</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>attlen</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>attlen</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>attndims</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>attndims</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>attstorage</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>attalign</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>attalign</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>strict</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>attidentity</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>attislocal</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>attinhcount</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attr1</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>!=</operator> <name><name>attr2</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* attacl and attoptions are not even present... */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>strict</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tupdesc1</name><operator>-&gt;</operator><name>constr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr1</name> <init>= <expr><name><name>tupdesc1</name><operator>-&gt;</operator><name>constr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr2</name> <init>= <expr><name><name>tupdesc2</name><operator>-&gt;</operator><name>constr</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>constr2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>constr1</name><operator>-&gt;</operator><name>has_not_null</name></name> <operator>!=</operator> <name><name>constr2</name><operator>-&gt;</operator><name>has_not_null</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>constr1</name><operator>-&gt;</operator><name>has_generated_stored</name></name> <operator>!=</operator> <name><name>constr2</name><operator>-&gt;</operator><name>has_generated_stored</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>constr1</name><operator>-&gt;</operator><name>num_defval</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>constr2</name><operator>-&gt;</operator><name>num_defval</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>defval1</name> <init>= <expr><name><name>constr1</name><operator>-&gt;</operator><name>defval</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>defval2</name> <init>= <expr><name><name>constr2</name><operator>-&gt;</operator><name>defval</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We can't assume that the items are always read from the system
			 * catalogs in the same order; so use the adnum field to identify
			 * the matching item to compare.
			 */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>defval2</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>defval1</name><operator>-&gt;</operator><name>adnum</name></name> <operator>==</operator> <name><name>defval2</name><operator>-&gt;</operator><name>adnum</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defval1</name><operator>-&gt;</operator><name>adbin</name></name></expr></argument>, <argument><expr><name><name>defval2</name><operator>-&gt;</operator><name>adbin</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name><name>constr1</name><operator>-&gt;</operator><name>missing</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>constr2</name><operator>-&gt;</operator><name>missing</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc1</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AttrMissing</name> <modifier>*</modifier></type><name>missval1</name> <init>= <expr><name><name>constr1</name><operator>-&gt;</operator><name>missing</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AttrMissing</name> <modifier>*</modifier></type><name>missval2</name> <init>= <expr><name><name>constr2</name><operator>-&gt;</operator><name>missing</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>missval1</name><operator>-&gt;</operator><name>am_present</name></name> <operator>!=</operator> <name><name>missval2</name><operator>-&gt;</operator><name>am_present</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>missval1</name><operator>-&gt;</operator><name>am_present</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>missatt1</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>datumIsEqual</name><argument_list>(<argument><expr><name><name>missval1</name><operator>-&gt;</operator><name>am_value</name></name></expr></argument>, <argument><expr><name><name>missval2</name><operator>-&gt;</operator><name>am_value</name></name></expr></argument>,
									  <argument><expr><name><name>missatt1</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>, <argument><expr><name><name>missatt1</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>constr2</name><operator>-&gt;</operator><name>missing</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>constr1</name><operator>-&gt;</operator><name>num_check</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>constr2</name><operator>-&gt;</operator><name>num_check</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ConstrCheck</name> <modifier>*</modifier></type><name>check1</name> <init>= <expr><name><name>constr1</name><operator>-&gt;</operator><name>check</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ConstrCheck</name> <modifier>*</modifier></type><name>check2</name> <init>= <expr><name><name>constr2</name><operator>-&gt;</operator><name>check</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Similarly, don't assume that the checks are always read in the
			 * same order; match them up by name and contents. (The name
			 * *should* be unique, but...)
			 */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>check2</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>check1</name><operator>-&gt;</operator><name>ccname</name></name></expr></argument>, <argument><expr><name><name>check2</name><operator>-&gt;</operator><name>ccname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>check1</name><operator>-&gt;</operator><name>ccbin</name></name></expr></argument>, <argument><expr><name><name>check2</name><operator>-&gt;</operator><name>ccbin</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<name><name>check1</name><operator>-&gt;</operator><name>ccvalid</name></name> <operator>==</operator> <name><name>check2</name><operator>-&gt;</operator><name>ccvalid</name></name> <operator>&amp;&amp;</operator>
					<name><name>check1</name><operator>-&gt;</operator><name>ccnoinherit</name></name> <operator>==</operator> <name><name>check2</name><operator>-&gt;</operator><name>ccnoinherit</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tupdesc2</name><operator>-&gt;</operator><name>constr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * hashTupleDesc
 *		Compute a hash value for a tuple descriptor.
 *
 * If two tuple descriptors would be considered equal by equalTupleDescs()
 * then their hash value will be equal according to this function.
 *
 * Note that currently contents of constraint are not hashed - it'd be a bit
 * painful to do so, and conflicts just due to constraints are unlikely.
 */</comment>
<function><type><name>uint32</name></type>
<name>hashTupleDesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TupleDescInitEntry
 *		This function initializes a single attribute structure in
 *		a previously allocated tuple descriptor.
 *
 * If attributeName is NULL, the attname field is set to an empty string
 * (this is for cases where we don't know or need a name for the field).
 * Also, some callers use this function to change the datatype-related fields
 * in an existing tupdesc; they pass attributeName = NameStr(att-&gt;attname)
 * to indicate that the attname field shouldn't be modified.
 *
 * Note that attcollation is set to the default for the specified datatype.
 * If a nondefault collation is needed, insert it afterwards using
 * TupleDescInitEntryCollation.
 */</comment>
<function><type><name>void</name></type>
<name>TupleDescInitEntry</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>,
				   <parameter><decl><type><name>AttrNumber</name></type> <name>attributeNumber</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attributeName</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>oidtypeid</name></decl></parameter>,
				   <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>attdim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>attributeNumber</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>attributeNumber</name> <operator>&lt;=</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize the attribute fields
	 */</comment>
	<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attributeNumber</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attrelid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* dummy value */</comment>

	<comment type="block">/*
	 * Note: attributeName can be NULL, because the planner doesn't always
	 * fill in valid resname values in targetlists, particularly for resjunk
	 * attributes. Also, do nothing if caller wants to re-use the old attname.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>attributeName</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>attributeName</name> <operator>!=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>att</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attributeNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attndims</name></name> <operator>=</operator> <name>attdim</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atthasmissing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* attacl, attoptions and attfdwoptions are not present in tupledescs */</comment>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oidtypeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>oidtypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>=</operator> <name>oidtypeid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>=</operator> <name><name>typeForm</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>=</operator> <name><name>typeForm</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name> <operator>=</operator> <name><name>typeForm</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <name><name>typeForm</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>=</operator> <name><name>typeForm</name><operator>-&gt;</operator><name>typcollation</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TupleDescInitBuiltinEntry
 *		Initialize a tuple descriptor without catalog access.  Only
 *		a limited range of builtin types are supported.
 */</comment>
<function><type><name>void</name></type>
<name>TupleDescInitBuiltinEntry</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>,
						  <parameter><decl><type><name>AttrNumber</name></type> <name>attributeNumber</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attributeName</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>oidtypeid</name></decl></parameter>,
						  <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>attdim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

	<comment type="block">/* sanity checks */</comment>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>attributeNumber</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>attributeNumber</name> <operator>&lt;=</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize the attribute fields */</comment>
	<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attributeNumber</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attrelid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* dummy value */</comment>

	<comment type="block">/* unlike TupleDescInitEntry, we require an attribute name */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attributeName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>att</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attributeNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attndims</name></name> <operator>=</operator> <name>attdim</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atthasmissing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* attacl, attoptions and attfdwoptions are not present in tupledescs */</comment>

	<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>=</operator> <name>oidtypeid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Our goal here is to support just enough types to let basic builtin
	 * commands work without catalog access - e.g. so that we can do certain
	 * things even in processes that are not connected to a database.
	 */</comment>
	<switch>switch <condition>(<expr><name>oidtypeid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TEXTOID</name></expr>:</case>
		<case>case <expr><name>TEXTARRAYOID</name></expr>:</case>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>=</operator> <name>DEFAULT_COLLATION_OID</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>BOOLOID</name></expr>:</case>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name> <operator>=</operator> <literal type="char">'c'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>INT4OID</name></expr>:</case>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>=</operator> <name>FLOAT8PASSBYVAL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name> <operator>=</operator> <literal type="char">'d'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported type %u"</literal></expr></argument>, <argument><expr><name>oidtypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * TupleDescInitEntryCollation
 *
 * Assign a nondefault collation to a previously initialized tuple descriptor
 * entry.
 */</comment>
<function><type><name>void</name></type>
<name>TupleDescInitEntryCollation</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>,
							<parameter><decl><type><name>AttrNumber</name></type> <name>attributeNumber</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name></type> <name>collationid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>attributeNumber</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>attributeNumber</name> <operator>&lt;=</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attributeNumber</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcollation</name> <operator>=</operator> <name>collationid</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * BuildDescForRelation
 *
 * Given a relation schema (list of ColumnDef nodes), build a TupleDesc.
 *
 * Note: the default assumption is no OIDs; caller may modify the returned
 * TupleDesc if it wants OIDs.  Also, tdtypeid will need to be filled in
 * later on.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>BuildDescForRelation</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_not_null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>atttypid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>atttypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>attcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attdim</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * allocate a new tuple descriptor
	 */</comment>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>has_not_null</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>schema</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * for each entry in the list, get the name and type information from
		 * the list and have TupleDescInitEntry fill in the attribute
		 * information we need.
		 */</comment>
		<expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>attname</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>colname</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>atttypid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>atttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attdim</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>arrayBounds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>setof</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" cannot be declared SETOF"</literal></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>,
						   <argument><expr><name>atttypid</name></expr></argument>, <argument><expr><name>atttypmod</name></expr></argument>, <argument><expr><name>attdim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Override TupleDescInitEntry's settings as requested */</comment>
		<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>storage</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>storage</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Fill in additional stuff not handled by TupleDescInitEntry */</comment>
		<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>has_not_null</name> <operator>|=</operator> <name><name>entry</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>is_local</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>inhcount</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>has_not_null</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><operator>(</operator><name>TupleConstr</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleConstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>has_generated_stored</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>defval</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>missing</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>check</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <name>constr</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BuildDescFromLists
 *
 * Build a TupleDesc given lists of column names (as String nodes),
 * column type OIDs, typmods, and collation OIDs.
 *
 * No constraints are generated.
 *
 * This is essentially a cut-down version of BuildDescForRelation for use
 * with functions returning RECORD.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>BuildDescFromLists</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>types</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>typmods</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l4</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>natts</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>natts</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>natts</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>typmods</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>natts</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>collations</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate a new tuple descriptor
	 */</comment>
	<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>forfour</name><argument_list>(<argument>l1</argument>, <argument>names</argument>, <argument>l2</argument>, <argument>types</argument>, <argument>l3</argument>, <argument>typmods</argument>, <argument>l4</argument>, <argument>collations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>atttypid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>atttypmod</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>attcollation</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l4</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>, <argument><expr><name>atttypid</name></expr></argument>, <argument><expr><name>atttypmod</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>
</unit>
