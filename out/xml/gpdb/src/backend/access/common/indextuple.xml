<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/common/indextuple.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * indextuple.c
 *	   This file contains index tuple accessor and mutator routines,
 *	   as well as various tuple utilities.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/common/indextuple.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/itup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>


<comment type="block">/* ----------------------------------------------------------------
 *				  index_ tuple interface routines
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *		index_form_tuple
 *
 *		This shouldn't leak any memory; otherwise, callers such as
 *		tuplesort_putindextuplevalues() will be very unhappy.
 *
 *		This shouldn't perform external table access provided caller
 *		does not pass values that are stored EXTERNAL.
 * ----------------
 */</comment>
<function><type><name>IndexTuple</name></type>
<name>index_form_tuple</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>				<comment type="block">/* tuple pointer */</comment>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>			<comment type="block">/* return tuple */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>,
				<decl><type ref="prev"/><name>data_size</name></decl>,
				<decl><type ref="prev"/><name>hoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>infomask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>tupmask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfAttributes</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TOAST_INDEX_HACK</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>untoasted_values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>untoasted_free</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>numberOfAttributes</name> <operator>&gt;</operator> <name>INDEX_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of index columns (%d) exceeds limit (%d)"</literal></expr></argument>,
						<argument><expr><name>numberOfAttributes</name></expr></argument>, <argument><expr><name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TOAST_INDEX_HACK</name></cpp:ifdef>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>untoasted_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Do nothing if value is NULL or not of varlena type */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If value is stored EXTERNAL, must fetch it so we are not depending
		 * on outside storage.  This should be improved someday.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>heap_tuple_fetch_attr</name><argument_list>(<argument><expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator>
													  <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>untoasted_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If value is above size target, and is of a compressible datatype,
		 * try to compress it in-line.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTENDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>VARSIZE</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>TOAST_INDEX_TARGET</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>==</operator> <literal type="char">'x'</literal> <operator>||</operator> <name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>==</operator> <literal type="char">'m'</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>cvalue</name> <init>= <expr><call><name>toast_compress_datum</name><argument_list>(<argument><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>cvalue</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* successful compression */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>untoasted_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>cvalue</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>untoasted_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>hasnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>infomask</name> <operator>|=</operator> <name>INDEX_NULL_MASK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hoff</name> <operator>=</operator> <call><name>IndexInfoFindDataOffset</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TOAST_INDEX_HACK</name></cpp:ifdef>
	<expr_stmt><expr><name>data_size</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
									   <argument><expr><name>untoasted_values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>data_size</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
									   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <name>hoff</name> <operator>+</operator> <name>data_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* be conservative */</comment>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <name>tp</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_fill_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TOAST_INDEX_HACK</name></cpp:ifdef>
					<argument><expr><name>untoasted_values</name></expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<argument><expr><name>values</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<argument><expr><name>isnull</name></expr></argument>,
					<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tp</name> <operator>+</operator> <name>hoff</name></expr></argument>,
					<argument><expr><name>data_size</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>tupmask</name></expr></argument>,
					<argument><expr><operator>(</operator><ternary><condition><expr><name>hasnull</name></expr> ?</condition><then> <expr><operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator> <name>tp</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TOAST_INDEX_HACK</name></cpp:ifdef>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>untoasted_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * We do this because heap_fill_tuple wants to initialize a "tupmask"
	 * which is used for HeapTuples, but we want an indextuple infomask. The
	 * only relevant info is the "has variable attributes" field. We have
	 * already set the hasnull bit above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupmask</name> <operator>&amp;</operator> <name>HEAP_HASVARWIDTH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>infomask</name> <operator>|=</operator> <name>INDEX_VAR_MASK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also assert we got rid of external attributes */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TOAST_INDEX_HACK</name></cpp:ifdef>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>tupmask</name> <operator>&amp;</operator> <name>HEAP_HASEXTERNAL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Here we make sure that the size will fit in the field reserved for it
	 * in t_info.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size</name> <operator>&amp;</operator> <name>INDEX_SIZE_MASK</name><operator>)</operator> <operator>!=</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row requires %zu bytes, maximum size is %zu"</literal></expr></argument>,
						<argument><expr><name>size</name></expr></argument>, <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>INDEX_SIZE_MASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>infomask</name> <operator>|=</operator> <name>size</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize metadata
	 */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_info</name></name> <operator>=</operator> <name>infomask</name></expr>;</expr_stmt>
	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		nocache_index_getattr
 *
 *		This gets called from index_getattr() macro, and only in cases
 *		where we can't use cacheoffset and the value is not null.
 *
 *		This caches attribute offsets in the attribute descriptor.
 *
 *		An alternative way to speed things up would be to cache offsets
 *		with the tuple, but that seems more difficult unless you take
 *		the storage hit of actually putting those offsets into the
 *		tuple you send to disk.  Yuck.
 *
 *		This scheme will be slightly slower than that, but should
 *		perform well for queries which hit large #'s of tuples.  After
 *		you cache the offsets once, examining all the other tuples using
 *		the same attribute descriptor will go much quicker. -cim 5/4/91
 * ----------------
 */</comment>
<function><type><name>Datum</name></type>
<name>nocache_index_getattr</name><parameter_list>(<parameter><decl><type><name>IndexTuple</name></type> <name>tup</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>,
					  <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>				<comment type="block">/* ptr to data part of tuple */</comment>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>		<comment type="block">/* ptr to null bitmap in tuple */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>slow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* do we have to walk attrs? */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>data_off</name></decl>;</decl_stmt>		<comment type="block">/* tuple data offset */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>			<comment type="block">/* current offset within data */</comment>

	<comment type="block">/* ----------------
	 *	 Three cases:
	 *
	 *	 1: No nulls and no variable-width attributes.
	 *	 2: Has a null or a var-width AFTER att.
	 *	 3: Has nulls or var-widths BEFORE att.
	 * ----------------
	 */</comment>

	<expr_stmt><expr><name>data_off</name> <operator>=</operator> <call><name>IndexInfoFindDataOffset</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name><operator>--</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IndexTupleHasNulls</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * there's a null somewhere in the tuple
		 *
		 * check to see if desired att is null
		 */</comment>

		<comment type="block">/* XXX "knows" t_bits are just after fixed tuple header! */</comment>
		<expr_stmt><expr><name>bp</name> <operator>=</operator> <operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tup</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now check to see if any preceding bits are null...
		 */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>byte</name> <init>= <expr><name>attnum</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>finalbit</name> <init>= <expr><name>attnum</name> <operator>&amp;</operator> <literal type="number">0x07</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/* check for nulls "before" final bit of last byte */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>~</operator><name><name>bp</name><index>[<expr><name>byte</name></expr>]</index></name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>finalbit</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* check for nulls in any "earlier" bytes */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>byte</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>bp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0xFF</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tup</name> <operator>+</operator> <name>data_off</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we get here, there are no nulls up to and including the target
		 * attribute.  If we have a cached offset, we can use it.
		 */</comment>
		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>fetchatt</name><argument_list>(<argument><expr><name>att</name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Otherwise, check for non-fixed-length attrs up to and including
		 * target.  If there aren't any, it's safe to cheaply initialize the
		 * cached offsets for these attrs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IndexTupleHasVarwidths</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>attnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we get here, we have a tuple with no nulls or var-widths up to
		 * and including the target attribute, so we can use the cached offset
		 * ... only we don't have it yet, or we'd not have got here.  Since
		 * it's cheap to compute offsets for fixed-width columns, we take the
		 * opportunity to initialize the cached offsets for *all* the leading
		 * fixed-width columns, in hope of avoiding future visits to this
		 * routine.
		 */</comment>
		<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* we might have set some offsets in the slow path previously */</comment>
		<while>while <condition>(<expr><name><name>j</name> <argument_list type="generic">&lt; <argument><expr><name>natts</name> <operator>&amp;&amp;</operator> <name>TupleDescAttr</name><operator>(</operator><name>tupleDesc</name>, <name>j</name><operator>)</operator><operator>-&gt;</operator><name>attcacheoff</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name> <operator>+</operator>
			<call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attlen</name></expr>;</expr_stmt>

		<for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>off</name> <operator>+=</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>&gt;</operator> <name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>usecache</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Now we know that we have to walk the tuple CAREFULLY.  But we still
		 * might be able to cache some offsets for next time.
		 *
		 * Note - This loop is a little tricky.  For each non-null attribute,
		 * we have to first account for alignment padding before the attr,
		 * then advance over the attr based on its length.  Nulls have no
		 * storage and no alignment padding either.  We can use/set
		 * attcacheoff until we reach either a null or a var-width attribute.
		 */</comment>
		<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>		<comment type="block">/* loop exit is at "break" */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IndexTupleHasNulls</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>att_isnull</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>usecache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<continue>continue;</continue>		<comment type="block">/* this cannot be the target att */</comment>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* If we know the next offset, we can skip the rest */</comment>
			<if_stmt><if>if <condition>(<expr><name>usecache</name> <operator>&amp;&amp;</operator> <name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We can only cache the offset for a varlena attribute if the
				 * offset is already suitably aligned, so that there would be
				 * no pad bytes in any case: then the offset will be valid for
				 * either an aligned or unaligned value.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>usecache</name> <operator>&amp;&amp;</operator>
					<name>off</name> <operator>==</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											<argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>usecache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* not varlena, so safe to use att_align_nominal */</comment>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>usecache</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>usecache</name> <operator>&amp;&amp;</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>usecache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>fetchatt</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an index tuple into Datum/isnull arrays.
 *
 * The caller must allocate sufficient storage for the output arrays.
 * (INDEX_MAX_KEYS entries should be enough.)
 *
 * This is nearly the same as heap_deform_tuple(), but for IndexTuples.
 * One difference is that the tuple should never have any missing columns.
 */</comment>
<function><type><name>void</name></type>
<name>index_deform_tuple</name><parameter_list>(<parameter><decl><type><name>IndexTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>hasnulls</name> <init>= <expr><call><name>IndexTupleHasNulls</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* number of atts to extract */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>				<comment type="block">/* ptr to tuple data */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>			<comment type="block">/* offset in tuple data */</comment>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>				<comment type="block">/* ptr to null bitmap in tuple */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>slow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* can we use/set attcacheoff? */</comment>

	<comment type="block">/* Assert to protect callers who allocate fixed-size arrays */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>natts</name> <operator>&lt;=</operator> <name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX "knows" t_bits are just after fixed tuple header! */</comment>
	<expr_stmt><expr><name>bp</name> <operator>=</operator> <operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tup</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tup</name> <operator>+</operator> <call><name>IndexInfoFindDataOffset</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>thisatt</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hasnulls</name> <operator>&amp;&amp;</operator> <call><name>att_isnull</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* can't use attcacheoff anymore */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name> <operator>&amp;&amp;</operator> <name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We can only cache the offset for a varlena attribute if the
			 * offset is already suitably aligned, so that there would be no
			 * pad bytes in any case: then the offset will be valid for either
			 * an aligned or unaligned value.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name> <operator>&amp;&amp;</operator>
				<name>off</name> <operator>==</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* not varlena, so safe to use att_align_nominal */</comment>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <call><name>fetchatt</name><argument_list>(<argument><expr><name>thisatt</name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* can't use attcacheoff anymore */</comment>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Create a palloc'd copy of an index tuple.
 */</comment>
<function><type><name>IndexTuple</name></type>
<name>CopyIndexTuple</name><parameter_list>(<parameter><decl><type><name>IndexTuple</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a palloc'd copy of an index tuple, leaving only the first
 * leavenatts attributes remaining.
 *
 * Truncation is guaranteed to result in an index tuple that is no
 * larger than the original.  It is safe to use the IndexTuple with
 * the original tuple descriptor, but caller must avoid actually
 * accessing truncated attributes from returned tuple!  In practice
 * this means that index_getattr() must be called with special care,
 * and that the truncated tuple should only ever be accessed by code
 * under caller's direct control.
 *
 * It's safe to call this function with a buffer lock held, since it
 * never performs external table access.  If it ever became possible
 * for index tuples to contain EXTERNAL TOAST values, then this would
 * have to be revisited.
 */</comment>
<function><type><name>IndexTuple</name></type>
<name>index_truncate_tuple</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>sourceDescriptor</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>source</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>leavenatts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>truncdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>truncated</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leavenatts</name> <operator>&lt;=</operator> <name><name>sourceDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Easy case: no truncation actually required */</comment>
	<if_stmt><if>if <condition>(<expr><name>leavenatts</name> <operator>==</operator> <name><name>sourceDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Create temporary descriptor to scribble on */</comment>
	<expr_stmt><expr><name>truncdesc</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>TupleDescSize</name><argument_list>(<argument><expr><name>sourceDescriptor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescCopy</name><argument_list>(<argument><expr><name>truncdesc</name></expr></argument>, <argument><expr><name>sourceDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>truncdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>=</operator> <name>leavenatts</name></expr>;</expr_stmt>

	<comment type="block">/* Deform, form copy of tuple with fewer attributes */</comment>
	<expr_stmt><expr><call><name>index_deform_tuple</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>truncdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>truncated</name> <operator>=</operator> <call><name>index_form_tuple</name><argument_list>(<argument><expr><name>truncdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>truncated</name><operator>-&gt;</operator><name>t_tid</name></name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>truncated</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cannot leak memory here, TupleDescCopy() doesn't allocate any inner
	 * structure, so, plain pfree() should clean all allocated memory
	 */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>truncdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>truncated</name></expr>;</return>
</block_content>}</block></function>
</unit>
