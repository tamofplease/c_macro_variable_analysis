<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/common/heaptuple.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * heaptuple.c
 *	  This file contains heap tuple accessor and mutator routines, as well
 *	  as various tuple utilities.
 *
 * Some notes about varlenas and this code:
 *
 * Before Postgres 8.3 varlenas always had a 4-byte length header, and
 * therefore always needed 4-byte alignment (at least).  This wasted space
 * for short varlenas, for example CHAR(1) took 5 bytes and could need up to
 * 3 additional padding bytes for alignment.
 *
 * Now, a short varlena (up to 126 data bytes) is reduced to a 1-byte header
 * and we don't align it.  To hide this from datatype-specific functions that
 * don't want to deal with it, such a datum is considered "toasted" and will
 * be expanded back to the normal 4-byte-header format by pg_detoast_datum.
 * (In performance-critical code paths we can use pg_detoast_datum_packed
 * and the appropriate access macros to avoid that overhead.)  Note that this
 * conversion is performed directly in heap_form_tuple, without invoking
 * tuptoaster.c.
 *
 * This change will break any code that assumes it needn't detoast values
 * that have been put into a tuple but never sent to disk.  Hopefully there
 * are few such places.
 *
 * Varlenas still have alignment 'i' (or 'd') in pg_type/pg_attribute, since
 * that's the normal requirement for the untoasted format.  But we ignore that
 * for the 1-byte-header format.  This means that the actual start position
 * of a varlena datum may vary depending on which format it has.  To determine
 * what is stored, we have to require that alignment padding bytes be zero.
 * (Postgres actually has always zeroed them, but now it's required!)  Since
 * the first byte of a 1-byte-header varlena can never be zero, we can examine
 * the first byte after the previous datum to tell if it's a pad byte or the
 * start of a 1-byte-header varlena.
 *
 * Note that while formerly we could rely on the first varlena column of a
 * system catalog to be at the offset suggested by the C struct for the
 * catalog, this is now risky: it's only safe if the preceding field is
 * word-aligned, so that there will never be any padding.
 *
 * We don't pack varlenas whose attstorage is 'p', since the data type
 * isn't expecting to have to detoast values.  This is used in particular
 * by oidvector and int2vector, which are used in the system catalogs
 * and we'd like to still refer to them via C struct offsets.
 *
 *
 * Portions Copyright (c) 2006-2009, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/common/heaptuple.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tuptable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/expandeddatum.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>                <comment type="block">/* GpIdentity.segindex */</comment>

<comment type="block">/* Does att's datatype allow packing into the 1-byte-header varlena format? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATT_IS_PACKABLE</name><parameter_list>(<parameter><type><name>att</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((att)-&gt;attlen == -1 &amp;&amp; (att)-&gt;attstorage != 'p')</cpp:value></cpp:define>
<comment type="block">/* Use this if it's already known varlena */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARLENA_ATT_IS_PACKABLE</name><parameter_list>(<parameter><type><name>att</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((att)-&gt;attstorage != 'p')</cpp:value></cpp:define>


<comment type="block">/* ----------------------------------------------------------------
 *						misc support routines
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Return the missing value of an attribute, or NULL if there isn't one.
 */</comment>
<function><type><name>Datum</name></type>
<name>getmissingattr</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>atthasmissing</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrMissing</name> <modifier>*</modifier></type><name>attrmiss</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>missing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>attrmiss</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>missing</name></name> <operator>+</operator> <operator>(</operator><name>attnum</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attrmiss</name><operator>-&gt;</operator><name>am_present</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return <expr><name><name>attrmiss</name><operator>-&gt;</operator><name>am_value</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_compute_data_size
 *		Determine size of the data area of a tuple to be constructed
 */</comment>
<function><type><name>Size</name></type>
<name>heap_compute_data_size</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>data_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfAttributes</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>atti</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>atti</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ATT_IS_PACKABLE</name><argument_list>(<argument><expr><name>atti</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>VARATT_CAN_MAKE_SHORT</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * we're anticipating converting to a short varlena header, so
			 * adjust length and don't count any alignment
			 */</comment>
			<expr_stmt><expr><name>data_length</name> <operator>+=</operator> <call><name>VARATT_CONVERTED_SHORT_SIZE</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>atti</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
				 <call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * we want to flatten the expanded value so that the constructed
			 * tuple doesn't depend on it
			 */</comment>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name><name>atti</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_length</name> <operator>+=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_align_datum</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name><name>atti</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>,
										  <argument><expr><name><name>atti</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name><name>atti</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>,
											  <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>data_length</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Per-attribute helper for heap_fill_tuple and other routines building tuples.
 *
 * Fill in either a data value or a bit in the null bitmask
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>fill_val</name><parameter_list>(<parameter><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl></parameter>,
		 <parameter><decl><type><name>bits8</name> <modifier>*</modifier><modifier>*</modifier></type><name>bit</name></decl></parameter>,
		 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>bitmask</name></decl></parameter>,
		 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dataP</name></decl></parameter>,
		 <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>infomask</name></decl></parameter>,
		 <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>,
		 <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>data_length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>*</operator><name>dataP</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're building a null bitmap, set the appropriate bit for the
	 * current column value here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bit</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bitmask</name> <operator>!=</operator> <name>HIGHBIT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>bit</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>*</operator><name>bit</name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>|=</operator> <name>HEAP_HASNULL</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><operator>*</operator><name>bit</name> <operator>|=</operator> <operator>*</operator><name>bitmask</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * XXX we use the att_align macros on the pointer value itself, not on an
	 * offset.  This is a bit of a hack.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pass-by-value */</comment>
		<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>store_att_byval</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_length</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* varlena */</comment>
		<decl_stmt><decl><type><name>Pointer</name></type>		<name>val</name> <init>= <expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>|=</operator> <name>HEAP_HASVARWIDTH</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * we want to flatten the expanded value so that the
				 * constructed tuple doesn't depend on it
				 */</comment>
				<decl_stmt><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eoh</name> <init>= <expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data</name></expr></argument>,
												  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EOH_flatten_into</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>|=</operator> <name>HEAP_HASEXTERNAL</name></expr>;</expr_stmt>
				<comment type="block">/* no alignment, since it's short by definition */</comment>
				<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>VARSIZE_EXTERNAL</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no alignment for short varlenas */</comment>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>VARLENA_ATT_IS_PACKABLE</name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>VARATT_CAN_MAKE_SHORT</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* convert to short varlena -- no alignment */</comment>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>VARATT_CONVERTED_SHORT_SIZE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SET_VARSIZE_SHORT</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_length</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* full 4-byte header varlena */</comment>
			<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data</name></expr></argument>,
											  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cstring ... never needs alignment */</comment>
		<expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>|=</operator> <name>HEAP_HASVARWIDTH</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name> <operator>==</operator> <literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* fixed-length pass-by-reference */</comment>
		<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_length</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>data_length</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>dataP</name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * heap_fill_tuple
 *		Load data portion of a tuple from values/isnull arrays
 *
 * We also fill the null bitmap (if any) and set the infomask bits
 * that reflect the tuple's data contents.
 *
 * NOTE: it is now REQUIRED that the caller have pre-zeroed the data area.
 *
 *
 * @param isnull will only be used if &lt;code&gt;bit&lt;/code&gt; is non-NULL
 * @param bit should be non-NULL (refer to td-&gt;t_bits) if isnull is set and contains non-null values
 */</comment>
<function><type><name>Size</name></type>
<name>heap_fill_tuple</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
				<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>data_size</name></decl></parameter>,
				<parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>infomask</name></decl></parameter>, <parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>bit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bitP</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfAttributes</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>bit</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bitP</name> <operator>=</operator> <operator>&amp;</operator><name><name>bit</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <name>HIGHBIT</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* just to keep compiler quiet */</comment>
		<expr_stmt><expr><name>bitP</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_HASNULL</name> <operator>|</operator> <name>HEAP_HASVARWIDTH</name> <operator>|</operator> <name>HEAP_HASEXTERNAL</name><operator>)</operator></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fill_val</name><argument_list>(<argument><expr><name>attr</name></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>bitP</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>bitP</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
				 <argument><expr><operator>&amp;</operator><name>bitmask</name></expr></argument>,
				 <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>,
				 <argument><expr><name>infomask</name></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>values</name></expr> ?</condition><then> <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>data</name> <operator>-</operator> <name>start</name><operator>)</operator> <operator>==</operator> <name>data_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>data_size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *						heap tuple interface
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *		heap_attisnull	- returns true iff tuple attribute is not present
 * ----------------
 */</comment>
<function><type><name>bool</name></type>
<name>heap_attisnull</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We allow a NULL tupledesc for relations not expected to have missing
	 * values, such as catalog relations and indexes.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>tupleDesc</name> <operator>||</operator> <name>attnum</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>tupleDesc</name> <operator>&amp;&amp;</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atthasmissing</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleNoNulls</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><call><name>att_isnull</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_bits</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>attnum</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TableOidAttributeNumber</name></expr>:</case>
		<case>case <expr><name>SelfItemPointerAttributeNumber</name></expr>:</case>
		<case>case <expr><name>MinTransactionIdAttributeNumber</name></expr>:</case>
		<case>case <expr><name>MinCommandIdAttributeNumber</name></expr>:</case>
		<case>case <expr><name>MaxTransactionIdAttributeNumber</name></expr>:</case>
		<case>case <expr><name>MaxCommandIdAttributeNumber</name></expr>:</case>
        <case>case <expr><name>GpSegmentIdAttributeNumber</name></expr>:</case>       <comment type="block">/*CDB*/</comment>
			<comment type="block">/* these are never null */</comment>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attnum: %d"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		nocachegetattr
 *
 *		This only gets called from fastgetattr() macro, in cases where
 *		we can't use a cacheoffset and the value is not null.
 *
 *		This caches attribute offsets in the attribute descriptor.
 *
 *		An alternative way to speed things up would be to cache offsets
 *		with the tuple, but that seems more difficult unless you take
 *		the storage hit of actually putting those offsets into the
 *		tuple you send to disk.  Yuck.
 *
 *		This scheme will be slightly slower than that, but should
 *		perform well for queries which hit large #'s of tuples.  After
 *		you cache the offsets once, examining all the other tuples using
 *		the same attribute descriptor will go much quicker. -cim 5/4/91
 *
 *		NOTE: if you need to change this code, see also heap_deform_tuple.
 *		Also see nocache_index_getattr, which is the same code for index
 *		tuples.
 * ----------------
 */</comment>
<function><type><name>Datum</name></type>
<name>nocachegetattr</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>,
			   <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tup</name> <init>= <expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>				<comment type="block">/* ptr to data part of tuple */</comment>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bp</name> <init>= <expr><name><name>tup</name><operator>-&gt;</operator><name>t_bits</name></name></expr></init></decl>;</decl_stmt>	<comment type="block">/* ptr to null bitmap in tuple */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>slow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* do we have to walk attrs? */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>			<comment type="block">/* current offset within data */</comment>

	<comment type="block">/* ----------------
	 *	 Three cases:
	 *
	 *	 1: No nulls and no variable-width attributes.
	 *	 2: Has a null or a var-width AFTER att.
	 *	 3: Has nulls or var-widths BEFORE att.
	 * ----------------
	 */</comment>

	<expr_stmt><expr><name>attnum</name><operator>--</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleNoNulls</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * there's a null somewhere in the tuple
		 *
		 * check to see if any preceding bits are null...
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>byte</name> <init>= <expr><name>attnum</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>finalbit</name> <init>= <expr><name>attnum</name> <operator>&amp;</operator> <literal type="number">0x07</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* check for nulls "before" final bit of last byte */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>~</operator><name><name>bp</name><index>[<expr><name>byte</name></expr>]</index></name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>finalbit</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* check for nulls in any "earlier" bytes */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>byte</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>bp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0xFF</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tup</name> <operator>+</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we get here, there are no nulls up to and including the target
		 * attribute.  If we have a cached offset, we can use it.
		 */</comment>
		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>fetchatt</name><argument_list>(<argument><expr><name>att</name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Otherwise, check for non-fixed-length attrs up to and including
		 * target.  If there aren't any, it's safe to cheaply initialize the
		 * cached offsets for these attrs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasVarWidth</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>attnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we get here, we have a tuple with no nulls or var-widths up to
		 * and including the target attribute, so we can use the cached offset
		 * ... only we don't have it yet, or we'd not have got here.  Since
		 * it's cheap to compute offsets for fixed-width columns, we take the
		 * opportunity to initialize the cached offsets for *all* the leading
		 * fixed-width columns, in hope of avoiding future visits to this
		 * routine.
		 */</comment>
		<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* we might have set some offsets in the slow path previously */</comment>
		<while>while <condition>(<expr><name><name>j</name> <argument_list type="generic">&lt; <argument><expr><name>natts</name> <operator>&amp;&amp;</operator> <name>TupleDescAttr</name><operator>(</operator><name>tupleDesc</name>, <name>j</name><operator>)</operator><operator>-&gt;</operator><name>attcacheoff</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name> <operator>+</operator>
			<call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attlen</name></expr>;</expr_stmt>

		<for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>off</name> <operator>+=</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>&gt;</operator> <name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>usecache</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Now we know that we have to walk the tuple CAREFULLY.  But we still
		 * might be able to cache some offsets for next time.
		 *
		 * Note - This loop is a little tricky.  For each non-null attribute,
		 * we have to first account for alignment padding before the attr,
		 * then advance over the attr based on its length.  Nulls have no
		 * storage and no alignment padding either.  We can use/set
		 * attcacheoff until we reach either a null or a var-width attribute.
		 */</comment>
		<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>		<comment type="block">/* loop exit is at "break" */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasNulls</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>att_isnull</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>usecache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<continue>continue;</continue>		<comment type="block">/* this cannot be the target att */</comment>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* If we know the next offset, we can skip the rest */</comment>
			<if_stmt><if>if <condition>(<expr><name>usecache</name> <operator>&amp;&amp;</operator> <name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We can only cache the offset for a varlena attribute if the
				 * offset is already suitably aligned, so that there would be
				 * no pad bytes in any case: then the offset will be valid for
				 * either an aligned or unaligned value.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>usecache</name> <operator>&amp;&amp;</operator>
					<name>off</name> <operator>==</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											<argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>usecache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* not varlena, so safe to use att_align_nominal */</comment>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>usecache</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>usecache</name> <operator>&amp;&amp;</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>usecache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>fetchatt</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		heap_getsysattr
 *
 *		Fetch the value of a system attribute for a tuple.
 *
 * This is a support routine for the heap_getattr macro.  The macro
 * has already determined that the attnum refers to a system attribute.
 * ----------------
 */</comment>
<function><type><name>Datum</name></type>
<name>heap_getsysattr</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Currently, no sys attribute ever reads as NULL. */</comment>
	<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>attnum</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SelfItemPointerAttributeNumber</name></expr>:</case>
			<comment type="block">/* pass-by-reference datatype */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>MinTransactionIdAttributeNumber</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>TransactionIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>MaxTransactionIdAttributeNumber</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>TransactionIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>MinCommandIdAttributeNumber</name></expr>:</case>
		<case>case <expr><name>MaxCommandIdAttributeNumber</name></expr>:</case>

			<comment type="block">/*
			 * cmin and cmax are now both aliases for the same field, which
			 * can in fact also be a combo command id.  XXX perhaps we should
			 * return the "real" cmin or cmax if possible, that is if we are
			 * inside the originating transaction?
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>CommandIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawCommandId</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TableOidAttributeNumber</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GpSegmentIdAttributeNumber</name></expr>:</case>                       <comment type="block">/*CDB*/</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attnum: %d"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		heap_copytuple
 *
 *		returns a copy of an entire tuple
 *
 * The HeapTuple struct, tuple header, and tuple data are all allocated
 * as a single palloc() block.
 * ----------------
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>heaptuple_copy_to</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>destlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>HEAPTUPLESIZE</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>destlen</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>destlen</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>destlen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>destlen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>destlen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newTuple</name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newTuple</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>HEAPTUPLESIZE</name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newTuple</name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>newTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>newTuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		heap_copytuple_with_tuple
 *
 *		copy a tuple into a caller-supplied HeapTuple management struct
 *
 * Note that after calling this function, the "dest" HeapTuple will not be
 * allocated as a single palloc() block (unlike with heap_copytuple()).
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>heap_copytuple_with_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>src</name><operator>-&gt;</operator><name>t_data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>dest</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>src</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Expand a tuple which has less attributes than required. For each attribute
 * not present in the sourceTuple, if there is a missing value that will be
 * used. Otherwise the attribute will be set to NULL.
 *
 * The source tuple must have less attributes than the required number.
 *
 * Only one of targetHeapTuple and targetMinimalTuple may be supplied. The
 * other argument must be NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>targetHeapTuple</name></decl></parameter>,
			 <parameter><decl><type><name>MinimalTuple</name> <modifier>*</modifier></type><name>targetMinimalTuple</name></decl></parameter>,
			 <parameter><decl><type><name>HeapTuple</name></type> <name>sourceTuple</name></decl></parameter>,
			 <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrMissing</name> <modifier>*</modifier></type><name>attrmiss</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>firstmissingnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasNulls</name> <init>= <expr><call><name>HeapTupleHasNulls</name><argument_list>(<argument><expr><name>sourceTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>targetTHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>sourceTHeader</name> <init>= <expr><name><name>sourceTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sourceNatts</name> <init>= <expr><call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name>sourceTHeader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sourceNullLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>targetNullLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>sourceDataLen</name> <init>= <expr><name><name>sourceTuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name><name>sourceTHeader</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>targetDataLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>nullBits</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>targetData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name>	   <modifier>*</modifier></type><name>infoMask</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>targetHeapTuple</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>targetMinimalTuple</name><operator>)</operator>
		   <operator>||</operator> <operator>(</operator><operator>!</operator><name>targetHeapTuple</name> <operator>&amp;&amp;</operator> <name>targetMinimalTuple</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sourceNatts</name> <operator>&lt;</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sourceNullLen</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>hasNulls</name></expr> ?</condition><then> <expr><call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>sourceNatts</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>targetDataLen</name> <operator>=</operator> <name>sourceDataLen</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
		<name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>missing</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If there are missing values we want to put them into the tuple.
		 * Before that we have to compute the extra length for the values
		 * array and the variable length data.
		 */</comment>
		<expr_stmt><expr><name>attrmiss</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>missing</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find the first item in attrmiss for which we don't have a value in
		 * the source. We can ignore all the missing entries before that.
		 */</comment>
		<for>for <control>(<init><expr><name>firstmissingnum</name> <operator>=</operator> <name>sourceNatts</name></expr>;</init>
			 <condition><expr><name>firstmissingnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition>
			 <incr><expr><name>firstmissingnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>attrmiss</name><index>[<expr><name>firstmissingnum</name></expr>]</index></name><operator>.</operator><name>am_present</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>hasNulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Now walk the missing attributes. If there is a missing value make
		 * space for it. Otherwise, it's going to be NULL.
		 */</comment>
		<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <name>firstmissingnum</name></expr>;</init>
			 <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition>
			 <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>attrmiss</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>.</operator><name>am_present</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>targetDataLen</name> <operator>=</operator> <call><name>att_align_datum</name><argument_list>(<argument><expr><name>targetDataLen</name></expr></argument>,
												<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>,
												<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>,
												<argument><expr><name><name>attrmiss</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>.</operator><name>am_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>targetDataLen</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>targetDataLen</name></expr></argument>,
													  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>,
													  <argument><expr><name><name>attrmiss</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>.</operator><name>am_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* no missing value, so it must be null */</comment>
				<expr_stmt><expr><name>hasNulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>							<comment type="block">/* end if have missing values */</comment>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If there are no missing values at all then NULLS must be allowed,
		 * since some of the attributes are known to be absent.
		 */</comment>
		<expr_stmt><expr><name>hasNulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hasNulls</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>targetNullLen</name> <operator>=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>targetNullLen</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>targetNullLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Allocate and zero the space needed.  Note that the tuple body and
	 * HeapTupleData management structure are allocated in one chunk.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetHeapTuple</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>HeapTupleHeaderData</name></expr></argument>, <argument><expr><name>t_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hoff</name> <operator>=</operator> <name>len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* align user data safely */</comment>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>targetDataLen</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>targetHeapTuple</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>HEAPTUPLESIZE</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>targetHeapTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_data</name></name>
			<operator>=</operator> <name>targetTHeader</name>
			<operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>targetHeapTuple</name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>targetHeapTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>targetHeapTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>sourceTuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>targetHeapTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>sourceTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>targetTHeader</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>sourceTHeader</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targetTHeader</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name>hoff</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetNatts</name><argument_list>(<argument><expr><name>targetTHeader</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetDatumLength</name><argument_list>(<argument><expr><name>targetTHeader</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name>targetTHeader</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name>targetTHeader</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We also make sure that t_ctid is invalid unless explicitly set */</comment>
		<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>targetTHeader</name><operator>-&gt;</operator><name>t_ctid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>targetNullLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nullBits</name> <operator>=</operator> <operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><operator>(</operator><operator>*</operator><name>targetHeapTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_data</name></name>
								  <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>HeapTupleHeaderData</name></expr></argument>, <argument><expr><name>t_bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>targetData</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><operator>(</operator><operator>*</operator><name>targetHeapTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_data</name></name> <operator>+</operator> <name>hoff</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>infoMask</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>targetTHeader</name><operator>-&gt;</operator><name>t_infomask</name></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>SizeofMinimalTupleHeader</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hoff</name> <operator>=</operator> <name>len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* align user data safely */</comment>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>targetDataLen</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>targetMinimalTuple</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>targetMinimalTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>targetMinimalTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name>hoff</name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>targetMinimalTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>sourceTHeader</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
		<comment type="block">/* Same macro works for MinimalTuples */</comment>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetNatts</name><argument_list>(<argument><expr><operator>*</operator><name>targetMinimalTuple</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>targetNullLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nullBits</name> <operator>=</operator> <operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>targetMinimalTuple</name>
								  <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>MinimalTupleData</name></expr></argument>, <argument><expr><name>t_bits</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>targetData</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>targetMinimalTuple</name> <operator>+</operator> <name>hoff</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>infoMask</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>targetMinimalTuple</name><operator>)</operator><operator>-&gt;</operator><name>t_infomask</name></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetNullLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>sourceNullLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if bitmap pre-existed copy in - all is set */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nullBits</name></expr></argument>,
				   <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>sourceTHeader</name><operator>)</operator>
				   <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>HeapTupleHeaderData</name></expr></argument>, <argument><expr><name>t_bits</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>sourceNullLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nullBits</name> <operator>+=</operator> <name>sourceNullLen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sourceNullLen</name> <operator>=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>sourceNatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Set NOT NULL for all existing attributes */</comment>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nullBits</name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><name>sourceNullLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>nullBits</name> <operator>+=</operator> <name>sourceNullLen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>sourceNatts</name> <operator>&amp;</operator> <literal type="number">0x07</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* build the mask (inverted!) */</comment>
				<expr_stmt><expr><name>bitMask</name> <operator>=</operator> <literal type="number">0xff</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>sourceNatts</name> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator></expr>;</expr_stmt>
				<comment type="block">/* Voila */</comment>
				<expr_stmt><expr><operator>*</operator><name>nullBits</name> <operator>=</operator> <operator>~</operator><name>bitMask</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>bitMask</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><name>sourceNatts</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>							<comment type="block">/* End if have null bitmap */</comment>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>targetData</name></expr></argument>,
		   <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>sourceTuple</name><operator>-&gt;</operator><name>t_data</name></name><operator>)</operator> <operator>+</operator> <name><name>sourceTHeader</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></argument>,
		   <argument><expr><name>sourceDataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>targetData</name> <operator>+=</operator> <name>sourceDataLen</name></expr>;</expr_stmt>

	<comment type="block">/* Now fill in the missing values */</comment>
	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <name>sourceNatts</name></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>

		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attrmiss</name> <operator>&amp;&amp;</operator> <name><name>attrmiss</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>.</operator><name>am_present</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fill_val</name><argument_list>(<argument><expr><name>attr</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>nullBits</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>nullBits</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>bitMask</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>targetData</name></expr></argument>,
					 <argument><expr><name>infoMask</name></expr></argument>,
					 <argument><expr><name><name>attrmiss</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>.</operator><name>am_value</name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>fill_val</name><argument_list>(<argument><expr><name>attr</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>nullBits</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>bitMask</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>targetData</name></expr></argument>,
					 <argument><expr><name>infoMask</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>							<comment type="block">/* end loop over missing attributes */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Fill in the missing values for a minimal HeapTuple
 */</comment>
<function><type><name>MinimalTuple</name></type>
<name>minimal_expand_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>sourceTuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>minimalTuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>expand_tuple</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minimalTuple</name></expr></argument>, <argument><expr><name>sourceTuple</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>minimalTuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fill in the missing values for an ordinary HeapTuple
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>heap_expand_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>sourceTuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heapTuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>expand_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>heapTuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sourceTuple</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>heapTuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		heap_copy_tuple_as_datum
 *
 *		copy a tuple as a composite-type Datum
 * ----------------
 */</comment>
<function><type><name>Datum</name></type>
<name>heap_copy_tuple_as_datum</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the tuple contains any external TOAST pointers, we have to inline
	 * those fields to meet the conventions for composite-type Datums.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>toast_flatten_tuple_to_datum</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>,
											<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>,
											<argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fast path for easy case: just make a palloc'd copy and insert the
	 * correct composite-Datum header fields (since those may not be set if
	 * the given tuple came from disk, rather than from heap_form_tuple).
	 */</comment>
	<expr_stmt><expr><name>td</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>td</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>HeapTupleHeaderSetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_form_tuple
 *		construct a tuple from the given values[] and isnull[] arrays,
 *		which are of the length indicated by tupleDescriptor-&gt;natts
 *
 * The result is allocated in the current memory context.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>heaptuple_form_to</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>dstlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>			<comment type="block">/* return tuple */</comment>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name></decl>;</decl_stmt>			<comment type="block">/* tuple data */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>,
				<decl><type ref="prev"/><name>data_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfAttributes</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>numberOfAttributes</name> <operator>&gt;</operator> <name>MaxTupleAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of columns (%d) exceeds limit (%d)"</literal></expr></argument>,
						<argument><expr><name>numberOfAttributes</name></expr></argument>, <argument><expr><name>MaxTupleAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for nulls
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Determine total space needed
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>HeapTupleHeaderData</name></expr></argument>, <argument><expr><name>t_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hasnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>numberOfAttributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hoff</name> <operator>=</operator> <name>len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* align user data safely */</comment>

	<expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>data_len</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dstlen</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>dstlen</name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name>HEAPTUPLESIZE</name> <operator>+</operator> <name>len</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>dstlen</name> <operator>=</operator> <name>HEAPTUPLESIZE</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dstlen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>dstlen</name> <operator>=</operator> <name>HEAPTUPLESIZE</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>HEAPTUPLESIZE</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>HEAPTUPLESIZE</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Allocate and zero the space needed.  Note that the tuple body and
	 * HeapTupleData management structure are allocated in one chunk.
	 */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>td</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * And fill in the information.  Note we fill the Datum fields even though
	 * this tuple may never become a Datum.  This lets HeapTupleHeaderGetDatum
	 * identify the tuple type if needed.
	 */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>HeapTupleHeaderSetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We also make sure that t_ctid is invalid unless explicitly set */</comment>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>td</name><operator>-&gt;</operator><name>t_ctid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>HeapTupleHeaderSetNatts</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><name>numberOfAttributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>td</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name>hoff</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_fill_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
					<argument><expr><name>values</name></expr></argument>,
					<argument><expr><name>isnull</name></expr></argument>,
					<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>td</name> <operator>+</operator> <name>hoff</name></expr></argument>,
					<argument><expr><name>data_len</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
					<argument><expr><operator>(</operator><ternary><condition><expr><name>hasnull</name></expr> ?</condition><then> <expr><name><name>td</name><operator>-&gt;</operator><name>t_bits</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_modify_tuple
 *		form a new tuple from an old tuple and a set of replacement values.
 *
 * The replValues, replIsnull, and doReplace arrays must be of the length
 * indicated by tupleDesc-&gt;natts.  The new tuple is constructed using the data
 * from replValues/replIsnull at columns where doReplace is true, and using
 * the data from the old tuple at columns where doReplace is false.
 *
 * The result is allocated in the current memory context.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>heap_modify_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
				  <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>replValues</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>replIsnull</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>doReplace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfAttributes</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newTuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * allocate and fill values and isnull arrays from either the tuple or the
	 * repl information, as appropriate.
	 *
	 * NOTE: it's debatable whether to use heap_deform_tuple() here or just
	 * heap_getattr() only the non-replaced columns.  The latter could win if
	 * there are many replaced columns and few non-replaced ones. However,
	 * heap_deform_tuple costs only O(N) while the heap_getattr way would cost
	 * O(N^2) if there are many non-replaced columns, so it seems better to
	 * err on the side of linear cost.
	 */</comment>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>attoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attoff</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>attoff</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>doReplace</name><index>[<expr><name>attoff</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>attoff</name></expr>]</index></name> <operator>=</operator> <name><name>replValues</name><index>[<expr><name>attoff</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attoff</name></expr>]</index></name> <operator>=</operator> <name><name>replIsnull</name><index>[<expr><name>attoff</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * create a new tuple from the values and isnull arrays
	 */</comment>
	<expr_stmt><expr><name>newTuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * copy the identification info of the old tuple: t_ctid, t_self
	 */</comment>
	<expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>

	<return>return <expr><name>newTuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_modify_tuple_by_cols
 *		form a new tuple from an old tuple and a set of replacement values.
 *
 * This is like heap_modify_tuple, except that instead of specifying which
 * column(s) to replace by a boolean map, an array of target column numbers
 * is used.  This is often more convenient when a fixed number of columns
 * are to be replaced.  The replCols, replValues, and replIsnull arrays must
 * be of length nCols.  Target column numbers are indexed from 1.
 *
 * The result is allocated in the current memory context.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>heap_modify_tuple_by_cols</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
						  <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>nCols</name></decl></parameter>,
						  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>replCols</name></decl></parameter>,
						  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>replValues</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>replIsnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfAttributes</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * allocate and fill values and isnull arrays from the tuple, then replace
	 * selected columns from the input arrays.
	 */</comment>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numberOfAttributes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>replCols</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>attnum</name> <operator>&gt;</operator> <name>numberOfAttributes</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid column number %d"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>replValues</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>replIsnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * create a new tuple from the values and isnull arrays
	 */</comment>
	<expr_stmt><expr><name>newTuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * copy the identification info of the old tuple: t_ctid, t_self
	 */</comment>
	<expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newTuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr>;</expr_stmt>

	<return>return <expr><name>newTuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_deform_tuple
 *		Given a tuple, extract data into values/isnull arrays; this is
 *		the inverse of heap_form_tuple.
 *
 *		Storage for the values/isnull arrays is provided by the caller;
 *		it should be sized according to tupleDesc-&gt;natts not
 *		HeapTupleHeaderGetNatts(tuple-&gt;t_data).
 *
 *		Note that for pass-by-reference datatypes, the pointer placed
 *		in the Datum will point into the given tuple.
 *
 *		When all or most of a tuple's fields need to be extracted,
 *		this routine will be significantly quicker than a loop around
 *		heap_getattr; the loop will become O(N^2) as soon as any
 *		noncacheable attribute offsets are involved.
 */</comment>
<function><type><name>void</name></type>
<name>heap_deform_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tup</name> <init>= <expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnulls</name> <init>= <expr><call><name>HeapTupleHasNulls</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tdesc_natts</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>			<comment type="block">/* number of atts to extract */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>				<comment type="block">/* ptr to tuple data */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>off</name></decl>;</decl_stmt>			<comment type="block">/* offset in tuple data */</comment>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bp</name> <init>= <expr><name><name>tup</name><operator>-&gt;</operator><name>t_bits</name></name></expr></init></decl>;</decl_stmt>	<comment type="block">/* ptr to null bitmap in tuple */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>slow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* can we use/set attcacheoff? */</comment>

	<expr_stmt><expr><name>natts</name> <operator>=</operator> <call><name>HeapTupleHeaderGetNatts</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In inheritance situations, it is possible that the given tuple actually
	 * has more fields than the caller is expecting.  Don't run off the end of
	 * the caller's arrays.
	 */</comment>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>natts</name></expr></argument>, <argument><expr><name>tdesc_natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tup</name> <operator>+</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>thisatt</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hasnulls</name> <operator>&amp;&amp;</operator> <call><name>att_isnull</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* can't use attcacheoff anymore */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name> <operator>&amp;&amp;</operator> <name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We can only cache the offset for a varlena attribute if the
			 * offset is already suitably aligned, so that there would be no
			 * pad bytes in any case: then the offset will be valid for either
			 * an aligned or unaligned value.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name> <operator>&amp;&amp;</operator>
				<name>off</name> <operator>==</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* not varlena, so safe to use att_align_nominal */</comment>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slow</name> <operator>&amp;&amp;</operator> <name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <call><name>fetchatt</name><argument_list>(<argument><expr><name>thisatt</name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If tuple doesn't have all the atts indicated by tupleDesc, read the
	 * rest as nulls or missing values as appropriate.
	 */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>tdesc_natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <call><name>getmissingattr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>isnull</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * heap_freetuple
 */</comment>
<function><type><name>void</name></type>
<name>heap_freetuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * heap_form_minimal_tuple
 *		construct a MinimalTuple from the given values[] and isnull[] arrays,
 *		which are of the length indicated by tupleDescriptor-&gt;natts
 *
 * This is exactly like heap_form_tuple() except that the result is a
 * "minimal" tuple lacking a HeapTupleData header as well as room for system
 * columns.
 *
 * The result is allocated in the current memory context.
 */</comment>
<function><type><name>MinimalTuple</name></type>
<name>heap_form_minimal_tuple</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
						<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>			<comment type="block">/* return tuple */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>,
				<decl><type ref="prev"/><name>data_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfAttributes</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>numberOfAttributes</name> <operator>&gt;</operator> <name>MaxTupleAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of columns (%d) exceeds limit (%d)"</literal></expr></argument>,
						<argument><expr><name>numberOfAttributes</name></expr></argument>, <argument><expr><name>MaxTupleAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for nulls
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Determine total space needed
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SizeofMinimalTupleHeader</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hasnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name>numberOfAttributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hoff</name> <operator>=</operator> <name>len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* align user data safely */</comment>

	<expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>data_len</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate and zero the space needed.
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And fill in the information.
	 */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetNatts</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>numberOfAttributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name>hoff</name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_fill_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
					<argument><expr><name>values</name></expr></argument>,
					<argument><expr><name>isnull</name></expr></argument>,
					<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <name>hoff</name></expr></argument>,
					<argument><expr><name>data_len</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
					<argument><expr><operator>(</operator><ternary><condition><expr><name>hasnull</name></expr> ?</condition><then> <expr><name><name>tuple</name><operator>-&gt;</operator><name>t_bits</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_free_minimal_tuple
 */</comment>
<function><type><name>void</name></type>
<name>heap_free_minimal_tuple</name><parameter_list>(<parameter><decl><type><name>MinimalTuple</name></type> <name>mtup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * heap_copy_minimal_tuple
 *		copy a MinimalTuple
 *
 * The result is allocated in the current memory context.
 */</comment>
<function><type><name>MinimalTuple</name></type>
<name>heap_copy_minimal_tuple</name><parameter_list>(<parameter><decl><type><name>MinimalTuple</name></type> <name>mtup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>mtup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>mtup</name></expr></argument>, <argument><expr><name><name>mtup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_tuple_from_minimal_tuple
 *		create a HeapTuple by copying from a MinimalTuple;
 *		system columns are filled with zeroes
 *
 * The result is allocated in the current memory context.
 * The HeapTuple struct, tuple header, and tuple data are all allocated
 * as a single palloc() block.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>heap_tuple_from_minimal_tuple</name><parameter_list>(<parameter><decl><type><name>MinimalTuple</name></type> <name>mtup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>len</name> <init>= <expr><name><name>mtup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>HEAPTUPLESIZE</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>result</name> <operator>+</operator> <name>HEAPTUPLESIZE</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>result</name><operator>-&gt;</operator><name>t_data</name></name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr></argument>, <argument><expr><name>mtup</name></expr></argument>, <argument><expr><name><name>mtup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>HeapTupleHeaderData</name></expr></argument>, <argument><expr><name>t_infomask2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * minimal_tuple_from_heap_tuple
 *		create a MinimalTuple by copying from a HeapTuple
 *
 * The result is allocated in the current memory context.
 */</comment>
<function><type><name>MinimalTuple</name></type>
<name>minimal_tuple_from_heap_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>htup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>&gt;</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_data</name></name> <operator>+</operator> <name>MINIMAL_TUPLE_OFFSET</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This mainly exists so JIT can inline the definition, but it's also
 * sometimes useful in debugging sessions.
 */</comment>
<function><type><name>size_t</name></type>
<name>varsize_any</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
