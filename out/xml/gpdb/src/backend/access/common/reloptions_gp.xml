<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/common/reloptions_gp.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * reloptions_gp.c
 *	  GPDB-specific relation options.
 *
 * These are in a separate file from reloptions.c, in order to reduce
 * conflicts when merging with upstream code.
 *
 *
 * Portions Copyright (c) 2017-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/common/reloptions_gp.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute_encoding.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/formatting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Helper macro used for validation
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KIND_IS_APPENDOPTIMIZED</name><parameter_list>(<parameter><type><name>kind</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((kind) &amp; RELOPT_KIND_APPENDOPTIMIZED) != 0)</cpp:value></cpp:define>

<comment type="block">/*
 * GPDB reloptions specification.
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>relopt_bool</name></type> <name><name>boolRelOpts_gp</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{
		<expr><block>{
			<expr><name>SOPT_CHECKSUM</name></expr>,
			<expr><literal type="string">"Append table checksum"</literal></expr>,
			<expr><name>RELOPT_KIND_APPENDOPTIMIZED</name></expr>,
			<expr><name>AccessExclusiveLock</name></expr>
		}</block></expr>,
		<expr><name>AO_DEFAULT_CHECKSUM</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{
			<expr><name>SOPT_ANALYZEHLL</name></expr>,
			<expr><literal type="string">"Enable HLL stats collection during analyze"</literal></expr>,
			<expr><name>RELOPT_KIND_HEAP</name> <operator>|</operator> <name>RELOPT_KIND_TOAST</name> <operator>|</operator> <name>RELOPT_KIND_APPENDOPTIMIZED</name></expr>,
			<expr><name>ShareUpdateExclusiveLock</name></expr>
		}</block></expr>,
		<expr><name>ANALYZE_DEFAULT_HLL</name></expr>
	}</block></expr>,
	<comment type="block">/* list terminator */</comment>
	<expr><block>{<expr><block>{<expr><name>NULL</name></expr>}</block></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>relopt_int</name></type> <name><name>intRelOpts_gp</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{
		<expr><block>{
			<expr><name>SOPT_FILLFACTOR</name></expr>,
			<expr><literal type="string">"Packs bitmap index pages only to this percentage"</literal></expr>,
			<expr><name>RELOPT_KIND_BITMAP</name></expr>,
			<expr><name>ShareUpdateExclusiveLock</name></expr>	<comment type="block">/* since it applies only to later
										 * inserts */</comment>
		}</block></expr>,
		<expr><name>BITMAP_DEFAULT_FILLFACTOR</name></expr>, <expr><name>BITMAP_MIN_FILLFACTOR</name></expr>, <expr><literal type="number">100</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{
			<expr><name>SOPT_BLOCKSIZE</name></expr>,
			<expr><literal type="string">"AO tables block size in bytes"</literal></expr>,
			<expr><name>RELOPT_KIND_APPENDOPTIMIZED</name></expr>,
			<expr><name>AccessExclusiveLock</name></expr>
		}</block></expr>,
		<expr><name>AO_DEFAULT_BLOCKSIZE</name></expr>, <expr><name>MIN_APPENDONLY_BLOCK_SIZE</name></expr>, <expr><name>MAX_APPENDONLY_BLOCK_SIZE</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{
			<expr><name>SOPT_COMPLEVEL</name></expr>,
			<expr><literal type="string">"AO table compression level"</literal></expr>,
			<expr><name>RELOPT_KIND_APPENDOPTIMIZED</name></expr>,
			<expr><name>ShareUpdateExclusiveLock</name></expr>	<comment type="block">/* since it applies only to later
										 * inserts */</comment>
		}</block></expr>,
		<expr><name>AO_DEFAULT_COMPRESSLEVEL</name></expr>, <expr><name>AO_MIN_COMPRESSLEVEL</name></expr>, <expr><name>AO_MAX_COMPRESSLEVEL</name></expr>
	}</block></expr>,
	<comment type="block">/* list terminator */</comment>
	<expr><block>{<expr><block>{<expr><name>NULL</name></expr>}</block></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>relopt_real</name></type> <name><name>realRelOpts_gp</name><index>[]</index></name> <init>=
<expr><block>{
	<comment type="block">/* list terminator */</comment>
	<expr><block>{<expr><block>{<expr><name>NULL</name></expr>}</block></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>relopt_string</name></type> <name><name>stringRelOpts_gp</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{
		<expr><block>{
			<expr><name>SOPT_COMPTYPE</name></expr>,
			<expr><literal type="string">"AO tables compression type"</literal></expr>,
			<expr><name>RELOPT_KIND_APPENDOPTIMIZED</name></expr>,
			<expr><name>AccessExclusiveLock</name></expr>
		}</block></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>true</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">""</literal></expr>
	}</block></expr>,
	<comment type="block">/* list terminator */</comment>
	<expr><block>{<expr><block>{<expr><name>NULL</name></expr>}</block></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>relopt_value</name> <modifier>*</modifier></type><name>get_option_set</name><parameter_list>(<parameter><decl><type><name>relopt_value</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opt_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>reloption_is_default</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optstr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>optlen</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * initialize_reloptions_gp
 * 		initialization routine for GPDB reloptions
 *
 * We use the add_*_option interface in reloptions.h to add GPDB-specific options.
 */</comment>
<function><type><name>void</name></type>
<name>initialize_reloptions_gp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>	<name>initialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* only add these on first call. */</comment>
	<if_stmt><if>if <condition>(<expr><name>initialized</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Set GPDB specific options */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>boolRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_bool_reloption</name><argument_list>(<argument><expr><name><name>boolRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>kinds</name></name></expr></argument>,
						   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>boolRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>,
						   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>boolRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>desc</name></name></expr></argument>,
						   <argument><expr><name><name>boolRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>default_val</name></expr></argument>,
						   <argument><expr><name><name>boolRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>lockmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>intRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_int_reloption</name><argument_list>(<argument><expr><name><name>intRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>kinds</name></name></expr></argument>,
						  <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>intRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>,
						  <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>intRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>desc</name></name></expr></argument>,
						  <argument><expr><name><name>intRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>default_val</name></expr></argument>,
						  <argument><expr><name><name>intRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>min</name></expr></argument>,
						  <argument><expr><name><name>intRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>max</name></expr></argument>,
						  <argument><expr><name><name>intRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>lockmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>realRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_real_reloption</name><argument_list>(<argument><expr><name><name>realRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>kinds</name></name></expr></argument>,
						   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>realRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>,
						   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>realRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>desc</name></name></expr></argument>,
						   <argument><expr><name><name>realRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>default_val</name></expr></argument>,
						   <argument><expr><name><name>realRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>min</name></expr></argument>, <argument><expr><name><name>realRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>max</name></expr></argument>,
						   <argument><expr><name><name>realRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>lockmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>stringRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_string_reloption</name><argument_list>(<argument><expr><name><name>stringRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>kinds</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>stringRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>stringRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>desc</name></name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name><name>stringRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>validate_cb</name></expr></argument>,
							 <argument><expr><name><name>stringRelOpts_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>lockmode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * This is set whenever the GUC gp_default_storage_options is set.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>StdRdOptions</name></type> <name>ao_storage_opts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ao_storage_opts_changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Accumulate a new datum for one AO storage option.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>accumAOStorageOpt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
				  <parameter><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>boolval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>intval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>astate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>SOPT_BLOCKSIZE</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* unit flags */</comment> ,
					   <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* hint message */</comment> )</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid integer value \"%s\" for storage option \"%s\""</literal></expr></argument>,
							<argument><expr><name>value</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s=%d"</literal></expr></argument>, <argument><expr><name>SOPT_BLOCKSIZE</name></expr></argument>, <argument><expr><name>intval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>SOPT_COMPTYPE</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s=%s"</literal></expr></argument>, <argument><expr><name>SOPT_COMPTYPE</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>SOPT_COMPLEVEL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* unit flags */</comment> ,
					   <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* hint message */</comment> )</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid integer value \"%s\" for storage option \"%s\""</literal></expr></argument>,
							<argument><expr><name>value</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s=%d"</literal></expr></argument>, <argument><expr><name>SOPT_COMPLEVEL</name></expr></argument>, <argument><expr><name>intval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>SOPT_CHECKSUM</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>boolval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid bool value \"%s\" for storage option \"%s\""</literal></expr></argument>,
							<argument><expr><name>value</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s=%s"</literal></expr></argument>, <argument><expr><name>SOPT_CHECKSUM</name></expr></argument>, <argument><expr><ternary><condition><expr><name>boolval</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Provide a user friendly message in case that the options are
		 * appendonly and its variants
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"appendonly"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"appendoptimized"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"orientation"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid storage option \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"For table access methods use \"default_table_access_method\" instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid storage option \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* disnull */</comment> <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reset appendonly storage options to factory defaults.  Callers must
 * free ao_opts-&gt;compresstype before calling this method.
 */</comment>
<function><type><specifier>inline</specifier> <name>void</name></type>
<name>resetAOStorageOpts</name><parameter_list>(<parameter><decl><type><name>StdRdOptions</name> <modifier>*</modifier></type><name>ao_opts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>=</operator> <name>AO_DEFAULT_BLOCKSIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>checksum</name></name> <operator>=</operator> <name>AO_DEFAULT_CHECKSUM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>=</operator> <name>AO_DEFAULT_COMPRESSLEVEL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This needs to happen whenever gp_default_storage_options GUC is
 * reset.
 */</comment>
<function><type><name>void</name></type>
<name>resetDefaultAOStorageOpts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>resetAOStorageOpts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ao_storage_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ao_storage_opts_changed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>StdRdOptions</name> <modifier>*</modifier></type>
<name>currentAOStorageOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><specifier>const</specifier> <name>StdRdOptions</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>ao_storage_opts</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set global appendonly storage options.
 */</comment>
<function><type><name>void</name></type>
<name>setDefaultAOStorageOpts</name><parameter_list>(<parameter><decl><type><name>StdRdOptions</name> <modifier>*</modifier></type><name>copy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ao_storage_opts</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ao_storage_opts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>copy</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Represent compresstype=none as an empty string (MPP-25073). */</comment>
		<expr_stmt><expr><name><name>ao_storage_opts</name><operator>.</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ao_storage_opts_changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>setDefaultCompressionLevel</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>compresstype</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Accept a string of the form "name=value,name=value,...".  Space
 * around ',' and '=' is allowed.  Parsed values are stored in
 * corresponding fields of StdRdOptions object.  The parser is a
 * finite state machine that changes states for each input character
 * scanned.
 */</comment>
<function><type><name>Datum</name></type>
<name>parseAOStorageOpts</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opts_str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>dims</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>lbs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name_st</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value_st</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<enum>enum <name>state</name>
	<block>{
		<comment type="block">/*
		 * Consume whitespace at the beginning of a name token.
		 */</comment>
		<decl><name>LEADING_NAME</name></decl>,

		<comment type="block">/*
		 * Name token is being scanned.  Allowed characters are alphabets,
		 * whitespace and '='.
		 */</comment>
		<decl><name>NAME_TOKEN</name></decl>,

		<comment type="block">/*
		 * Name token was terminated by whitespace.  This state scans the
		 * trailing whitespace after name token.
		 */</comment>
		<decl><name>TRAILING_NAME</name></decl>,

		<comment type="block">/*
		 * Whitespace after '=' and before value token.
		 */</comment>
		<decl><name>LEADING_VALUE</name></decl>,

		<comment type="block">/*
		 * Value token is being scanned.  Allowed characters are alphabets,
		 * digits, '_'.  Value should be delimited by a ',', whitespace or end
		 * of string '\0'.
		 */</comment>
		<decl><name>VALUE_TOKEN</name></decl>,

		<comment type="block">/*
		 * Whitespace after value token.
		 */</comment>
		<decl><name>TRAILING_VALUE</name></decl>,

		<comment type="block">/*
		 * End of string.  This state can only be entered from VALUE_TOKEN or
		 * TRAILING_VALUE.
		 */</comment>
		<decl><name>EOS</name></decl>
	}</block>;</enum>
	<decl_stmt><decl><type><name><name>enum</name> <name>state</name></name></type>	<name>st</name> <init>= <expr><name>LEADING_NAME</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize ArrayBuildState ourselves rather than leaving it to
	 * accumArrayResult().  This aviods the catalog lookup (pg_type) performed
	 * by accumArrayResult().
	 */</comment>
	<expr_stmt><expr><name>astate</name> <operator>=</operator> <operator>(</operator><name>ArrayBuildState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayBuildState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>mcontext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>alen</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>			<comment type="block">/* Initial number of name=value pairs. */</comment>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>alen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>alen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>nelems</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>typlen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>typalign</name></name> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>opts_str</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><operator>++</operator><name>cp</name></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>st</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>LEADING_NAME</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>st</name> <operator>=</operator> <name>NAME_TOKEN</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>name_st</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid storage option name in \"%s\""</literal></expr></argument>,
									<argument><expr><name>opts_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>NAME_TOKEN</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>st</name> <operator>=</operator> <name>TRAILING_NAME</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>st</name> <operator>=</operator> <name>LEADING_VALUE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>isalpha</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid storage option name in \"%s\""</literal></expr></argument>,
									<argument><expr><name>opts_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>st</name> <operator>!=</operator> <name>NAME_TOKEN</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>cp</name> <operator>-</operator> <name>name_st</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_st</name></expr></argument>, <argument><expr><name>cp</name> <operator>-</operator> <name>name_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>name</name><index>[<expr><name>cp</name> <operator>-</operator> <name>name_st</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<for>for <control>(<init><expr><name>name_st</name> <operator>=</operator> <name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>name_st</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>name_st</name></expr></incr>)</control><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>name_st</name> <operator>=</operator> <call><name>pg_tolower</name><argument_list>(<argument><expr><operator>*</operator><name>name_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>TRAILING_NAME</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>st</name> <operator>=</operator> <name>LEADING_VALUE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for option \"%s\", expected \"=\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>LEADING_VALUE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>isalnum</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>st</name> <operator>=</operator> <name>VALUE_TOKEN</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>value_st</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for option \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>VALUE_TOKEN</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>st</name> <operator>=</operator> <name>TRAILING_VALUE</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>st</name> <operator>=</operator> <name>EOS</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>st</name> <operator>=</operator> <name>LEADING_NAME</name></expr>;</expr_stmt></block_content></block></if>
				<comment type="block">/* Need to check '_' for rle_type */</comment>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>isalnum</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'_'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for option \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>st</name> <operator>!=</operator> <name>VALUE_TOKEN</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>cp</name> <operator>-</operator> <name>value_st</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>value_st</name></expr></argument>, <argument><expr><name>cp</name> <operator>-</operator> <name>value_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>value</name><index>[<expr><name>cp</name> <operator>-</operator> <name>value_st</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<for>for <control>(<init><expr><name>value_st</name> <operator>=</operator> <name>value</name></expr>;</init> <condition><expr><operator>*</operator><name>value_st</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>value_st</name></expr></incr>)</control><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>value_st</name> <operator>=</operator> <call><name>pg_tolower</name><argument_list>(<argument><expr><operator>*</operator><name>value_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>accumAOStorageOpt</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>astate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>TRAILING_VALUE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>st</name> <operator>=</operator> <name>LEADING_NAME</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>st</name> <operator>=</operator> <name>EOS</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"syntax error after \"%s\""</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>EOS</name></expr>:</case>

				<comment type="block">/*
				 * We better get out of the loop right after entering this
				 * state.  Therefore, we should never get here.
				 */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid value \"%s\" for GUC"</literal></expr></argument>, <argument><expr><name>opts_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch><empty_stmt>;</empty_stmt>
	</block_content>}</block> while <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>;</do>
	<if_stmt><if>if <condition>(<expr><name>st</name> <operator>!=</operator> <name>EOS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid value \"%s\" for GUC"</literal></expr></argument>, <argument><expr><name>opts_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>lbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>astate</name><operator>-&gt;</operator><name>nelems</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeMdArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>dvalues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>astate</name><operator>-&gt;</operator><name>dnulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>astate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a datum that is array of "name=value" strings for each
 * appendonly storage option in opts.  This datum is used to populate
 * pg_class.reloptions during relation creation.
 *
 * To avoid catalog bloat, we only create "name=value" item for those
 * values in opts that are not specified in WITH clause and are
 * different from their initial defaults.
 */</comment>
<function><type><name>Datum</name></type>
<name>transformAOStdRdOptions</name><parameter_list>(<parameter><decl><type><name>StdRdOptions</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>withOpts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>strval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>withDatums</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>withLen</name></decl>,
				<decl><type ref="prev"/><name>soptLen</name></decl>,
				<decl><type ref="prev"/><name>nWithOpts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>withArr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>foundBlksz</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>foundComptype</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>foundComplevel</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>foundChecksum</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>foundAnalyzeHLL</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * withOpts must be parsed to see if an option was spcified in WITH()
	 * clause.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>withOpts</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>withArr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>withOpts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>withArr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>withArr</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>withDatums</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nWithOpts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Include options specified in WITH() clause in the same order as
		 * they are specified.  Otherwise we will end up with regression
		 * failures due to diff with respect to answer file.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nWithOpts</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>DatumGetTextP</name><argument_list>(<argument><expr><name><name>withDatums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>strval</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Text datums are usually not null terminated.  We must never
			 * access beyond their length.
			 */</comment>
			<expr_stmt><expr><name>withLen</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * withDatums[i] may not be used directly.  It may be e.g.
			 * "bLoCksiZe=3213".  Therefore we don't set it as reloptions as
			 * is.
			 */</comment>
			<expr_stmt><expr><name>soptLen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_BLOCKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>withLen</name> <operator>&gt;</operator> <name>soptLen</name> <operator>&amp;&amp;</operator>
				<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>strval</name></expr></argument>, <argument><expr><name>SOPT_BLOCKSIZE</name></expr></argument>, <argument><expr><name>soptLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>foundBlksz</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%d"</literal></expr></argument>,
												 <argument><expr><name>SOPT_BLOCKSIZE</name></expr></argument>,
												 <argument><expr><name><name>opts</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
										  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>soptLen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_COMPTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>withLen</name> <operator>&gt;</operator> <name>soptLen</name> <operator>&amp;&amp;</operator>
				<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>strval</name></expr></argument>, <argument><expr><name>SOPT_COMPTYPE</name></expr></argument>, <argument><expr><name>soptLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>foundComptype</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Record "none" as compresstype in reloptions if it was
				 * explicitly specified in WITH clause.
				 */</comment>
				<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%s"</literal></expr></argument>,
												 <argument><expr><name>SOPT_COMPTYPE</name></expr></argument>,
												 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>opts</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><name><name>opts</name><operator>-&gt;</operator><name>compresstype</name></name></expr> </then><else>: <expr><literal type="string">"none"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
										  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>soptLen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_COMPLEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>withLen</name> <operator>&gt;</operator> <name>soptLen</name> <operator>&amp;&amp;</operator>
				<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>strval</name></expr></argument>, <argument><expr><name>SOPT_COMPLEVEL</name></expr></argument>, <argument><expr><name>soptLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>foundComplevel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%d"</literal></expr></argument>,
												 <argument><expr><name>SOPT_COMPLEVEL</name></expr></argument>,
												 <argument><expr><name><name>opts</name><operator>-&gt;</operator><name>compresslevel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
										  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>soptLen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_CHECKSUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>withLen</name> <operator>&gt;</operator> <name>soptLen</name> <operator>&amp;&amp;</operator>
				<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>strval</name></expr></argument>, <argument><expr><name>SOPT_CHECKSUM</name></expr></argument>, <argument><expr><name>soptLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>foundChecksum</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%s"</literal></expr></argument>,
												 <argument><expr><name>SOPT_CHECKSUM</name></expr></argument>,
												 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>opts</name><operator>-&gt;</operator><name>checksum</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
										  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>soptLen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_ANALYZEHLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>withLen</name> <operator>&gt;</operator> <name>soptLen</name> <operator>&amp;&amp;</operator>
				<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>strval</name></expr></argument>, <argument><expr><name>SOPT_ANALYZEHLL</name></expr></argument>, <argument><expr><name>soptLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>foundAnalyzeHLL</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%s"</literal></expr></argument>,
												 <argument><expr><name>SOPT_ANALYZEHLL</name></expr></argument>,
												 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>opts</name><operator>-&gt;</operator><name>analyze_hll_non_part_table</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
										  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>opts</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>!=</operator> <name>AO_DEFAULT_BLOCKSIZE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>foundBlksz</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%d"</literal></expr></argument>,
										 <argument><expr><name>SOPT_BLOCKSIZE</name></expr></argument>,
										 <argument><expr><name><name>opts</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
								  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Record compression options only if compression is enabled.  No need to
	 * check compresstype here as by the time we get here, "opts" should have
	 * been set by default_reloptions() correctly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>&gt;</operator> <name>AO_DEFAULT_COMPRESSLEVEL</name> <operator>&amp;&amp;</operator>
		<name><name>opts</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>foundComptype</name> <operator>&amp;&amp;</operator> <operator>(</operator>
							   <operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>, <argument><expr><name>AO_DEFAULT_COMPRESSTYPE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
								<operator>&amp;&amp;</operator> <name><name>opts</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>foundComplevel</name><operator>)</operator> <operator>||</operator>
							   <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>opts</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>,
											 <argument><expr><name>AO_DEFAULT_COMPRESSTYPE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%s"</literal></expr></argument>,
											 <argument><expr><name>SOPT_COMPTYPE</name></expr></argument>,
											 <argument><expr><name><name>opts</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
									  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* When compression is enabled, default compresslevel is 1. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>opts</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>foundComplevel</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%d"</literal></expr></argument>,
											 <argument><expr><name>SOPT_COMPLEVEL</name></expr></argument>,
											 <argument><expr><name><name>opts</name><operator>-&gt;</operator><name>compresslevel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
									  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>opts</name><operator>-&gt;</operator><name>checksum</name></name> <operator>!=</operator> <name>AO_DEFAULT_CHECKSUM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>foundChecksum</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%s"</literal></expr></argument>,
										 <argument><expr><name>SOPT_CHECKSUM</name></expr></argument>,
										 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>opts</name><operator>-&gt;</operator><name>checksum</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
								  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>opts</name><operator>-&gt;</operator><name>analyze_hll_non_part_table</name></name> <operator>!=</operator> <name>ANALYZE_DEFAULT_HLL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>foundAnalyzeHLL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%s"</literal></expr></argument>,
										 <argument><expr><name>SOPT_ANALYZEHLL</name></expr></argument>,
										 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>opts</name><operator>-&gt;</operator><name>analyze_hll_non_part_table</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
								  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><name>astate</name></expr> ?</condition><then>
		<expr><call><name>makeArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr> </then><else>:
		<expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * Check if the given reloption string has default value.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>reloption_is_default</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optstr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>optlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> 		<modifier>*</modifier></type><name>defaultopt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 		<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>optlen</name> <operator>&gt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_BLOCKSIZE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>optstr</name></expr></argument>, <argument><expr><name>SOPT_BLOCKSIZE</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_BLOCKSIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>defaultopt</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%d"</literal></expr></argument>,
										 <argument><expr><name>SOPT_BLOCKSIZE</name></expr></argument>,
										 <argument><expr><name>AO_DEFAULT_BLOCKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>optlen</name> <operator>&gt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_COMPTYPE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>optstr</name></expr></argument>, <argument><expr><name>SOPT_COMPTYPE</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_COMPTYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>defaultopt</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%s"</literal></expr></argument>,
										 <argument><expr><name>SOPT_COMPTYPE</name></expr></argument>,
										 <argument><expr><name>AO_DEFAULT_COMPRESSTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>optlen</name> <operator>&gt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_COMPLEVEL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>optstr</name></expr></argument>, <argument><expr><name>SOPT_COMPLEVEL</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_COMPLEVEL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>defaultopt</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%d"</literal></expr></argument>,
										 <argument><expr><name>SOPT_COMPLEVEL</name></expr></argument>,
										 <argument><expr><name>AO_DEFAULT_COMPRESSLEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>optlen</name> <operator>&gt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_CHECKSUM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>optstr</name></expr></argument>, <argument><expr><name>SOPT_CHECKSUM</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_CHECKSUM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>defaultopt</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%s"</literal></expr></argument>,
										 <argument><expr><name>SOPT_CHECKSUM</name></expr></argument>,
										 <argument><expr><ternary><condition><expr><name>AO_DEFAULT_CHECKSUM</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>optlen</name> <operator>&gt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_ANALYZEHLL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>optstr</name></expr></argument>, <argument><expr><name>SOPT_ANALYZEHLL</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"analyze_hll_non_part_table"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>defaultopt</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%s"</literal></expr></argument>,
							  <argument><expr><name>SOPT_ANALYZEHLL</name></expr></argument>,
										 <argument><expr><ternary><condition><expr><name>ANALYZE_DEFAULT_HLL</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>defaultopt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>defaultopt</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>optlen</name> <operator>&amp;&amp;</operator> 
				<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>optstr</name></expr></argument>, <argument><expr><name>defaultopt</name></expr></argument>, <argument><expr><name>optlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>defaultopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * Check if two string arrays of reloptions are the same.
 *
 * Note that this will not handle the case where the option doesn't contain 
 * the '=' sign in it, e.g. "checksum" vs. "checksum=true". But it seems 
 * that at this point we should always have both options as "x=y" anyways.
 */</comment>
<function><type><name>bool</name></type>
<name>relOptionsEquals</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>oldOptions</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>newOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> 	<modifier>*</modifier></type><name>oldoptarray</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>newoptarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> 		<modifier>*</modifier></type><name>opts1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>opts2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>noldoptions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nnewoptions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<comment type="block">/* Deconstruct both options. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>oldOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldoptarray</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>oldOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>oldoptarray</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>opts1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>noldoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newoptarray</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>newOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>newoptarray</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>opts2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nnewoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nnewoptions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> 	<modifier>*</modifier></type><name>newopt_str</name> <init>= <expr><call><name>VARDATA</name><argument_list>(<argument><expr><name><name>opts2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>	<name>newopt_len</name> <init>= <expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>opts2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> 	<name>keylen</name></decl>;</decl_stmt>

		<comment type="block">/* Should be "x=y" but better panic here rather than returning wrong result. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strchr</name><argument_list>(<argument><expr><name>newopt_str</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>keylen</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>newopt_str</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call> <operator>-</operator> <name>newopt_str</name></expr>;</expr_stmt>

		<comment type="block">/* Search for a match in old options. */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>noldoptions</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> 	<modifier>*</modifier></type><name>oldopt_str</name> <init>= <expr><call><name>VARDATA</name><argument_list>(<argument><expr><name><name>opts1</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>	<name>oldopt_len</name> <init>= <expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>opts1</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Not the same option. */</comment>
			<if_stmt><if>if <condition>(<expr><name>oldopt_len</name> <operator>&lt;=</operator> <name>keylen</name> <operator>||</operator> 
					<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>oldopt_str</name></expr></argument>, <argument><expr><name>newopt_str</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Old option should be as "x=y" too. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oldopt_str</name><index>[<expr><name>keylen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Key found, now they must match exactly otherwise it's a changed option. */</comment>
			<if_stmt><if>if <condition>(<expr><name>oldopt_len</name> <operator>!=</operator> <name>newopt_len</name> <operator>||</operator>
					<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>oldopt_str</name></expr></argument>, <argument><expr><name>newopt_str</name></expr></argument>, <argument><expr><name>oldopt_len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<break>break;</break></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* 
		 * If key not found, then it must've changed unless it's a default value 
		 * that doesn't appear in the old reloptions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>noldoptions</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>reloption_is_default</name><argument_list>(<argument><expr><name>newopt_str</name></expr></argument>, <argument><expr><name>newopt_len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>validate_and_adjust_options</name><parameter_list>(<parameter><decl><type><name>StdRdOptions</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
							<parameter><decl><type><name>relopt_value</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>num_options</name></decl></parameter>, <parameter><decl><type><name>relopt_kind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>relopt_value</name> <modifier>*</modifier></type><name>blocksize_opt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>relopt_value</name> <modifier>*</modifier></type><name>comptype_opt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>relopt_value</name> <modifier>*</modifier></type><name>complevel_opt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>relopt_value</name> <modifier>*</modifier></type><name>checksum_opt</name></decl>;</decl_stmt>

	<comment type="block">/* blocksize */</comment>
	<expr_stmt><expr><name>blocksize_opt</name> <operator>=</operator> <call><name>get_option_set</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>num_options</name></expr></argument>, <argument><expr><name>SOPT_BLOCKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>blocksize_opt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>KIND_IS_APPENDOPTIMIZED</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>validate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"usage of parameter \"blocksize\" in a non relation object is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>=</operator> <name><name>blocksize_opt</name><operator>-&gt;</operator><name>values</name><operator>.</operator><name>int_val</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>&lt;</operator> <name>MIN_APPENDONLY_BLOCK_SIZE</name> <operator>||</operator>
			<name><name>result</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>&gt;</operator> <name>MAX_APPENDONLY_BLOCK_SIZE</name> <operator>||</operator>
			<name><name>result</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>%</operator> <name>MIN_APPENDONLY_BLOCK_SIZE</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>validate</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block size must be between 8KB and 2MB and be a multiple of 8KB"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Got block size %d."</literal></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>=</operator> <name>DEFAULT_APPENDONLY_BLOCK_SIZE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

	</block_content>}</block></if></if_stmt>

	<comment type="block">/* compression type */</comment>
	<expr_stmt><expr><name>comptype_opt</name> <operator>=</operator> <call><name>get_option_set</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>num_options</name></expr></argument>, <argument><expr><name>SOPT_COMPTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>comptype_opt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>KIND_IS_APPENDOPTIMIZED</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>validate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"usage of parameter \"compresstype\" in a non relation object is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>compresstype_is_valid</name><argument_list>(<argument><expr><name><name>comptype_opt</name><operator>-&gt;</operator><name>values</name><operator>.</operator><name>string_val</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown compresstype \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>comptype_opt</name><operator>-&gt;</operator><name>values</name><operator>.</operator><name>string_val</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>comptype_opt</name><operator>-&gt;</operator><name>values</name><operator>.</operator><name>string_val</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pg_tolower</name><argument_list>(<argument><expr><name><name>comptype_opt</name><operator>-&gt;</operator><name>values</name><operator>.</operator><name>string_val</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* compression level */</comment>
	<expr_stmt><expr><name>complevel_opt</name> <operator>=</operator> <call><name>get_option_set</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>num_options</name></expr></argument>, <argument><expr><name>SOPT_COMPLEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>complevel_opt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>KIND_IS_APPENDOPTIMIZED</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>validate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"usage of parameter \"compresslevel\" in a non relation object is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>=</operator> <name><name>complevel_opt</name><operator>-&gt;</operator><name>values</name><operator>.</operator><name>int_val</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
			<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>validate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compresstype \"%s\" can\'t be used with compresslevel 0"</literal></expr></argument>,
							<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>validate</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compresslevel=%d is out of range (should be positive)"</literal></expr></argument>,
								<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>=</operator> <call><name>setDefaultCompressionLevel</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * use the default compressor if compresslevel was indicated but not
		 * compresstype. must make a copy otherwise str_tolower below will
		 * crash.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>, <argument><expr><name>AO_DEFAULT_COMPRESSTYPE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Check upper bound of compresslevel for each compression type */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>, <argument><expr><literal type="string">"zlib"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifndef>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"zlib compression is not supported by this build"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Compile without --without-zlib to use zlib compression."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>&gt;</operator> <literal type="number">9</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>validate</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compresslevel=%d is out of range for zlib (should be in the range 1 to 9)"</literal></expr></argument>,
									<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>=</operator> <call><name>setDefaultCompressionLevel</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>, <argument><expr><literal type="string">"zstd"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_ZSTD</name></cpp:ifndef>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Zstandard library is not supported by this build"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Compile with --with-zstd to use Zstandard compression."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>&gt;</operator> <literal type="number">19</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>validate</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compresslevel=%d is out of range for zstd (should be in the range 1 to 19)"</literal></expr></argument>,
									<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>=</operator> <call><name>setDefaultCompressionLevel</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>, <argument><expr><literal type="string">"quicklz"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LIBQUICKLZ</name></cpp:ifndef>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"QuickLZ library is not supported by this build"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Compile with --with-quicklz to use QuickLZ compression."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>validate</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compresslevel=%d is out of range for quicklz (should be 1)"</literal></expr></argument>,
									<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>=</operator> <call><name>setDefaultCompressionLevel</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>, <argument><expr><literal type="string">"rle_type"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>&gt;</operator> <literal type="number">4</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>validate</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compresslevel=%d is out of range for rle_type (should be in the range 1 to 4)"</literal></expr></argument>,
								<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>=</operator> <call><name>setDefaultCompressionLevel</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* checksum */</comment>
	<expr_stmt><expr><name>checksum_opt</name> <operator>=</operator> <call><name>get_option_set</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>num_options</name></expr></argument>, <argument><expr><name>SOPT_CHECKSUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>checksum_opt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>KIND_IS_APPENDOPTIMIZED</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>validate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"usage of parameter \"checksum\" in a non relation object is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>checksum</name></name> <operator>=</operator> <name><name>checksum_opt</name><operator>-&gt;</operator><name>values</name><operator>.</operator><name>bool_val</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
		<name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>==</operator> <name>AO_DEFAULT_COMPRESSLEVEL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>=</operator> <call><name>setDefaultCompressionLevel</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>validate_and_refill_options</name><parameter_list>(<parameter><decl><type><name>StdRdOptions</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>relopt_value</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>numrelopts</name></decl></parameter>, <parameter><decl><type><name>relopt_kind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>validate</name> <operator>&amp;&amp;</operator>
		<name>ao_storage_opts_changed</name> <operator>&amp;&amp;</operator>
		<call><name>KIND_IS_APPENDOPTIMIZED</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>get_option_set</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>numrelopts</name></expr></argument>, <argument><expr><name>SOPT_BLOCKSIZE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>=</operator> <name><name>ao_storage_opts</name><operator>.</operator><name>blocksize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>get_option_set</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>numrelopts</name></expr></argument>, <argument><expr><name>SOPT_COMPLEVEL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>=</operator> <name><name>ao_storage_opts</name><operator>.</operator><name>compresslevel</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>get_option_set</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>numrelopts</name></expr></argument>, <argument><expr><name>SOPT_COMPTYPE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>, <argument><expr><name><name>ao_storage_opts</name><operator>.</operator><name>compresstype</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>get_option_set</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>numrelopts</name></expr></argument>, <argument><expr><name>SOPT_CHECKSUM</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>checksum</name></name> <operator>=</operator> <name><name>ao_storage_opts</name><operator>.</operator><name>checksum</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>validate_and_adjust_options</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>numrelopts</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>validate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>parse_validate_reloptions</name><parameter_list>(<parameter><decl><type><name>StdRdOptions</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>validate</name></decl></parameter>, <parameter><decl><type><name>relopt_kind</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>relopt_value</name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_options</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>parseRelOptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>validate</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>validate_and_adjust_options</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>num_options</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>validate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_options_deep</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>num_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * validateAppendOnlyRelOptions
 *
 *		Various checks for validity of appendonly relation rules.
 */</comment>
<function><type><name>void</name></type>
<name>validateAppendOnlyRelOptions</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>blocksize</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>safewrite</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>complevel</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>comptype</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>checksum</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>co</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>comptype</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>comptype</name></expr></argument>, <argument><expr><literal type="string">"quicklz"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>comptype</name></expr></argument>, <argument><expr><literal type="string">"zlib"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>comptype</name></expr></argument>, <argument><expr><literal type="string">"rle_type"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>comptype</name></expr></argument>, <argument><expr><literal type="string">"zstd"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>co</name> <operator>&amp;&amp;</operator>
			<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>comptype</name></expr></argument>, <argument><expr><literal type="string">"rle_type"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be used with Append Only relations row orientation"</literal></expr></argument>,
							<argument><expr><name>comptype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>comptype</name> <operator>&amp;&amp;</operator> <name>complevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compresstype cannot be used with compresslevel 0"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>comptype</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>comptype</name></expr></argument>, <argument><expr><literal type="string">"zlib"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifndef>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"zlib compression is not supported by this build"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Compile without --without-zlib to use zlib compression."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><name><name>complevel</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>complevel</name></expr></argument> &gt;</argument_list></name> <literal type="number">9</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compresslevel=%d is out of range (should be between 0 and 9)"</literal></expr></argument>,
								<argument><expr><name>complevel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>comptype</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>comptype</name></expr></argument>, <argument><expr><literal type="string">"zstd"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_ZSTD</name></cpp:ifndef>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Zstandard library is not supported by this build"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Compile without --without-zstd to use Zstandard compression."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><name><name>complevel</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>complevel</name></expr></argument> &gt;</argument_list></name> <literal type="number">19</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compresslevel=%d is out of range for zstd (should be in the range 1 to 19)"</literal></expr></argument>,
								<argument><expr><name>complevel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>comptype</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>comptype</name></expr></argument>, <argument><expr><literal type="string">"quicklz"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LIBQUICKLZ</name></cpp:ifndef>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"QuickLZ library is not supported by this build"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Compile with --with-quicklz to use QuickLZ compression."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><name>complevel</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compresslevel=%d is out of range for quicklz (should be 1)"</literal></expr></argument>,
								<argument><expr><name>complevel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>comptype</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>comptype</name></expr></argument>, <argument><expr><literal type="string">"rle_type"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>complevel</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>complevel</name></expr></argument> &gt;</argument_list></name> <literal type="number">4</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compresslevel=%d is out of range for rle_type (should be in the range 1 to 4)"</literal></expr></argument>,
							<argument><expr><name>complevel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>blocksize</name> <argument_list type="generic">&lt; <argument><expr><name>MIN_APPENDONLY_BLOCK_SIZE</name> <operator>||</operator>
		<name>blocksize</name></expr></argument> &gt;</argument_list></name> <name>MAX_APPENDONLY_BLOCK_SIZE</name> <operator>||</operator>
		<name>blocksize</name> <operator>%</operator> <name>MIN_APPENDONLY_BLOCK_SIZE</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block size must be between 8KB and 2MB and be an 8KB multiple, got %d"</literal></expr></argument>, <argument><expr><name>blocksize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>safewrite</name> <operator>&gt;</operator> <name>MAX_APPENDONLY_BLOCK_SIZE</name> <operator>||</operator> <name>safewrite</name> <operator>%</operator> <literal type="number">8</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"safefswrite size must be less than 8MB and be a multiple of 8"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp_safefswritesize</name> <operator>&gt;</operator> <name>blocksize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block size (%d) is smaller gp_safefswritesize (%d)"</literal></expr></argument>,
						<argument><expr><name>blocksize</name></expr></argument>, <argument><expr><name>gp_safefswritesize</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increase blocksize or decrease gp_safefswritesize if it is safe to do so on this file system."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * if no compressor type was specified, we set to no compression (level 0)
 * otherwise default for both zlib, quicklz, zstd and RLE to level 1.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setDefaultCompressionLevel</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>compresstype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>compresstype</name> <operator>||</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * It's used to prevent persistent memory leaks when parseRelOptions() is called repeatedly.
 */</comment>
<function><type><name>void</name></type>
<name>free_options_deep</name><parameter_list>(<parameter><decl><type><name>relopt_value</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_options</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isset</name> <operator>&amp;&amp;</operator>
			<name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>RELOPT_TYPE_STRING</name> <operator>&amp;&amp;</operator>
			<name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>values</name><operator>.</operator><name>string_val</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>values</name><operator>.</operator><name>string_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>relopt_value</name> <modifier>*</modifier></type>
<name>get_option_set</name><parameter_list>(<parameter><decl><type><name>relopt_value</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opt_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>opt_name_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp_len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>opt_name_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>opt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_options</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>cmp_len</name> <operator>=</operator> <ternary><condition><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>-&gt;</operator><name>namelen</name></name> <operator>&gt;</operator> <name>opt_name_len</name></expr> ?</condition><then> <expr><name>opt_name_len</name></expr> </then><else>: <expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>-&gt;</operator><name>namelen</name></name></expr></else></ternary></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isset</name> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>opt_name</name></expr></argument>, <argument><expr><name>cmp_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>&amp;</operator><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------
 * Attribute Encoding specific functions
 * ------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Check if the name is one of the ENCODING clauses.
 */</comment>
<function><type><name>bool</name></type>
<name>is_storage_encoding_directive</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* names we expect to see in ENCODING clauses */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>storage_directive_names</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"compresstype"</literal></expr>, 
						<expr><literal type="string">"compresslevel"</literal></expr>,
						<expr><literal type="string">"blocksize"</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>storage_directive_names</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>storage_directive_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add any missing encoding attributes (compresstype = none,
 * blocksize=...).  The column specific encoding attributes supported
 * today are compresstype, compresslevel and blocksize.  Refer to
 * pg_compression.c for more info.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>fillin_encoding</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aocoColumnEncoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>foundCompressType</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>foundCompressTypeNone</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmplevel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>foundBlockSize</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>retList</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>aocoColumnEncoding</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>el</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>StdRdOptions</name> <modifier>*</modifier></type><name>ao_opts</name> <init>= <expr><call><name>currentAOStorageOptions</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aocoColumnEncoding</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>el</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"compresstype"</literal></expr></argument>, <argument><expr><name><name>el</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>foundCompressType</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"none"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>foundCompressTypeNone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"compresslevel"</literal></expr></argument>, <argument><expr><name><name>el</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cmplevel</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"blocksize"</literal></expr></argument>, <argument><expr><name><name>el</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>foundBlockSize</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>foundCompressType</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name>cmplevel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No compression option specified, use current defaults. */</comment>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <ternary><condition><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then>
				<expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"none"</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>el</name> <operator>=</operator> <call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"compresstype"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>retList</name></expr></argument>, <argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>el</name> <operator>=</operator> <call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"compresslevel"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresslevel</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>retList</name></expr></argument>, <argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>foundCompressType</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name>cmplevel</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmplevel</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * User wants to disable compression by specifying
			 * compresslevel=0.
			 */</comment>
			<expr_stmt><expr><name>el</name> <operator>=</operator> <call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"compresstype"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>retList</name></expr></argument>, <argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * User wants to enable compression by specifying non-zero
			 * compresslevel.  Therefore, choose default compresstype
			 * if configured, otherwise use zlib.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>AO_DEFAULT_COMPRESSTYPE</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>el</name> <operator>=</operator> <call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"compresstype"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>retList</name></expr></argument>, <argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>foundCompressType</name> <operator>&amp;&amp;</operator> <name>cmplevel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>foundCompressTypeNone</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * User wants to disable compression by specifying
			 * compresstype=none.
			 */</comment>
			<expr_stmt><expr><name>el</name> <operator>=</operator> <call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"compresslevel"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>retList</name></expr></argument>, <argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Valid compresstype specified.  Use default
			 * compresslevel if it's non-zero, otherwise use 1.
			 */</comment>
			<expr_stmt><expr><name>el</name> <operator>=</operator> <call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"compresslevel"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then>
												  <expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresslevel</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>retList</name></expr></argument>, <argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>foundBlockSize</name> <operator>==</operator> <name>false</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>el</name> <operator>=</operator> <call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"blocksize"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>retList</name></expr></argument>, <argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>retList</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make encoding (compresstype = ..., blocksize=...) based on
 * currently configured defaults.
 * For blocksize, it is impossible for the value to be unset
 * if an appendonly relation, hence the default is always ignored.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>default_column_encoding_clause</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>e1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>StdRdOptions</name> <modifier>*</modifier></type><name>ao_opts</name> <init>= <expr><call><name>currentAOStorageOptions</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>appendonly</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>blocksize</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>compresslevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>compresstype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type>	<name>compresstype_nd</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>appendonly</name> <operator>=</operator> <name>rel</name> <operator>&amp;&amp;</operator> <call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>appendonly</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GetAppendOnlyEntryAttributes</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>blocksize</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>compresslevel</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>compresstype_nd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>compresstype</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name>compresstype_nd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>compresstype</name> <operator>=</operator> <ternary><condition><expr><name>compresstype</name> <operator>&amp;&amp;</operator> <name><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr> </then><else>: 
					<expr><operator>(</operator><ternary><condition><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"none"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>e1</name> <operator>=</operator> <call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"compresstype"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blocksize</name> <operator>=</operator> <ternary><condition><expr><name>appendonly</name></expr> ?</condition><then> <expr><name>blocksize</name></expr> </then><else>: 
					<expr><operator>(</operator><ternary><condition><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>ao_opts</name><operator>-&gt;</operator><name>blocksize</name></name></expr> </then><else>: <expr><name>AO_DEFAULT_BLOCKSIZE</name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>e2</name> <operator>=</operator> <call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"blocksize"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name>blocksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>compresslevel</name> <operator>=</operator> <ternary><condition><expr><name>appendonly</name> <operator>&amp;&amp;</operator> <name>compresslevel</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>compresslevel</name></expr> </then><else>:
					<expr><operator>(</operator><ternary><condition><expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresslevel</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>ao_opts</name><operator>-&gt;</operator><name>compresslevel</name></name></expr> </then><else>: <expr><name>AO_DEFAULT_COMPRESSLEVEL</name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>e3</name> <operator>=</operator> <call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"compresslevel"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name>compresslevel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * See if two encodings attempt to set the same parameters.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>encodings_overlap</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lca</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lca</argument>, <argument>a</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lcb</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>ela</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lca</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lcb</argument>, <argument>b</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>elb</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>ela</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name><name>elb</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validate the sanity of column reference storage clauses.
 *
 * 1. Ensure that we only refer to columns that exist.
 * 2. Ensure that each column is referenced either zero times or once.
 * 3. Ensure that the column reference storage clauses do not clash with the
 * 	  gp_default_storage_options
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validateColumnStorageEncodingClauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aocoColumnEncoding</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableElts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>HTAB</name></name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<struct>struct <name>colent</name> <block>{
		<decl_stmt><decl><type><name>char</name></type> <name><name>colname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
	}</block> <decl><modifier>*</modifier><name>ce</name> <init>= <expr><name>NULL</name></expr></init></decl>;</struct>

	<comment type="block">/* Generate a hash table for all the columns */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tableElts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator><name>n</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><ternary><condition><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
							<expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>colname</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ht</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HASHCTL</name></type>  <name>cacheInfo</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>      <name>cacheFlags</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cacheInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cacheInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cacheInfo</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cacheInfo</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ce</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name>cacheFlags</name> <operator>=</operator> <name>HASH_ELEM</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>ht</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"column info cache"</literal></expr></argument>,
								 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableElts</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>cacheInfo</name></expr></argument>, <argument><expr><name>cacheFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The user specified a duplicate column name. We check duplicate
			 * column names VERY late (under MergeAttributes(), which is called
			 * by DefineRelation(). For the specific case here, it is safe to
			 * call out that this is a duplicate. We don't need to delay until
			 * we look at inheritance.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" duplicated"</literal></expr></argument>,
								<argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If the table has no columns -- usually in the partitioning case -- then
	 * we can short circuit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ht</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * All column reference storage directives without the DEFAULT
	 * clause should refer to real columns.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aocoColumnEncoding</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ColumnReferenceStorageDirective</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>deflt</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type> <name><name>colname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> <name>collen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>column</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><ternary><condition><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>collen</name></expr> ?</condition><then> <expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>collen</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>column</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>colname</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>count</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" referenced in more than one COLUMN ENCODING clause"</literal></expr></argument>,
								<argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aocoColumnEncoding</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>crsd</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>d</name> <init>= <expr><call><name>transformRelOptions</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name><name>crsd</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StdRdOptions</name> <modifier>*</modifier></type><name>stdRdOptions</name> <init>= <expr><operator>(</operator><name>StdRdOptions</name> <operator>*</operator><operator>)</operator><call><name>default_reloptions</name><argument_list>(<argument><expr><name>d</name></expr></argument>,
																	<argument><expr><name>true</name></expr></argument>,
																	<argument><expr><name>RELOPT_KIND_APPENDOPTIMIZED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>validateAppendOnlyRelOptions</name><argument_list>(<argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>,
									 <argument><expr><name>gp_safefswritesize</name></expr></argument>,
									 <argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>compresslevel</name></name></expr></argument>,
									 <argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>,
									 <argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Make a default column storage directive from a WITH clause
 * Ignore options in the WITH clause that don't appear in
 * storage_directives for column-level compression.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>form_default_storage_directive</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>enc</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>el</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>el</name><operator>-&gt;</operator><name>defname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"oids"</literal></expr></argument>, <argument><expr><name><name>el</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"fillfactor"</literal></expr></argument>, <argument><expr><name><name>el</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"tablename"</literal></expr></argument>, <argument><expr><name><name>el</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* checksum is not a column specific attribute. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"checksum"</literal></expr></argument>, <argument><expr><name><name>el</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform and validate the actual encoding clauses.
 *
 * We need tell the underlying system that these are AO/CO tables too,
 * hence the concatenation of the extra elements.
 *
 * If 'validate' is true, we validate that the optionsa are valid WITH options
 * for an AO table. Otherwise, any unrecognized options are passed through as
 * is.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformStorageEncodingClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>aocoColumnEncoding</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>	   <modifier>*</modifier></type><name>dl</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aocoColumnEncoding</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>dl</name> <operator>=</operator> <operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>dl</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name>SOPT_CHECKSUM</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>SOPT_CHECKSUM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a column specific option"</literal></expr></argument>,
							<argument><expr><name>SOPT_CHECKSUM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* add defaults for missing values */</comment>
	<expr_stmt><expr><name>aocoColumnEncoding</name> <operator>=</operator> <call><name>fillin_encoding</name><argument_list>(<argument><expr><name>aocoColumnEncoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The following two statements validate that the encoding clause is well
	 * formed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>validate</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>aocoColumnEncoding</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>default_reloptions</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>RELOPT_KIND_APPENDOPTIMIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>aocoColumnEncoding</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the column reference storage encoding clause for `column'.
 *
 * This is called by transformColumnEncoding() in a loop but stenc should be
 * quite small in practice.
 */</comment>
<function><type><specifier>static</specifier> <name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type>
<name>find_crsd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>column</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stenc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stenc</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>deflt</name></name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>column</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>column</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse and validate COLUMN &lt;col&gt; ENCODING ... directives.
 *
 * The 'colDefs', 'stenc' and 'taboptions' arguments are parts of the
 * CREATE TABLE or ALTER TABLE command:
 *
 * 'colDefs' - list of ColumnDefs
 * 'stenc' - list of ColumnReferenceStorageDirectives
 * 'withOptions' - list of WITH options
 * 'parentenc' - list of ColumnReferenceStorageDirectives explicitly defined for
 * parent partition
 * 'explicitOnly' - Only return explicitly defined column encoding values
 *  to be used for child partitions
 *
 * ENCODING options can be attached to column definitions, like
 * "mycolumn integer ENCODING ..."; these go into ColumnDefs. They
 * can also be specified with the "COLUMN mycolumn ENCODING ..." syntax;
 * they go into the ColumnReferenceStorageDirectives. And table-wide
 * defaults can be given in the WITH clause.
 *
 * Normally if any ENCODING clause was given for a non-AO/CO table,
 * we should report an error. However, exception exists in DefineRelation()
 * where we allow that to happen, so we pass in errorOnEncodingClause to
 * indicate whether we should report this error. 
 *
 * This function is called for RELKIND_PARTITIONED_TABLE as well even if we
 * don't store entries in pg_attribute_encoding for rootpartition. The reason
 * is to transformColumnEncoding for parent as need to use them later while
 * creating partitions in GPDB legacy partitioning syntax. Hence, if
 * rootpartition add to the list, only encoding elements specified in command,
 * defaults based on GUCs and such are skipped. Each child partition would
 * independently later run through this logic and that time add those GUC
 * specific defaults if required. Reason to avoid adding defaults for
 * rootpartition is need to first merge partition level user specified options
 * and then need to add defaults only for remaining columns.
 *
 * NOTE: This is *not* performed during the parse analysis phase, like
 * most transformation, but only later in DefineRelation() or ATExecAddColumn(). 
 * This needs access to possible inherited columns, so it can only be done after
 * expanding them.
 */</comment>
<function><type><name>List</name><modifier>*</modifier></type> <name>transformColumnEncoding</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colDefs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stenc</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>withOptions</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentenc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>explicitOnly</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>errorOnEncodingClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>deflt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>stenc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>validateColumnStorageEncodingClauses</name><argument_list>(<argument><expr><name>stenc</name></expr></argument>, <argument><expr><name>colDefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* get the default clause, if there is one. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stenc</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ColumnReferenceStorageDirective</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>errorOnEncodingClause</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ENCODING clause only supported with column oriented tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>deflt</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Some quick validation: there should only be one default
			 * clause
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>deflt</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only one default column encoding may be specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>deflt</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deflt</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <call><name>transformStorageEncodingClause</name><argument_list>(<argument><expr><name><name>deflt</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The default encoding and the with clause better not
			 * try and set the same options!
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>encodings_overlap</name><argument_list>(<argument><expr><name>withOptions</name></expr></argument>, <argument><expr><name><name>deflt</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DEFAULT COLUMN ENCODING clause cannot override values set in WITH clause"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

	</block_content>}</block>

	<comment type="block">/*
	 * If no default has been specified, we might create one out of the
	 * WITH clause.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>deflt</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tmpenc</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmpenc</name> <operator>=</operator> <call><name>form_default_storage_directive</name><argument_list>(<argument><expr><name>withOptions</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>deflt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnReferenceStorageDirective</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deflt</name><operator>-&gt;</operator><name>deflt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deflt</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <call><name>transformStorageEncodingClause</name><argument_list>(<argument><expr><name>tmpenc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>colDefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>encoding</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find a storage encoding for this column, in this order:
		 *
		 * 1. An explicit encoding clause in the ColumnDef
		 * 2. A column reference storage directive for this column
		 * 3. A default column encoding in the statement
		 * 4. Parent partition's column encoding values
		 * 5. A default for the type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>encoding</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>transformStorageEncodingClause</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>errorOnEncodingClause</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ENCODING clause only supported with column oriented tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>find_crsd</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>stenc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>transformStorageEncodingClause</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>deflt</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>deflt</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name>explicitOnly</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>parentenc</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>parent_col_encoding</name> <init>= <expr><call><name>find_crsd</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>parentenc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>transformStorageEncodingClause</name><argument_list>(<argument><expr><name><name>parent_col_encoding</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>typeName</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>get_type_encoding</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>encoding</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>default_column_encoding_clause</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>encoding</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnReferenceStorageDirective</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>column</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Update the corresponding ColumnReferenceStorageDirective clause
 * in a list of such clauses: current_encodings.
 *
 * return whether current_encodings was modified
 * (either existing changed or new crsd added for new column)
 */</comment>
<function><type><name>bool</name></type>
<name>updateEncodingList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>current_encodings</name></decl></parameter>, <parameter><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>new_crsd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_current</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>crsd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc_current</argument>, <argument>current_encodings</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>current_crsd</name> <init>= <expr><operator>(</operator><name>ColumnReferenceStorageDirective</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc_current</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>current_crsd</name><operator>-&gt;</operator><name>deflt</name></name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>new_crsd</name><operator>-&gt;</operator><name>column</name></name></expr></argument>, <argument><expr><name><name>current_crsd</name><operator>-&gt;</operator><name>column</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>crsd</name> <operator>=</operator> <name>current_crsd</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>crsd</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>merged_encodings</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Create a new list of encodings merging the existing and new values.
		 *
		 * Assuming crsd-&gt;encoding is complete list of all encoding attributes,
		 * but new_crsd-&gt;encoding may or may not be complete list.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>crsd-&gt;encoding</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DefElem</name>  <modifier>*</modifier></type><name>el1</name>        <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DefElem</name>  <modifier>*</modifier></type><name>el2</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>current_updated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach</name> <argument_list>(<argument>lc2</argument>, <argument>new_crsd-&gt;encoding</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>el2</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>el1</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name><name>el2</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
					<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>el1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>el2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>current_updated</name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>is_changed</name>       <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>merged_encodings</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>merged_encodings</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>el2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>current_updated</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>merged_encodings</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>merged_encodings</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>el1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<comment type="block">/*
		 * Validate the merged encodings to weed out duplicate parameters and/or
		 * invalid parameter values.
		 * We can have duplicate parameters if user enters for eg:
		 * ALTER COLUMN a SET ENCODING (compresslevel=3, compresslevel=4);
		 */</comment>
		<expr_stmt><expr><name>merged_encodings</name> <operator>=</operator>
			<call><name>transformStorageEncodingClause</name><argument_list>(<argument><expr><name>merged_encodings</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update current_encodings in place with the merged and validated merged_encodings
		 */</comment>
		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>crsd</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>crsd</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>merged_encodings</name></expr>;</expr_stmt>
		<return>return <expr><name>is_changed</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * new_crsd-&gt;column not found in current_encodings
		 * Must be coming from a newly added column
		 */</comment>

		<expr_stmt><expr><name><name>new_crsd</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <call><name>transformStorageEncodingClause</name><argument_list>(<argument><expr><name><name>new_crsd</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>lappend</name><argument_list>(<argument><expr><name>current_encodings</name></expr></argument>, <argument><expr><name>new_crsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GPDB: Convenience function to judge a relation option whether already in opts
 */</comment>
<function><type><name>bool</name></type>
<name>reloptions_has_opt</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>opts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GPDB: Convenience function to build storage reloptions for a given relation, just for AO table.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>build_ao_rel_storage_opts</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>checksum</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>blocksize</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>compresslevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>compresstype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type>	<name>compresstype_nd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAttributes</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>blocksize</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>compresslevel</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>checksum</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>compresstype_nd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>compresstype</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name>compresstype_nd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>reloptions_has_opt</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><literal type="string">"blocksize"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>opts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"blocksize"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name>blocksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>reloptions_has_opt</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><literal type="string">"compresslevel"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>opts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"compresslevel"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name>compresslevel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>reloptions_has_opt</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><literal type="string">"checksum"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>opts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"checksum"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>reloptions_has_opt</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><literal type="string">"compresstype"</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>compresstype</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>compresstype</name> <operator>&amp;&amp;</operator> <name><name>compresstype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"none"</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>opts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"compresstype"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>opts</name></expr>;</return>
</block_content>}</block></function>
</unit>
