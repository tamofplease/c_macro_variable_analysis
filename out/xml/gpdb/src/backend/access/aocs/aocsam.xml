<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/aocs/aocsam.c"><comment type="block">/*--------------------------------------------------------------------------
 *
 * aocsam.c
 *	  Append only columnar access methods
 *
 * Portions Copyright (c) 2009-2010, Greenplum Inc.
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/access/aocs/aocsam.c
 *
 *--------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/relpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/aocssegfiles.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/aomd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonlytid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonlywriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hio.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_fastsequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_appendonly.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute_encoding.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbaocsam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyblockdirectory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystoragelayer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystorageread.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystoragewrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datumstream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>AOCSScanDesc</name></type> <name>aocs_beginscan_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
						<parameter><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>seginfo</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>total_seg</name></decl></parameter>,
						<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						<parameter><decl><type><name>Snapshot</name></type> <name>appendOnlyMetaDataSnapshot</name></decl></parameter>,
						<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>proj</name></decl></parameter>,
						<parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Open the segment file for a specified column associated with the datum
 * stream.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>open_datumstreamread_segfile</name><parameter_list>(
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>basepath</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name></type> <name>node</name></decl></parameter>,
							 <parameter><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier></type><name>segInfo</name></decl></parameter>,
							 <parameter><decl><type><name>DatumStreamRead</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>colNo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>segNo</name> <init>= <expr><name><name>segInfo</name><operator>-&gt;</operator><name>segno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fn</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fileSegNo</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AOCSVPInfoEntry</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>getAOCSVPEntry</name><argument_list>(<argument><expr><name>segInfo</name></expr></argument>, <argument><expr><name>colNo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FormatAOSegmentFileName</name><argument_list>(<argument><expr><name>basepath</name></expr></argument>, <argument><expr><name>segNo</name></expr></argument>, <argument><expr><name>colNo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileSegNo</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>datumstreamread_open_file</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>eof</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>eof_uncompressed</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
							  <argument><expr><name>fileSegNo</name></expr></argument>, <argument><expr><name><name>segInfo</name><operator>-&gt;</operator><name>formatversion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open all segment files associted with the datum stream.
 *
 * Currently, there is one segment file for each column. This function
 * only opens files for those columns which are in the projection.
 *
 * If blockDirectory is not NULL, the first block info is written to
 * the block directory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>open_all_datumstreamread_segfiles</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								  <parameter><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier></type><name>segInfo</name></decl></parameter>,
								  <parameter><decl><type><name>DatumStreamRead</name> <modifier>*</modifier><modifier>*</modifier></type><name>ds</name></decl></parameter>,
								  <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>proj_atts</name></decl></parameter>,
								  <parameter><decl><type><name>AttrNumber</name></type> <name>num_proj_atts</name></decl></parameter>,
								  <parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>basepath</name> <init>= <expr><call><name>relpathbackend</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>proj_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_proj_atts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name><name>proj_atts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>open_datumstreamread_segfile</name><argument_list>(<argument><expr><name>basepath</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>segInfo</name></expr></argument>, <argument><expr><name><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>datumstreamread_block</name><argument_list>(<argument><expr><name><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>, <argument><expr><name>blockDirectory</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>basepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialise data streams for every column used in this query. For writes, this
 * means all columns.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>open_ds_write</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>DatumStreamWrite</name> <modifier>*</modifier><modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>relationTupleDesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>checksum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nvp</name> <init>= <expr><name><name>relationTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StdRdOptions</name> <modifier>*</modifier><modifier>*</modifier></type><name>opts</name> <init>= <expr><call><name>RelationGetAttributeOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* open datum streams.  It will open segment file underneath */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nvp</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>relationTupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>clvl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>blksz</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>titleBuf</name></decl>;</decl_stmt>

		<comment type="block">/* UNDONE: Need to track and dispose of this storage... */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>,
						 <argument><expr><literal type="string">"Write of Append-Only Column-Oriented relation '%s', column #%d '%s'"</literal></expr></argument>,
						 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
						 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We always record all the three column specific attributes for each
		 * column of a column oriented table.  Note: checksum is a table level
		 * attribute.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>blocksize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find blocksize option for AOCO column in pg_attribute_encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ct</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>compresstype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>clvl</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>compresslevel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blksz</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>blocksize</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>create_datumstreamwrite</name><argument_list>(<argument><expr><name>ct</name></expr></argument>,
										<argument><expr><name>clvl</name></expr></argument>,
										<argument><expr><name>checksum</name></expr></argument>,
										 <comment type="block">/* safeFSWriteSize */</comment> <argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* UNDONE: Need to wire
																	 * down pg_appendonly
																	 * column? */</comment>
										<argument><expr><name>blksz</name></expr></argument>,
										<argument><expr><name>attr</name></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										<comment type="block">/* title */</comment> <argument><expr><name><name>titleBuf</name><operator>.</operator><name>data</name></name></expr></argument>,
										<argument><expr><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></for>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialise data streams for every column used in this query. For writes, this
 * means all columns.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>open_ds_read</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>DatumStreamRead</name> <modifier>*</modifier><modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>relationTupleDesc</name></decl></parameter>,
			 <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>proj_atts</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>num_proj_atts</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>checksum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 *  RelationGetAttributeOptions does not always success return opts. e.g.
	 *  `ALTER TABLE ADD COLUMN` with an illegal option.
	 *
	 *  In this situation, the transaction will abort, and the Relation will be
	 *  free. Upstream have sanity check to promise we must have a worked TupleDesc
	 *  attached the Relation during memory recycle. Otherwise, the query will crash.
	 *
	 *  For some reason, we can not put the option validation check into "perp"
	 *  phase for AOCO table ALTER command.
	 *  (commit: e707c19c885fadffe50095cc699e52af1ee64f4b)
	 *
	 *  So, a fake TupleDesc temporary replace into Relation.
	 */</comment>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>orig_att</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>orig_att</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name><name>relationTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StdRdOptions</name> <modifier>*</modifier><modifier>*</modifier></type><name>opts</name> <init>= <expr><call><name>RelationGetAttributeOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>orig_att</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name> <operator>=</operator> <name>orig_att</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Clear all the entries to NULL first, as the NULL value is used during
	 * closing
	 */</comment>
	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name><name>relationTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* And then initialize the data streams for those columns we need */</comment>
	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_proj_atts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>			<name>attno</name> <init>= <expr><name><name>proj_atts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type>	<name>attr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>			   <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>				<name>clvl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>				<name>blksz</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>titleBuf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attno</name> <operator>&lt;=</operator> <name><name>relationTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>relationTupleDesc</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We always record all the three column specific attributes for each
		 * column of a column oriented table.  Note: checksum is a table level
		 * attribute.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>opts</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>opts</name><index>[<expr><name>attno</name></expr>]</index></name><operator>-&gt;</operator><name>blocksize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find blocksize option for AOCO column in pg_attribute_encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ct</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>attno</name></expr>]</index></name><operator>-&gt;</operator><name>compresstype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>clvl</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>attno</name></expr>]</index></name><operator>-&gt;</operator><name>compresslevel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blksz</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>attno</name></expr>]</index></name><operator>-&gt;</operator><name>blocksize</name></expr>;</expr_stmt>

		<comment type="block">/* UNDONE: Need to track and dispose of this storage... */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>, <argument><expr><literal type="string">"Scan of Append-Only Column-Oriented relation '%s', column #%d '%s'"</literal></expr></argument>,
						 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
						 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <call><name>create_datumstreamread</name><argument_list>(<argument><expr><name>ct</name></expr></argument>,
										   <argument><expr><name>clvl</name></expr></argument>,
										   <argument><expr><name>checksum</name></expr></argument>,
										    <comment type="block">/* safeFSWriteSize */</comment> <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* UNDONE:Need to wire
																			 * down pg_appendonly
																			 * column */</comment>
										   <argument><expr><name>blksz</name></expr></argument>,
										   <argument><expr><name>attr</name></expr></argument>,
										   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										    <comment type="block">/* title */</comment> <argument><expr><name><name>titleBuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>close_ds_read</name><parameter_list>(<parameter><decl><type><name>DatumStreamRead</name> <modifier>*</modifier><modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>destroy_datumstreamread</name><argument_list>(<argument><expr><name><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>close_ds_write</name><parameter_list>(<parameter><decl><type><name>DatumStreamWrite</name> <modifier>*</modifier><modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nvp</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>destroy_datumstreamwrite</name><argument_list>(<argument><expr><name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>initscan_with_colinfo</name><parameter_list>(<parameter><decl><type><name>AOCSScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>oldCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>		<name>natts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>scanCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name></name> <operator>=</operator> <operator>(</operator><name>DatumStreamRead</name> <operator>*</operator><operator>*</operator><operator>)</operator>
								  <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DatumStreamRead</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>proj_atts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>num_proj_atts</name></name> <operator>=</operator> <name>natts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>proj_atts</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator>
										 <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>proj_atts</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <name>attno</name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>open_ds_read</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name></name></expr></argument>,
				 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name></name></expr></argument>,
				 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>proj_atts</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>num_proj_atts</name></name></expr></argument>,
				 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cur_seg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cur_seg_row</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>cdb_fake_ctid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_count_heap_scan</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>open_next_scan_seg</name><parameter_list>(<parameter><decl><type><name>AOCSScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><operator>++</operator><name><name>scan</name><operator>-&gt;</operator><name>cur_seg</name></name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>total_seg</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier></type><name>curSegInfo</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>seginfo</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>cur_seg</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>curSegInfo</name><operator>-&gt;</operator><name>total_tupcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>emptySeg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If the segment is entirely empty, nothing to do.
			 *
			 * We assume the corresponding segments for every column to be in
			 * the same state. So somewhat arbitrarily, we check the state of
			 * the first column we'll be accessing.
			 */</comment>

			<comment type="block">/*
			 * subtle: we must check for AWAITING_DROP before calling getAOCSVPEntry().
			 * ALTER TABLE ADD COLUMN does not update vpinfos on AWAITING_DROP segments.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>curSegInfo</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>AOSEG_STATE_AWAITING_DROP</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>emptySeg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>AOCSVPInfoEntry</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>getAOCSVPEntry</name><argument_list>(<argument><expr><name>curSegInfo</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>proj_atts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>eof</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inconsistent segment state for relation %s, segment %d, tuple count "</literal> <name>INT64_FORMAT</name></expr></argument>,
						 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>curSegInfo</name><operator>-&gt;</operator><name>segno</name></name></expr></argument>,
						 <argument><expr><name><name>curSegInfo</name><operator>-&gt;</operator><name>total_tupcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>emptySeg</name></expr>)</condition>
			<block>{<block_content>

				<comment type="block">/*
				 * If the scan also builds the block directory, initialize it
				 * here.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_Init_forInsert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>,
															<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>,
															<argument><expr><operator>(</operator><name>FileSegInfo</name> <operator>*</operator><operator>)</operator> <name>curSegInfo</name></expr></argument>,
															<argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* lastSequence */</comment> ,
															<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
															<argument><expr><name><name>curSegInfo</name><operator>-&gt;</operator><name>segno</name></name></expr></argument>,
															<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
															<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>open_all_datumstreamread_segfiles</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
												  <argument><expr><name>curSegInfo</name></expr></argument>,
												  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name></name></expr></argument>,
												  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>proj_atts</name></name></expr></argument>,
												  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>num_proj_atts</name></name></expr></argument>,
												  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><name><name>scan</name><operator>-&gt;</operator><name>cur_seg</name></name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>close_cur_scan_seg</name><parameter_list>(<parameter><decl><type><name>AOCSScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>cur_seg</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If rescan is called before we lazily initialized then there is nothing to
	 * do
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init>
		 <condition><expr><name>attno</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition>
		 <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>datumstreamread_close_file</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_End_forInsert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * aocs_beginrangescan
 *
 * begins range-limited relation scan
 */</comment>
<function><type><name>AOCSScanDesc</name></type>
<name>aocs_beginrangescan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
					<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
					<parameter><decl><type><name>Snapshot</name></type> <name>appendOnlyMetaDataSnapshot</name></decl></parameter>,
					<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>segfile_no_arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segfile_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>seginfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RelationIncrementReferenceCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seginfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AOCSFileSegInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>segfile_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>segfile_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>seginfo</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>GetAOCSFileSegInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
										<argument><expr><name><name>segfile_no_arr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><call><name>aocs_beginscan_internal</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
								   <argument><expr><name>seginfo</name></expr></argument>,
								   <argument><expr><name>segfile_count</name></expr></argument>,
								   <argument><expr><name>snapshot</name></expr></argument>,
								   <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>AOCSScanDesc</name></type>
<name>aocs_beginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
			   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>proj</name></decl></parameter>,
			   <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOCSFileSegInfo</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>seginfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>			<name>aocsMetaDataSnapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>				<name>total_seg</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RelationIncrementReferenceCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The append-only meta data should never be fetched with
	 * SnapshotAny as bogus results are returned.
	 * We use SnapshotSelf for metadata, as regular MVCC snapshot can hide newly
	 * globally inserted tuples from global index build process.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>!=</operator> <name>SnapshotAny</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>aocsMetaDataSnapshot</name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>aocsMetaDataSnapshot</name> <operator>=</operator> <name>SnapshotSelf</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>seginfo</name> <operator>=</operator> <call><name>GetAllAOCSFileSegInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>aocsMetaDataSnapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_seg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>aocs_beginscan_internal</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
								   <argument><expr><name>seginfo</name></expr></argument>,
								   <argument><expr><name>total_seg</name></expr></argument>,
								   <argument><expr><name>snapshot</name></expr></argument>,
								   <argument><expr><name>aocsMetaDataSnapshot</name></expr></argument>,
								   <argument><expr><name>proj</name></expr></argument>,
								   <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * begin the scan over the given relation.
 */</comment>
<function><type><specifier>static</specifier> <name>AOCSScanDesc</name></type>
<name>aocs_beginscan_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
						<parameter><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>seginfo</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>total_seg</name></decl></parameter>,
						<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						<parameter><decl><type><name>Snapshot</name></type> <name>appendOnlyMetaDataSnapshot</name></decl></parameter>,
						<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>proj</name></decl></parameter>,
						<parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOCSScanDesc</name></type>	<name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>		<name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>visimaprelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>visimapidxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <operator>(</operator><name>AOCSScanDesc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AOCSScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name> <operator>=</operator> <name>appendOnlyMetaDataSnapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>seginfo</name></name> <operator>=</operator> <name>seginfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>total_seg</name></name> <operator>=</operator> <name>total_seg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>scanCtx</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<comment type="block">/* relationTupleDesc will be inited by the slot when needed */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We get an array of booleans to indicate which columns are needed. But
	 * if you have a very wide table, and you only select a few columns from
	 * it, just scanning the boolean array to figure out which columns are
	 * needed can incur a noticeable overhead in aocs_getnext. So convert it
	 * into an array of the attribute numbers of the required columns.
	 *
	 * However, if no array is given, then let it get lazily initialized when
	 * needed since all the attributes will be fetched.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>proj</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>natts</name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>proj_atts</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator>
										 <call><name>palloc0</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>num_proj_atts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>proj</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>proj_atts</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>num_proj_atts</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAttributes</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>visimaprelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visimapidxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>total_seg</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AppendOnlyVisimap_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>,
							   <argument><expr><name>visimaprelid</name></expr></argument>,
							   <argument><expr><name>visimapidxid</name></expr></argument>,
							   <argument><expr><name>AccessShareLock</name></expr></argument>,
							   <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>aocs_rescan</name><parameter_list>(<parameter><decl><type><name>AOCSScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>close_cur_scan_seg</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>close_ds_read</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>initscan_with_colinfo</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>aocs_endscan</name><parameter_list>(<parameter><decl><type><name>AOCSScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>close_cur_scan_seg</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>proj_atts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>close_ds_read</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>proj_atts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>proj_atts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>proj_atts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>total_seg</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>seginfo</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>seginfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>seginfo</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>seginfo</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>seginfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>total_seg</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AppendOnlyVisimap_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>RelationDecrementReferenceCount</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Upgrades a Datum value from a previous version of the AOCS page format. The
 * DatumStreamRead that is passed must correspond to the column being upgraded.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>upgrade_datum_impl</name><parameter_list>(<parameter><decl><type><name>DatumStreamRead</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name><name>values</name><index>[]</index></name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name><name>isnull</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>formatversion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> 	<name>convert_numeric</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG82NumericConversionNeeded</name><argument_list>(<argument><expr><name>formatversion</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * On the first call for this DatumStream, figure out if this column is
		 * a numeric, or a domain over numerics.
		 *
		 * TODO: consolidate this code with upgrade_tuple() in appendonlyam.c.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>baseTypeOid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>baseTypeOid</name></name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>typeInfo</name><operator>.</operator><name>typid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If this Datum is a numeric, we need to convert it. */</comment>
		<expr_stmt><expr><name>convert_numeric</name> <operator>=</operator> <operator>(</operator><name><name>ds</name><operator>-&gt;</operator><name>baseTypeOid</name></name> <operator>==</operator> <name>NUMERICOID</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>isnull</name><index>[<expr><name>attno</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>convert_numeric</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Before PostgreSQL 8.3, the n_weight and n_sign_dscale fields were the
		 * other way 'round. Swap them.
		 */</comment>
		<decl_stmt><decl><type><name>Datum</name></type> 		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>numericdata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>upgradedata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>datalen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint16</name></type>		<name>tmp</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We need to make a copy of this data so that any other tuples pointing
		 * to it won't be affected. Store it in the upgrade space for this
		 * DatumStream.
		 */</comment>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <name><name>values</name><index>[<expr><name>attno</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>datalen</name> <operator>=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>upgradedata</name> <operator>=</operator> <call><name>datumstreamread_get_upgrade_space</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>upgradedata</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Swap the fields. */</comment>
		<expr_stmt><expr><name>numericdata</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>upgradedata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>numericdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>numericdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>numericdata</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>numericdata</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Re-point the Datum to the upgraded numeric. */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>upgradedata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>upgrade_datum_scan</name><parameter_list>(<parameter><decl><type><name>AOCSScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name><name>values</name><index>[]</index></name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name><name>isnull</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>formatversion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>upgrade_datum_impl</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>formatversion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>upgrade_datum_fetch</name><parameter_list>(<parameter><decl><type><name>AOCSFetchDesc</name></type> <name>fetch</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name><name>values</name><index>[]</index></name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name><name>isnull</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>formatversion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>upgrade_datum_impl</name><argument_list>(<argument><expr><name><name>fetch</name><operator>-&gt;</operator><name>datumStreamFetchDesc</name><index>[<expr><name>attno</name></expr>]</index></name><operator>-&gt;</operator><name>datumStream</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>,
					   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>formatversion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>aocs_getnext</name><parameter_list>(<parameter><decl><type><name>AOCSScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>d</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>null</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AOTupleId</name></type>	<name>aoTupleId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>rowNum</name> <init>= <expr><call><name>INT64CONST</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isSnapshotAny</name> <init>= <expr><operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name> <operator>==</operator> <name>SnapshotAny</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>natts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt>
		<comment type="block">/* Pin it! ... and of course release it upon destruction / rescan */</comment>
		<expr_stmt><expr><call><name>PinTupleDesc</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initscan_with_colinfo</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>natts</name> <operator>&lt;=</operator> <name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>relationTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier></type><name>curseginfo</name></decl>;</decl_stmt>

<label><name>ReadNext</name>:</label>
		<comment type="block">/* If necessary, open next seg */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>cur_seg</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>open_next_scan_seg</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* No more seg, we are at the end */</comment>
				<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cur_seg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cur_seg_row</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>cur_seg</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>curseginfo</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>seginfo</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>cur_seg</name></name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Read from cur_seg */</comment>
		<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>num_proj_atts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>proj_atts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>datumstreamread_advance</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>err</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>datumstreamread_block</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Ha, cannot read next block, we need to go to next seg
					 */</comment>
					<expr_stmt><expr><call><name>close_cur_scan_seg</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>ReadNext</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>datumstreamread_advance</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>err</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Get the column's datum right here since the data structures
			 * should still be hot in CPU data cache memory.
			 */</comment>
			<expr_stmt><expr><call><name>datumstreamread_get</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>null</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Perform any required upgrades on the Datum we just fetched.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>curseginfo</name><operator>-&gt;</operator><name>formatversion</name></name> <operator>&lt;</operator> <call><name>AORelationVersion_GetLatest</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>upgrade_datum_scan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>null</name></expr></argument>,
								   <argument><expr><name><name>curseginfo</name><operator>-&gt;</operator><name>formatversion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>rowNum</name> <operator>==</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name><operator>-&gt;</operator><name>blockFirstRowNum</name> <operator>!=</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name><operator>-&gt;</operator><name>blockFirstRowNum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rowNum</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name><operator>-&gt;</operator><name>blockFirstRowNum</name> <operator>+</operator>
					<call><name>datumstreamread_nth</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>columnScanInfo</name><operator>.</operator><name>ds</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cur_seg_row</name></name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rowNum</name> <operator>==</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AOTupleIdInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aoTupleId</name></expr></argument>, <argument><expr><name><name>curseginfo</name><operator>-&gt;</operator><name>segno</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>cur_seg_row</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>AOTupleIdInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aoTupleId</name></expr></argument>, <argument><expr><name><name>curseginfo</name><operator>-&gt;</operator><name>segno</name></name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSnapshotAny</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AppendOnlyVisimap_IsVisible</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The tuple is invisible.
			 * In `analyze`, we can simply return false
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_TYPE_ANALYZE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>rowNum</name> <operator>=</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>ReadNext</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cdb_fake_ctid</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>ItemPointer</name><operator>)</operator> <operator>&amp;</operator><name>aoTupleId</name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name>natts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>cdb_fake_ctid</name></name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"Never here"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Open next file segment for write.  See SetCurrentFileSegForWrite */</comment>
<comment type="block">/* XXX Right now, we put each column to different files */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>OpenAOCSDatumStreams</name><parameter_list>(<parameter><decl><type><name>AOCSInsertDesc</name></type> <name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>basepath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fn</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fileSegNo</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier></type><name>seginfo</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nvp</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>ds</name></name> <operator>=</operator> <operator>(</operator><name>DatumStreamWrite</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DatumStreamWrite</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nvp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>open_ds_write</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ds</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
				  <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now open seg info file and get eof mark. */</comment>
	<expr_stmt><expr><name>seginfo</name> <operator>=</operator> <call><name>GetAOCSFileSegInfo</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>,
								 <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>,
								 <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>fsInfo</name></name> <operator>=</operator> <name>seginfo</name></expr>;</expr_stmt>

	<comment type="block">/* Never insert into a segment that is awaiting a drop */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>fsInfo</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>AOSEG_STATE_AWAITING_DROP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"cannot insert into segno (%d) for AO relid %d that is in state AOSEG_STATE_AWAITING_DROP"</literal></expr></argument>,
			 <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>=</operator> <name><name>seginfo</name><operator>-&gt;</operator><name>total_tupcount</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>aoi_rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>backend</name></name> <operator>=</operator> <name><name>desc</name><operator>-&gt;</operator><name>aoi_rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>basepath</name> <operator>=</operator> <call><name>relpath</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nvp</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AOCSVPInfoEntry</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>getAOCSVPEntry</name><argument_list>(<argument><expr><name>seginfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>FormatAOSegmentFileName</name><argument_list>(<argument><expr><name>basepath</name></expr></argument>, <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>segno</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileSegNo</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>datumstreamwrite_open_file</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>eof</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>eof_uncompressed</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>,
								   <argument><expr><name>fileSegNo</name></expr></argument>, <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>formatversion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>basepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>SetBlockFirstRowNums</name><parameter_list>(<parameter><decl><type><name>DatumStreamWrite</name> <modifier>*</modifier><modifier>*</modifier></type><name>datumStreams</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>numDatumStreams</name></decl></parameter>,
					 <parameter><decl><type><name>int64</name></type> <name>blockFirstRowNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>datumStreams</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numDatumStreams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>datumStreams</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>datumStreams</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>blockFirstRowNum</name> <operator>=</operator> <name>blockFirstRowNum</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<function><type><name>AOCSInsertDesc</name></type>
<name>aocs_insert_init</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>num_rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NameData</name></type>    <name>nd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOCSInsertDesc</name></type> <name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>firstSequence</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>desc</name> <operator>=</operator> <operator>(</operator><name>AOCSInsertDesc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AOCSInsertDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>aoi_rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Writers uses this since they have exclusive access to the lock acquired
	 * with LockRelationAppendOnlySegmentFile for the segment-file.
	 */</comment>

	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segno</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>cur_segno</name></name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GetAppendOnlyEntryAttributes</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>blocksz</name></name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>compLevel</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>nd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>compType</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name>nd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
                              <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>segrelid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>blkdirrelid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>visimaprelid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>visimapidxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OpenAOCSDatumStreams</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Obtain the next list of fast sequences for this relation.
	 *
	 * Even in the case of no indexes, we need to update the fast sequences,
	 * since the table may contain indexes at some point of time.
	 */</comment>
	<expr_stmt><expr><name>firstSequence</name> <operator>=</operator> <call><name>GetFastSequences</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>segrelid</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>num_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>numSequences</name></name> <operator>=</operator> <name>num_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>firstSequence</name> <operator>&gt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>rowCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>lastSequence</name></name> <operator>=</operator> <name>firstSequence</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetBlockFirstRowNums</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>ds</name></name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>lastSequence</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the block directory. */</comment>
	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_Init_forInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>desc</name><operator>-&gt;</operator><name>blockDirectory</name></name><operator>)</operator></expr></argument>,
											<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>,	<comment type="block">/* CONCERN: Safe to
																				 * assume all block
																				 * directory entries for
																				 * segment are "covered"
																				 * by same exclusive
																				 * lock. */</comment>
											<argument><expr><operator>(</operator><name>FileSegInfo</name> <operator>*</operator><operator>)</operator> <name><name>desc</name><operator>-&gt;</operator><name>fsInfo</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>lastSequence</name></name></expr></argument>,
											<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>aocs_insert_values</name><parameter_list>(<parameter><decl><type><name>AOCSInsertDesc</name></type> <name>idesc</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>null</name></decl></parameter>, <parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>idesc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(
								   <argument><expr><literal type="string">"appendonly_insert"</literal></expr></argument>,
								   <argument><expr><name>DDLNotSpecified</name></expr></argument>,
								   <argument><expr><literal type="string">""</literal></expr></argument>,	<comment type="block">/* databaseName */</comment>
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* tableName */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* As usual, at this moment, we assume one col per vp */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>toFree1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name> <init>= <expr><name><name>d</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>err</name> <init>= <expr><call><name>datumstreamwrite_put</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name><name>null</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>toFree1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>toFree1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Use the de-toasted and/or de-compressed as datum instead.
			 */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>toFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>itemCount</name> <init>= <expr><call><name>datumstreamwrite_nth</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>toFree2</name></decl>;</decl_stmt>

			<comment type="block">/* write the block up to this one */</comment>
			<expr_stmt><expr><call><name>datumstreamwrite_block</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>idesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>itemCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * since we have written all up to the new tuple, the new
				 * blockFirstRowNum is the inserted tuple's row number
				 */</comment>
				<expr_stmt><expr><name><name>idesc</name><operator>-&gt;</operator><name>ds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>blockFirstRowNum</name> <operator>=</operator> <name><name>idesc</name><operator>-&gt;</operator><name>lastSequence</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>ds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>blockFirstRowNum</name> <operator>==</operator> <name><name>idesc</name><operator>-&gt;</operator><name>lastSequence</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


			<comment type="block">/* now write this new item to the new block */</comment>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>datumstreamwrite_put</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name><name>null</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>toFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>toFree2</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>null</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>datumstreamwrite_lob</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										   <argument><expr><name>datum</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>idesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>,
										   <argument><expr><name>i</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>err</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * A lob will live by itself in the block so this assignment
				 * is for the block that contains tuples AFTER the one we are
				 * inserting
				 */</comment>
				<expr_stmt><expr><name><name>idesc</name><operator>-&gt;</operator><name>ds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>blockFirstRowNum</name> <operator>=</operator> <name><name>idesc</name><operator>-&gt;</operator><name>lastSequence</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>toFree1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>toFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>idesc</name><operator>-&gt;</operator><name>insertCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>idesc</name><operator>-&gt;</operator><name>lastSequence</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>idesc</name><operator>-&gt;</operator><name>numSequences</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><name>idesc</name><operator>-&gt;</operator><name>numSequences</name></name><operator>)</operator><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>numSequences</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AOTupleIdInit</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>, <argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>, <argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>lastSequence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the allocated fast sequence numbers are used up, we request for a
	 * next list of fast sequence numbers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>idesc</name><operator>-&gt;</operator><name>numSequences</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>firstSequence</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>firstSequence</name> <operator>=</operator>
			<call><name>GetFastSequences</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>segrelid</name></name></expr></argument>,
							 <argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>,
							 <argument><expr><name>NUM_FAST_SEQUENCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>firstSequence</name> <operator>==</operator> <name><name>idesc</name><operator>-&gt;</operator><name>lastSequence</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>idesc</name><operator>-&gt;</operator><name>numSequences</name></name> <operator>=</operator> <name>NUM_FAST_SEQUENCES</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>aocs_insert_finish</name><parameter_list>(<parameter><decl><type><name>AOCSInsertDesc</name></type> <name>idesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>idesc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>datumstreamwrite_block</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>idesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>datumstreamwrite_close_file</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_End_forInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>idesc</name><operator>-&gt;</operator><name>blockDirectory</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdateAOCSFileSegInfo</name><argument_list>(<argument><expr><name>idesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>fsInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>close_ds_write</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>ds</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>positionFirstBlockOfRange</name><parameter_list>(<parameter><decl><type><name>DatumStreamFetchDesc</name></type> <name>datumStreamFetchDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AppendOnlyBlockDirectoryEntry_GetBeginRange</name><argument_list>(
												<argument><expr><operator>&amp;</operator><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>blockDirectoryEntry</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>scanNextFileOffset</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>scanNextRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>positionLimitToEndOfRange</name><parameter_list>(<parameter><decl><type><name>DatumStreamFetchDesc</name></type> <name>datumStreamFetchDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AppendOnlyBlockDirectoryEntry_GetEndRange</name><argument_list>(
											  <argument><expr><operator>&amp;</operator><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>blockDirectoryEntry</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>scanAfterFileOffset</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>scanLastRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>positionSkipCurrentBlock</name><parameter_list>(<parameter><decl><type><name>DatumStreamFetchDesc</name></type> <name>datumStreamFetchDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>scanNextFileOffset</name></name> <operator>=</operator>
		<name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>fileOffset</name></name> <operator>+</operator>
		<name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>overallBlockLen</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>scanNextRowNum</name></name> <operator>=</operator>
		<name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>lastRowNum</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the tuple's datum from the block indicated by the block directory entry
 * that covers the tuple, given the colno.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fetchFromCurrentBlock</name><parameter_list>(<parameter><decl><type><name>AOCSFetchDesc</name></type> <name>aocsFetchDesc</name></decl></parameter>,
					  <parameter><decl><type><name>int64</name></type> <name>rowNum</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>colno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DatumStreamFetchDesc</name></type> <name>datumStreamFetchDesc</name> <init>=
	<expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>datumStreamFetchDesc</name><index>[<expr><name>colno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DatumStreamRead</name> <modifier>*</modifier></type><name>datumStream</name> <init>= <expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>datumStream</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rowNumInBlock</name> <init>= <expr><name>rowNum</name> <operator>-</operator> <name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>firstRowNum</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rowNumInBlock</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * MPP-17061: gotContents could be false in the case of aborted rows. As
	 * described in the repro in MPP-17061, if aocs_fetch is trying to fetch
	 * an invisible/aborted row, it could set the block header metadata of
	 * currentBlock to the next CO block, but without actually reading in next
	 * CO block's content.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>gotContents</name></name> <operator>==</operator> <name>false</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>datumstreamread_block_content</name><argument_list>(<argument><expr><name>datumStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>gotContents</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>datumstreamread_find</name><argument_list>(<argument><expr><name>datumStream</name></expr></argument>, <argument><expr><name>rowNumInBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>formatversion</name> <init>= <expr><name><name>datumStream</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>formatVersion</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>datumstreamread_get</name><argument_list>(<argument><expr><name>datumStream</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>values</name><index>[<expr><name>colno</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>nulls</name><index>[<expr><name>colno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Perform any required upgrades on the Datum we just fetched.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>formatversion</name> <operator>&lt;</operator> <call><name>AORelationVersion_GetLatest</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>upgrade_datum_fetch</name><argument_list>(<argument><expr><name>aocsFetchDesc</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
								<argument><expr><name>formatversion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>datumstreamread_get</name><argument_list>(<argument><expr><name>datumStream</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>scanToFetchValue</name><parameter_list>(<parameter><decl><type><name>AOCSFetchDesc</name></type> <name>aocsFetchDesc</name></decl></parameter>,
				 <parameter><decl><type><name>int64</name></type> <name>rowNum</name></decl></parameter>,
				 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>colno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DatumStreamFetchDesc</name></type> 			<name>datumStreamFetchDesc</name> <init>= <expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>datumStreamFetchDesc</name><index>[<expr><name>colno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DatumStreamRead</name> 				<modifier>*</modifier></type><name>datumStream</name> <init>= <expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>datumStream</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOFetchBlockMetadata</name> 			<modifier>*</modifier></type><name>currentBlock</name> <init>= <expr><operator>&amp;</operator><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyBlockDirectoryEntry</name> 	<modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>&amp;</operator><name><name>currentBlock</name><operator>-&gt;</operator><name>blockDirectoryEntry</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>							<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>datumstreamread_find_block</name><argument_list>(<argument><expr><name>datumStream</name></expr></argument>,
									   <argument><expr><name>datumStreamFetchDesc</name></expr></argument>,
									   <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyBlockDirectoryEntry_RangeHasRow</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We fell into a hole inside the resolved block directory entry
			 * we obtained from AppendOnlyBlockDirectory_GetEntry().
			 * This should not be happening for versions &gt;= PG12. Scream
			 * appropriately. See AppendOnlyBlockDirectoryEntry for details.
			 */</comment>
			<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name><name>datumStream</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>formatVersion</name></name> <operator>&gt;=</operator> <name>AORelationVersion_PG12</name></expr></argument>,
					  <argument><expr><name>ERROR</name></expr></argument>,
					  <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					   <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"datum with row number %ld and col no %d not found in block directory entry range"</literal></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call><operator>,</operator>
					   <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"block directory entry: (fileOffset = %ld, firstRowNum = %ld, "</literal>
								 <literal type="string">"afterFileOffset = %ld, lastRowNum = %ld)"</literal></expr></argument>,
								 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>fileOffset</name></name></expr></argument>,
								 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>,
								 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>afterFileOffset</name></name></expr></argument>,
								 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>lastRowNum</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * The resolved block directory entry we obtained from
			 * AppendOnlyBlockDirectory_GetEntry() has range s.t.
			 * firstRowNum &lt; lastRowNum &lt; rowNum
			 * This can happen when rowNum maps to an aborted transaction, and
			 * we find an earlier committed block directory row due to the
			 * &lt;= scan condition in AppendOnlyBlockDirectory_GetEntry().
			 */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fetchFromCurrentBlock</name><argument_list>(<argument><expr><name>aocsFetchDesc</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>closeFetchSegmentFile</name><parameter_list>(<parameter><decl><type><name>DatumStreamFetchDesc</name></type> <name>datumStreamFetchDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>datumstreamread_close_file</name><argument_list>(<argument><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>datumStream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>openFetchSegmentFile</name><parameter_list>(<parameter><decl><type><name>AOCSFetchDesc</name></type> <name>aocsFetchDesc</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>openSegmentFileNum</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>colNo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier></type><name>fsInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segmentFileNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>logicalEof</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DatumStreamFetchDesc</name></type> <name>datumStreamFetchDesc</name> <init>= <expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>datumStreamFetchDesc</name><index>[<expr><name>colNo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>totalSegfiles</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Segment file not visible in catalog information. */</comment>

		<expr_stmt><expr><name>fsInfo</name> <operator>=</operator> <name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>segmentFileNum</name> <operator>=</operator> <name><name>fsInfo</name><operator>-&gt;</operator><name>segno</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>openSegmentFileNum</name> <operator>==</operator> <name>segmentFileNum</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Don't try to open a segment file when its EOF is 0, since the file may
	 * not exist. See MPP-8280. Also skip the segment file if it is awaiting a
	 * drop.
	 *
	 * Check for awaiting-drop first, before accessing the vpinfo, because
	 * vpinfo might not be valid on awaiting-drop segment after adding a column.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fsInfo</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>AOSEG_STATE_AWAITING_DROP</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>AOCSVPInfoEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>getAOCSVPEntry</name><argument_list>(<argument><expr><name>fsInfo</name></expr></argument>, <argument><expr><name>colNo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>logicalEof</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>eof</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>logicalEof</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>open_datumstreamread_segfile</name><argument_list>(<argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>basepath</name></name></expr></argument>, <argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>,
								 <argument><expr><name>fsInfo</name></expr></argument>,
								 <argument><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>datumStream</name></name></expr></argument>,
								 <argument><expr><name>colNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name>openSegmentFileNum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>logicalEof</name></name> <operator>=</operator> <name>logicalEof</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Note: we don't reset the block directory entry here. This is crucial, so we
 * can use the block directory entry later on. See comment in AOFetchBlockMetadata
 * FIXME: reset other fields here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>resetCurrentBlockInfo</name><parameter_list>(<parameter><decl><type><name>AOFetchBlockMetadata</name> <modifier>*</modifier></type><name>currentBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>currentBlock</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>currentBlock</name><operator>-&gt;</operator><name>firstRowNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>currentBlock</name><operator>-&gt;</operator><name>lastRowNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the fetch descriptor.
 */</comment>
<function><type><name>AOCSFetchDesc</name></type>
<name>aocs_fetch_init</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
				<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
				<parameter><decl><type><name>Snapshot</name></type> <name>appendOnlyMetaDataSnapshot</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>proj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOCSFetchDesc</name></type> <name>aocsFetchDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>basePath</name> <init>= <expr><call><name>relpathbackend</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StdRdOptions</name> <modifier>*</modifier><modifier>*</modifier></type><name>opts</name> <init>= <expr><call><name>RelationGetAttributeOptions</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * increment relation ref count while scanning relation
	 *
	 * This is just to make really sure the relcache entry won't go away while
	 * the scan has a pointer to it.  Caller should be holding the rel open
	 * anyway, so this is redundant in all normal scenarios...
	 */</comment>
	<expr_stmt><expr><call><name>RelationIncrementReferenceCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aocsFetchDesc</name> <operator>=</operator> <operator>(</operator><name>AOCSFetchDesc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AOCSFetchDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name> <operator>=</operator> <name>appendOnlyMetaDataSnapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>


	<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>initContext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segmentFileNameMaxLen</name></name> <operator>=</operator> <call><name>AOSegmentFilePathNameLen</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segmentFileName</name></name> <operator>=</operator>
		<operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segmentFileNameMaxLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segmentFileName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>basepath</name></name> <operator>=</operator> <name>basePath</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>proj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>checksum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>visimaprelid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>visimapidxid</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
                              <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segrelid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>visimaprelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visimapidxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GetAppendOnlyEntryAttributes</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>checksum</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name></name> <operator>=</operator>
		<call><name>GetAllAOCSFileSegInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>totalSegfiles</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * Initialize lastSequence only for segments which we got above is sufficient,
	 * rather than all AOTupleId_MultiplierSegmentFileNum ones that introducing
	 * too many unnecessary calls in most cases.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>lastSequence</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>lastSequence</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>totalSegfiles</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* always initailize segment 0 */</comment>
		<expr_stmt><expr><name>segno</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>segno</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* set corresponding bit for target segment */</comment>
		<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>lastSequence</name><index>[<expr><name>segno</name></expr>]</index></name> <operator>=</operator> <call><name>ReadLastSequence</name><argument_list>(<argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segrelid</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_Init_forSearch</name><argument_list>(
											<argument><expr><operator>&amp;</operator><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>,
											<argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
											<argument><expr><operator>(</operator><name>FileSegInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name></name></expr></argument>,
											<argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>totalSegfiles</name></name></expr></argument>,
											<argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
											<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
											<argument><expr><name>true</name></expr></argument>,
											<argument><expr><name>proj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>datumStreamFetchDesc</name></name> <operator>=</operator> <operator>(</operator><name>DatumStreamFetchDesc</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DatumStreamFetchDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>colno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>colno</name> <operator>&lt;</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>colno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>

		<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>datumStreamFetchDesc</name><index>[<expr><name>colno</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>proj</name><index>[<expr><name>colno</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>clvl</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>blksz</name></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>titleBuf</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We always record all the three column specific attributes for
			 * each column of a column oriented table. Note: checksum is a
			 * table level attribute.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opts</name><index>[<expr><name>colno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ct</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>colno</name></expr>]</index></name><operator>-&gt;</operator><name>compresstype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>clvl</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>colno</name></expr>]</index></name><operator>-&gt;</operator><name>compresslevel</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>blksz</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>colno</name></expr>]</index></name><operator>-&gt;</operator><name>blocksize</name></expr>;</expr_stmt>

			<comment type="block">/* UNDONE: Need to track and dispose of this storage... */</comment>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>, <argument><expr><literal type="string">"Fetch from Append-Only Column-Oriented relation '%s', column #%d '%s'"</literal></expr></argument>,
							 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>colno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>datumStreamFetchDesc</name><index>[<expr><name>colno</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>DatumStreamFetchDesc</name><operator>)</operator>
				<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DatumStreamFetchDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>datumStreamFetchDesc</name><index>[<expr><name>colno</name></expr>]</index></name><operator>-&gt;</operator><name>datumStream</name> <operator>=</operator>
				<call><name>create_datumstreamread</name><argument_list>(<argument><expr><name>ct</name></expr></argument>,
									   <argument><expr><name>clvl</name></expr></argument>,
									   <argument><expr><name>checksum</name></expr></argument>,
									    <comment type="block">/* safeFSWriteSize */</comment> <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* UNDONE:Need to wire
																		 * down pg_appendonly
																		 * column */</comment>
									   <argument><expr><name>blksz</name></expr></argument>,
									   <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name><operator>.</operator><name>data</name></name></expr></argument>,
									    <comment type="block">/* title */</comment> <argument><expr><name><name>titleBuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>opts</name><index>[<expr><name>colno</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>opts</name><index>[<expr><name>colno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>opts</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>AppendOnlyVisimap_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>,
						   <argument><expr><name>visimaprelid</name></expr></argument>,
						   <argument><expr><name>visimapidxid</name></expr></argument>,
						   <argument><expr><name>AccessShareLock</name></expr></argument>,
						   <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>aocsFetchDesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the tuple based on the given tuple id.
 *
 * If the 'slot' is not NULL, the tuple will be assigned to the slot.
 *
 * Return true if the tuple is found. Otherwise, return false.
 */</comment>
<function><type><name>bool</name></type>
<name>aocs_fetch</name><parameter_list>(<parameter><decl><type><name>AOCSFetchDesc</name></type> <name>aocsFetchDesc</name></decl></parameter>,
		   <parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>,
		   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>segmentFileNum</name> <init>= <expr><call><name>AOTupleIdGet_segmentFileNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>rowNum</name> <init>= <expr><call><name>AOTupleIdGet_rowNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name> <init>= <expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isSnapshotAny</name> <init>= <expr><operator>(</operator><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>==</operator> <name>SnapshotAny</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numCols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segmentFileNum</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>lastSequence</name><index>[<expr><name>segmentFileNum</name></expr>]</index></name> <operator>==</operator> <name>InvalidAORowNum</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Row No. %ld in segment file No. %d is out of scanning scope for target relfilenode %u."</literal></expr></argument>,
				 		<argument><expr><name>rowNum</name></expr></argument>, <argument><expr><name>segmentFileNum</name></expr></argument>, <argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * if the rowNum is bigger than lastsequence, skip it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rowNum</name> <operator>&gt;</operator> <name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>lastSequence</name><index>[<expr><name>segmentFileNum</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Go through columns one by one. Check if the current block has the
	 * requested tuple. If so, fetch it. Otherwise, read the block that
	 * contains the requested tuple.
	 */</comment>
	<for>for <control>(<init><expr><name>colno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>colno</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>colno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DatumStreamFetchDesc</name></type> <name>datumStreamFetchDesc</name> <init>= <expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>datumStreamFetchDesc</name><index>[<expr><name>colno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If this column does not need to be fetched, skip it. */</comment>
		<if_stmt><if>if <condition>(<expr><name>datumStreamFetchDesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_datumstream</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"aocs_fetch filePathName %s segno %u rowNum  "</literal> <name>INT64_FORMAT</name>
			   <literal type="string">" firstRowNum "</literal> <name>INT64_FORMAT</name> <literal type="string">" lastRowNum "</literal> <name>INT64_FORMAT</name> <literal type="string">" "</literal></expr></argument>,
			   <argument><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>datumStream</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>bufferedRead</name><operator>.</operator><name>filePathName</name></name></expr></argument>,
			   <argument><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>num</name></name></expr></argument>,
			   <argument><expr><name>rowNum</name></expr></argument>,
			   <argument><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>,
			   <argument><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>lastRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the current block has the requested tuple, read it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name> <operator>&amp;&amp;</operator>
			<name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>num</name></name> <operator>==</operator> <name>segmentFileNum</name> <operator>&amp;&amp;</operator>
			<name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>blockDirectory</name><operator>.</operator><name>currentSegmentFileNum</name></name> <operator>==</operator> <name>segmentFileNum</name> <operator>&amp;&amp;</operator>
			<name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>valid</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>rowNum</name> <operator>&gt;=</operator> <name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>firstRowNum</name></name> <operator>&amp;&amp;</operator>
				<name>rowNum</name> <operator>&lt;=</operator> <name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>lastRowNum</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSnapshotAny</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AppendOnlyVisimap_IsVisible</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>fetchFromCurrentBlock</name><argument_list>(<argument><expr><name>aocsFetchDesc</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Otherwise, fetch the right block.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyBlockDirectoryEntry_RangeHasRow</name><argument_list>(
														  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>blockDirectoryEntry</name></name><operator>)</operator></expr></argument>,
														  <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The tuple is covered by the current Block Directory entry,
				 * but is it before or after our current block?
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>rowNum</name> <operator>&lt;</operator> <name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>firstRowNum</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Set scan range to prior block
					 */</comment>
					<expr_stmt><expr><call><name>positionFirstBlockOfRange</name><argument_list>(<argument><expr><name>datumStreamFetchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>scanAfterFileOffset</name></name> <operator>=</operator>
						<name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>fileOffset</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>scanLastRowNum</name></name> <operator>=</operator>
						<name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>firstRowNum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Set scan range to following blocks.
					 */</comment>
					<expr_stmt><expr><call><name>positionSkipCurrentBlock</name><argument_list>(<argument><expr><name>datumStreamFetchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>positionLimitToEndOfRange</name><argument_list>(<argument><expr><name>datumStreamFetchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSnapshotAny</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AppendOnlyVisimap_IsVisible</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>scanToFetchValue</name><argument_list>(<argument><expr><name>aocsFetchDesc</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Open or switch open, if necessary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name> <operator>&amp;&amp;</operator>
			<name>segmentFileNum</name> <operator>!=</operator> <name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>num</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>closeFetchSegmentFile</name><argument_list>(<argument><expr><name>datumStreamFetchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>openFetchSegmentFile</name><argument_list>(<argument><expr><name>aocsFetchDesc</name></expr></argument>,
									  <argument><expr><name>segmentFileNum</name></expr></argument>,
									  <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<comment type="block">/* Segment file not in aoseg table.. */</comment>
				<comment type="block">/* Must be aborted or deleted and reclaimed. */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Reset currentBlock info */</comment>
			<expr_stmt><expr><call><name>resetCurrentBlockInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Need to get the Block Directory entry that covers the TID.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyBlockDirectory_GetEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>,
											   <argument><expr><name>aoTupleId</name></expr></argument>,
											   <argument><expr><name>colno</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>blockDirectoryEntry</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>		<comment type="block">/* Row not represented in Block Directory. */</comment>
			<comment type="block">/* Must be aborted or deleted and reclaimed. */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSnapshotAny</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AppendOnlyVisimap_IsVisible</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Set scan range covered by new Block Directory entry.
		 */</comment>
		<expr_stmt><expr><call><name>positionFirstBlockOfRange</name><argument_list>(<argument><expr><name>datumStreamFetchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>positionLimitToEndOfRange</name><argument_list>(<argument><expr><name>datumStreamFetchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>scanToFetchValue</name><argument_list>(<argument><expr><name>aocsFetchDesc</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name>colno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>ItemPointer</name><operator>)</operator><operator>(</operator><name>aoTupleId</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>aocs_fetch_finish</name><parameter_list>(<parameter><decl><type><name>AOCSFetchDesc</name></type> <name>aocsFetchDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>colno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name> <init>= <expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relation</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>colno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>colno</name> <operator>&lt;</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>colno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DatumStreamFetchDesc</name></type> <name>datumStreamFetchDesc</name> <init>= <expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>datumStreamFetchDesc</name><index>[<expr><name>colno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>datumStreamFetchDesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>datumStream</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>datumstreamread_close_file</name><argument_list>(<argument><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>datumStream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>destroy_datumstreamread</name><argument_list>(<argument><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>datumStream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>datumStreamFetchDesc</name><operator>-&gt;</operator><name>datumStream</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datumStreamFetchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>datumStreamFetchDesc</name><index>[<expr><name>colno</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>datumStreamFetchDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_End_forSearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FreeAllAOCSSegFileInfo</name><argument_list>(<argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name></name></expr></argument>, <argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>totalSegfiles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>RelationDecrementReferenceCount</name><argument_list>(<argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>segmentFileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>basepath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aocsFetchDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*
 * appendonly_delete_init
 *
 * before using appendonly_delete() to delete tuples from append-only segment
 * files, we need to call this function to initialize the delete desc
 * data structured.
 */</comment>
<function><type><name>AOCSDeleteDesc</name></type>
<name>aocs_delete_init</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Get the pg_appendonly information
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>visimaprelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>visimapidxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOCSDeleteDesc</name></type> <name>aoDeleteDesc</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AOCSDeleteDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>aod_rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name> <init>= <expr><call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
                              <argument><expr><name>snapshot</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>visimaprelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visimapidxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>,
						   <argument><expr><name>visimaprelid</name></expr></argument>,
						   <argument><expr><name>visimapidxid</name></expr></argument>,
						   <argument><expr><name>RowExclusiveLock</name></expr></argument>,
						   <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimapDelete_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>visiMapDelete</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>aoDeleteDesc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>aocs_delete_finish</name><parameter_list>(<parameter><decl><type><name>AOCSDeleteDesc</name></type> <name>aoDeleteDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aoDeleteDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimapDelete_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>visiMapDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyVisimap_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>aoDeleteDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TM_Result</name></type>
<name>aocs_delete</name><parameter_list>(<parameter><decl><type><name>AOCSDeleteDesc</name></type> <name>aoDeleteDesc</name></decl></parameter>,
			<parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aoDeleteDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_delete</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"AOCS delete tuple from table '%s' (AOTupleId %s)"</literal></expr></argument>,
		   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>aod_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>AOTupleIdToString</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(
								   <argument><expr><literal type="string">"appendonly_delete"</literal></expr></argument>,
								   <argument><expr><name>DDLNotSpecified</name></expr></argument>,
								   <argument><expr><literal type="string">""</literal></expr></argument>,	<comment type="block">/* databaseName */</comment>
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>aod_rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* tableName */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>AppendOnlyVisimapDelete_Hide</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>visiMapDelete</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a scan on varblock headers in an AOCS segfile.  The
 * segfile is identified by colno.
 */</comment>
<function><type><name>AOCSHeaderScanDesc</name></type>
<name>aocs_begin_headerscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOCSHeaderScanDesc</name></type> <name>hdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyStorageAttributes</name></type> <name>ao_attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StdRdOptions</name> <modifier>*</modifier><modifier>*</modifier></type><name>opts</name> <init>= <expr><call><name>RelationGetAttributeOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opts</name><index>[<expr><name>colno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GetAppendOnlyEntryAttributes</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name><name>ao_attr</name><operator>.</operator><name>checksum</name></name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We are concerned with varblock headers only, not their content.
	 * Therefore, don't waste cycles in decompressing the content.
	 */</comment>
	<expr_stmt><expr><name><name>ao_attr</name><operator>.</operator><name>compress</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ao_attr</name><operator>.</operator><name>compressType</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ao_attr</name><operator>.</operator><name>compressLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ao_attr</name><operator>.</operator><name>overflowSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ao_attr</name><operator>.</operator><name>safeFSWriteSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hdesc</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AOCSHeaderScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyStorageRead_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hdesc</name><operator>-&gt;</operator><name>ao_read</name></name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <comment type="line">//current memory context</comment>
							   <argument><expr><name><name>opts</name><index>[<expr><name>colno</name></expr>]</index></name><operator>-&gt;</operator><name>blocksize</name></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><literal type="string">"ALTER TABLE ADD COLUMN scan"</literal></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>ao_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdesc</name><operator>-&gt;</operator><name>colno</name></name> <operator>=</operator> <name>colno</name></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hdesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open AOCS segfile for scanning varblock headers.
 */</comment>
<function><type><name>void</name></type>
<name>aocs_headerscan_opensegfile</name><parameter_list>(<parameter><decl><type><name>AOCSHeaderScanDesc</name></type> <name>hdesc</name></decl></parameter>,
							<parameter><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier></type><name>seginfo</name></decl></parameter>,
							<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>basepath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOCSVPInfoEntry</name> <modifier>*</modifier></type><name>vpe</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fn</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fileSegNo</name></decl>;</decl_stmt>

	<comment type="block">/* Close currently open segfile, if any. */</comment>
	<expr_stmt><expr><call><name>AppendOnlyStorageRead_CloseFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hdesc</name><operator>-&gt;</operator><name>ao_read</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FormatAOSegmentFileName</name><argument_list>(<argument><expr><name>basepath</name></expr></argument>, <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>segno</name></name></expr></argument>,
							<argument><expr><name><name>hdesc</name><operator>-&gt;</operator><name>colno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileSegNo</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vpe</name> <operator>=</operator> <call><name>getAOCSVPEntry</name><argument_list>(<argument><expr><name>seginfo</name></expr></argument>, <argument><expr><name><name>hdesc</name><operator>-&gt;</operator><name>colno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyStorageRead_OpenFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hdesc</name><operator>-&gt;</operator><name>ao_read</name></name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>formatversion</name></name></expr></argument>,
								   <argument><expr><name><name>vpe</name><operator>-&gt;</operator><name>eof</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>aocs_get_nextheader</name><parameter_list>(<parameter><decl><type><name>AOCSHeaderScanDesc</name></type> <name>hdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>hdesc</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>current</name><operator>.</operator><name>firstRowNum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AppendOnlyStorageRead_SkipCurrentBlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hdesc</name><operator>-&gt;</operator><name>ao_read</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>AppendOnlyStorageRead_ReadNextBlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hdesc</name><operator>-&gt;</operator><name>ao_read</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>aocs_end_headerscan</name><parameter_list>(<parameter><decl><type><name>AOCSHeaderScanDesc</name></type> <name>hdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AppendOnlyStorageRead_CloseFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hdesc</name><operator>-&gt;</operator><name>ao_read</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyStorageRead_FinishSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hdesc</name><operator>-&gt;</operator><name>ao_read</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize one datum stream per new column for writing.
 */</comment>
<function><type><name>AOCSAddColumnDesc</name></type>
<name>aocs_addcol_init</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>num_newcols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>clvl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>blksz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOCSAddColumnDesc</name></type> <name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>iattr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>titleBuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>checksum</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AOCSAddColumnDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name> <operator>=</operator> <name>num_newcols</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>cur_segno</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Rewrite catalog phase of alter table has updated catalog with info for
	 * new columns, which is available through rel.
	 */</comment>
	<decl_stmt><decl><type><name>StdRdOptions</name> <modifier>*</modifier><modifier>*</modifier></type><name>opts</name> <init>= <expr><call><name>RelationGetAttributeOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DatumStreamWrite</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>GetAppendOnlyEntryAttributes</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>checksum</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>iattr</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <name>num_newcols</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_newcols</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>iattr</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>iattr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ADD COLUMN new segfile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opts</name><index>[<expr><name>iattr</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ct</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>iattr</name></expr>]</index></name><operator>-&gt;</operator><name>compresstype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>clvl</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>iattr</name></expr>]</index></name><operator>-&gt;</operator><name>compresslevel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blksz</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>iattr</name></expr>]</index></name><operator>-&gt;</operator><name>blocksize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>create_datumstreamwrite</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name>clvl</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>blksz</name></expr></argument> <comment type="block">/* safeFSWriteSize */</comment> ,
											   <argument><expr><name>attr</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name><name>titleBuf</name><operator>.</operator><name>data</name></name></expr></argument>,
											   <argument><expr><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>desc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create new physical segfiles for each newly added column.
 */</comment>
<function><type><name>void</name></type>
<name>aocs_addcol_newsegfile</name><parameter_list>(<parameter><decl><type><name>AOCSAddColumnDesc</name></type> <name>desc</name></decl></parameter>,
					   <parameter><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier></type><name>seginfo</name></decl></parameter>,
					   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>basepath</name></decl></parameter>,
					   <parameter><decl><type><name>RelFileNodeBackend</name></type> <name>relfilenode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fileSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fn</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>appendOnlyMetaDataSnapshot</name> <init>= <expr><call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Column numbers of newly added columns start from here. */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>colno</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>need_close_file</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>aocs_addcol_closefiles</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_End_addCol</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_Init_addCol</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>,
										 <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
										 <argument><expr><operator>(</operator><name>FileSegInfo</name> <operator>*</operator><operator>)</operator> <name>seginfo</name></expr></argument>,
										 <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>,
										 <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>segno</name></name></expr></argument>,
										 <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument> <comment type="block">/* isAOCol */</comment> )</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>colno</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>version</name></decl>;</decl_stmt>

		<comment type="block">/* Always write in the latest format */</comment>
		<expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>AORelationVersion_GetLatest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FormatAOSegmentFileName</name><argument_list>(<argument><expr><name>basepath</name></expr></argument>, <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>segno</name></name></expr></argument>, <argument><expr><name>colno</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>fileSegNo</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>datumstreamwrite_open_file</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fn</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* eof */</comment> , <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* eof_uncompressed */</comment> ,
								   <argument><expr><operator>&amp;</operator><name>relfilenode</name></expr></argument>, <argument><expr><name>fileSegNo</name></expr></argument>,
								   <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>blockFirstRowNum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>cur_segno</name></name> <operator>=</operator> <name><name>seginfo</name><operator>-&gt;</operator><name>segno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>aocs_addcol_closefiles</name><parameter_list>(<parameter><decl><type><name>AOCSAddColumnDesc</name></type> <name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>colno</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>datumstreamwrite_block</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>colno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>datumstreamwrite_close_file</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Update pg_aocsseg_* with eof of each segfile we just closed. */</comment>
	<expr_stmt><expr><call><name>AOCSFileSegInfoAddVpe</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>, <argument><expr><name>desc</name></expr></argument>,
						  <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* non-empty VPEntry */</comment> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>aocs_addcol_setfirstrownum</name><parameter_list>(<parameter><decl><type><name>AOCSAddColumnDesc</name></type> <name>desc</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
       <decl_stmt><decl><type><name>int</name></type>                     <name>i</name></decl>;</decl_stmt>
       <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
       <block>{<block_content>
               <comment type="block">/*
                * Next block's first row number.
                */</comment>
               <expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>blockFirstRowNum</name> <operator>=</operator> <name>firstRowNum</name></expr>;</expr_stmt>
       </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Force writing new varblock in each segfile open for insert.
 */</comment>
<function><type><name>void</name></type>
<name>aocs_addcol_endblock</name><parameter_list>(<parameter><decl><type><name>AOCSAddColumnDesc</name></type> <name>desc</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>colno</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>datumstreamwrite_block</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>colno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Next block's first row number.  In this case, the block being ended
		 * has less number of rows than its capacity.
		 */</comment>
		<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>blockFirstRowNum</name> <operator>=</operator> <name>firstRowNum</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Insert one new datum for each new column being added.  This is
 * derived from aocs_insert_values().
 */</comment>
<function><type><name>void</name></type>
<name>aocs_addcol_insert_datum</name><parameter_list>(<parameter><decl><type><name>AOCSAddColumnDesc</name></type> <name>desc</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>toFree1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>toFree2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>itemCount</name></decl>;</decl_stmt>

	<comment type="block">/* first column's number */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>colno</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <name><name>d</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>datumstreamwrite_put</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>toFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>toFree1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Use the de-toasted and/or de-compressed as datum instead.
			 */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>toFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We have reached max number of datums that can be accommodated
			 * in current varblock.
			 */</comment>
			<expr_stmt><expr><name>itemCount</name> <operator>=</operator> <call><name>datumstreamwrite_nth</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* write the block up to this one */</comment>
			<expr_stmt><expr><call><name>datumstreamwrite_block</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>colno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>itemCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Next block's first row number */</comment>
				<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>blockFirstRowNum</name> <operator>+=</operator> <name>itemCount</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* now write this new item to the new block */</comment>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>datumstreamwrite_put</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>toFree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>toFree2</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>datumstreamwrite_lob</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										   <argument><expr><name>datum</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>,
										   <argument><expr><name>i</name> <operator>+</operator> <name>colno</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>err</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Have written the block above with column value
				 * corresponding to a row, so now update the first row number
				 * to correctly reflect for next block.
				 */</comment>
				<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>blockFirstRowNum</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>toFree1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>toFree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>aocs_addcol_finish</name><parameter_list>(<parameter><decl><type><name>AOCSAddColumnDesc</name></type> <name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>aocs_addcol_closefiles</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_End_addCol</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>destroy_datumstreamwrite</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>dsw</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add empty VPEs (eof=0) to pg_aocsseg_* catalog, corresponding to
 * each new column being added.
 */</comment>
<function><type><name>void</name></type>
<name>aocs_addcol_emptyvpe</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					 <parameter><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>segInfos</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nseg</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>num_newcols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nseg</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name><name>segInfos</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>total_tupcount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * On QD, all tuples in pg_aocsseg_* catalog have eof=0. On QE,
			 * tuples with eof=0 may exist in pg_aocsseg_* already, caused by
			 * VACUUM.  We need to add corresponding tuples with eof=0 for
			 * each newly added column on QE.
			 */</comment>
			<expr_stmt><expr><call><name>AOCSFileSegInfoAddVpe</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>segInfos</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>segno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>num_newcols</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* empty VPEntry */</comment> )</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
