<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/aocs/aocs_compaction.c"><comment type="block">/*------------------------------------------------------------------------------
 *
 * Code dealing with the compaction of append-only tables.
 *
 * Copyright (c) 2013-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/access/aocs/aocs_compaction.c
 *
 *------------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/aosegfiles.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/aomd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/aocs_compaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonly_compaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonlywriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_fastsequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_appendonly.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbaocsam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Drops a segment file.
 *
 * Actually, we just truncate the segfile to 0 bytes, to reclaim the space.
 * Before GPDB 6, we used to remove the file, but with WAL replication, we
 * no longer have a convenient function to remove a single segment of a
 * relation. An empty file is as almost as good as a non-existent file. If
 * the relation is dropped later, the code in mdunlink() will remove all
 * segments, including any empty ones we've left behind.
 */</comment>
<function><type><name>void</name></type>
<name>AOCSCompaction_DropSegmentFile</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aorel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>col</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>filenamepath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>pseudoSegNo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>File</name></type>		<name>fd</name></decl>;</decl_stmt>

		<comment type="block">/* Open and truncate the relation segfile */</comment>
		<expr_stmt><expr><call><name>MakeAOSegmentFileName</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pseudoSegNo</name></expr></argument>, <argument><expr><name>filenamepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Drop segment file: "</literal>
			   <literal type="string">"segno %d"</literal></expr></argument>,
			   <argument><expr><name>pseudoSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenAOSegmentFile</name><argument_list>(<argument><expr><name>filenamepath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TruncateAOSegmentFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>pseudoSegNo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseAOSegmentFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * The file we were about to drop/truncate didn't exist. That's normal,
			 * for example, if a column is added with ALTER TABLE ADD COLUMN.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"could not truncate segfile %s, because it does not exist"</literal></expr></argument>, <argument><expr><name>filenamepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * AOCSSegmentFileTruncateToEOF()
 *
 * Truncates the files for all columns of logical segfile 'segno' to
 * the EOF values from 'vpinfo'. The caller is responsible for locking so
 * that a concurrent backend doesn't write to the segfile while we truncate
 * it.
 *
 * This is used to clean up space left behind by aborted or crashed
 * transactions.
 */</comment>
<function><type><name>void</name></type>
<name>AOCSSegmentFileTruncateToEOF</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aorel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>AOCSVPInfo</name> <modifier>*</modifier></type><name>vpinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>vpinfo</name><operator>-&gt;</operator><name>nEntry</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>segeof</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>filenamepath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AOCSVPInfoEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>File</name></type>		<name>fd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>fileSegNo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>vpinfo</name><operator>-&gt;</operator><name>entry</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>segeof</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>eof</name></name></expr>;</expr_stmt>

		<comment type="block">/* Open and truncate the relation segfile to its eof */</comment>
		<expr_stmt><expr><call><name>MakeAOSegmentFileName</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileSegNo</name></expr></argument>, <argument><expr><name>filenamepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Opening AO COL relation \"%s.%s\", relation id %u, relfilenode %u column #%d, logical segment #%d (physical segment file #%d, logical EOF "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
			   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>relname</name></expr></argument>,
			   <argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
			   <argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
			   <argument><expr><name>j</name></expr></argument>,
			   <argument><expr><name>segno</name></expr></argument>,
			   <argument><expr><name>fileSegNo</name></expr></argument>,
			   <argument><expr><name>segeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenAOSegmentFile</name><argument_list>(<argument><expr><name>filenamepath</name></expr></argument>, <argument><expr><name>segeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TruncateAOSegmentFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>fileSegNo</name></expr></argument>, <argument><expr><name>segeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseAOSegmentFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				   <argument><expr><literal type="string">"Successfully truncated AO COL relation \"%s.%s\", relation id %u, relfilenode %u column #%d, logical segment #%d (physical segment file #%d, logical EOF "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
				   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>relname</name></expr></argument>,
				   <argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
				   <argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
				   <argument><expr><name>j</name></expr></argument>,
				   <argument><expr><name>segno</name></expr></argument>,
				   <argument><expr><name>fileSegNo</name></expr></argument>,
				   <argument><expr><name>segeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				   <argument><expr><literal type="string">"No gp_relation_node entry for AO COL relation \"%s.%s\", relation id %u, relfilenode %u column #%d, logical segment #%d (physical segment file #%d, logical EOF "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
				   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>relname</name></expr></argument>,
				   <argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
				   <argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
				   <argument><expr><name>j</name></expr></argument>,
				   <argument><expr><name>segno</name></expr></argument>,
				   <argument><expr><name>fileSegNo</name></expr></argument>,
				   <argument><expr><name>segeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AOCSMoveTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
			  <parameter><decl><type><name>AOCSInsertDesc</name></type> <name>insertDesc</name></decl></parameter>,
			  <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
			  <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOTupleId</name>  <modifier>*</modifier></type><name>oldAoTupleId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOTupleId</name></type>	<name>newAoTupleId</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldAoTupleId</name> <operator>=</operator> <operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr>;</expr_stmt>
	<comment type="block">/* Extract all the values of the tuple */</comment>
	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>aocs_insert_values</name><argument_list>(<argument><expr><name>insertDesc</name></expr></argument>,
							  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
							  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>newAoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newAoTupleId</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* insert index' tuples if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>, <argument><expr><name>DEBUG5</name></expr></argument>,
		   <argument><expr><literal type="string">"Compaction: Moved tuple (%d,"</literal> <name>INT64_FORMAT</name> <literal type="string">") -&gt; (%d,"</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
		   <argument><expr><call><name>AOTupleIdGet_segmentFileNum</name><argument_list>(<argument><expr><name>oldAoTupleId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AOTupleIdGet_rowNum</name><argument_list>(<argument><expr><name>oldAoTupleId</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>AOTupleIdGet_segmentFileNum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newAoTupleId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AOTupleIdGet_rowNum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newAoTupleId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine of AOCSCompact().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AOCSSegmentFileFullCompaction</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aorel</name></decl></parameter>,
							  <parameter><decl><type><name>AOCSInsertDesc</name></type> <name>insertDesc</name></decl></parameter>,
							  <parameter><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier></type><name>fsinfo</name></decl></parameter>,
							  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyVisimap</name></type> <name>visiMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOCSScanDesc</name></type> <name>scanDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>compact_segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>mt_bind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>tupleCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>tuplePerPage</name> <init>= <expr><name>INT_MAX</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>insertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>compact_segno</name> <operator>=</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>segno</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fsinfo</name><operator>-&gt;</operator><name>varblockcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuplePerPage</name> <operator>=</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>total_tupcount</name></name> <operator>/</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>varblockcount</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>visiMap</name></expr></argument>,
						   <argument><expr><name><name>insertDesc</name><operator>-&gt;</operator><name>visimaprelid</name></name></expr></argument>,
						   <argument><expr><name><name>insertDesc</name><operator>-&gt;</operator><name>visimapidxid</name></name></expr></argument>,
						   <argument><expr><name>ShareLock</name></expr></argument>,
						   <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>,
		   <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Compact AO segfile %d, relation %sd"</literal></expr></argument>,
		   <argument><expr><name>compact_segno</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scanDesc</name> <operator>=</operator> <call><name>aocs_beginrangescan</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>,
								   <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>compact_segno</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>mt_bind</name> <operator>=</operator> <call><name>create_memtuple_binding</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need a ResultRelInfo and an EState so we can use the regular
	 * executor's index-entry-making machinery.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* dummy */</comment>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name> <operator>=</operator> <name>aorel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* we don't fire triggers */</comment>
	<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't want uniqueness checks to be performed while "insert"ing tuples
	 * to a destination segfile during AOCSMoveTuple(). This is to ensure that
	 * we can avoid spurious conflicts between the moved tuple and the original
	 * tuple.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>gp_bypass_unique_check</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>aocs_getnext</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
 		 * AppendOnlyVisimap_IsVisible() has already been called in aocs_getnext().
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AppendOnlyVisimap_IsVisible</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>,
										   <argument><expr><operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AOCSMoveTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
					  <argument><expr><name>insertDesc</name></expr></argument>,
					  <argument><expr><name>resultRelInfo</name></expr></argument>,
					  <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for vacuum delay point after approximatly a var block
		 */</comment>
		<expr_stmt><expr><name>tupleCount</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>VacuumCostActive</name> <operator>&amp;&amp;</operator> <name>tupleCount</name> <operator>%</operator> <name>tuplePerPage</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MarkAOCSFileSegInfoAwaitingDrop</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>compact_segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_DeleteSegmentFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>visiMap</name></expr></argument>,
										<argument><expr><name>compact_segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete all mini pages of the segment files if block directory exists */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>insertDesc</name><operator>-&gt;</operator><name>blkdirrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_DeleteSegmentFile</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>,
												   <argument><expr><name>snapshot</name></expr></argument>,
												   <argument><expr><name>compact_segno</name></expr></argument>,
												   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Finished compaction: "</literal>
		   <literal type="string">"AO segfile %d, relation %s, moved tuple count "</literal> <name>INT64_FORMAT</name></expr></argument>,
		   <argument><expr><name>compact_segno</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>tupleCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>visiMap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroy_memtuple_binding</name><argument_list>(<argument><expr><name>mt_bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>aocs_endscan</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Performs a compaction of an append-only relation in column-orientation.
 *
 * The compaction segment file should be locked for this transaction in
 * the appendonlywriter.c code.
 *
 * On exit, *insert_segno will be set to the the segment that was used as the
 * insertion target. The segfiles listed in 'avoid_segnos' will not be used
 * for insertion.
 *
 * The caller is required to hold either an AccessExclusiveLock (vacuum full)
 * or a ShareLock on the relation.
 */</comment>
<function><type><name>void</name></type>
<name>AOCSCompact</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aorel</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>compaction_segno</name></decl></parameter>,
			<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>insert_segno</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>isFull</name></decl></parameter>,
			<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>avoid_segnos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOCSInsertDesc</name></type> <name>insertDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier></type><name>fsinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>appendOnlyMetaDataSnapshot</name> <init>= <expr><call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Compact AO relation %s"</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch under the write lock to get latest committed eof. */</comment>
	<expr_stmt><expr><name>fsinfo</name> <operator>=</operator> <call><name>GetAOCSFileSegInfo</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>, <argument><expr><name>compaction_segno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyCompaction_ShouldCompact</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>,
										   <argument><expr><name>compaction_segno</name></expr></argument>, <argument><expr><name><name>fsinfo</name><operator>-&gt;</operator><name>total_tupcount</name></name></expr></argument>, <argument><expr><name>isFull</name></expr></argument>,
										   <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>insert_segno</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* get the insertion segment on first call. */</comment>
			<expr_stmt><expr><operator>*</operator><name>insert_segno</name> <operator>=</operator> <call><name>ChooseSegnoForCompactionWrite</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>avoid_segnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>insert_segno</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note: since we don't know how many rows will actually be inserted
			 * we provide the default number of rows to bump gp_fastsequence by.
			 */</comment>
			<expr_stmt><expr><name>insertDesc</name> <operator>=</operator> <call><name>aocs_insert_init</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><operator>*</operator><name>insert_segno</name></expr></argument>, <argument><expr><name>NUM_FAST_SEQUENCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AOCSSegmentFileFullCompaction</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>,
										  <argument><expr><name>insertDesc</name></expr></argument>,
										  <argument><expr><name>fsinfo</name></expr></argument>,
										  <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>insertDesc</name><operator>-&gt;</operator><name>skipModCountIncrement</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>aocs_insert_finish</name><argument_list>(<argument><expr><name>insertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* FIXME: Could not find a target segment. What now? */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fsinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
