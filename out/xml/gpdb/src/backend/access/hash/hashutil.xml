<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/hash/hashutil.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * hashutil.c
 *	  Utility code for Postgres hash implementation.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/hash/hashutil.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALC_NEW_BUCKET</name><parameter_list>(<parameter><type><name>old_bucket</name></type></parameter>, <parameter><type><name>lowmask</name></type></parameter>)</parameter_list></cpp:macro> \
			<cpp:value>old_bucket | (lowmask + 1)</cpp:value></cpp:define>

<comment type="block">/*
 * _hash_checkqual -- does the index tuple satisfy the scan conditions?
 */</comment>
<function><type><name>bool</name></type>
<name>_hash_checkqual</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Currently, we can't check any of the scan conditions since we do not
	 * have the original index entry value to supply to the sk_func. Always
	 * return true; we expect that hashgettuple already set the recheck flag
	 * to make the main indexscan code do it.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>key</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>scanKeySize</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>scanKeySize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>test</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>itup</name></expr></argument>,
							  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>,
							  <argument><expr><name>tupdesc</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* assume sk_func is strict */</comment>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
								 <argument><expr><name>datum</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>key</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>scanKeySize</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _hash_datum2hashkey -- given a Datum, call the index's hash function
 *
 * The Datum is assumed to be of the index's column type, so we can use the
 * "primary" hash function that's tracked for us by the generic index code.
 */</comment>
<function><type><name>uint32</name></type>
<name>_hash_datum2hashkey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>procinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name></decl>;</decl_stmt>

	<comment type="block">/* XXX assumes index has only one attribute */</comment>
	<expr_stmt><expr><name>procinfo</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<return>return <expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>FunctionCall1Coll</name><argument_list>(<argument><expr><name>procinfo</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _hash_datum2hashkey_type -- given a Datum of a specified type,
 *			hash it in a fashion compatible with this index
 *
 * This is much more expensive than _hash_datum2hashkey, so use it only in
 * cross-type situations.
 */</comment>
<function><type><name>uint32</name></type>
<name>_hash_datum2hashkey_type</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>keytype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>hash_proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name></decl>;</decl_stmt>

	<comment type="block">/* XXX assumes index has only one attribute */</comment>
	<expr_stmt><expr><name>hash_proc</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><name>keytype</name></expr></argument>,
								  <argument><expr><name>keytype</name></expr></argument>,
								  <argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegProcedureIsValid</name><argument_list>(<argument><expr><name>hash_proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing support function %d(%u,%u) for index \"%s\""</literal></expr></argument>,
			 <argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>, <argument><expr><name>keytype</name></expr></argument>, <argument><expr><name>keytype</name></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<return>return <expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>OidFunctionCall1Coll</name><argument_list>(<argument><expr><name>hash_proc</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _hash_hashkey2bucket -- determine which bucket the hashkey maps to.
 */</comment>
<function><type><name>Bucket</name></type>
<name>_hash_hashkey2bucket</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>hashkey</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>maxbucket</name></decl></parameter>,
					 <parameter><decl><type><name>uint32</name></type> <name>highmask</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>lowmask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bucket</name></type>		<name>bucket</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>bucket</name> <operator>=</operator> <name>hashkey</name> <operator>&amp;</operator> <name>highmask</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bucket</name> <operator>&gt;</operator> <name>maxbucket</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bucket</name> <operator>=</operator> <name>bucket</name> <operator>&amp;</operator> <name>lowmask</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>bucket</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _hash_log2 -- returns ceil(lg2(num))
 */</comment>
<function><type><name>uint32</name></type>
<name>_hash_log2</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name></decl>,
				<decl><type ref="prev"/><name>limit</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>limit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>limit</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>limit</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<empty_stmt>;</empty_stmt></block_content></block></for>
	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _hash_spareindex -- returns spare index / global splitpoint phase of the
 *					   bucket
 */</comment>
<function><type><name>uint32</name></type>
<name>_hash_spareindex</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>num_bucket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>splitpoint_group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>splitpoint_phases</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>splitpoint_group</name> <operator>=</operator> <call><name>_hash_log2</name><argument_list>(<argument><expr><name>num_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>splitpoint_group</name> <operator>&lt;</operator> <name>HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>splitpoint_group</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* account for single-phase groups */</comment>
	<expr_stmt><expr><name>splitpoint_phases</name> <operator>=</operator> <name>HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE</name></expr>;</expr_stmt>

	<comment type="block">/* account for multi-phase groups before splitpoint_group */</comment>
	<expr_stmt><expr><name>splitpoint_phases</name> <operator>+=</operator>
		<operator>(</operator><operator>(</operator><name>splitpoint_group</name> <operator>-</operator> <name>HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE</name><operator>)</operator> <operator>&lt;&lt;</operator>
		 <name>HASH_SPLITPOINT_PHASE_BITS</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* account for phases within current group */</comment>
	<expr_stmt><expr><name>splitpoint_phases</name> <operator>+=</operator>
		<operator>(</operator><operator>(</operator><operator>(</operator><name>num_bucket</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator>
		  <operator>(</operator><name>splitpoint_group</name> <operator>-</operator> <operator>(</operator><name>HASH_SPLITPOINT_PHASE_BITS</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;</operator>
		 <name>HASH_SPLITPOINT_PHASE_MASK</name><operator>)</operator></expr>;</expr_stmt>	<comment type="block">/* to 0-based value. */</comment>

	<return>return <expr><name>splitpoint_phases</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_hash_get_totalbuckets -- returns total number of buckets allocated till
 *							the given splitpoint phase.
 */</comment>
<function><type><name>uint32</name></type>
<name>_hash_get_totalbuckets</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>splitpoint_phase</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>splitpoint_group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>total_buckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>phases_within_splitpoint_group</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>splitpoint_phase</name> <operator>&lt;</operator> <name>HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>splitpoint_phase</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* get splitpoint's group */</comment>
	<expr_stmt><expr><name>splitpoint_group</name> <operator>=</operator> <name>HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>splitpoint_group</name> <operator>+=</operator>
		<operator>(</operator><operator>(</operator><name>splitpoint_phase</name> <operator>-</operator> <name>HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE</name><operator>)</operator> <operator>&gt;&gt;</operator>
		 <name>HASH_SPLITPOINT_PHASE_BITS</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* account for buckets before splitpoint_group */</comment>
	<expr_stmt><expr><name>total_buckets</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>splitpoint_group</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* account for buckets within splitpoint_group */</comment>
	<expr_stmt><expr><name>phases_within_splitpoint_group</name> <operator>=</operator>
		<operator>(</operator><operator>(</operator><operator>(</operator><name>splitpoint_phase</name> <operator>-</operator> <name>HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE</name><operator>)</operator> <operator>&amp;</operator>
		  <name>HASH_SPLITPOINT_PHASE_MASK</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* from 0-based to 1-based */</comment>
	<expr_stmt><expr><name>total_buckets</name> <operator>+=</operator>
		<operator>(</operator><operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>splitpoint_group</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <name>HASH_SPLITPOINT_PHASE_BITS</name><operator>)</operator> <operator>*</operator>
		 <name>phases_within_splitpoint_group</name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>total_buckets</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _hash_checkpage -- sanity checks on the format of all hash pages
 *
 * If flags is not zero, it is a bitwise OR of the acceptable page types
 * (values of hasho_flag &amp; LH_PAGE_TYPE).
 */</comment>
<function><type><name>void</name></type>
<name>_hash_checkpage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * ReadBuffer verifies that every newly-read page passes
	 * PageHeaderIsValid, which means it either contains a reasonably sane
	 * page header or is all-zero.  We have to defend against the all-zero
	 * case, however.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" contains unexpected zero page at block %u"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please REINDEX it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Additionally check that the special area looks sane.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageGetSpecialSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashPageOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" contains corrupted page at block %u"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please REINDEX it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>opaque</name> <init>= <expr><operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>opaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>&amp;</operator> <name>flags</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" contains corrupted page at block %u"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please REINDEX it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When checking the metapage, also verify magic number and version.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <name>LH_META_PAGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name> <init>= <expr><call><name>HashPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_magic</name></name> <operator>!=</operator> <name>HASH_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" is not a hash index"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_version</name></name> <operator>!=</operator> <name>HASH_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" has wrong hash version"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please REINDEX it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>hashoptions</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>default_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>validate</name></expr></argument>, <argument><expr><name>RELOPT_KIND_HASH</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _hash_get_indextuple_hashkey - get the hash index tuple's hash key value
 */</comment>
<function><type><name>uint32</name></type>
<name>_hash_get_indextuple_hashkey</name><parameter_list>(<parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We assume the hash key is the first attribute and can't be null, so
	 * this can be done crudely but very very cheaply ...
	 */</comment>
	<expr_stmt><expr><name>attp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>itup</name> <operator>+</operator> <call><name>IndexInfoFindDataOffset</name><argument_list>(<argument><expr><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>attp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _hash_convert_tuple - convert raw index data to hash key
 *
 * Inputs: values and isnull arrays for the user data column(s)
 * Outputs: values and isnull arrays for the index tuple, suitable for
 *		passing to index_form_tuple().
 *
 * Returns true if successful, false if not (because there are null values).
 * On a false result, the given data need not be indexed.
 *
 * Note: callers know that the index-column arrays are always of length 1.
 * In principle, there could be more than one input column, though we do not
 * currently support that.
 */</comment>
<function><type><name>bool</name></type>
<name>_hash_convert_tuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
					<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>user_values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>user_isnull</name></decl></parameter>,
					<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>index_values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>index_isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashkey</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We do not insert null values into hash indexes.  This is okay because
	 * the only supported search operator is '=', and we assume it is strict.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>user_isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hashkey</name> <operator>=</operator> <call><name>_hash_datum2hashkey</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>user_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>hashkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index_isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _hash_binsearch - Return the offset number in the page where the
 *					 specified hash value should be sought or inserted.
 *
 * We use binary search, relying on the assumption that the existing entries
 * are ordered by hash key.
 *
 * Returns the offset of the first index entry having hashkey &gt;= hash_value,
 * or the page's max offset plus one if hash_value is greater than all
 * existing hash keys in the page.  This is the appropriate place to start
 * a search, or to insert a new item.
 */</comment>
<function><type><name>OffsetNumber</name></type>
<name>_hash_binsearch</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hash_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>lower</name></decl>;</decl_stmt>

	<comment type="block">/* Loop invariant: lower &lt;= desired place &lt;= upper */</comment>
	<expr_stmt><expr><name>upper</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>lower</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>upper</name> <operator>&gt;</operator> <name>lower</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>hashkey</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <operator>(</operator><name>upper</name> <operator>+</operator> <name>lower</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hashkey</name> <operator>=</operator> <call><name>_hash_get_indextuple_hashkey</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hashkey</name> <operator>&lt;</operator> <name>hash_value</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lower</name> <operator>=</operator> <name>off</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>upper</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>lower</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _hash_binsearch_last
 *
 * Same as above, except that if there are multiple matching items in the
 * page, we return the offset of the last one instead of the first one,
 * and the possible range of outputs is 0..maxoffset not 1..maxoffset+1.
 * This is handy for starting a new page in a backwards scan.
 */</comment>
<function><type><name>OffsetNumber</name></type>
<name>_hash_binsearch_last</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hash_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>lower</name></decl>;</decl_stmt>

	<comment type="block">/* Loop invariant: lower &lt;= desired place &lt;= upper */</comment>
	<expr_stmt><expr><name>upper</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lower</name> <operator>=</operator> <name>FirstOffsetNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>upper</name> <operator>&gt;</operator> <name>lower</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>hashkey</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>off</name> <operator>=</operator> <operator>(</operator><name>upper</name> <operator>+</operator> <name>lower</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hashkey</name> <operator>=</operator> <call><name>_hash_get_indextuple_hashkey</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hashkey</name> <operator>&gt;</operator> <name>hash_value</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>upper</name> <operator>=</operator> <name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>lower</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>lower</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_hash_get_oldblock_from_newbucket() -- get the block number of a bucket
 *			from which current (new) bucket is being split.
 */</comment>
<function><type><name>BlockNumber</name></type>
<name>_hash_get_oldblock_from_newbucket</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Bucket</name></type> <name>new_bucket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bucket</name></type>		<name>old_bucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * To get the old bucket from the current bucket, we need a mask to modulo
	 * into lower half of table.  This mask is stored in meta page as
	 * hashm_lowmask, but here we can't rely on the same, because we need a
	 * value of lowmask that was prevalent at the time when bucket split was
	 * started.  Masking the most significant bit of new bucket would give us
	 * old bucket.
	 */</comment>
	<expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint32</name><operator>)</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><call><name>fls</name><argument_list>(<argument><expr><name>new_bucket</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_bucket</name> <operator>=</operator> <name>new_bucket</name> <operator>&amp;</operator> <name>mask</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>HASH_METAPAGE</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>, <argument><expr><name>LH_META_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>BUCKET_TO_BLKNO</name><argument_list>(<argument><expr><name>metap</name></expr></argument>, <argument><expr><name>old_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>blkno</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_hash_get_newblock_from_oldbucket() -- get the block number of a bucket
 *			that will be generated after split from old bucket.
 *
 * This is used to find the new bucket from old bucket based on current table
 * half.  It is mainly required to finish the incomplete splits where we are
 * sure that not more than one bucket could have split in progress from old
 * bucket.
 */</comment>
<function><type><name>BlockNumber</name></type>
<name>_hash_get_newblock_from_oldbucket</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Bucket</name></type> <name>old_bucket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bucket</name></type>		<name>new_bucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>HASH_METAPAGE</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>, <argument><expr><name>LH_META_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_bucket</name> <operator>=</operator> <call><name>_hash_get_newbucket_from_oldbucket</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>old_bucket</name></expr></argument>,
													<argument><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_lowmask</name></name></expr></argument>,
													<argument><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>BUCKET_TO_BLKNO</name><argument_list>(<argument><expr><name>metap</name></expr></argument>, <argument><expr><name>new_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>blkno</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_hash_get_newbucket_from_oldbucket() -- get the new bucket that will be
 *			generated after split from current (old) bucket.
 *
 * This is used to find the new bucket from old bucket.  New bucket can be
 * obtained by OR'ing old bucket with most significant bit of current table
 * half (lowmask passed in this function can be used to identify msb of
 * current table half).  There could be multiple buckets that could have
 * been split from current bucket.  We need the first such bucket that exists.
 * Caller must ensure that no more than one split has happened from old
 * bucket.
 */</comment>
<function><type><name>Bucket</name></type>
<name>_hash_get_newbucket_from_oldbucket</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Bucket</name></type> <name>old_bucket</name></decl></parameter>,
								   <parameter><decl><type><name>uint32</name></type> <name>lowmask</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>maxbucket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bucket</name></type>		<name>new_bucket</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>new_bucket</name> <operator>=</operator> <call><name>CALC_NEW_BUCKET</name><argument_list>(<argument><expr><name>old_bucket</name></expr></argument>, <argument><expr><name>lowmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>new_bucket</name> <operator>&gt;</operator> <name>maxbucket</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lowmask</name> <operator>=</operator> <name>lowmask</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_bucket</name> <operator>=</operator> <call><name>CALC_NEW_BUCKET</name><argument_list>(<argument><expr><name>old_bucket</name></expr></argument>, <argument><expr><name>lowmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>new_bucket</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _hash_kill_items - set LP_DEAD state for items an indexscan caller has
 * told us were killed.
 *
 * scan-&gt;opaque, referenced locally through so, contains information about the
 * current page and killed tuples thereon (generally, this should only be
 * called if so-&gt;numKilled &gt; 0).
 *
 * The caller does not have a lock on the page and may or may not have the
 * page pinned in a buffer.  Note that read-lock is sufficient for setting
 * LP_DEAD status (which is only a hint).
 *
 * The caller must have pin on bucket buffer, but may or may not have pin
 * on overflow buffer, as indicated by HashScanPosIsPinned(so-&gt;currPos).
 *
 * We match items by heap TID before assuming they are the right ones to
 * delete.
 *
 * There are never any scans active in a bucket at the time VACUUM begins,
 * because VACUUM takes a cleanup lock on the primary bucket page and scans
 * hold a pin.  A scan can begin after VACUUM leaves the primary bucket page
 * but before it finishes the entire bucket, but it can never pass VACUUM,
 * because VACUUM always locks the next page before releasing the lock on
 * the previous one.  Therefore, we don't have to worry about accidentally
 * killing a TID that has been reused for an unrelated tuple.
 */</comment>
<function><type><name>void</name></type>
<name>_hash_kill_items</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HashScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>HashScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numKilled</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>killedsomething</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>havePin</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>killedItems</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HashScanPosIsValid</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Always reset the scan state, so we don't look for same items on other
	 * pages.
	 */</comment>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>currPage</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HashScanPosIsPinned</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We already have pin on this buffer, so, all we need to do is
		 * acquire lock on it.
		 */</comment>
		<expr_stmt><expr><name>havePin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>HASH_READ</name></expr></argument>, <argument><expr><name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numKilled</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>itemIndex</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>killedItems</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HashScanPosItem</name> <modifier>*</modifier></type><name>currItem</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>items</name><index>[<expr><name>itemIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>currItem</name><operator>-&gt;</operator><name>indexOffset</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>&gt;=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>firstItem</name></name> <operator>&amp;&amp;</operator>
			   <name>itemIndex</name> <operator>&lt;=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lastItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>ituple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ituple</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>currItem</name><operator>-&gt;</operator><name>heapTid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* found the item */</comment>
				<expr_stmt><expr><call><name>ItemIdMarkDead</name><argument_list>(<argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>killedsomething</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>			<comment type="block">/* out of inner search loop */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Since this can be redone later if needed, mark as dirty hint. Whenever
	 * we mark anything LP_DEAD, we also set the page's
	 * LH_PAGE_HAS_DEAD_TUPLES flag, which is likewise just a hint.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>killedsomething</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>|=</operator> <name>LH_PAGE_HAS_DEAD_TUPLES</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirtyHint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>hashso_bucket_buf</name></name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>||</operator>
		<name>havePin</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
