<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/nbtree/nbtsort.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nbtsort.c
 *		Build a btree from sorted input by loading leaf pages sequentially.
 *
 * NOTES
 *
 * We use tuplesort.c to sort the given index tuples into order.
 * Then we scan the index tuples in order and build the btree pages
 * for each level.  We load source tuples into leaf-level pages.
 * Whenever we fill a page at one level, we add a link to it to its
 * parent level (starting a new parent level if necessary).  When
 * done, we write out each final page on each level, adding it to
 * its parent level.  When we have only one page on a level, it must be
 * the root -- it can be attached to the btree metapage and we are done.
 *
 * It is not wise to pack the pages entirely full, since then *any*
 * insertion would cause a split (and not only of the leaf page; the need
 * for a split would cascade right up the tree).  The steady-state load
 * factor for btrees is usually estimated at 70%.  We choose to pack leaf
 * pages to the user-controllable fill factor (default 90%) while upper pages
 * are always packed to 70%.  This gives us reasonable density (there aren't
 * many upper pages if the keys are reasonable-size) without risking a lot of
 * cascading splits during early insertions.
 *
 * Formerly the index pages being built were kept in shared buffers, but
 * that is of no value (since other backends have no interest in them yet)
 * and it created locking problems for CHECKPOINT, because the upper-level
 * pages were held exclusive-locked for long periods.  Now we just build
 * the pages in local memory and smgrwrite or smgrextend them as we finish
 * them.  They will need to be re-read into shared buffers on first use after
 * the build finishes.
 *
 * Since the index will never be used unless it is completely built,
 * from a crash-recovery point of view there is no need to WAL-log the
 * steps of the build.  After completing the index build, we can just sync
 * the whole file to disk using smgrimmedsync() before exiting this module.
 * This can be seen to be sufficient for crash recovery by considering that
 * it's effectively equivalent to what would happen if a CHECKPOINT occurred
 * just after the index build.  However, it is clearly not sufficient if the
 * DBA is using the WAL log for PITR or replication purposes, since another
 * machine would not be able to reconstruct the index from WAL.  Therefore,
 * we log the completed index pages to WAL if and only if WAL archiving is
 * active.
 *
 * This code isn't concerned about the FSM at all. The caller is responsible
 * for initializing that.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/access/nbtree/nbtsort.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>		<comment type="block">/* pgrminclude ignore */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sortsupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>


<comment type="block">/* Magic numbers for parallel state sharing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_BTREE_SHARED</name></cpp:macro>		<cpp:value>UINT64CONST(0xA000000000000001)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_TUPLESORT</name></cpp:macro>			<cpp:value>UINT64CONST(0xA000000000000002)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_TUPLESORT_SPOOL2</name></cpp:macro>	<cpp:value>UINT64CONST(0xA000000000000003)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_QUERY_TEXT</name></cpp:macro>			<cpp:value>UINT64CONST(0xA000000000000004)</cpp:value></cpp:define>

<comment type="block">/*
 * DISABLE_LEADER_PARTICIPATION disables the leader's participation in
 * parallel index builds.  This may be useful as a debugging aid.
#undef DISABLE_LEADER_PARTICIPATION
 */</comment>

<comment type="block">/*
 * Status record for spooling/sorting phase.  (Note we may have two of
 * these due to the special requirements for uniqueness-checking with
 * dead tuples.)
 */</comment>
<typedef>typedef <type><struct>struct <name>BTSpool</name>
<block>{
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>sortstate</name></decl>;</decl_stmt>	<comment type="block">/* state data for tuplesort.c */</comment>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isunique</name></decl>;</decl_stmt>
}</block></struct></type> <name>BTSpool</name>;</typedef>

<comment type="block">/*
 * Status for index builds performed in parallel.  This is allocated in a
 * dynamic shared memory segment.  Note that there is a separate tuplesort TOC
 * entry, private to tuplesort.c but allocated by this module on its behalf.
 */</comment>
<typedef>typedef <type><struct>struct <name>BTShared</name>
<block>{
	<comment type="block">/*
	 * These fields are not modified during the sort.  They primarily exist
	 * for the benefit of worker processes that need to create BTSpool state
	 * corresponding to that used by the leader.
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heaprelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isunique</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isconcurrent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>scantuplesortstates</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * workersdonecv is used to monitor the progress of workers.  All parallel
	 * participants must indicate that they are done before leader can use
	 * mutable state that workers maintain during scan (and before leader can
	 * proceed to tuplesort_performsort()).
	 */</comment>
	<decl_stmt><decl><type><name>ConditionVariable</name></type> <name>workersdonecv</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * mutex protects all fields before heapdesc.
	 *
	 * These fields contain status information of interest to B-Tree index
	 * builds that must work just the same when an index is built in parallel.
	 */</comment>
	<decl_stmt><decl><type><name>slock_t</name></type>		<name>mutex</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Mutable state that is maintained by workers, and reported back to
	 * leader at end of parallel scan.
	 *
	 * nparticipantsdone is number of worker processes finished.
	 *
	 * reltuples is the total number of input heap tuples.
	 *
	 * havedead indicates if RECENTLY_DEAD tuples were encountered during
	 * build.
	 *
	 * indtuples is the total number of tuples that made it into the index.
	 *
	 * brokenhotchain indicates if any worker detected a broken HOT chain
	 * during build.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nparticipantsdone</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>havedead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>indtuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>brokenhotchain</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * ParallelTableScanDescData data follows. Can't directly embed here, as
	 * implementations of the parallel table scan desc interface might need
	 * stronger alignment.
	 */</comment>
}</block></struct></type> <name>BTShared</name>;</typedef>

<comment type="block">/*
 * Return pointer to a BTShared's parallel table scan.
 *
 * c.f. shm_toc_allocate as to why BUFFERALIGN is used, rather than just
 * MAXALIGN.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ParallelTableScanFromBTShared</name><parameter_list>(<parameter><type><name>shared</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(ParallelTableScanDesc) ((char *) (shared) + BUFFERALIGN(sizeof(BTShared)))</cpp:value></cpp:define>

<comment type="block">/*
 * Status for leader in parallel index build.
 */</comment>
<typedef>typedef <type><struct>struct <name>BTLeader</name>
<block>{
	<comment type="block">/* parallel context itself */</comment>
	<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * nparticipanttuplesorts is the exact number of worker processes
	 * successfully launched, plus one leader process if it participates as a
	 * worker (only DISABLE_LEADER_PARTICIPATION builds avoid leader
	 * participating as a worker).
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nparticipanttuplesorts</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Leader process convenience pointers to shared state (leader avoids TOC
	 * lookups).
	 *
	 * btshared is the shared state for entire build.  sharedsort is the
	 * shared, tuplesort-managed state passed to each process tuplesort.
	 * sharedsort2 is the corresponding btspool2 shared state, used only when
	 * building unique indexes.  snapshot is the snapshot used by the scan iff
	 * an MVCC snapshot is required.
	 */</comment>
	<decl_stmt><decl><type><name>BTShared</name>   <modifier>*</modifier></type><name>btshared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>sharedsort</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>sharedsort2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
}</block></struct></type> <name>BTLeader</name>;</typedef>

<comment type="block">/*
 * Working state for btbuild and its callback.
 *
 * When parallel CREATE INDEX is used, there is a BTBuildState for each
 * participant.
 */</comment>
<typedef>typedef <type><struct>struct <name>BTBuildState</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>isunique</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>havedead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTSpool</name>    <modifier>*</modifier></type><name>spool</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * spool2 is needed only when the index is a unique index. Dead tuples are
	 * put into spool2 instead of spool in order to avoid uniqueness check.
	 */</comment>
	<decl_stmt><decl><type><name>BTSpool</name>    <modifier>*</modifier></type><name>spool2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>indtuples</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * btleader is only present when a parallel index build is performed, and
	 * only in the leader process. (Actually, only the leader has a
	 * BTBuildState.  Workers have their own spool and spool2, though.)
	 */</comment>
	<decl_stmt><decl><type><name>BTLeader</name>   <modifier>*</modifier></type><name>btleader</name></decl>;</decl_stmt>
}</block></struct></type> <name>BTBuildState</name>;</typedef>

<comment type="block">/*
 * Status record for a btree page being built.  We have one of these
 * for each active tree level.
 *
 * The reason we need to store a copy of the minimum key is that we'll
 * need to propagate it to the parent node when this page is linked
 * into its parent.  However, if the page is not a leaf page, the first
 * entry on the page doesn't need to contain a key, so we will not have
 * stored the key itself on the page.  (You might think we could skip
 * copying the minimum key on leaf pages, but actually we must have a
 * writable copy anyway because we'll poke the page's address into it
 * before passing it up to the parent...)
 */</comment>
<typedef>typedef <type><struct>struct <name>BTPageState</name>
<block>{
	<decl_stmt><decl><type><name>Page</name></type>		<name>btps_page</name></decl>;</decl_stmt>		<comment type="block">/* workspace for page building */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>btps_blkno</name></decl>;</decl_stmt>		<comment type="block">/* block # to write this page at */</comment>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>btps_minkey</name></decl>;</decl_stmt>	<comment type="block">/* copy of minimum key (first item) on page */</comment>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>btps_lastoff</name></decl>;</decl_stmt>	<comment type="block">/* last item offset loaded */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>btps_level</name></decl>;</decl_stmt>		<comment type="block">/* tree level (0 = leaf) */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>btps_full</name></decl>;</decl_stmt>		<comment type="block">/* "full" if less than this much free space */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>BTPageState</name></name> <modifier>*</modifier></type><name>btps_next</name></decl>;</decl_stmt>	<comment type="block">/* link to parent level, if any */</comment>
}</block></struct></type> <name>BTPageState</name>;</typedef>

<comment type="block">/*
 * Overall status record for index writing phase.
 */</comment>
<typedef>typedef <type><struct>struct <name>BTWriteState</name>
<block>{
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTScanInsert</name></type> <name>inskey</name></decl>;</decl_stmt>		<comment type="block">/* generic insertion scankey */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>btws_use_wal</name></decl>;</decl_stmt>	<comment type="block">/* dump pages to WAL? */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>btws_pages_alloced</name></decl>;</decl_stmt> <comment type="block">/* # pages allocated */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>btws_pages_written</name></decl>;</decl_stmt> <comment type="block">/* # pages written out */</comment>
	<decl_stmt><decl><type><name>Page</name></type>		<name>btws_zeropage</name></decl>;</decl_stmt>	<comment type="block">/* workspace for filling zeroes */</comment>
}</block></struct></type> <name>BTWriteState</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>_bt_spools_heapscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
								  <parameter><decl><type><name>BTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_spooldestroy</name><parameter_list>(<parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_spool</name><parameter_list>(<parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>self</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_leafbuild</name><parameter_list>(<parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>, <parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_build_callback</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tupleId</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tupleIsAlive</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Page</name></type> <name>_bt_blnewpage</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BTPageState</name> <modifier>*</modifier></type><name>_bt_pagestate</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_slideleft</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_sortaddtup</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>itemsize</name></decl></parameter>,
						   <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>itup_off</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_buildadd</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						 <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_uppershutdown</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_load</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>,
					 <parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>, <parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_begin_parallel</name><parameter_list>(<parameter><decl><type><name>BTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isconcurrent</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>request</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_end_parallel</name><parameter_list>(<parameter><decl><type><name>BTLeader</name> <modifier>*</modifier></type><name>btleader</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>_bt_parallel_estimate_shared</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>_bt_parallel_heapscan</name><parameter_list>(<parameter><decl><type><name>BTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>,
									<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>brokenhotchain</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_leader_participate_as_worker</name><parameter_list>(<parameter><decl><type><name>BTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_parallel_scan_and_sort</name><parameter_list>(<parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>, <parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool2</name></decl></parameter>,
									   <parameter><decl><type><name>BTShared</name> <modifier>*</modifier></type><name>btshared</name></decl></parameter>, <parameter><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>sharedsort</name></decl></parameter>,
									   <parameter><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>sharedsort2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sortmem</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>progress</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	btbuild() -- build a new btree index.
 */</comment>
<function><type><name>IndexBuildResult</name> <modifier>*</modifier></type>
<name>btbuild</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexBuildResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTBuildState</name></type> <name>buildstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BTREE_BUILD_STATS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>log_btree_build_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* BTREE_BUILD_STATS */</comment>

	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>isunique</name></name> <operator>=</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>havedead</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>heap</name></name> <operator>=</operator> <name>heap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>spool</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>spool2</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>indtuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>btleader</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We expect to be called exactly once for any index relation. If that's
	 * not the case, big trouble's what we have.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index \"%s\" already contains data"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <call><name>_bt_spools_heapscan</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buildstate</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finish the build by (1) completing the sort of the spool file, (2)
	 * inserting the sorted tuples into btree pages and (3) building the upper
	 * levels.  Finally, it may also be necessary to end use of parallelism.
	 */</comment>
	<expr_stmt><expr><call><name>_bt_leafbuild</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>spool</name></name></expr></argument>, <argument><expr><name><name>buildstate</name><operator>.</operator><name>spool2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bt_spooldestroy</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>spool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>buildstate</name><operator>.</operator><name>spool2</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_spooldestroy</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>spool2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>buildstate</name><operator>.</operator><name>btleader</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_end_parallel</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>btleader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>IndexBuildResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBuildResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>heap_tuples</name></name> <operator>=</operator> <name>reltuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>index_tuples</name></name> <operator>=</operator> <name><name>buildstate</name><operator>.</operator><name>indtuples</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BTREE_BUILD_STATS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>log_btree_build_stats</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"BTREE BUILD STATS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* BTREE_BUILD_STATS */</comment>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create and initialize one or two spool structures, and save them in caller's
 * buildstate argument.  May also fill-in fields within indexInfo used by index
 * builds.
 *
 * Scans the heap, possibly in parallel, filling spools with IndexTuples.  This
 * routine encapsulates all aspects of managing parallelism.  Caller need only
 * call _bt_end_parallel() in parallel case after it is done with spool/spool2.
 *
 * Returns the total number of heap tuples scanned.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>_bt_spools_heapscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>BTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>,
					<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTSpool</name>    <modifier>*</modifier></type><name>btspool</name> <init>= <expr><operator>(</operator><name>BTSpool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTSpool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortCoordinate</name></type> <name>coordinate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We size the sort area as maintenance_work_mem rather than work_mem to
	 * speed index creation.  This should be OK since a single backend can't
	 * run multiple index creations in parallel (see also: notes on
	 * parallelism and maintenance_work_mem below).
	 */</comment>
	<expr_stmt><expr><name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name> <operator>=</operator> <name>heap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btspool</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btspool</name><operator>-&gt;</operator><name>isunique</name></name> <operator>=</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr>;</expr_stmt>

	<comment type="block">/* Save as primary spool */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>spool</name></name> <operator>=</operator> <name>btspool</name></expr>;</expr_stmt>

	<comment type="block">/* Report table scan phase started */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_SUBPHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_BTREE_PHASE_INDEXBUILD_TABLESCAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Attempt to launch parallel worker scan when required */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ParallelWorkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_begin_parallel</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name></expr></argument>,
						   <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If parallel build requested and at least one worker process was
	 * successfully launched, set up coordination state
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buildstate</name><operator>-&gt;</operator><name>btleader</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>coordinate</name> <operator>=</operator> <operator>(</operator><name>SortCoordinate</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SortCoordinateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coordinate</name><operator>-&gt;</operator><name>isWorker</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coordinate</name><operator>-&gt;</operator><name>nParticipants</name></name> <operator>=</operator>
			<name><name>buildstate</name><operator>-&gt;</operator><name>btleader</name><operator>-&gt;</operator><name>nparticipanttuplesorts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coordinate</name><operator>-&gt;</operator><name>sharedsort</name></name> <operator>=</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>btleader</name><operator>-&gt;</operator><name>sharedsort</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Begin serial/leader tuplesort.
	 *
	 * In cases where parallelism is involved, the leader receives the same
	 * share of maintenance_work_mem as a serial sort (it is generally treated
	 * in the same way as a serial sort once we return).  Parallel worker
	 * Tuplesortstates will have received only a fraction of
	 * maintenance_work_mem, though.
	 *
	 * We rely on the lifetime of the Leader Tuplesortstate almost not
	 * overlapping with any worker Tuplesortstate's lifetime.  There may be
	 * some small overlap, but that's okay because we rely on leader
	 * Tuplesortstate only allocating a small, fixed amount of memory here.
	 * When its tuplesort_performsort() is called (by our caller), and
	 * significant amounts of memory are likely to be used, all workers must
	 * have already freed almost all memory held by their Tuplesortstates
	 * (they are about to go away completely, too).  The overall effect is
	 * that maintenance_work_mem always represents an absolute high watermark
	 * on the amount of memory used by a CREATE INDEX operation, regardless of
	 * the use of parallelism or any other factor.
	 */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>spool</name><operator>-&gt;</operator><name>sortstate</name></name> <operator>=</operator>
		<call><name>tuplesort_begin_index_btree</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>isunique</name></name></expr></argument>,
									<argument><expr><name>maintenance_work_mem</name></expr></argument>, <argument><expr><name>coordinate</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If building a unique index, put dead tuples in a second spool to keep
	 * them out of the uniqueness check.  We expect that the second spool (for
	 * dead tuples) won't get very full, so we give it only work_mem.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTSpool</name>    <modifier>*</modifier></type><name>btspool2</name> <init>= <expr><operator>(</operator><name>BTSpool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTSpool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SortCoordinate</name></type> <name>coordinate2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Initialize secondary spool */</comment>
		<expr_stmt><expr><name><name>btspool2</name><operator>-&gt;</operator><name>heap</name></name> <operator>=</operator> <name>heap</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>btspool2</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>btspool2</name><operator>-&gt;</operator><name>isunique</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<comment type="block">/* Save as secondary spool */</comment>
		<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>spool2</name></name> <operator>=</operator> <name>btspool2</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>buildstate</name><operator>-&gt;</operator><name>btleader</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Set up non-private state that is passed to
			 * tuplesort_begin_index_btree() about the basic high level
			 * coordination of a parallel sort.
			 */</comment>
			<expr_stmt><expr><name>coordinate2</name> <operator>=</operator> <operator>(</operator><name>SortCoordinate</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SortCoordinateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coordinate2</name><operator>-&gt;</operator><name>isWorker</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coordinate2</name><operator>-&gt;</operator><name>nParticipants</name></name> <operator>=</operator>
				<name><name>buildstate</name><operator>-&gt;</operator><name>btleader</name><operator>-&gt;</operator><name>nparticipanttuplesorts</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coordinate2</name><operator>-&gt;</operator><name>sharedsort</name></name> <operator>=</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>btleader</name><operator>-&gt;</operator><name>sharedsort2</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We expect that the second one (for dead tuples) won't get very
		 * full, so we give it only work_mem
		 */</comment>
		<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>spool2</name><operator>-&gt;</operator><name>sortstate</name></name> <operator>=</operator>
			<call><name>tuplesort_begin_index_btree</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>,
										<argument><expr><name>coordinate2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fill spool using either serial or parallel heap scan */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>buildstate</name><operator>-&gt;</operator><name>btleader</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <call><name>table_index_build_scan</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										   <argument><expr><name>_bt_build_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>buildstate</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <call><name>_bt_parallel_heapscan</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Set the progress target for the next phase.  Reset the block number
	 * values set by table_index_build_scan
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name><name>index</name><index>[]</index></name> <init>= <expr><block>{
			<expr><name>PROGRESS_CREATEIDX_TUPLES_TOTAL</name></expr>,
			<expr><name>PROGRESS_SCAN_BLOCKS_TOTAL</name></expr>,
			<expr><name>PROGRESS_SCAN_BLOCKS_DONE</name></expr>
		}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int64</name></type> <name><name>val</name><index>[]</index></name> <init>= <expr><block>{
			<expr><name><name>buildstate</name><operator>-&gt;</operator><name>indtuples</name></name></expr>,
			<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>
		}</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pgstat_progress_update_multi_param</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* okay, all heap tuples are spooled */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buildstate</name><operator>-&gt;</operator><name>spool2</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>buildstate</name><operator>-&gt;</operator><name>havedead</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* spool2 turns out to be unnecessary */</comment>
		<expr_stmt><expr><call><name>_bt_spooldestroy</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>spool2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>spool2</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>reltuples</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * clean up a spool structure and its substructures.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_spooldestroy</name><parameter_list>(<parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>btspool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * spool an index entry into the sort file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_spool</name><parameter_list>(<parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tuplesort_putindextuplevalues</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,
								  <argument><expr><name>self</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * given a spool loaded by successive calls to _bt_spool,
 * create an entire btree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_leafbuild</name><parameter_list>(<parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>, <parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTWriteState</name></type> <name>wstate</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BTREE_BUILD_STATS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>log_btree_build_stats</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"BTREE BUILD (Spool) STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* BTREE_BUILD_STATS */</comment>

	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_SUBPHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_BTREE_PHASE_PERFORMSORT_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>btspool2</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_SUBPHASE</name></expr></argument>,
									 <argument><expr><name>PROGRESS_BTREE_PHASE_PERFORMSORT_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>btspool2</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>heap</name></name> <operator>=</operator> <name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name><name>btspool</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>inskey</name></name> <operator>=</operator> <call><name>_bt_mkscankey</name><argument_list>(<argument><expr><name><name>wstate</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to log index creation in WAL iff WAL archiving/streaming is
	 * enabled UNLESS the index isn't WAL-logged anyway.
	 */</comment>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>btws_use_wal</name></name> <operator>=</operator> <call><name>XLogIsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>wstate</name><operator>.</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reserve the metapage */</comment>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>btws_pages_alloced</name></name> <operator>=</operator> <name>BTREE_METAPAGE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>btws_pages_written</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>btws_zeropage</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* until needed */</comment>

	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_SUBPHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_BTREE_PHASE_LEAF_LOAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bt_load</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wstate</name></expr></argument>, <argument><expr><name>btspool</name></expr></argument>, <argument><expr><name>btspool2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Per-tuple callback for table_index_build_scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_build_callback</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
				   <parameter><decl><type><name>ItemPointer</name></type> <name>tupleId</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>tupleIsAlive</name></decl></parameter>,
				   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTBuildState</name> <modifier>*</modifier></type><name>buildstate</name> <init>= <expr><operator>(</operator><name>BTBuildState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * insert the index tuple into the appropriate spool file for subsequent
	 * processing
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupleIsAlive</name> <operator>||</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>spool2</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_spool</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>spool</name></name></expr></argument>, <argument><expr><name>tupleId</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* dead tuples are put into spool2 */</comment>
		<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>havedead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_spool</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>spool2</name></name></expr></argument>, <argument><expr><name>tupleId</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>indtuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * allocate workspace for a new, clean btree page, not linked to any siblings.
 */</comment>
<function><type><specifier>static</specifier> <name>Page</name></type>
<name>_bt_blnewpage</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Zero the page and set up standard page header info */</comment>
	<expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize BT opaque state */</comment>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>BTP_LEAF</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Make the P_HIKEY line pointer appear allocated */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<return>return <expr><name>page</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * emit a completed btree page, and release the working storage.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_blwritepage</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Ensure rd_smgr is open (could have been closed by relcache flush!) */</comment>
	<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>wstate</name><operator>-&gt;</operator><name>btws_use_wal</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We use the heap NEWPAGE record type for this */</comment>
		<expr_stmt><expr><call><name>log_newpage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have to write pages nonsequentially, fill in the space with
	 * zeroes until we come back and overwrite.  This is not logically
	 * necessary on standard Unix filesystems (unwritten space will read as
	 * zeroes anyway), but it should help to avoid fragmentation. The dummy
	 * pages aren't WAL-logged though.
	 */</comment>
	<while>while <condition>(<expr><name>blkno</name> <operator>&gt;</operator> <name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_written</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>wstate</name><operator>-&gt;</operator><name>btws_zeropage</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>btws_zeropage</name></name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* don't set checksum for all-zero page */</comment>
		<expr_stmt><expr><call><name>smgrextend</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>,
				   <argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_written</name></name><operator>++</operator></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>wstate</name><operator>-&gt;</operator><name>btws_zeropage</name></name></expr></argument>,
				   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>PageSetChecksumInplace</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now write the page.  There's no need for smgr to schedule an fsync for
	 * this write; we'll do it ourselves before ending the build.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_written</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* extending the file... */</comment>
		<expr_stmt><expr><call><name>smgrextend</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_written</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* overwriting a block we zero-filled before */</comment>
		<expr_stmt><expr><call><name>smgrwrite</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
				  <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * allocate and initialize a new BTPageState.  the returned structure
 * is suitable for immediate use by _bt_buildadd.
 */</comment>
<function><type><specifier>static</specifier> <name>BTPageState</name> <modifier>*</modifier></type>
<name>_bt_pagestate</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>BTPageState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTPageState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* create initial page for level */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_page</name></name> <operator>=</operator> <call><name>_bt_blnewpage</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* and assign it a page position */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_blkno</name></name> <operator>=</operator> <name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_alloced</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* initialize lastoff so first item goes into P_FIRSTKEY */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_lastoff</name></name> <operator>=</operator> <name>P_HIKEY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
	<comment type="block">/* set "full" threshold based on level.  See notes at head of file. */</comment>
	<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_full</name></name> <operator>=</operator> <operator>(</operator><name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><literal type="number">100</literal> <operator>-</operator> <name>BTREE_NONLEAF_FILLFACTOR</name><operator>)</operator> <operator>/</operator> <literal type="number">100</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_full</name></name> <operator>=</operator> <call><name>RelationGetTargetPageFreeSpace</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,
														  <argument><expr><name>BTREE_DEFAULT_FILLFACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<comment type="block">/* no parent level, yet */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * slide an array of ItemIds back one slot (from P_FIRSTKEY to
 * P_HIKEY, overwriting P_HIKEY).  we need to do this when we discover
 * that we have built an ItemId array in what has turned out to be a
 * P_RIGHTMOST page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_slideleft</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>previi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>thisii</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>previi</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <name>P_FIRSTKEY</name></expr>;</init> <condition><expr><name>off</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>off</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>thisii</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>previi</name> <operator>=</operator> <operator>*</operator><name>thisii</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>previi</name> <operator>=</operator> <name>thisii</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add an item to a page being built.
 *
 * The main difference between this routine and a bare PageAddItem call
 * is that this code knows that the leftmost data item on a non-leaf
 * btree page doesn't need to have a key.  Therefore, it strips such
 * items down to just the item header.
 *
 * This is almost like nbtinsert.c's _bt_pgaddtup(), but we can't use
 * that because it assumes that P_RIGHTMOST() will return the correct
 * answer for the page.  Here, we don't know yet if the page will be
 * rightmost.  Offset P_FIRSTKEY is always the first data key.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_sortaddtup</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
			   <parameter><decl><type><name>Size</name></type> <name>itemsize</name></decl></parameter>,
			   <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
			   <parameter><decl><type><name>OffsetNumber</name></type> <name>itup_off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTupleData</name></type> <name>trunctuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>itup_off</name> <operator>==</operator> <name>P_FIRSTKEY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>trunctuple</name> <operator>=</operator> <operator>*</operator><name>itup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trunctuple</name><operator>.</operator><name>t_info</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<comment type="block">/* Deliberately zero INDEX_ALT_TID_MASK bits */</comment>
		<expr_stmt><expr><call><name>BTreeTupleSetNAtts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>&amp;</operator><name>trunctuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><name>itemsize</name></expr></argument>, <argument><expr><name>itup_off</name></expr></argument>,
					<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to the index page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*----------
 * Add an item to a disk page from the sort output.
 *
 * We must be careful to observe the page layout conventions of nbtsearch.c:
 * - rightmost pages start data items at P_HIKEY instead of at P_FIRSTKEY.
 * - on non-leaf pages, the key portion of the first item need not be
 *	 stored, we should store only the link.
 *
 * A leaf page being built looks like:
 *
 * +----------------+---------------------------------+
 * | PageHeaderData | linp0 linp1 linp2 ...           |
 * +-----------+----+---------------------------------+
 * | ... linpN |									  |
 * +-----------+--------------------------------------+
 * |	 ^ last										  |
 * |												  |
 * +-------------+------------------------------------+
 * |			 | itemN ...                          |
 * +-------------+------------------+-----------------+
 * |		  ... item3 item2 item1 | "special space" |
 * +--------------------------------+-----------------+
 *
 * Contrast this with the diagram in bufpage.h; note the mismatch
 * between linps and items.  This is because we reserve linp0 as a
 * placeholder for the pointer to the "high key" item; when we have
 * filled up the page, we will set linp0 to point to itemN and clear
 * linpN.  On the other hand, if we find this is the last (rightmost)
 * page, we leave the items alone and slide the linp array over.  If
 * the high key is to be truncated, offset 1 is deleted, and we insert
 * the truncated high key at offset 1.
 *
 * 'last' pointer indicates the last offset added to the page.
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_buildadd</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>npage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>last_off</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>pgspc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>itupsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isleaf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is a handy place to check for cancel interrupts during the btree
	 * load phase of index creation.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>npage</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>btps_page</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nblkno</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>btps_blkno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_off</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>btps_lastoff</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>pgspc</name> <operator>=</operator> <call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itupsz</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itupsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itupsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Leaf case has slightly different rules due to suffix truncation */</comment>
	<expr_stmt><expr><name>isleaf</name> <operator>=</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>btps_level</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check whether the new item can fit on a btree page on current level at
	 * all.
	 *
	 * Every newly built index will treat heap TID as part of the keyspace,
	 * which imposes the requirement that new high keys must occasionally have
	 * a heap TID appended within _bt_truncate().  That may leave a new pivot
	 * tuple one or two MAXALIGN() quantums larger than the original first
	 * right tuple it's derived from.  v4 deals with the problem by decreasing
	 * the limit on the size of tuples inserted on the leaf level by the same
	 * small amount.  Enforce the new v4+ limit on the leaf level, and the old
	 * limit on internal levels, since pivot tuples may need to make use of
	 * the reserved space.  This should never fail on internal pages.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>itupsz</name> <operator>&gt;</operator> <call><name>BTMaxItemSize</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_check_third_page</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>, <argument><expr><name>isleaf</name></expr></argument>, <argument><expr><name>npage</name></expr></argument>,
							 <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check to see if current page will fit new item, with space left over to
	 * append a heap TID during suffix truncation when page is a leaf page.
	 *
	 * It is guaranteed that we can fit at least 2 non-pivot tuples plus a
	 * high key with heap TID when finishing off a leaf page, since we rely on
	 * _bt_check_third_page() rejecting oversized non-pivot tuples.  On
	 * internal pages we can always fit 3 pivot tuples with larger internal
	 * page tuple limit (includes page high key).
	 *
	 * Most of the time, a page is only "full" in the sense that the soft
	 * fillfactor-wise limit has been exceeded.  However, we must always leave
	 * at least two items plus a high key on each page before starting a new
	 * page.  Disregard fillfactor and insert on "full" current page if we
	 * don't have the minimum number of items yet.  (Note that we deliberately
	 * assume that suffix truncation neither enlarges nor shrinks new high key
	 * when applying soft limit.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pgspc</name> <operator>&lt;</operator> <name>itupsz</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>isleaf</name></expr> ?</condition><then> <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name><name>pgspc</name> <argument_list type="generic">&lt; <argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_full</name></name> <operator>&amp;&amp;</operator> <name>last_off</name></expr></argument> &gt;</argument_list></name> <name>P_FIRSTKEY</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Finish off the page and write it out.
		 */</comment>
		<decl_stmt><decl><type><name>Page</name></type>		<name>opage</name> <init>= <expr><name>npage</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>oblkno</name> <init>= <expr><name>nblkno</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>ii</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>hii</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>oitup</name></decl>;</decl_stmt>

		<comment type="block">/* Create new page of same level */</comment>
		<expr_stmt><expr><name>npage</name> <operator>=</operator> <call><name>_bt_blnewpage</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* and assign it a page position */</comment>
		<expr_stmt><expr><name>nblkno</name> <operator>=</operator> <name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_alloced</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * We copy the last item on the page into the new page, and then
		 * rearrange the old page so that the 'last item' becomes its high key
		 * rather than a true data item.  There had better be at least two
		 * items on the page already, else the page would be empty of useful
		 * data.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>last_off</name> <operator>&gt;</operator> <name>P_FIRSTKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ii</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><name>last_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oitup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_sortaddtup</name><argument_list>(<argument><expr><name>npage</name></expr></argument>, <argument><expr><call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oitup</name></expr></argument>, <argument><expr><name>P_FIRSTKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Move 'last' into the high key position on opage.  _bt_blnewpage()
		 * allocated empty space for a line pointer when opage was first
		 * created, so this is a matter of rearranging already-allocated space
		 * on page, and initializing high key line pointer. (Actually, leaf
		 * pages must also swap oitup with a truncated version of oitup, which
		 * is sometimes larger than oitup, though never by more than the space
		 * needed to append a heap TID.)
		 */</comment>
		<expr_stmt><expr><name>hii</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>hii</name> <operator>=</operator> <operator>*</operator><name>ii</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemIdSetUnused</name><argument_list>(<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* redundant */</comment>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>opage</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isleaf</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>lastleft</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>truncated</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>truncsz</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Truncate away any unneeded attributes from high key on leaf
			 * level.  This is only done at the leaf level because downlinks
			 * in internal pages are either negative infinity items, or get
			 * their contents from copying from one level down.  See also:
			 * _bt_split().
			 *
			 * We don't try to bias our choice of split point to make it more
			 * likely that _bt_truncate() can truncate away more attributes,
			 * whereas the split point passed to _bt_split() is chosen much
			 * more delicately.  Suffix truncation is mostly useful because it
			 * improves space utilization for workloads with random
			 * insertions.  It doesn't seem worthwhile to add logic for
			 * choosing a split point here for a benefit that is bound to be
			 * much smaller.
			 *
			 * Since the truncated tuple is often smaller than the original
			 * tuple, it cannot just be copied in place (besides, we want to
			 * actually save space on the leaf page).  We delete the original
			 * high key, and add our own truncated high key at the same
			 * offset.
			 *
			 * Note that the page layout won't be changed very much.  oitup is
			 * already located at the physical beginning of tuple space, so we
			 * only shift the line pointer array back and forth, and overwrite
			 * the tuple space previously occupied by oitup.  This is fairly
			 * cheap.
			 */</comment>
			<expr_stmt><expr><name>ii</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>last_off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lastleft</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>truncated</name> <operator>=</operator> <call><name>_bt_truncate</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>lastleft</name></expr></argument>, <argument><expr><name>oitup</name></expr></argument>,
									 <argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>inskey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>truncsz</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>truncated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_bt_sortaddtup</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><name>truncsz</name></expr></argument>, <argument><expr><name>truncated</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>truncated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* oitup should continue to point to the page's high key */</comment>
			<expr_stmt><expr><name>hii</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oitup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>opage</name></expr></argument>, <argument><expr><name>hii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Link the old page into its parent, using its minimum key. If we
		 * don't have a parent, we have to create one; this adds a new btree
		 * level.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>btps_next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_next</name></name> <operator>=</operator> <call><name>_bt_pagestate</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_level</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>, <argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator>
				<call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>, <argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
			   <call><name>P_LEFTMOST</name><argument_list>(<argument><expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>opage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>, <argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			   <operator>!</operator><call><name>P_LEFTMOST</name><argument_list>(<argument><expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>opage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTreeInnerTupleSetDownLink</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>, <argument><expr><name>oblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_buildadd</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_next</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Save a copy of the high key from the old page.  It is also used as
		 * the minimum key for the new page.
		 */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>oitup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set the sibling links for both pages.
		 */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>oopaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>opage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>nopaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>npage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>oopaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>nblkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>oblkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nopaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt>	<comment type="block">/* redundant */</comment>
		</block_content>}</block>

		<comment type="block">/*
		 * Write out the old page.  We never need to touch it again, so we can
		 * free the opage workspace too.
		 */</comment>
		<expr_stmt><expr><call><name>_bt_blwritepage</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name>opage</name></expr></argument>, <argument><expr><name>oblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset last_off to point to new page
		 */</comment>
		<expr_stmt><expr><name>last_off</name> <operator>=</operator> <name>P_FIRSTKEY</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * By here, either original page is still the current page, or a new page
	 * was created that became the current page.  Either way, the current page
	 * definitely has space for new item.
	 *
	 * If the new item is the first for its page, stash a copy for later. Note
	 * this will only happen for the first item on a level; on later pages,
	 * the first item for a page is copied from the prior page in the code
	 * above.  The minimum key for an entire level is nothing more than a
	 * minus infinity (downlink only) pivot tuple placeholder.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>last_off</name> <operator>==</operator> <name>P_HIKEY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* _bt_sortaddtup() will perform full truncation later */</comment>
		<expr_stmt><expr><call><name>BTreeTupleSetNAtts</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add the new item into the current page.
	 */</comment>
	<expr_stmt><expr><name>last_off</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>last_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bt_sortaddtup</name><argument_list>(<argument><expr><name>npage</name></expr></argument>, <argument><expr><name>itupsz</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>last_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_page</name></name> <operator>=</operator> <name>npage</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_blkno</name></name> <operator>=</operator> <name>nblkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>btps_lastoff</name></name> <operator>=</operator> <name>last_off</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finish writing out the completed btree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_uppershutdown</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rootblkno</name> <init>= <expr><name>P_NONE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>rootlevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapage</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Each iteration of this loop completes one more level of the tree.
	 */</comment>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>state</name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>btps_next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>btps_blkno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We have to link the last page on this level to somewhere.
		 *
		 * If we're at the top, it's the root, so attach it to the metapage.
		 * Otherwise, add an entry for it to its parent using its minimum key.
		 * This may cause the last page of the parent level to split, but
		 * that's not a problem -- we haven't gotten to it yet.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>btps_next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_ROOT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rootblkno</name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rootlevel</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>btps_level</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>, <argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator>
					<call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>, <argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
				   <call><name>P_LEFTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>, <argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				   <operator>!</operator><call><name>P_LEFTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BTreeInnerTupleSetDownLink</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_bt_buildadd</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_next</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_minkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>btps_minkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * This is the rightmost page, so the ItemId array needs to be slid
		 * back one slot.  Then we can dump out the page.
		 */</comment>
		<expr_stmt><expr><call><name>_bt_slideleft</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_blwritepage</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_page</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>btps_blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>btps_page</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* writepage freed the workspace */</comment>
	</block_content>}</block></for>

	<comment type="block">/*
	 * As the last step in the process, construct the metapage and make it
	 * point to the new root (unless we had no data at all, in which case it's
	 * set to point to "P_NONE").  This changes the index to the "valid" state
	 * by filling in a valid magic number in the metapage.
	 */</comment>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bt_initmetapage</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>, <argument><expr><name>rootblkno</name></expr></argument>, <argument><expr><name>rootlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bt_blwritepage</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name>metapage</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read tuples in correct sort order from tuplesort, and load them into
 * btree leaves.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_load</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>, <parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTPageState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>merge</name> <init>= <expr><operator>(</operator><name>btspool2</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>,
				<decl><type ref="prev"/><name>itup2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>load1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdes</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>keysz</name> <init>= <expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>tuples_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>merge</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Another BTSpool for dead tuples exists. Now we have to merge
		 * btspool and btspool2.
		 */</comment>

		<comment type="block">/* the preparation of merge */</comment>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>tuplesort_getindextuple</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup2</name> <operator>=</operator> <call><name>tuplesort_getindextuple</name><argument_list>(<argument><expr><name><name>btspool2</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Prepare SortSupport data for each column */</comment>
		<expr_stmt><expr><name>sortKeys</name> <operator>=</operator> <operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>keysz</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortSupportData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>keysz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortSupport</name></type> <name>sortKey</name> <init>= <expr><name>sortKeys</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ScanKey</name></type>		<name>scanKey</name> <init>= <expr><name><name>wstate</name><operator>-&gt;</operator><name>inskey</name><operator>-&gt;</operator><name>scankeys</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name></type>		<name>strategy</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_collation</name></name> <operator>=</operator> <name><name>scanKey</name><operator>-&gt;</operator><name>sk_collation</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_nulls_first</name></name> <operator>=</operator>
				<operator>(</operator><name><name>scanKey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name> <operator>=</operator> <name><name>scanKey</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
			<comment type="block">/* Abbreviation is not supported here */</comment>
			<expr_stmt><expr><name><name>sortKey</name><operator>-&gt;</operator><name>abbreviate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name><name>sortKey</name><operator>-&gt;</operator><name>ssup_attno</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>strategy</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>scanKey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then>
				<expr><name>BTGreaterStrategyNumber</name></expr> </then><else>: <expr><name>BTLessStrategyNumber</name></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PrepareSortSupportFromIndexRel</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>sortKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>load1</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* load BTSpool next ? */</comment>
			<if_stmt><if>if <condition>(<expr><name>itup2</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>itup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>itup</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int32</name></type>		<name>compare</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>keysz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SortSupport</name></type> <name>entry</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Datum</name></type>		<name>attrDatum1</name></decl>,
								<decl><type ref="prev"/><name>attrDatum2</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>isNull1</name></decl>,
								<decl><type ref="prev"/><name>isNull2</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>entry</name> <operator>=</operator> <name>sortKeys</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>attrDatum1</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tupdes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>attrDatum2</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>itup2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tupdes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name>attrDatum1</name></expr></argument>, <argument><expr><name>isNull1</name></expr></argument>,
												  <argument><expr><name>attrDatum2</name></expr></argument>, <argument><expr><name>isNull2</name></expr></argument>,
												  <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>load1</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>compare</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/*
				 * If key values are equal, we sort on ItemPointer.  This is
				 * required for btree indexes, since heap TID is treated as an
				 * implicit last key attribute in order to ensure that all
				 * keys in the index are physically unique.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ItemPointerCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>itup2</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>load1</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>load1</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* When we see first tuple, create first index page */</comment>
			<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>_bt_pagestate</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>load1</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>_bt_buildadd</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>tuplesort_getindextuple</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>_bt_buildadd</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>itup2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>itup2</name> <operator>=</operator> <call><name>tuplesort_getindextuple</name><argument_list>(<argument><expr><name><name>btspool2</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Report progress */</comment>
			<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_TUPLES_DONE</name></expr></argument>,
										 <argument><expr><operator>++</operator><name>tuples_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sortKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* merge is unnecessary */</comment>
		<while>while <condition>(<expr><operator>(</operator><name>itup</name> <operator>=</operator> <call><name>tuplesort_getindextuple</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>,
											   <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* When we see first tuple, create first index page */</comment>
			<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>_bt_pagestate</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>_bt_buildadd</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Report progress */</comment>
			<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CREATEIDX_TUPLES_DONE</name></expr></argument>,
										 <argument><expr><operator>++</operator><name>tuples_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Close down final pages and write the metapage */</comment>
	<expr_stmt><expr><call><name>_bt_uppershutdown</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the index is WAL-logged, we must fsync it down to disk before it's
	 * safe to commit the transaction.  (For a non-WAL-logged index we don't
	 * care since the index will be uninteresting after a crash anyway.)
	 *
	 * It's obvious that we must do this when not WAL-logging the build. It's
	 * less obvious that we have to do it even if we did WAL-log the index
	 * pages.  The reason is that since we're building outside shared buffers,
	 * a CHECKPOINT occurring during the build has no way to flush the
	 * previously written data to disk (indeed it won't know the index even
	 * exists).  A crash later on would replay WAL from the checkpoint,
	 * therefore it wouldn't replay our earlier WAL entries. If we do not
	 * fsync those pages here, they might still not be on disk when the crash
	 * occurs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>smgrimmedsync</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create parallel context, and launch workers for leader.
 *
 * buildstate argument should be initialized (with the exception of the
 * tuplesort state in spools, which may later be created based on shared
 * state initially set up here).
 *
 * isconcurrent indicates if operation is CREATE INDEX CONCURRENTLY.
 *
 * request is the target number of parallel worker processes to launch.
 *
 * Sets buildstate's BTLeader, which caller must use to shut down parallel
 * mode by passing it to _bt_end_parallel() at the very end of its index
 * build.  If not even a single worker process can be launched, this is
 * never set, and caller should proceed with a serial index build.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_begin_parallel</name><parameter_list>(<parameter><decl><type><name>BTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isconcurrent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>request</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>scantuplesortstates</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>estbtshared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>estsort</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTShared</name>   <modifier>*</modifier></type><name>btshared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>sharedsort</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>sharedsort2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTSpool</name>    <modifier>*</modifier></type><name>btspool</name> <init>= <expr><name><name>buildstate</name><operator>-&gt;</operator><name>spool</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTLeader</name>   <modifier>*</modifier></type><name>btleader</name> <init>= <expr><operator>(</operator><name>BTLeader</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTLeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>leaderparticipates</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sharedquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>querylen</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DISABLE_LEADER_PARTICIPATION</name></cpp:ifdef>
	<expr_stmt><expr><name>leaderparticipates</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Enter parallel mode, and create context for parallel build of btree
	 * index
	 */</comment>
	<expr_stmt><expr><call><name>EnterParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>request</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pcxt</name> <operator>=</operator> <call><name>CreateParallelContext</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><literal type="string">"_bt_parallel_build_main"</literal></expr></argument>,
								 <argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scantuplesortstates</name> <operator>=</operator> <ternary><condition><expr><name>leaderparticipates</name></expr> ?</condition><then> <expr><name>request</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>request</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare for scan of the base relation.  In a normal index build, we use
	 * SnapshotAny because we must retrieve all tuples and do our own time
	 * qual checks (because we have to index RECENTLY_DEAD tuples).  In a
	 * concurrent build, we take a regular MVCC snapshot and index whatever's
	 * live according to that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isconcurrent</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name>SnapshotAny</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Estimate size for our own PARALLEL_KEY_BTREE_SHARED workspace, and
	 * PARALLEL_KEY_TUPLESORT tuplesort workspace
	 */</comment>
	<expr_stmt><expr><name>estbtshared</name> <operator>=</operator> <call><name>_bt_parallel_estimate_shared</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>estbtshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>estsort</name> <operator>=</operator> <call><name>tuplesort_estimate_shared</name><argument_list>(<argument><expr><name>scantuplesortstates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>estsort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unique case requires a second spool, and so we may have to account for
	 * another shared workspace for that -- PARALLEL_KEY_TUPLESORT_SPOOL2
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>btspool</name><operator>-&gt;</operator><name>isunique</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>estsort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Finally, estimate PARALLEL_KEY_QUERY_TEXT space */</comment>
	<expr_stmt><expr><name>querylen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>querylen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Everyone's had a chance to ask for space, so now create the DSM */</comment>
	<expr_stmt><expr><call><name>InitializeParallelDSM</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store shared build state, for which we reserved space */</comment>
	<expr_stmt><expr><name>btshared</name> <operator>=</operator> <operator>(</operator><name>BTShared</name> <operator>*</operator><operator>)</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>estbtshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Initialize immutable state */</comment>
	<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>heaprelid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>indexrelid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>isunique</name></name> <operator>=</operator> <name><name>btspool</name><operator>-&gt;</operator><name>isunique</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>isconcurrent</name></name> <operator>=</operator> <name>isconcurrent</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>scantuplesortstates</name></name> <operator>=</operator> <name>scantuplesortstates</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ConditionVariableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btshared</name><operator>-&gt;</operator><name>workersdonecv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btshared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Initialize mutable state */</comment>
	<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>nparticipantsdone</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>havedead</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>indtuples</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>brokenhotchain</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_parallelscan_initialize</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>,
								  <argument><expr><call><name>ParallelTableScanFromBTShared</name><argument_list>(<argument><expr><name>btshared</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store shared tuplesort-private state, for which we reserved space.
	 * Then, initialize opaque state using tuplesort routine.
	 */</comment>
	<expr_stmt><expr><name>sharedsort</name> <operator>=</operator> <operator>(</operator><name>Sharedsort</name> <operator>*</operator><operator>)</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>estsort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tuplesort_initialize_shared</name><argument_list>(<argument><expr><name>sharedsort</name></expr></argument>, <argument><expr><name>scantuplesortstates</name></expr></argument>,
								<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_BTREE_SHARED</name></expr></argument>, <argument><expr><name>btshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TUPLESORT</name></expr></argument>, <argument><expr><name>sharedsort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Unique case requires a second spool, and associated shared state */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>btspool</name><operator>-&gt;</operator><name>isunique</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sharedsort2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Store additional shared tuplesort-private state, for which we
		 * reserved space.  Then, initialize opaque state using tuplesort
		 * routine.
		 */</comment>
		<expr_stmt><expr><name>sharedsort2</name> <operator>=</operator> <operator>(</operator><name>Sharedsort</name> <operator>*</operator><operator>)</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>estsort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplesort_initialize_shared</name><argument_list>(<argument><expr><name>sharedsort2</name></expr></argument>, <argument><expr><name>scantuplesortstates</name></expr></argument>,
									<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TUPLESORT_SPOOL2</name></expr></argument>, <argument><expr><name>sharedsort2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Store query string for workers */</comment>
	<expr_stmt><expr><name>sharedquery</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>querylen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>sharedquery</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>, <argument><expr><name>querylen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_QUERY_TEXT</name></expr></argument>, <argument><expr><name>sharedquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Launch workers, saving status for leader/caller */</comment>
	<expr_stmt><expr><call><name>LaunchParallelWorkers</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btleader</name><operator>-&gt;</operator><name>pcxt</name></name> <operator>=</operator> <name>pcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btleader</name><operator>-&gt;</operator><name>nparticipanttuplesorts</name></name> <operator>=</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>leaderparticipates</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>btleader</name><operator>-&gt;</operator><name>nparticipanttuplesorts</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>btleader</name><operator>-&gt;</operator><name>btshared</name></name> <operator>=</operator> <name>btshared</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btleader</name><operator>-&gt;</operator><name>sharedsort</name></name> <operator>=</operator> <name>sharedsort</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btleader</name><operator>-&gt;</operator><name>sharedsort2</name></name> <operator>=</operator> <name>sharedsort2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btleader</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>

	<comment type="block">/* If no workers were successfully launched, back out (do serial build) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>_bt_end_parallel</name><argument_list>(<argument><expr><name>btleader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Save leader state now that it's clear build will be parallel */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>btleader</name></name> <operator>=</operator> <name>btleader</name></expr>;</expr_stmt>

	<comment type="block">/* Join heap scan ourselves */</comment>
	<if_stmt><if>if <condition>(<expr><name>leaderparticipates</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_leader_participate_as_worker</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Caller needs to wait for all launched workers when we return.  Make
	 * sure that the failure-to-start case will not hang forever.
	 */</comment>
	<expr_stmt><expr><call><name>WaitForParallelWorkersToAttach</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Shut down workers, destroy parallel context, and end parallel mode.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_end_parallel</name><parameter_list>(<parameter><decl><type><name>BTLeader</name> <modifier>*</modifier></type><name>btleader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Shutdown worker processes */</comment>
	<expr_stmt><expr><call><name>WaitForParallelWorkersToFinish</name><argument_list>(<argument><expr><name><name>btleader</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Free last reference to MVCC snapshot, if one was used */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name><name>btleader</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>btleader</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>DestroyParallelContext</name><argument_list>(<argument><expr><name><name>btleader</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExitParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns size of shared memory required to store state for a parallel
 * btree index build based on the snapshot its parallel scan will use.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>_bt_parallel_estimate_shared</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* c.f. shm_toc_allocate as to why BUFFERALIGN is used */</comment>
	<return>return <expr><call><name>add_size</name><argument_list>(<argument><expr><call><name>BUFFERALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTShared</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>table_parallelscan_estimate</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Within leader, wait for end of heap scan.
 *
 * When called, parallel heap scan started by _bt_begin_parallel() will
 * already be underway within worker processes (when leader participates
 * as a worker, we should end up here just as workers are finishing).
 *
 * Fills in fields needed for ambuild statistics, and lets caller set
 * field indicating that some worker encountered a broken HOT chain.
 *
 * Returns the total number of heap tuples scanned.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>_bt_parallel_heapscan</name><parameter_list>(<parameter><decl><type><name>BTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>brokenhotchain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTShared</name>   <modifier>*</modifier></type><name>btshared</name> <init>= <expr><name><name>buildstate</name><operator>-&gt;</operator><name>btleader</name><operator>-&gt;</operator><name>btshared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nparticipanttuplesorts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nparticipanttuplesorts</name> <operator>=</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>btleader</name><operator>-&gt;</operator><name>nparticipanttuplesorts</name></name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btshared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>btshared</name><operator>-&gt;</operator><name>nparticipantsdone</name></name> <operator>==</operator> <name>nparticipanttuplesorts</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>havedead</name></name> <operator>=</operator> <name><name>btshared</name><operator>-&gt;</operator><name>havedead</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>indtuples</name></name> <operator>=</operator> <name><name>btshared</name><operator>-&gt;</operator><name>indtuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>brokenhotchain</name> <operator>=</operator> <name><name>btshared</name><operator>-&gt;</operator><name>brokenhotchain</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <name><name>btshared</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btshared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btshared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ConditionVariableSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btshared</name><operator>-&gt;</operator><name>workersdonecv</name></name></expr></argument>,
							   <argument><expr><name>WAIT_EVENT_PARALLEL_CREATE_INDEX_SCAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>reltuples</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Within leader, participate as a parallel worker.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_leader_participate_as_worker</name><parameter_list>(<parameter><decl><type><name>BTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTLeader</name>   <modifier>*</modifier></type><name>btleader</name> <init>= <expr><name><name>buildstate</name><operator>-&gt;</operator><name>btleader</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTSpool</name>    <modifier>*</modifier></type><name>leaderworker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTSpool</name>    <modifier>*</modifier></type><name>leaderworker2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sortmem</name></decl>;</decl_stmt>

	<comment type="block">/* Allocate memory and initialize private spool */</comment>
	<expr_stmt><expr><name>leaderworker</name> <operator>=</operator> <operator>(</operator><name>BTSpool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTSpool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>leaderworker</name><operator>-&gt;</operator><name>heap</name></name> <operator>=</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>spool</name><operator>-&gt;</operator><name>heap</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>leaderworker</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>spool</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>leaderworker</name><operator>-&gt;</operator><name>isunique</name></name> <operator>=</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>spool</name><operator>-&gt;</operator><name>isunique</name></name></expr>;</expr_stmt>

	<comment type="block">/* Initialize second spool, if required */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>btleader</name><operator>-&gt;</operator><name>btshared</name><operator>-&gt;</operator><name>isunique</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>leaderworker2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Allocate memory for worker's own private secondary spool */</comment>
		<expr_stmt><expr><name>leaderworker2</name> <operator>=</operator> <operator>(</operator><name>BTSpool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTSpool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize worker's own secondary spool */</comment>
		<expr_stmt><expr><name><name>leaderworker2</name><operator>-&gt;</operator><name>heap</name></name> <operator>=</operator> <name><name>leaderworker</name><operator>-&gt;</operator><name>heap</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>leaderworker2</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name><name>leaderworker</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>leaderworker2</name><operator>-&gt;</operator><name>isunique</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Might as well use reliable figure when doling out maintenance_work_mem
	 * (when requested number of workers were not launched, this will be
	 * somewhat higher than it is for other workers).
	 */</comment>
	<expr_stmt><expr><name>sortmem</name> <operator>=</operator> <name>maintenance_work_mem</name> <operator>/</operator> <name><name>btleader</name><operator>-&gt;</operator><name>nparticipanttuplesorts</name></name></expr>;</expr_stmt>

	<comment type="block">/* Perform work common to all participants */</comment>
	<expr_stmt><expr><call><name>_bt_parallel_scan_and_sort</name><argument_list>(<argument><expr><name>leaderworker</name></expr></argument>, <argument><expr><name>leaderworker2</name></expr></argument>, <argument><expr><name><name>btleader</name><operator>-&gt;</operator><name>btshared</name></name></expr></argument>,
							   <argument><expr><name><name>btleader</name><operator>-&gt;</operator><name>sharedsort</name></name></expr></argument>, <argument><expr><name><name>btleader</name><operator>-&gt;</operator><name>sharedsort2</name></name></expr></argument>,
							   <argument><expr><name>sortmem</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BTREE_BUILD_STATS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>log_btree_build_stats</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"BTREE BUILD (Leader Partial Spool) STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* BTREE_BUILD_STATS */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Perform work within a launched parallel process.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_parallel_build_main</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sharedquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTSpool</name>    <modifier>*</modifier></type><name>btspool</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTSpool</name>    <modifier>*</modifier></type><name>btspool2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTShared</name>   <modifier>*</modifier></type><name>btshared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>sharedsort</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>sharedsort2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heapRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>heapLockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>indexLockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sortmem</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BTREE_BUILD_STATS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>log_btree_build_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* BTREE_BUILD_STATS */</comment>

	<comment type="block">/* Set debug_query_string for individual workers first */</comment>
	<expr_stmt><expr><name>sharedquery</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_QUERY_TEXT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>sharedquery</name></expr>;</expr_stmt>

	<comment type="block">/* Report the query string from leader */</comment>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up nbtree shared state */</comment>
	<expr_stmt><expr><name>btshared</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_BTREE_SHARED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open relations using lock modes known to be obtained by index.c */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>btshared</name><operator>-&gt;</operator><name>isconcurrent</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>heapLockmode</name> <operator>=</operator> <name>ShareLock</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexLockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>heapLockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexLockmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Open relations within worker */</comment>
	<expr_stmt><expr><name>heapRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>btshared</name><operator>-&gt;</operator><name>heaprelid</name></name></expr></argument>, <argument><expr><name>heapLockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>btshared</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></argument>, <argument><expr><name>indexLockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize worker's own spool */</comment>
	<expr_stmt><expr><name>btspool</name> <operator>=</operator> <operator>(</operator><name>BTSpool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTSpool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name> <operator>=</operator> <name>heapRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btspool</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>indexRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btspool</name><operator>-&gt;</operator><name>isunique</name></name> <operator>=</operator> <name><name>btshared</name><operator>-&gt;</operator><name>isunique</name></name></expr>;</expr_stmt>

	<comment type="block">/* Look up shared state private to tuplesort.c */</comment>
	<expr_stmt><expr><name>sharedsort</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TUPLESORT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tuplesort_attach_shared</name><argument_list>(<argument><expr><name>sharedsort</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>btshared</name><operator>-&gt;</operator><name>isunique</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>btspool2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sharedsort2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Allocate memory for worker's own private secondary spool */</comment>
		<expr_stmt><expr><name>btspool2</name> <operator>=</operator> <operator>(</operator><name>BTSpool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTSpool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize worker's own secondary spool */</comment>
		<expr_stmt><expr><name><name>btspool2</name><operator>-&gt;</operator><name>heap</name></name> <operator>=</operator> <name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>btspool2</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name><name>btspool</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>btspool2</name><operator>-&gt;</operator><name>isunique</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<comment type="block">/* Look up shared state private to tuplesort.c */</comment>
		<expr_stmt><expr><name>sharedsort2</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TUPLESORT_SPOOL2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplesort_attach_shared</name><argument_list>(<argument><expr><name>sharedsort2</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Perform sorting of spool, and possibly a spool2 */</comment>
	<expr_stmt><expr><name>sortmem</name> <operator>=</operator> <name>maintenance_work_mem</name> <operator>/</operator> <name><name>btshared</name><operator>-&gt;</operator><name>scantuplesortstates</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bt_parallel_scan_and_sort</name><argument_list>(<argument><expr><name>btspool</name></expr></argument>, <argument><expr><name>btspool2</name></expr></argument>, <argument><expr><name>btshared</name></expr></argument>, <argument><expr><name>sharedsort</name></expr></argument>,
							   <argument><expr><name>sharedsort2</name></expr></argument>, <argument><expr><name>sortmem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BTREE_BUILD_STATS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>log_btree_build_stats</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"BTREE BUILD (Worker Partial Spool) STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* BTREE_BUILD_STATS */</comment>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>indexLockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>heapLockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Perform a worker's portion of a parallel sort.
 *
 * This generates a tuplesort for passed btspool, and a second tuplesort
 * state if a second btspool is need (i.e. for unique index builds).  All
 * other spool fields should already be set when this is called.
 *
 * sortmem is the amount of working memory to use within each worker,
 * expressed in KBs.
 *
 * When this returns, workers are done, and need only release resources.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_parallel_scan_and_sort</name><parameter_list>(<parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool</name></decl></parameter>, <parameter><decl><type><name>BTSpool</name> <modifier>*</modifier></type><name>btspool2</name></decl></parameter>,
						   <parameter><decl><type><name>BTShared</name> <modifier>*</modifier></type><name>btshared</name></decl></parameter>, <parameter><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>sharedsort</name></decl></parameter>,
						   <parameter><decl><type><name>Sharedsort</name> <modifier>*</modifier></type><name>sharedsort2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sortmem</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>progress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortCoordinate</name></type> <name>coordinate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTBuildState</name></type> <name>buildstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize local tuplesort coordination state */</comment>
	<expr_stmt><expr><name>coordinate</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SortCoordinateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>coordinate</name><operator>-&gt;</operator><name>isWorker</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>coordinate</name><operator>-&gt;</operator><name>nParticipants</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>coordinate</name><operator>-&gt;</operator><name>sharedsort</name></name> <operator>=</operator> <name>sharedsort</name></expr>;</expr_stmt>

	<comment type="block">/* Begin "partial" tuplesort */</comment>
	<expr_stmt><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name> <operator>=</operator> <call><name>tuplesort_begin_index_btree</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>,
													 <argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,
													 <argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>isunique</name></name></expr></argument>,
													 <argument><expr><name>sortmem</name></expr></argument>, <argument><expr><name>coordinate</name></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Just as with serial case, there may be a second spool.  If so, a
	 * second, dedicated spool2 partial tuplesort is required.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>btspool2</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortCoordinate</name></type> <name>coordinate2</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We expect that the second one (for dead tuples) won't get very
		 * full, so we give it only work_mem (unless sortmem is less for
		 * worker).  Worker processes are generally permitted to allocate
		 * work_mem independently.
		 */</comment>
		<expr_stmt><expr><name>coordinate2</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SortCoordinateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coordinate2</name><operator>-&gt;</operator><name>isWorker</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coordinate2</name><operator>-&gt;</operator><name>nParticipants</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coordinate2</name><operator>-&gt;</operator><name>sharedsort</name></name> <operator>=</operator> <name>sharedsort2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>btspool2</name><operator>-&gt;</operator><name>sortstate</name></name> <operator>=</operator>
			<call><name>tuplesort_begin_index_btree</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>, <argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										<argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>sortmem</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>coordinate2</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fill in buildstate for _bt_build_callback() */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>isunique</name></name> <operator>=</operator> <name><name>btshared</name><operator>-&gt;</operator><name>isunique</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>havedead</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>heap</name></name> <operator>=</operator> <name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>spool</name></name> <operator>=</operator> <name>btspool</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>spool2</name></name> <operator>=</operator> <name>btspool2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>indtuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>btleader</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Join parallel scan */</comment>
	<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name> <operator>=</operator> <name><name>btshared</name><operator>-&gt;</operator><name>isconcurrent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_parallel</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>,
									<argument><expr><call><name>ParallelTableScanFromBTShared</name><argument_list>(<argument><expr><name>btshared</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <call><name>table_index_build_scan</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>, <argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>,
									   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>progress</name></expr></argument>, <argument><expr><name>_bt_build_callback</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buildstate</name></expr></argument>, <argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Execute this worker's part of the sort.
	 *
	 * Unlike leader and serial cases, we cannot avoid calling
	 * tuplesort_performsort() for spool2 if it ends up containing no dead
	 * tuples (this is disallowed for workers by tuplesort).
	 */</comment>
	<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>btspool2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>btspool2</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Done.  Record ambuild statistics, and whether we encountered a broken
	 * HOT chain.
	 */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btshared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>nparticipantsdone</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>+=</operator> <name>reltuples</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>buildstate</name><operator>.</operator><name>havedead</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>havedead</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>indtuples</name></name> <operator>+=</operator> <name><name>buildstate</name><operator>.</operator><name>indtuples</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>btshared</name><operator>-&gt;</operator><name>brokenhotchain</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btshared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Notify leader */</comment>
	<expr_stmt><expr><call><name>ConditionVariableSignal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btshared</name><operator>-&gt;</operator><name>workersdonecv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can end tuplesorts immediately */</comment>
	<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>btspool</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>btspool2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>btspool2</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
