<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/nbtree/nbtsplitloc.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nbtsplitloc.c
 *	  Choose split point code for Postgres btree implementation.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/nbtree/nbtsplitloc.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>

<comment type="block">/* limits on split interval (default strategy only) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_LEAF_INTERVAL</name></cpp:macro>			<cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_INTERNAL_INTERVAL</name></cpp:macro>		<cpp:value>18</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum
<block>{
	<comment type="block">/* strategy for searching through materialized list of split points */</comment>
	<decl><name>SPLIT_DEFAULT</name></decl>,				<comment type="block">/* give some weight to truncation */</comment>
	<decl><name>SPLIT_MANY_DUPLICATES</name></decl>,		<comment type="block">/* find minimally distinguishing point */</comment>
	<decl><name>SPLIT_SINGLE_VALUE</name></decl>			<comment type="block">/* leave left page almost full */</comment>
}</block></enum></type> <name>FindSplitStrat</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/* details of free space left by split */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name>curdelta</name></decl>;</decl_stmt>		<comment type="block">/* current leftfree/rightfree delta */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name>leftfree</name></decl>;</decl_stmt>		<comment type="block">/* space left on left page post-split */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name>rightfree</name></decl>;</decl_stmt>		<comment type="block">/* space left on right page post-split */</comment>

	<comment type="block">/* split point identifying fields (returned by _bt_findsplitloc) */</comment>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>firstoldonright</name></decl>;</decl_stmt>	<comment type="block">/* first item on new right page */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>newitemonleft</name></decl>;</decl_stmt>	<comment type="block">/* new item goes on left, or right? */</comment>

}</block></struct></type> <name>SplitPoint</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/* context data for _bt_recsplitloc */</comment>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>			<comment type="block">/* index relation */</comment>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>			<comment type="block">/* page undergoing split */</comment>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>newitem</name></decl>;</decl_stmt>		<comment type="block">/* new item (cause of page split) */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>newitemsz</name></decl>;</decl_stmt>		<comment type="block">/* size of newitem (includes line pointer) */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_leaf</name></decl>;</decl_stmt>		<comment type="block">/* T if splitting a leaf page */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_rightmost</name></decl>;</decl_stmt>	<comment type="block">/* T if splitting rightmost page on level */</comment>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl>;</decl_stmt>	<comment type="block">/* where the new item is to be inserted */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>leftspace</name></decl>;</decl_stmt>		<comment type="block">/* space available for items on left page */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>rightspace</name></decl>;</decl_stmt>		<comment type="block">/* space available for items on right page */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>olddataitemstotal</name></decl>;</decl_stmt>	<comment type="block">/* space taken by old items */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>minfirstrightsz</name></decl>;</decl_stmt>	<comment type="block">/* smallest firstoldonright tuple size */</comment>

	<comment type="block">/* candidate split point data */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxsplits</name></decl>;</decl_stmt>		<comment type="block">/* maximum number of splits */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nsplits</name></decl>;</decl_stmt>		<comment type="block">/* current number of splits */</comment>
	<decl_stmt><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>splits</name></decl>;</decl_stmt>			<comment type="block">/* all candidate split points for page */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>interval</name></decl>;</decl_stmt>		<comment type="block">/* current range of acceptable split points */</comment>
}</block></struct></type> <name>FindSplitData</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_recsplitloc</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
							<parameter><decl><type><name>OffsetNumber</name></type> <name>firstoldonright</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newitemonleft</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>olddataitemstoleft</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>firstoldonrightsz</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_deltasortsplits</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>fillfactormult</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>usemult</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_bt_splitcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_afternewitemoff</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>leaffillfactor</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>usemult</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_adjacenthtid</name><parameter_list>(<parameter><decl><type><name>ItemPointer</name></type> <name>lowhtid</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>highhtid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OffsetNumber</name></type> <name>_bt_bestsplitloc</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>perfectpenalty</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newitemonleft</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_bt_strategy</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>leftpage</name></decl></parameter>,
						 <parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>rightpage</name></decl></parameter>, <parameter><decl><type><name>FindSplitStrat</name> <modifier>*</modifier></type><name>strategy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_interval_edges</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
							   <parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier><modifier>*</modifier></type><name>leftinterval</name></decl></parameter>, <parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier><modifier>*</modifier></type><name>rightinterval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>_bt_split_penalty</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>split</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>IndexTuple</name></type> <name>_bt_split_lastleft</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
											<parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>split</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>IndexTuple</name></type> <name>_bt_split_firstright</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
											  <parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>split</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	_bt_findsplitloc() -- find an appropriate place to split a page.
 *
 * The main goal here is to equalize the free space that will be on each
 * split page, *after accounting for the inserted tuple*.  (If we fail to
 * account for it, we might find ourselves with too little room on the page
 * that it needs to go into!)
 *
 * If the page is the rightmost page on its level, we instead try to arrange
 * to leave the left split page fillfactor% full.  In this way, when we are
 * inserting successively increasing keys (consider sequences, timestamps,
 * etc) we will end up with a tree whose pages are about fillfactor% full,
 * instead of the 50% full result that we'd get without this special case.
 * This is the same as nbtsort.c produces for a newly-created tree.  Note
 * that leaf and nonleaf pages use different fillfactors.  Note also that
 * there are a number of further special cases where fillfactor is not
 * applied in the standard way.
 *
 * We are passed the intended insert position of the new tuple, expressed as
 * the offsetnumber of the tuple it must go in front of (this could be
 * maxoff+1 if the tuple is to go at the end).  The new tuple itself is also
 * passed, since it's needed to give some weight to how effective suffix
 * truncation will be.  The implementation picks the split point that
 * maximizes the effectiveness of suffix truncation from a small list of
 * alternative candidate split points that leave each side of the split with
 * about the same share of free space.  Suffix truncation is secondary to
 * equalizing free space, except in cases with large numbers of duplicates.
 * Note that it is always assumed that caller goes on to perform truncation,
 * even with pg_upgrade'd indexes where that isn't actually the case
 * (!heapkeyspace indexes).  See nbtree/README for more information about
 * suffix truncation.
 *
 * We return the index of the first existing tuple that should go on the
 * righthand page, plus a boolean indicating whether the new tuple goes on
 * the left or right page.  The bool is necessary to disambiguate the case
 * where firstright == newitemoff.
 */</comment>
<function><type><name>OffsetNumber</name></type>
<name>_bt_findsplitloc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
				 <parameter><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl></parameter>,
				 <parameter><decl><type><name>Size</name></type> <name>newitemsz</name></decl></parameter>,
				 <parameter><decl><type><name>IndexTuple</name></type> <name>newitem</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newitemonleft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>leftspace</name></decl>,
				<decl><type ref="prev"/><name>rightspace</name></decl>,
				<decl><type ref="prev"/><name>olddataitemstotal</name></decl>,
				<decl><type ref="prev"/><name>olddataitemstoleft</name></decl>,
				<decl><type ref="prev"/><name>perfectpenalty</name></decl>,
				<decl><type ref="prev"/><name>leaffillfactor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FindSplitData</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FindSplitStrat</name></type> <name>strategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>,
				<decl><type ref="prev"/><name>foundfirstright</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>fillfactormult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>usemult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SplitPoint</name></type>	<name>leftpage</name></decl>,
				<decl><type ref="prev"/><name>rightpage</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Total free space available on a btree page, after fixed overhead */</comment>
	<expr_stmt><expr><name>leftspace</name> <operator>=</operator> <name>rightspace</name> <operator>=</operator>
		<call><name>PageGetPageSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>SizeOfPageHeaderData</name> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTPageOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The right page will have the same high key as the old page */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rightspace</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
							 <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Count up total space in data items before actually scanning 'em */</comment>
	<expr_stmt><expr><name>olddataitemstotal</name> <operator>=</operator> <name>rightspace</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leaffillfactor</name> <operator>=</operator> <call><name>RelationGetFillFactor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BTREE_DEFAULT_FILLFACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Passed-in newitemsz is MAXALIGNED but does not include line pointer */</comment>
	<expr_stmt><expr><name>newitemsz</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>page</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>newitem</name></name> <operator>=</operator> <name>newitem</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>newitemsz</name></name> <operator>=</operator> <name>newitemsz</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>is_leaf</name></name> <operator>=</operator> <call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>is_rightmost</name></name> <operator>=</operator> <call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>leftspace</name></name> <operator>=</operator> <name>leftspace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>rightspace</name></name> <operator>=</operator> <name>rightspace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>olddataitemstotal</name></name> <operator>=</operator> <name>olddataitemstotal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>minfirstrightsz</name></name> <operator>=</operator> <name>SIZE_MAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>newitemoff</name></name> <operator>=</operator> <name>newitemoff</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * maxsplits should never exceed maxoff because there will be at most as
	 * many candidate split points as there are points _between_ tuples, once
	 * you imagine that the new item is already on the original page (the
	 * final number of splits may be slightly lower because not all points
	 * between tuples will be legal).
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>maxsplits</name></name> <operator>=</operator> <name>maxoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>splits</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SplitPoint</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>state</name><operator>.</operator><name>maxsplits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>nsplits</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan through the data items and calculate space usage for a split at
	 * each possible position
	 */</comment>
	<expr_stmt><expr><name>olddataitemstoleft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
		 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>itemsz</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<comment type="block">/*
		 * When item offset number is not newitemoff, neither side of the
		 * split can be newitem.  Record a split after the previous data item
		 * from original page, but before the current data item from original
		 * page. (_bt_recsplitloc() will reject the split when there are no
		 * previous data items, which we rely on.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>&lt;</operator> <name>newitemoff</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bt_recsplitloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>olddataitemstoleft</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>offnum</name> <operator>&gt;</operator> <name>newitemoff</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bt_recsplitloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>olddataitemstoleft</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Record a split after all "offnum &lt; newitemoff" original page
			 * data items, but before newitem
			 */</comment>
			<expr_stmt><expr><call><name>_bt_recsplitloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>olddataitemstoleft</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Record a split after newitem, but before data item from
			 * original page at offset newitemoff/current offset
			 */</comment>
			<expr_stmt><expr><call><name>_bt_recsplitloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>olddataitemstoleft</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>olddataitemstoleft</name> <operator>+=</operator> <name>itemsz</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Record a split after all original page data items, but before newitem.
	 * (Though only when it's possible that newitem will end up alone on new
	 * right page.)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>olddataitemstoleft</name> <operator>==</operator> <name>olddataitemstotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newitemoff</name> <operator>&gt;</operator> <name>maxoff</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_recsplitloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>newitemoff</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>olddataitemstotal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * I believe it is not possible to fail to find a feasible split, but just
	 * in case ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>nsplits</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find a feasible split point for index \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Start search for a split point among list of legal split points.  Give
	 * primary consideration to equalizing available free space in each half
	 * of the split initially (start with default strategy), while applying
	 * rightmost and split-after-new-item optimizations where appropriate.
	 * Either of the two other fallback strategies may be required for cases
	 * with a large number of duplicates around the original/space-optimal
	 * split point.
	 *
	 * Default strategy gives some weight to suffix truncation in deciding a
	 * split point on leaf pages.  It attempts to select a split point where a
	 * distinguishing attribute appears earlier in the new high key for the
	 * left side of the split, in order to maximize the number of trailing
	 * attributes that can be truncated away.  Only candidate split points
	 * that imply an acceptable balance of free space on each side are
	 * considered.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>.</operator><name>is_leaf</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fillfactormult only used on rightmost page */</comment>
		<expr_stmt><expr><name>usemult</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>is_rightmost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fillfactormult</name> <operator>=</operator> <name>BTREE_NONLEAF_FILLFACTOR</name> <operator>/</operator> <literal type="number">100.0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>.</operator><name>is_rightmost</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Rightmost leaf page --  fillfactormult always used */</comment>
		<expr_stmt><expr><name>usemult</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fillfactormult</name> <operator>=</operator> <name>leaffillfactor</name> <operator>/</operator> <literal type="number">100.0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>_bt_afternewitemoff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>, <argument><expr><name>leaffillfactor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usemult</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * New item inserted at rightmost point among a localized grouping on
		 * a leaf page -- apply "split after new item" optimization, either by
		 * applying leaf fillfactor multiplier, or by choosing the exact split
		 * point that leaves the new item as last on the left. (usemult is set
		 * for us.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>usemult</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* fillfactormult should be set based on leaf fillfactor */</comment>
			<expr_stmt><expr><name>fillfactormult</name> <operator>=</operator> <name>leaffillfactor</name> <operator>/</operator> <literal type="number">100.0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* find precise split point after newitemoff */</comment>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>.</operator><name>nsplits</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>split</name> <init>= <expr><name><name>state</name><operator>.</operator><name>splits</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>split</name><operator>-&gt;</operator><name>newitemonleft</name></name> <operator>&amp;&amp;</operator>
					<name>newitemoff</name> <operator>==</operator> <name><name>split</name><operator>-&gt;</operator><name>firstoldonright</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>splits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>newitemonleft</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<return>return <expr><name>newitemoff</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Cannot legally split after newitemoff; proceed with split
			 * without using fillfactor multiplier.  This is defensive, and
			 * should never be needed in practice.
			 */</comment>
			<expr_stmt><expr><name>fillfactormult</name> <operator>=</operator> <literal type="number">0.50</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Other leaf page.  50:50 page split. */</comment>
		<expr_stmt><expr><name>usemult</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<comment type="block">/* fillfactormult not used, but be tidy */</comment>
		<expr_stmt><expr><name>fillfactormult</name> <operator>=</operator> <literal type="number">0.50</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Set an initial limit on the split interval/number of candidate split
	 * points as appropriate.  The "Prefix B-Trees" paper refers to this as
	 * sigma l for leaf splits and sigma b for internal ("branch") splits.
	 * It's hard to provide a theoretical justification for the initial size
	 * of the split interval, though it's clear that a small split interval
	 * makes suffix truncation much more effective without noticeably
	 * affecting space utilization over time.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>interval</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>nsplits</name></name> <operator>*</operator> <literal type="number">0.05</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><ternary><condition><expr><name><name>state</name><operator>.</operator><name>is_leaf</name></name></expr> ?</condition><then> <expr><name>MAX_LEAF_INTERVAL</name></expr> </then><else>:
						 <expr><name>MAX_INTERNAL_INTERVAL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save leftmost and rightmost splits for page before original ordinal
	 * sort order is lost by delta/fillfactormult sort
	 */</comment>
	<expr_stmt><expr><name>leftpage</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>splits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightpage</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>splits</name><index>[<expr><name><name>state</name><operator>.</operator><name>nsplits</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Give split points a fillfactormult-wise delta, and sort on deltas */</comment>
	<expr_stmt><expr><call><name>_bt_deltasortsplits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>fillfactormult</name></expr></argument>, <argument><expr><name>usemult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine if default strategy/split interval will produce a
	 * sufficiently distinguishing split, or if we should change strategies.
	 * Alternative strategies change the range of split points that are
	 * considered acceptable (split interval), and possibly change
	 * fillfactormult, in order to deal with pages with a large number of
	 * duplicates gracefully.
	 *
	 * Pass low and high splits for the entire page (including even newitem).
	 * These are used when the initial split interval encloses split points
	 * that are full of duplicates, and we need to consider if it's even
	 * possible to avoid appending a heap TID.
	 */</comment>
	<expr_stmt><expr><name>perfectpenalty</name> <operator>=</operator> <call><name>_bt_strategy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftpage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightpage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>SPLIT_DEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Default strategy worked out (always works out with internal page).
		 * Original split interval still stands.
		 */</comment>
	</block_content>}</block></if>

	<comment type="block">/*
	 * Many duplicates strategy is used when a heap TID would otherwise be
	 * appended, but the page isn't completely full of logical duplicates.
	 *
	 * The split interval is widened to include all legal candidate split
	 * points.  There may be a few as two distinct values in the whole-page
	 * split interval.  Many duplicates strategy has no hard requirements for
	 * space utilization, though it still keeps the use of space balanced as a
	 * non-binding secondary goal (perfect penalty is set so that the
	 * first/lowest delta split points that avoids appending a heap TID is
	 * used).
	 *
	 * Single value strategy is used when it is impossible to avoid appending
	 * a heap TID.  It arranges to leave the left page very full.  This
	 * maximizes space utilization in cases where tuples with the same
	 * attribute values span many pages.  Newly inserted duplicates will tend
	 * to have higher heap TID values, so we'll end up splitting to the right
	 * consistently.  (Single value strategy is harmless though not
	 * particularly useful with !heapkeyspace indexes.)
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>SPLIT_MANY_DUPLICATES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>is_leaf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* No need to resort splits -- no change in fillfactormult/deltas */</comment>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>interval</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>nsplits</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>SPLIT_SINGLE_VALUE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>is_leaf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Split near the end of the page */</comment>
		<expr_stmt><expr><name>usemult</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fillfactormult</name> <operator>=</operator> <name>BTREE_SINGLEVAL_FILLFACTOR</name> <operator>/</operator> <literal type="number">100.0</literal></expr>;</expr_stmt>
		<comment type="block">/* Resort split points with new delta */</comment>
		<expr_stmt><expr><call><name>_bt_deltasortsplits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>fillfactormult</name></expr></argument>, <argument><expr><name>usemult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Appending a heap TID is unavoidable, so interval of 1 is fine */</comment>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>interval</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Search among acceptable split points (using final split interval) for
	 * the entry that has the lowest penalty, and is therefore expected to
	 * maximize fan-out.  Sets *newitemonleft for us.
	 */</comment>
	<expr_stmt><expr><name>foundfirstright</name> <operator>=</operator> <call><name>_bt_bestsplitloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>perfectpenalty</name></expr></argument>, <argument><expr><name>newitemonleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>splits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>foundfirstright</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine to record a particular point between two tuples (possibly the
 * new item) on page (ie, combination of firstright and newitemonleft
 * settings) in *state for later analysis.  This is also a convenient point
 * to check if the split is legal (if it isn't, it won't be recorded).
 *
 * firstoldonright is the offset of the first item on the original page that
 * goes to the right page, and firstoldonrightsz is the size of that tuple.
 * firstoldonright can be &gt; max offset, which means that all the old items go
 * to the left page and only the new item goes to the right page.  In that
 * case, firstoldonrightsz is not used.
 *
 * olddataitemstoleft is the total size of all old items to the left of the
 * split point that is recorded here when legal.  Should not include
 * newitemsz, since that is handled here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_recsplitloc</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
				<parameter><decl><type><name>OffsetNumber</name></type> <name>firstoldonright</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>newitemonleft</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>olddataitemstoleft</name></decl></parameter>,
				<parameter><decl><type><name>Size</name></type> <name>firstoldonrightsz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>leftfree</name></decl>,
				<decl><type ref="prev"/><name>rightfree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>firstrightitemsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>newitemisfirstonright</name></decl>;</decl_stmt>

	<comment type="block">/* Is the new item going to be the first item on the right page? */</comment>
	<expr_stmt><expr><name>newitemisfirstonright</name> <operator>=</operator> <operator>(</operator><name>firstoldonright</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemoff</name></name>
							 <operator>&amp;&amp;</operator> <operator>!</operator><name>newitemonleft</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>newitemisfirstonright</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>firstrightitemsz</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemsz</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>firstrightitemsz</name> <operator>=</operator> <name>firstoldonrightsz</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Account for all the old tuples */</comment>
	<expr_stmt><expr><name>leftfree</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>leftspace</name></name> <operator>-</operator> <name>olddataitemstoleft</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightfree</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>rightspace</name></name> <operator>-</operator>
		<operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>olddataitemstotal</name></name> <operator>-</operator> <name>olddataitemstoleft</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * The first item on the right page becomes the high key of the left page;
	 * therefore it counts against left space as well as right space (we
	 * cannot assume that suffix truncation will make it any smaller).  When
	 * index has included attributes, then those attributes of left page high
	 * key will be truncated leaving that page with slightly more free space.
	 * However, that shouldn't affect our ability to find valid split
	 * location, since we err in the direction of being pessimistic about free
	 * space on the left half.  Besides, even when suffix truncation of
	 * non-TID attributes occurs, the new high key often won't even be a
	 * single MAXALIGN() quantum smaller than the firstright tuple it's based
	 * on.
	 *
	 * If we are on the leaf level, assume that suffix truncation cannot avoid
	 * adding a heap TID to the left half's new high key when splitting at the
	 * leaf level.  In practice the new high key will often be smaller and
	 * will rarely be larger, but conservatively assume the worst case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>is_leaf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>leftfree</name> <operator>-=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <operator>(</operator><name>firstrightitemsz</name> <operator>+</operator>
							 <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>leftfree</name> <operator>-=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <name>firstrightitemsz</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* account for the new item */</comment>
	<if_stmt><if>if <condition>(<expr><name>newitemonleft</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>leftfree</name> <operator>-=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemsz</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>rightfree</name> <operator>-=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemsz</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If we are not on the leaf level, we will be able to discard the key
	 * data from the first item that winds up on the right page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>is_leaf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rightfree</name> <operator>+=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <name>firstrightitemsz</name> <operator>-</operator>
			<operator>(</operator><name>int16</name><operator>)</operator> <operator>(</operator><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Record split if legal */</comment>
	<if_stmt><if>if <condition>(<expr><name>leftfree</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rightfree</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nsplits</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>maxsplits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Determine smallest firstright item size on page */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>minfirstrightsz</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>minfirstrightsz</name></name></expr></argument>, <argument><expr><name>firstrightitemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>splits</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>nsplits</name></name></expr>]</index></name><operator>.</operator><name>curdelta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>splits</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>nsplits</name></name></expr>]</index></name><operator>.</operator><name>leftfree</name> <operator>=</operator> <name>leftfree</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>splits</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>nsplits</name></name></expr>]</index></name><operator>.</operator><name>rightfree</name> <operator>=</operator> <name>rightfree</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>splits</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>nsplits</name></name></expr>]</index></name><operator>.</operator><name>firstoldonright</name> <operator>=</operator> <name>firstoldonright</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>splits</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>nsplits</name></name></expr>]</index></name><operator>.</operator><name>newitemonleft</name> <operator>=</operator> <name>newitemonleft</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nsplits</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine to assign space deltas to materialized array of candidate split
 * points based on current fillfactor, and to sort array using that fillfactor
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_deltasortsplits</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>fillfactormult</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>usemult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nsplits</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>split</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>splits</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>delta</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>usemult</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>delta</name> <operator>=</operator> <name>fillfactormult</name> <operator>*</operator> <name><name>split</name><operator>-&gt;</operator><name>leftfree</name></name> <operator>-</operator>
				<operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>fillfactormult</name><operator>)</operator> <operator>*</operator> <name><name>split</name><operator>-&gt;</operator><name>rightfree</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>delta</name> <operator>=</operator> <name><name>split</name><operator>-&gt;</operator><name>leftfree</name></name> <operator>-</operator> <name><name>split</name><operator>-&gt;</operator><name>rightfree</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>-</operator><name>delta</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Save delta */</comment>
		<expr_stmt><expr><name><name>split</name><operator>-&gt;</operator><name>curdelta</name></name> <operator>=</operator> <name>delta</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>splits</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>nsplits</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SplitPoint</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>_bt_splitcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * qsort-style comparator used by _bt_deltasortsplits()
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_bt_splitcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>split1</name> <init>= <expr><operator>(</operator><name>SplitPoint</name> <operator>*</operator><operator>)</operator> <name>arg1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>split2</name> <init>= <expr><operator>(</operator><name>SplitPoint</name> <operator>*</operator><operator>)</operator> <name>arg2</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>split1</name><operator>-&gt;</operator><name>curdelta</name></name> <operator>&gt;</operator> <name><name>split2</name><operator>-&gt;</operator><name>curdelta</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>split1</name><operator>-&gt;</operator><name>curdelta</name></name> <operator>&lt;</operator> <name><name>split2</name><operator>-&gt;</operator><name>curdelta</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine to determine whether or not a non-rightmost leaf page should be
 * split immediately after the would-be original page offset for the
 * new/incoming tuple (or should have leaf fillfactor applied when new item is
 * to the right on original page).  This is appropriate when there is a
 * pattern of localized monotonically increasing insertions into a composite
 * index, where leading attribute values form local groupings, and we
 * anticipate further insertions of the same/current grouping (new item's
 * grouping) in the near future.  This can be thought of as a variation on
 * applying leaf fillfactor during rightmost leaf page splits, since cases
 * that benefit will converge on packing leaf pages leaffillfactor% full over
 * time.
 *
 * We may leave extra free space remaining on the rightmost page of a "most
 * significant column" grouping of tuples if that grouping never ends up
 * having future insertions that use the free space.  That effect is
 * self-limiting; a future grouping that becomes the "nearest on the right"
 * grouping of the affected grouping usually puts the extra free space to good
 * use.
 *
 * Caller uses optimization when routine returns true, though the exact action
 * taken by caller varies.  Caller uses original leaf page fillfactor in
 * standard way rather than using the new item offset directly when *usemult
 * was also set to true here.  Otherwise, caller applies optimization by
 * locating the legal split point that makes the new tuple the very last tuple
 * on the left side of the split.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_afternewitemoff</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>leaffillfactor</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>usemult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>nkeyatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keepnatts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>is_leaf</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>is_rightmost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nkeyatts</name> <operator>=</operator> <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Single key indexes not considered here */</comment>
	<if_stmt><if>if <condition>(<expr><name>nkeyatts</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Ascending insertion pattern never inferred when new item is first */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>newitemoff</name></name> <operator>==</operator> <name>P_FIRSTKEY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Only apply optimization on pages with equisized tuples, since ordinal
	 * keys are likely to be fixed-width.  Testing if the new tuple is
	 * variable width directly might also work, but that fails to apply the
	 * optimization to indexes with a numeric_ops attribute.
	 *
	 * Conclude that page has equisized tuples when the new item is the same
	 * width as the smallest item observed during pass over page, and other
	 * non-pivot tuples must be the same width as well.  (Note that the
	 * possibly-truncated existing high key isn't counted in
	 * olddataitemstotal, and must be subtracted from maxoff.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>newitemsz</name></name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>minfirstrightsz</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>newitemsz</name></name> <operator>*</operator> <operator>(</operator><name>maxoff</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>olddataitemstotal</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Avoid applying optimization when tuples are wider than a tuple
	 * consisting of two non-NULL int8/int64 attributes (or four non-NULL
	 * int4/int32 attributes)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>newitemsz</name></name> <operator>&gt;</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * At least the first attribute's value must be equal to the corresponding
	 * value in previous tuple to apply optimization.  New item cannot be a
	 * duplicate, either.
	 *
	 * Handle case where new item is to the right of all items on the existing
	 * page.  This is suggestive of monotonically increasing insertions in
	 * itself, so the "heap TID adjacency" test is not applied here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>newitemoff</name></name> <operator>&gt;</operator> <name>maxoff</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>keepnatts</name> <operator>=</operator> <call><name>_bt_keep_natts_fast</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>newitem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>keepnatts</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>keepnatts</name> <operator>&lt;=</operator> <name>nkeyatts</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>usemult</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * "Low cardinality leading column, high cardinality suffix column"
	 * indexes with a random insertion pattern (e.g., an index with a boolean
	 * column, such as an index on '(book_is_in_print, book_isbn)') present us
	 * with a risk of consistently misapplying the optimization.  We're
	 * willing to accept very occasional misapplication of the optimization,
	 * provided the cases where we get it wrong are rare and self-limiting.
	 *
	 * Heap TID adjacency strongly suggests that the item just to the left was
	 * inserted very recently, which limits overapplication of the
	 * optimization.  Besides, all inappropriate cases triggered here will
	 * still split in the middle of the page on average.
	 */</comment>
	<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>newitemoff</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Do cheaper test first */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_adjacenthtid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>newitem</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Check same conditions as rightmost item case, too */</comment>
	<expr_stmt><expr><name>keepnatts</name> <operator>=</operator> <call><name>_bt_keep_natts_fast</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>newitem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>keepnatts</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>keepnatts</name> <operator>&lt;=</operator> <name>nkeyatts</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>interp</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemoff</name></name> <operator>/</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>maxoff</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>leaffillfactormult</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <name>leaffillfactor</name> <operator>/</operator> <literal type="number">100.0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Don't allow caller to split after a new item when it will result in
		 * a split point to the right of the point that a leaf fillfactor
		 * split would use -- have caller apply leaf fillfactor instead
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>usemult</name> <operator>=</operator> <name>interp</name> <operator>&gt;</operator> <name>leaffillfactormult</name></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for determining if two heap TIDS are "adjacent".
 *
 * Adjacent means that the high TID is very likely to have been inserted into
 * heap relation immediately after the low TID, probably during the current
 * transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_adjacenthtid</name><parameter_list>(<parameter><decl><type><name>ItemPointer</name></type> <name>lowhtid</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>highhtid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lowblk</name></decl>,
				<decl><type ref="prev"/><name>highblk</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lowblk</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>lowhtid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>highblk</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>highhtid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make optimistic assumption of adjacency when heap blocks match */</comment>
	<if_stmt><if>if <condition>(<expr><name>lowblk</name> <operator>==</operator> <name>highblk</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* When heap block one up, second offset should be FirstOffsetNumber */</comment>
	<if_stmt><if>if <condition>(<expr><name>lowblk</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>highblk</name> <operator>&amp;&amp;</operator>
		<call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>highhtid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FirstOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine to find the "best" split point among candidate split points.
 * The best split point is the split point with the lowest penalty among split
 * points that fall within current/final split interval.  Penalty is an
 * abstract score, with a definition that varies depending on whether we're
 * splitting a leaf page or an internal page.  See _bt_split_penalty() for
 * details.
 *
 * "perfectpenalty" is assumed to be the lowest possible penalty among
 * candidate split points.  This allows us to return early without wasting
 * cycles on calculating the first differing attribute for all candidate
 * splits when that clearly cannot improve our choice (or when we only want a
 * minimally distinguishing split point, and don't want to make the split any
 * more unbalanced than is necessary).
 *
 * We return the index of the first existing tuple that should go on the right
 * page, plus a boolean indicating if new item is on left of split point.
 */</comment>
<function><type><specifier>static</specifier> <name>OffsetNumber</name></type>
<name>_bt_bestsplitloc</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>perfectpenalty</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newitemonleft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bestpenalty</name></decl>,
				<decl><type ref="prev"/><name>lowsplit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>highsplit</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>nsplits</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>bestpenalty</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lowsplit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>lowsplit</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>highsplit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>penalty</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>penalty</name> <operator>=</operator> <call><name>_bt_split_penalty</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>splits</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>penalty</name> <operator>&lt;=</operator> <name>perfectpenalty</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bestpenalty</name> <operator>=</operator> <name>penalty</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lowsplit</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>penalty</name> <operator>&lt;</operator> <name>bestpenalty</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bestpenalty</name> <operator>=</operator> <name>penalty</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lowsplit</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>newitemonleft</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>splits</name><index>[<expr><name>lowsplit</name></expr>]</index></name><operator>.</operator><name>newitemonleft</name></expr>;</expr_stmt>
	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>splits</name><index>[<expr><name>lowsplit</name></expr>]</index></name><operator>.</operator><name>firstoldonright</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine to decide whether split should use default strategy/initial
 * split interval, or whether it should finish splitting the page using
 * alternative strategies (this is only possible with leaf pages).
 *
 * Caller uses alternative strategy (or sticks with default strategy) based
 * on how *strategy is set here.  Return value is "perfect penalty", which is
 * passed to _bt_bestsplitloc() as a final constraint on how far caller is
 * willing to go to avoid appending a heap TID when using the many duplicates
 * strategy (it also saves _bt_bestsplitloc() useless cycles).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_bt_strategy</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>leftpage</name></decl></parameter>,
			 <parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>rightpage</name></decl></parameter>, <parameter><decl><type><name>FindSplitStrat</name> <modifier>*</modifier></type><name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>leftmost</name></decl>,
				<decl><type ref="prev"/><name>rightmost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>leftinterval</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rightinterval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>perfectpenalty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>indnkeyatts</name> <init>= <expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Assume that alternative strategy won't be used for now */</comment>
	<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>SPLIT_DEFAULT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use smallest observed first right item size for entire page as perfect
	 * penalty on internal pages.  This can save cycles in the common case
	 * where most or all splits (not just splits within interval) have first
	 * right tuples that are the same size.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>is_leaf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>minfirstrightsz</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Use leftmost and rightmost tuples from leftmost and rightmost splits in
	 * current split interval
	 */</comment>
	<expr_stmt><expr><call><name>_bt_interval_edges</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftinterval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightinterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftmost</name> <operator>=</operator> <call><name>_bt_split_lastleft</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>leftinterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightmost</name> <operator>=</operator> <call><name>_bt_split_firstright</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>rightinterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If initial split interval can produce a split point that will at least
	 * avoid appending a heap TID in new high key, we're done.  Finish split
	 * with default strategy and initial split interval.
	 */</comment>
	<expr_stmt><expr><name>perfectpenalty</name> <operator>=</operator> <call><name>_bt_keep_natts_fast</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>leftmost</name></expr></argument>, <argument><expr><name>rightmost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>perfectpenalty</name> <operator>&lt;=</operator> <name>indnkeyatts</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>perfectpenalty</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Work out how caller should finish split when even their "perfect"
	 * penalty for initial/default split interval indicates that the interval
	 * does not contain even a single split that avoids appending a heap TID.
	 *
	 * Use the leftmost split's lastleft tuple and the rightmost split's
	 * firstright tuple to assess every possible split.
	 */</comment>
	<expr_stmt><expr><name>leftmost</name> <operator>=</operator> <call><name>_bt_split_lastleft</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>leftpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightmost</name> <operator>=</operator> <call><name>_bt_split_firstright</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>rightpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If page (including new item) has many duplicates but is not entirely
	 * full of duplicates, a many duplicates strategy split will be performed.
	 * If page is entirely full of duplicates, a single value strategy split
	 * will be performed.
	 */</comment>
	<expr_stmt><expr><name>perfectpenalty</name> <operator>=</operator> <call><name>_bt_keep_natts_fast</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>leftmost</name></expr></argument>, <argument><expr><name>rightmost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>perfectpenalty</name> <operator>&lt;=</operator> <name>indnkeyatts</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>SPLIT_MANY_DUPLICATES</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Caller should choose the lowest delta split that avoids appending a
		 * heap TID.  Maximizing the number of attributes that can be
		 * truncated away (returning perfectpenalty when it happens to be less
		 * than the number of key attributes in index) can result in continual
		 * unbalanced page splits.
		 *
		 * Just avoiding appending a heap TID can still make splits very
		 * unbalanced, but this is self-limiting.  When final split has a very
		 * high delta, one side of the split will likely consist of a single
		 * value.  If that page is split once again, then that split will
		 * likely use the single value strategy.
		 */</comment>
		<return>return <expr><name>indnkeyatts</name></expr>;</return>
	</block_content>}</block></if>

	<comment type="block">/*
	 * Single value strategy is only appropriate with ever-increasing heap
	 * TIDs; otherwise, original default strategy split should proceed to
	 * avoid pathological performance.  Use page high key to infer if this is
	 * the rightmost page among pages that store the same duplicate value.
	 * This should not prevent insertions of heap TIDs that are slightly out
	 * of order from using single value strategy, since that's expected with
	 * concurrent inserters of the same duplicate value.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>is_rightmost</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>SPLIT_SINGLE_VALUE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>hikey</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hikey</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>perfectpenalty</name> <operator>=</operator> <call><name>_bt_keep_natts_fast</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>hikey</name></expr></argument>,
											 <argument><expr><name><name>state</name><operator>-&gt;</operator><name>newitem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>perfectpenalty</name> <operator>&lt;=</operator> <name>indnkeyatts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>SPLIT_SINGLE_VALUE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Have caller finish split using default strategy, since page
			 * does not appear to be the rightmost page for duplicates of the
			 * value the page is filled with
			 */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>perfectpenalty</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine to locate leftmost and rightmost splits for current/default
 * split interval.  Note that it will be the same split iff there is only one
 * split in interval.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_interval_edges</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier><modifier>*</modifier></type><name>leftinterval</name></decl></parameter>,
				   <parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier><modifier>*</modifier></type><name>rightinterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>highsplit</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>interval</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>nsplits</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>deltaoptimal</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>deltaoptimal</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>splits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>leftinterval</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>rightinterval</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delta is an absolute distance to optimal split point, so both the
	 * leftmost and rightmost split point will usually be at the end of the
	 * array
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>highsplit</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>distant</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>splits</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>distant</name><operator>-&gt;</operator><name>firstoldonright</name></name> <operator>&lt;</operator> <name><name>deltaoptimal</name><operator>-&gt;</operator><name>firstoldonright</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>leftinterval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>leftinterval</name> <operator>=</operator> <name>distant</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>distant</name><operator>-&gt;</operator><name>firstoldonright</name></name> <operator>&gt;</operator> <name><name>deltaoptimal</name><operator>-&gt;</operator><name>firstoldonright</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rightinterval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>rightinterval</name> <operator>=</operator> <name>distant</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>distant</name><operator>-&gt;</operator><name>newitemonleft</name></name> <operator>&amp;&amp;</operator> <name><name>deltaoptimal</name><operator>-&gt;</operator><name>newitemonleft</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * "incoming tuple will become first on right page" (distant) is
			 * to the left of "incoming tuple will become last on left page"
			 * (delta-optimal)
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>distant</name><operator>-&gt;</operator><name>firstoldonright</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>leftinterval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>leftinterval</name> <operator>=</operator> <name>distant</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>distant</name><operator>-&gt;</operator><name>newitemonleft</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>deltaoptimal</name><operator>-&gt;</operator><name>newitemonleft</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * "incoming tuple will become last on left page" (distant) is to
			 * the right of "incoming tuple will become first on right page"
			 * (delta-optimal)
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>distant</name><operator>-&gt;</operator><name>firstoldonright</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rightinterval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>rightinterval</name> <operator>=</operator> <name>distant</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* There was only one or two splits in initial split interval */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>distant</name> <operator>==</operator> <name>deltaoptimal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>leftinterval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>leftinterval</name> <operator>=</operator> <name>distant</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rightinterval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>rightinterval</name> <operator>=</operator> <name>distant</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>leftinterval</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>rightinterval</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine to find penalty for caller's candidate split point.
 *
 * On leaf pages, penalty is the attribute number that distinguishes each side
 * of a split.  It's the last attribute that needs to be included in new high
 * key for left page.  It can be greater than the number of key attributes in
 * cases where a heap TID will need to be appended during truncation.
 *
 * On internal pages, penalty is simply the size of the first item on the
 * right half of the split (including line pointer overhead).  This tuple will
 * become the new high key for the left page.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>_bt_split_penalty</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>split</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>lastleftuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>firstrighttuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>is_leaf</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>split</name><operator>-&gt;</operator><name>newitemonleft</name></name> <operator>&amp;&amp;</operator>
			<name><name>split</name><operator>-&gt;</operator><name>firstoldonright</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemoff</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>newitemsz</name></name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>split</name><operator>-&gt;</operator><name>firstoldonright</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>lastleftuple</name> <operator>=</operator> <call><name>_bt_split_lastleft</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>split</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstrighttuple</name> <operator>=</operator> <call><name>_bt_split_firstright</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>split</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lastleftuple</name> <operator>!=</operator> <name>firstrighttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>_bt_keep_natts_fast</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>lastleftuple</name></expr></argument>, <argument><expr><name>firstrighttuple</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine to get a lastleft IndexTuple for a spit point from page
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>IndexTuple</name></type>
<name>_bt_split_lastleft</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>split</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>split</name><operator>-&gt;</operator><name>newitemonleft</name></name> <operator>&amp;&amp;</operator> <name><name>split</name><operator>-&gt;</operator><name>firstoldonright</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemoff</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>newitem</name></name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
						   <argument><expr><call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name><name>split</name><operator>-&gt;</operator><name>firstoldonright</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine to get a firstright IndexTuple for a spit point from page
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>IndexTuple</name></type>
<name>_bt_split_firstright</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SplitPoint</name> <modifier>*</modifier></type><name>split</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>split</name><operator>-&gt;</operator><name>newitemonleft</name></name> <operator>&amp;&amp;</operator> <name><name>split</name><operator>-&gt;</operator><name>firstoldonright</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemoff</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>newitem</name></name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>split</name><operator>-&gt;</operator><name>firstoldonright</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
