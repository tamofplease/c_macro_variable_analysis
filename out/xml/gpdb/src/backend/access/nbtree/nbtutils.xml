<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/nbtree/nbtutils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nbtutils.c
 *	  Utility code for Postgres btree implementation.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/nbtree/nbtutils.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct <name>BTSortArrayContext</name>
<block>{
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reverse</name></decl>;</decl_stmt>
}</block></struct></type> <name>BTSortArrayContext</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>_bt_find_extreme_element</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>,
									  <parameter><decl><type><name>StrategyNumber</name></type> <name>strat</name></decl></parameter>,
									  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_bt_sort_array_elements</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>reverse</name></decl></parameter>,
									<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_bt_compare_array_elements</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_compare_scankey_args</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>op</name></decl></parameter>,
									 <parameter><decl><type><name>ScanKey</name></type> <name>leftarg</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>rightarg</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_fix_scankey_strategy</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>indoption</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_mark_scankey_required</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_check_rowcompare</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>,
								 <parameter><decl><type><name>IndexTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tupnatts</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
								 <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>continuescan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>_bt_keep_natts</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>lastleft</name></decl></parameter>,
						   <parameter><decl><type><name>IndexTuple</name></type> <name>firstright</name></decl></parameter>, <parameter><decl><type><name>BTScanInsert</name></type> <name>itup_key</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * _bt_mkscankey
 *		Build an insertion scan key that contains comparison data from itup
 *		as well as comparator routines appropriate to the key datatypes.
 *
 *		When itup is a non-pivot tuple, the returned insertion scan key is
 *		suitable for finding a place for it to go on the leaf level.  Pivot
 *		tuples can be used to re-find leaf page with matching high key, but
 *		then caller needs to set scan key's pivotsearch field to true.  This
 *		allows caller to search for a leaf page with a matching high key,
 *		which is usually to the left of the first leaf page a non-pivot match
 *		might appear on.
 *
 *		The result is intended for use with _bt_compare() and _bt_truncate().
 *		Callers that don't need to fill out the insertion scankey arguments
 *		(e.g. they use an ad-hoc comparison routine, or only need a scankey
 *		for _bt_truncate()) can pass a NULL index tuple.  The scankey will
 *		be initialized as if an "all truncated" pivot tuple was passed
 *		instead.
 *
 *		Note that we may occasionally have to share lock the metapage to
 *		determine whether or not the keys in the index are expected to be
 *		unique (i.e. if this is a "heapkeyspace" index).  We assume a
 *		heapkeyspace index when caller passes a NULL tuple, allowing index
 *		build callers to avoid accessing the non-existent metapage.
 */</comment>
<function><type><name>BTScanInsert</name></type>
<name>_bt_mkscankey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTScanInsert</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>itupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>indnkeyatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>indoption</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tupnatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>itupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indnkeyatts</name> <operator>=</operator> <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indoption</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_indoption</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupnatts</name> <operator>=</operator> <ternary><condition><expr><name>itup</name></expr> ?</condition><then> <expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupnatts</name> <operator>&lt;=</operator> <call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We'll execute search using scan key constructed on key columns.
	 * Truncated attributes and non-key attributes are omitted from the final
	 * scan key.
	 */</comment>
	<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BTScanInsertData</name></expr></argument>, <argument><expr><name>scankeys</name></expr></argument>)</argument_list></call> <operator>+</operator>
				 <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>heapkeyspace</name></name> <operator>=</operator> <name>itup</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>_bt_heapkeyspace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>anynullkeys</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* initial assumption */</comment>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nextkey</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>pivotsearch</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>keysz</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>indnkeyatts</name></expr></argument>, <argument><expr><name>tupnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>scantid</name></name> <operator>=</operator> <ternary><condition><expr><name><name>key</name><operator>-&gt;</operator><name>heapkeyspace</name></name> <operator>&amp;&amp;</operator> <name>itup</name></expr> ?</condition><then>
		<expr><call><name>BTreeTupleGetHeapTID</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>skey</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>scankeys</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indnkeyatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>procinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>arg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>null</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We can use the cached (default) support procs since no cross-type
		 * comparison can be needed.
		 */</comment>
		<expr_stmt><expr><name>procinfo</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Key arguments built from truncated attributes (or when caller
		 * provides no tuple) are defensively represented as NULL values. They
		 * should never be used.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>tupnatts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>null</name></expr> ?</condition><then> <expr><name>SK_ISNULL</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>indoption</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <name>SK_BT_INDOPTION_SHIFT</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyEntryInitializeWithInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name>flags</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
									   <argument><expr><name>InvalidStrategy</name></expr></argument>,
									   <argument><expr><name>InvalidOid</name></expr></argument>,
									   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name>procinfo</name></expr></argument>,
									   <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Record if any key attribute is NULL (or truncated) */</comment>
		<if_stmt><if>if <condition>(<expr><name>null</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>anynullkeys</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>key</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * free a retracement stack made by _bt_search.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_freestack</name><parameter_list>(<parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTStack</name></type>		<name>ostack</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>stack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ostack</name> <operator>=</operator> <name>stack</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>bts_parent</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ostack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 *	_bt_preprocess_array_keys() -- Preprocess SK_SEARCHARRAY scan keys
 *
 * If there are any SK_SEARCHARRAY scan keys, deconstruct the array(s) and
 * set up BTArrayKeyInfo info for each one that is an equality-type key.
 * Prepare modified scan keys in so-&gt;arrayKeyData, which will hold the current
 * array elements during each primitive indexscan operation.  For inequality
 * array keys, it's sufficient to find the extreme element value and replace
 * the whole array with that scalar value.
 *
 * Note: the reason we need so-&gt;arrayKeyData, rather than just scribbling
 * on scan-&gt;keyData, is that callers are permitted to call btrescan without
 * supplying a new set of scankey data.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_preprocess_array_keys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfKeys</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>indoption</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name><operator>-&gt;</operator><name>rd_indoption</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numArrayKeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<comment type="block">/* Quick check to see if there are any array keys */</comment>
	<expr_stmt><expr><name>numArrayKeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfKeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHARRAY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numArrayKeys</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_ROW_HEADER</name> <operator>|</operator> <name>SK_SEARCHNULL</name> <operator>|</operator> <name>SK_SEARCHNOTNULL</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* If any arrays are null as a whole, we can quit right now. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Quit if nothing to do. */</comment>
	<if_stmt><if>if <condition>(<expr><name>numArrayKeys</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make a scan-lifespan context to hold array-associated data, or reset it
	 * if we already have one from a previous rescan cycle.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>arrayContext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayContext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
												 <argument><expr><literal type="string">"BTree array context"</literal></expr></argument>,
												 <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>arrayContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>arrayContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create modifiable copy of scan-&gt;keyData in the workspace context */</comment>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name></name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name></name></expr></argument>,
		   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name></expr></argument>,
		   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate space for per-array data in the workspace context */</comment>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name></name> <operator>=</operator> <operator>(</operator><name>BTArrayKeyInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numArrayKeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BTArrayKeyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now process each array key */</comment>
	<expr_stmt><expr><name>numArrayKeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfKeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arrayval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>elmlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>elmbyval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>elmalign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_elems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elem_values</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>elem_nulls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_nonnulls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHARRAY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * First, deconstruct the array into elements.  Anything allocated
		 * here (including a possibly detoasted array value) is in the
		 * workspace context.
		 */</comment>
		<expr_stmt><expr><name>arrayval</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We could cache this data, but not clear it's worth it */</comment>
		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>elmlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>,
						  <argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>elem_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compress out any null elements.  We can ignore them since we assume
		 * all btree operators are strict.
		 */</comment>
		<expr_stmt><expr><name>num_nonnulls</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_elems</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elem_nulls</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>elem_values</name><index>[<expr><name>num_nonnulls</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>elem_values</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* We could pfree(elem_nulls) now, but not worth the cycles */</comment>

		<comment type="block">/* If there's no non-nulls, the scan qual is unsatisfiable */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_nonnulls</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numArrayKeys</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the comparison operator is not equality, then the array qual
		 * degenerates to a simple comparison against the smallest or largest
		 * non-null array element, as appropriate.
		 */</comment>
		<switch>switch <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
			<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator>
					<call><name>_bt_find_extreme_element</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>,
											 <argument><expr><name>BTGreaterStrategyNumber</name></expr></argument>,
											 <argument><expr><name>elem_values</name></expr></argument>, <argument><expr><name>num_nonnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
				<comment type="block">/* proceed with rest of loop */</comment>
				<break>break;</break>
			<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
			<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator>
					<call><name>_bt_find_extreme_element</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>,
											 <argument><expr><name>BTLessStrategyNumber</name></expr></argument>,
											 <argument><expr><name>elem_values</name></expr></argument>, <argument><expr><name>num_nonnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized StrategyNumber: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cur</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Sort the non-null elements and eliminate any duplicates.  We must
		 * sort in the same ordering used by the index column, so that the
		 * successive primitive indexscans produce data in index order.
		 */</comment>
		<expr_stmt><expr><name>num_elems</name> <operator>=</operator> <call><name>_bt_sort_array_elements</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>,
											<argument><expr><operator>(</operator><name><name>indoption</name><index>[<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>INDOPTION_DESC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>,
											<argument><expr><name>elem_values</name></expr></argument>, <argument><expr><name>num_nonnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * And set up the BTArrayKeyInfo data.
		 */</comment>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>numArrayKeys</name></expr>]</index></name><operator>.</operator><name>scan_key</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>numArrayKeys</name></expr>]</index></name><operator>.</operator><name>num_elems</name> <operator>=</operator> <name>num_elems</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>numArrayKeys</name></expr>]</index></name><operator>.</operator><name>elem_values</name> <operator>=</operator> <name>elem_values</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numArrayKeys</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name> <operator>=</operator> <name>numArrayKeys</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_find_extreme_element() -- get least or greatest array element
 *
 * scan and skey identify the index column, whose opfamily determines the
 * comparison semantics.  strat should be BTLessStrategyNumber to get the
 * least element, or BTGreaterStrategyNumber to get the greatest.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>_bt_find_extreme_element</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>,
						 <parameter><decl><type><name>StrategyNumber</name></type> <name>strat</name></decl></parameter>,
						 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elemtype</name></decl>,
				<decl><type ref="prev"/><name>cmp_op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>cmp_proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>flinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Determine the nominal datatype of the array elements.  We have to
	 * support the convention that sk_subtype == InvalidOid means the opclass
	 * input type; this is a hack to simplify life for ScanKeyInit().
	 */</comment>
	<expr_stmt><expr><name>elemtype</name> <operator>=</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>elemtype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>elemtype</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look up the appropriate comparison operator in the opfamily.
	 *
	 * Note: it's possible that this would fail, if the opfamily is
	 * incomplete, but it seems quite unlikely that an opfamily would omit
	 * non-cross-type comparison operators for any datatype that it supports
	 * at all.
	 */</comment>
	<expr_stmt><expr><name>cmp_op</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
								 <argument><expr><name>elemtype</name></expr></argument>,
								 <argument><expr><name>elemtype</name></expr></argument>,
								 <argument><expr><name>strat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cmp_op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
			 <argument><expr><name>strat</name></expr></argument>, <argument><expr><name>elemtype</name></expr></argument>, <argument><expr><name>elemtype</name></expr></argument>,
			 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>cmp_proc</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>cmp_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegProcedureIsValid</name><argument_list>(<argument><expr><name>cmp_proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing oprcode for operator %u"</literal></expr></argument>, <argument><expr><name>cmp_op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>cmp_proc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nelems</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>elems</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>,
										   <argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
										   <argument><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										   <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_sort_array_elements() -- sort and de-dup array elements
 *
 * The array elements are sorted in-place, and the new number of elements
 * after duplicate removal is returned.
 *
 * scan and skey identify the index column, whose opfamily determines the
 * comparison semantics.  If reverse is true, we sort in descending order.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_bt_sort_array_elements</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>reverse</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>elems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elemtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>cmp_proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTSortArrayContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>last_non_dup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>nelems</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no work to do */</comment>

	<comment type="block">/*
	 * Determine the nominal datatype of the array elements.  We have to
	 * support the convention that sk_subtype == InvalidOid means the opclass
	 * input type; this is a hack to simplify life for ScanKeyInit().
	 */</comment>
	<expr_stmt><expr><name>elemtype</name> <operator>=</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>elemtype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>elemtype</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look up the appropriate comparison function in the opfamily.
	 *
	 * Note: it's possible that this would fail, if the opfamily is
	 * incomplete, but it seems quite unlikely that an opfamily would omit
	 * non-cross-type support functions for any datatype that it supports at
	 * all.
	 */</comment>
	<expr_stmt><expr><name>cmp_proc</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
								 <argument><expr><name>elemtype</name></expr></argument>,
								 <argument><expr><name>elemtype</name></expr></argument>,
								 <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegProcedureIsValid</name><argument_list>(<argument><expr><name>cmp_proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing support function %d(%u,%u) in opfamily %u"</literal></expr></argument>,
			 <argument><expr><name>BTORDER_PROC</name></expr></argument>, <argument><expr><name>elemtype</name></expr></argument>, <argument><expr><name>elemtype</name></expr></argument>,
			 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Sort the array elements */</comment>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>cmp_proc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cxt</name><operator>.</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>collation</name></name> <operator>=</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_collation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>reverse</name></name> <operator>=</operator> <name>reverse</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>elems</name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>_bt_compare_array_elements</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now scan the sorted elements and remove duplicates */</comment>
	<expr_stmt><expr><name>last_non_dup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>compare</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cxt</name><operator>.</operator><name>flinfo</name></name></expr></argument>,
												  <argument><expr><name><name>cxt</name><operator>.</operator><name>collation</name></name></expr></argument>,
												  <argument><expr><name><name>elems</name><index>[<expr><name>last_non_dup</name></expr>]</index></name></expr></argument>,
												  <argument><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>elems</name><index>[<expr><operator>++</operator><name>last_non_dup</name></expr>]</index></name> <operator>=</operator> <name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>last_non_dup</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_arg comparator for sorting array elements
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_bt_compare_array_elements</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>da</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Datum</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>db</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Datum</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTSortArrayContext</name> <modifier>*</modifier></type><name>cxt</name> <init>= <expr><operator>(</operator><name>BTSortArrayContext</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>compare</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cxt</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>,
											  <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>,
											  <argument><expr><name>da</name></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>reverse</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>INVERT_COMPARE_RESULT</name><argument_list>(<argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>compare</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_start_array_keys() -- Initialize array keys at start of a scan
 *
 * Set up the cur_elem counters and fill in the first sk_argument value for
 * each array scankey.  We can't do this until we know the scan direction.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_start_array_keys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTArrayKeyInfo</name> <modifier>*</modifier></type><name>curArrayKey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKey</name></type>		<name>skey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name><index>[<expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>scan_key</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>num_elems</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name> <operator>=</operator> <name><name>curArrayKey</name><operator>-&gt;</operator><name>num_elems</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <name><name>curArrayKey</name><operator>-&gt;</operator><name>elem_values</name><index>[<expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_advance_array_keys() -- Advance to next set of array elements
 *
 * Returns true if there is another set of values to consider, false if not.
 * On true result, the scankeys are initialized with the next set of values.
 */</comment>
<function><type><name>bool</name></type>
<name>_bt_advance_array_keys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must advance the last array key most quickly, since it will
	 * correspond to the lowest-order index column among the available
	 * qualifications. This is necessary to ensure correct ordering of output
	 * when there are multiple array keys.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTArrayKeyInfo</name> <modifier>*</modifier></type><name>curArrayKey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKey</name></type>		<name>skey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name><index>[<expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>scan_key</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cur_elem</name> <init>= <expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_elems</name> <init>= <expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>num_elems</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>--</operator><name>cur_elem</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cur_elem</name> <operator>=</operator> <name>num_elems</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* need to advance next array key */</comment>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>++</operator><name>cur_elem</name> <operator>&gt;=</operator> <name>num_elems</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cur_elem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* need to advance next array key */</comment>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name> <operator>=</operator> <name>cur_elem</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <name><name>curArrayKey</name><operator>-&gt;</operator><name>elem_values</name><index>[<expr><name>cur_elem</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* advance parallel scan */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>parallel_scan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_parallel_advance_array_keys</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_mark_array_keys() -- Handle array keys during btmarkpos
 *
 * Save the current state of the array keys as the "mark" position.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_mark_array_keys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTArrayKeyInfo</name> <modifier>*</modifier></type><name>curArrayKey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>mark_elem</name></name> <operator>=</operator> <name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_restore_array_keys() -- Handle array keys during btrestrpos
 *
 * Restore the array keys to where they were when the mark was set.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_restore_array_keys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Restore each array key to its position when the mark was set */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>numArrayKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTArrayKeyInfo</name> <modifier>*</modifier></type><name>curArrayKey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKey</name></type>		<name>skey</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name><index>[<expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>scan_key</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>mark_elem</name> <init>= <expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>mark_elem</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name> <operator>!=</operator> <name>mark_elem</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>curArrayKey</name><operator>-&gt;</operator><name>cur_elem</name></name> <operator>=</operator> <name>mark_elem</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <name><name>curArrayKey</name><operator>-&gt;</operator><name>elem_values</name><index>[<expr><name>mark_elem</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we changed any keys, we must redo _bt_preprocess_keys.  That might
	 * sound like overkill, but in cases with multiple keys per index column
	 * it seems necessary to do the full set of pushups.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>changed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>_bt_preprocess_keys</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* The mark should have been set on a consistent set of keys... */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	_bt_preprocess_keys() -- Preprocess scan keys
 *
 * The given search-type keys (in scan-&gt;keyData[] or so-&gt;arrayKeyData[])
 * are copied to so-&gt;keyData[] with possible transformation.
 * scan-&gt;numberOfKeys is the number of input keys, so-&gt;numberOfKeys gets
 * the number of output keys (possibly less, never greater).
 *
 * The output keys are marked with additional sk_flag bits beyond the
 * system-standard bits supplied by the caller.  The DESC and NULLS_FIRST
 * indoption bits for the relevant index attribute are copied into the flags.
 * Also, for a DESC column, we commute (flip) all the sk_strategy numbers
 * so that the index sorts in the desired direction.
 *
 * One key purpose of this routine is to discover which scan keys must be
 * satisfied to continue the scan.  It also attempts to eliminate redundant
 * keys and detect contradictory keys.  (If the index opfamily provides
 * incomplete sets of cross-type operators, we may fail to detect redundant
 * or contradictory keys, but we can survive that.)
 *
 * The output keys must be sorted by index attribute.  Presently we expect
 * (but verify) that the input keys are already so sorted --- this is done
 * by match_clauses_to_index() in indxpath.c.  Some reordering of the keys
 * within each attribute may be done as a byproduct of the processing here,
 * but no other code depends on that.
 *
 * The output keys are marked with flags SK_BT_REQFWD and/or SK_BT_REQBKWD
 * if they must be satisfied in order to continue the scan forward or backward
 * respectively.  _bt_checkkeys uses these flags.  For example, if the quals
 * are "x = 1 AND y &lt; 4 AND z &lt; 5", then _bt_checkkeys will reject a tuple
 * (1,2,7), but we must continue the scan in case there are tuples (1,3,z).
 * But once we reach tuples like (1,4,z) we can stop scanning because no
 * later tuples could match.  This is reflected by marking the x and y keys,
 * but not the z key, with SK_BT_REQFWD.  In general, the keys for leading
 * attributes with "=" keys are marked both SK_BT_REQFWD and SK_BT_REQBKWD.
 * For the first attribute without an "=" key, any "&lt;" and "&lt;=" keys are
 * marked SK_BT_REQFWD while any "&gt;" and "&gt;=" keys are marked SK_BT_REQBKWD.
 * This can be seen to be correct by considering the above example.  Note
 * in particular that if there are no keys for a given attribute, the keys for
 * subsequent attributes can never be required; for instance "WHERE y = 4"
 * requires a full-index scan.
 *
 * If possible, redundant keys are eliminated: we keep only the tightest
 * &gt;/&gt;= bound and the tightest &lt;/&lt;= bound, and if there's an = key then
 * that's the only one returned.  (So, we return either a single = key,
 * or one or two boundary-condition keys for each attr.)  However, if we
 * cannot compare two keys for lack of a suitable cross-type operator,
 * we cannot eliminate either.  If there are two such keys of the same
 * operator strategy, the second one is just pushed into the output array
 * without further processing here.  We may also emit both &gt;/&gt;= or both
 * &lt;/&lt;= keys if we can't compare them.  The logic about required keys still
 * works if we don't eliminate redundant keys.
 *
 * Note that one reason we need direction-sensitive required-key flags is
 * precisely that we may not be able to eliminate redundant keys.  Suppose
 * we have "x &gt; 4::int AND x &gt; 10::bigint", and we are unable to determine
 * which key is more restrictive for lack of a suitable cross-type operator.
 * _bt_first will arbitrarily pick one of the keys to do the initial
 * positioning with.  If it picks x &gt; 4, then the x &gt; 10 condition will fail
 * until we reach index entries &gt; 10; but we can't stop the scan just because
 * x &gt; 10 is failing.  On the other hand, if we are scanning backwards, then
 * failure of either key is indeed enough to stop the scan.  (In general, when
 * inequality keys are present, the initial-positioning code only promises to
 * position before the first possible match, not exactly at the first match,
 * for a forward scan; or after the last match for a backward scan.)
 *
 * As a byproduct of this work, we can detect contradictory quals such
 * as "x = 1 AND x &gt; 2".  If we see that, we return so-&gt;qual_ok = false,
 * indicating the scan need not be run at all since no tuples can match.
 * (In this case we do not bother completing the output key array!)
 * Again, missing cross-type operators might cause us to fail to prove the
 * quals contradictory when they really are, but the scan will work correctly.
 *
 * Row comparison keys are currently also treated without any smarts:
 * we just transfer them into the preprocessed array without any
 * editorialization.  We can treat them the same as an ordinary inequality
 * comparison on the row's first index column, for the purposes of the logic
 * about required keys.
 *
 * Note: the reason we have to copy the preprocessed scan keys into private
 * storage is that we are modifying the array based on comparisons of the
 * key argument values, which could change on a rescan or after moving to
 * new elements of array keys.  Therefore we can't overwrite the source data.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_preprocess_keys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfKeys</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>indoption</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name><operator>-&gt;</operator><name>rd_indoption</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>new_numberOfKeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfEqualCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>inkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>outkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name><name>xform</name><index>[<expr><name>BTMaxStrategyNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>test_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name></decl>;</decl_stmt>

	<comment type="block">/* initialize result variables */</comment>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>numberOfKeys</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* done if qual-less scan */</comment>

	<comment type="block">/*
	 * Read so-&gt;arrayKeyData if array keys are present, else scan-&gt;keyData
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inkeys</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>arrayKeyData</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>inkeys</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>outkeys</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>keyData</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>&amp;</operator><name><name>inkeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* we check that input keys are correctly ordered */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"btree index keys must be ordered by attribute"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We can short-circuit most of the work if there's just one key */</comment>
	<if_stmt><if>if <condition>(<expr><name>numberOfKeys</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Apply indoption to scankey (might change sk_strategy!) */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_fix_scankey_strategy</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>indoption</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outkeys</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<comment type="block">/* We can mark the qual as required if it's for first index col */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bt_mark_scankey_required</name><argument_list>(<argument><expr><name>outkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, do the full set of pushups.
	 */</comment>
	<expr_stmt><expr><name>new_numberOfKeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>numberOfEqualCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize for processing of keys for attr 1.
	 *
	 * xform[i] points to the currently best scan key of strategy type i+1; it
	 * is NULL if we haven't yet found such a key for this attr.
	 */</comment>
	<expr_stmt><expr><name>attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>xform</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xform</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop iterates from 0 to numberOfKeys inclusive; we use the last pass to
	 * handle after-last-key processing.  Actual exit from the loop is at the
	 * "break" statement below.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>cur</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>numberOfKeys</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Apply indoption to scankey (might change sk_strategy!) */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_fix_scankey_strategy</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>indoption</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* NULL can't be matched, so give up */</comment>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we are at the end of the keys for a particular attr, finish up
		 * processing and emit the cleaned-up keys.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>numberOfKeys</name> <operator>||</operator> <name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>!=</operator> <name>attno</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>priorNumberOfEqualCols</name> <init>= <expr><name>numberOfEqualCols</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* check input keys are correctly ordered */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>numberOfKeys</name> <operator>&amp;&amp;</operator> <name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>&lt;</operator> <name>attno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"btree index keys must be ordered by attribute"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If = has been specified, all other keys can be eliminated as
			 * redundant.  If we have a case like key = 1 AND key &gt; 2, we can
			 * set qual_ok to false and abandon further processing.
			 *
			 * We also have to deal with the case of "key IS NULL", which is
			 * unsatisfiable in combination with any other index condition. By
			 * the time we get here, that's been classified as an equality
			 * check, and we've rejected any combination of it with a regular
			 * equality condition; but not with other types of conditions.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>xform</name><index>[<expr><name>BTEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScanKey</name></type>		<name>eq</name> <init>= <expr><name><name>xform</name><index>[<expr><name>BTEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>BTMaxStrategyNumber</name></expr>;</init> <condition><expr><operator>--</operator><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ScanKey</name></type>		<name>chk</name> <init>= <expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>chk</name> <operator>||</operator> <name>j</name> <operator>==</operator> <operator>(</operator><name>BTEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>eq</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNULL</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* IS NULL is contradictory to anything else */</comment>
						<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<return>return;</return>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>_bt_compare_scankey_args</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>chk</name></expr></argument>, <argument><expr><name>eq</name></expr></argument>, <argument><expr><name>chk</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>test_result</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>test_result</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* keys proven mutually contradictory */</comment>
							<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<return>return;</return>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/* else discard the redundant non-equality key */</comment>
						<expr_stmt><expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* else, cannot determine redundancy, keep both keys */</comment>
				</block_content>}</block></for>
				<comment type="block">/* track number of attrs for which we have "=" keys */</comment>
				<expr_stmt><expr><name>numberOfEqualCols</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* try to keep only one of &lt;, &lt;= */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>xform</name><index>[<expr><name>BTLessStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>
				<operator>&amp;&amp;</operator> <name><name>xform</name><index>[<expr><name>BTLessEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScanKey</name></type>		<name>lt</name> <init>= <expr><name><name>xform</name><index>[<expr><name>BTLessStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ScanKey</name></type>		<name>le</name> <init>= <expr><name><name>xform</name><index>[<expr><name>BTLessEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>_bt_compare_scankey_args</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>le</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>, <argument><expr><name>le</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>test_result</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>test_result</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>xform</name><index>[<expr><name>BTLessEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>xform</name><index>[<expr><name>BTLessStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* try to keep only one of &gt;, &gt;= */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>xform</name><index>[<expr><name>BTGreaterStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>
				<operator>&amp;&amp;</operator> <name><name>xform</name><index>[<expr><name>BTGreaterEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScanKey</name></type>		<name>gt</name> <init>= <expr><name><name>xform</name><index>[<expr><name>BTGreaterStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ScanKey</name></type>		<name>ge</name> <init>= <expr><name><name>xform</name><index>[<expr><name>BTGreaterEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>_bt_compare_scankey_args</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ge</name></expr></argument>, <argument><expr><name>gt</name></expr></argument>, <argument><expr><name>ge</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>test_result</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>test_result</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>xform</name><index>[<expr><name>BTGreaterEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>xform</name><index>[<expr><name>BTGreaterStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Emit the cleaned-up keys into the outkeys[] array, and then
			 * mark them if they are required.  They are required (possibly
			 * only in one direction) if all attrs before this one had "=".
			 */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>BTMaxStrategyNumber</name></expr>;</init> <condition><expr><operator>--</operator><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ScanKey</name></type>		<name>outkey</name> <init>= <expr><operator>&amp;</operator><name><name>outkeys</name><index>[<expr><name>new_numberOfKeys</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outkey</name></expr></argument>, <argument><expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>priorNumberOfEqualCols</name> <operator>==</operator> <name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>_bt_mark_scankey_required</name><argument_list>(<argument><expr><name>outkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Exit loop here if done.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>numberOfKeys</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* Re-initialize for new attno */</comment>
			<expr_stmt><expr><name>attno</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>xform</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xform</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check strategy this key's operator corresponds to */</comment>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/* if row comparison, push it directly to the output array */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_HEADER</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ScanKey</name></type>		<name>outkey</name> <init>= <expr><operator>&amp;</operator><name><name>outkeys</name><index>[<expr><name>new_numberOfKeys</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outkey</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>numberOfEqualCols</name> <operator>==</operator> <name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>_bt_mark_scankey_required</name><argument_list>(<argument><expr><name>outkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We don't support RowCompare using equality; such a qual would
			 * mess up the numberOfEqualCols tracking.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>!=</operator> <operator>(</operator><name>BTEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* have we seen one of these before? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* nope, so remember this scankey */</comment>
			<expr_stmt><expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* yup, keep only the more restrictive key */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>_bt_compare_scankey_args</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>test_result</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>test_result</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>xform</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>j</name> <operator>==</operator> <operator>(</operator><name>BTEqualStrategyNumber</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* key == a &amp;&amp; key == b, but a != b */</comment>
					<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* else old key is more restrictive, keep it */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We can't determine which key is more restrictive.  Keep the
				 * previous one in xform[j] and push this one directly to the
				 * output array.
				 */</comment>
				<decl_stmt><decl><type><name>ScanKey</name></type>		<name>outkey</name> <init>= <expr><operator>&amp;</operator><name><name>outkeys</name><index>[<expr><name>new_numberOfKeys</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outkey</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>numberOfEqualCols</name> <operator>==</operator> <name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>_bt_mark_scankey_required</name><argument_list>(<argument><expr><name>outkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>=</operator> <name>new_numberOfKeys</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two scankey values using a specified operator.
 *
 * The test we want to perform is logically "leftarg op rightarg", where
 * leftarg and rightarg are the sk_argument values in those ScanKeys, and
 * the comparison operator is the one in the op ScanKey.  However, in
 * cross-data-type situations we may need to look up the correct operator in
 * the index's opfamily: it is the one having amopstrategy = op-&gt;sk_strategy
 * and amoplefttype/amoprighttype equal to the two argument datatypes.
 *
 * If the opfamily doesn't supply a complete set of cross-type operators we
 * may not be able to make the comparison.  If we can make the comparison
 * we store the operator result in *result and return true.  We return false
 * if the comparison could not be made.
 *
 * Note: op always points at the same ScanKey as either leftarg or rightarg.
 * Since we don't scribble on the scankeys, this aliasing should cause no
 * trouble.
 *
 * Note: this routine needs to be insensitive to any DESC option applied
 * to the index column.  For example, "x &lt; 4" is a tighter constraint than
 * "x &lt; 5" regardless of which way the index is sorted.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_compare_scankey_args</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>op</name></decl></parameter>,
						 <parameter><decl><type><name>ScanKey</name></type> <name>leftarg</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>rightarg</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>lefttype</name></decl>,
				<decl><type ref="prev"/><name>righttype</name></decl>,
				<decl><type ref="prev"/><name>optype</name></decl>,
				<decl><type ref="prev"/><name>opcintype</name></decl>,
				<decl><type ref="prev"/><name>cmp_op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strat</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First, deal with cases where one or both args are NULL.  This should
	 * only happen when the scankeys represent IS NULL/NOT NULL conditions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>leftarg</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|</operator> <name><name>rightarg</name><operator>-&gt;</operator><name>sk_flags</name></name><operator>)</operator> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>leftnull</name></decl>,
					<decl><type ref="prev"/><name>rightnull</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_SEARCHNULL</name> <operator>|</operator> <name>SK_SEARCHNOTNULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>leftnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>leftnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rightarg</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rightarg</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_SEARCHNULL</name> <operator>|</operator> <name>SK_SEARCHNOTNULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rightnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>rightnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * We treat NULL as either greater than or less than all other values.
		 * Since true &gt; false, the tests below work correctly for NULLS LAST
		 * logic.  If the index is NULLS FIRST, we need to flip the strategy.
		 */</comment>
		<expr_stmt><expr><name>strat</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>strat</name> <operator>=</operator> <call><name>BTCommuteStrategyNumber</name><argument_list>(<argument><expr><name>strat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>strat</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>leftnull</name> <operator>&lt;</operator> <name>rightnull</name><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>leftnull</name> <operator>&lt;=</operator> <name>rightnull</name><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>leftnull</name> <operator>==</operator> <name>rightnull</name><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>leftnull</name> <operator>&gt;=</operator> <name>rightnull</name><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>leftnull</name> <operator>&gt;</operator> <name>rightnull</name><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized StrategyNumber: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>strat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The opfamily we need to worry about is identified by the index column.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>==</operator> <name><name>rightarg</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>opcintype</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine the actual datatypes of the ScanKey arguments.  We have to
	 * support the convention that sk_subtype == InvalidOid means the opclass
	 * input type; this is a hack to simplify life for ScanKeyInit().
	 */</comment>
	<expr_stmt><expr><name>lefttype</name> <operator>=</operator> <name><name>leftarg</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lefttype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lefttype</name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>righttype</name> <operator>=</operator> <name><name>rightarg</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>righttype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>righttype</name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>optype</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>optype</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>optype</name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If leftarg and rightarg match the types expected for the "op" scankey,
	 * we can use its already-looked-up comparison function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lefttype</name> <operator>==</operator> <name>opcintype</name> <operator>&amp;&amp;</operator> <name>righttype</name> <operator>==</operator> <name>optype</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>,
												 <argument><expr><name><name>op</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
												 <argument><expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>,
												 <argument><expr><name><name>rightarg</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, we need to go to the syscache to find the appropriate
	 * operator.  (This cannot result in infinite recursion, since no
	 * indexscan initiated by syscache lookup will use cross-data-type
	 * operators.)
	 *
	 * If the sk_strategy was flipped by _bt_fix_scankey_strategy, we have to
	 * un-flip it to get the correct opfamily member.
	 */</comment>
	<expr_stmt><expr><name>strat</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>strat</name> <operator>=</operator> <call><name>BTCommuteStrategyNumber</name><argument_list>(<argument><expr><name>strat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cmp_op</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
								 <argument><expr><name>lefttype</name></expr></argument>,
								 <argument><expr><name>righttype</name></expr></argument>,
								 <argument><expr><name>strat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cmp_op</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RegProcedure</name></type> <name>cmp_proc</name> <init>= <expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>cmp_op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RegProcedureIsValid</name><argument_list>(<argument><expr><name>cmp_proc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>OidFunctionCall2Coll</name><argument_list>(<argument><expr><name>cmp_proc</name></expr></argument>,
														<argument><expr><name><name>op</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
														<argument><expr><name><name>leftarg</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>,
														<argument><expr><name><name>rightarg</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Can't make the comparison */</comment>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>			<comment type="block">/* suppress compiler warnings */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust a scankey's strategy and flags setting as needed for indoptions.
 *
 * We copy the appropriate indoption value into the scankey sk_flags
 * (shifting to avoid clobbering system-defined flag bits).  Also, if
 * the DESC option is set, commute (flip) the operator strategy number.
 *
 * A secondary purpose is to check for IS NULL/NOT NULL scankeys and set up
 * the strategy field correctly for them.
 *
 * Lastly, for ordinary scankeys (not IS NULL/NOT NULL), we check for a
 * NULL comparison value.  Since all btree operators are assumed strict,
 * a NULL means that the qual cannot be satisfied.  We return true if the
 * comparison value isn't NULL, or false if the scan should be abandoned.
 *
 * This function is applied to the *input* scankey structure; therefore
 * on a rescan we will be looking at already-processed scankeys.  Hence
 * we have to be careful not to re-commute the strategy if we already did it.
 * It's a bit ugly to modify the caller's copy of the scankey but in practice
 * there shouldn't be any problem, since the index's indoptions are certainly
 * not going to change while the scankey survives.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_fix_scankey_strategy</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>indoption</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>addflags</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>addflags</name> <operator>=</operator> <name><name>indoption</name><index>[<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>SK_BT_INDOPTION_SHIFT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We treat all btree operators as strict (even if they're not so marked
	 * in pg_proc). This means that it is impossible for an operator condition
	 * with a NULL comparison constant to succeed, and we can reject it right
	 * away.
	 *
	 * However, we now also support "x IS NULL" clauses as search conditions,
	 * so in that case keep going. The planner has not filled in any
	 * particular strategy in this case, so set it to BTEqualStrategyNumber
	 * --- we can treat IS NULL as an equality operator for purposes of search
	 * strategy.
	 *
	 * Likewise, "x IS NOT NULL" is supported.  We treat that as either "less
	 * than NULL" in a NULLS LAST index, or "greater than NULL" in a NULLS
	 * FIRST index.
	 *
	 * Note: someday we might have to fill in sk_collation from the index
	 * column's collation.  At the moment this is a non-issue because we'll
	 * never actually call the comparison operator on a NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* SK_ISNULL shouldn't be set in a row header scankey */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_HEADER</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set indoption flags in scankey (might be done already) */</comment>
		<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|=</operator> <name>addflags</name></expr>;</expr_stmt>

		<comment type="block">/* Set correct strategy for IS NULL or NOT NULL search */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_subtype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNOTNULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>=</operator> <name>BTGreaterStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>=</operator> <name>BTLessStrategyNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_subtype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* regular qual, so it cannot be satisfied */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Needn't do the rest */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Adjust strategy for DESC, if we didn't already */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>addflags</name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>=</operator> <call><name>BTCommuteStrategyNumber</name><argument_list>(<argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|=</operator> <name>addflags</name></expr>;</expr_stmt>

	<comment type="block">/* If it's a row header, fix row member flags and strategies similarly */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_HEADER</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanKey</name></type>		<name>subkey</name> <init>= <expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>addflags</name> <operator>=</operator> <name><name>indoption</name><index>[<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>SK_BT_INDOPTION_SHIFT</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>addflags</name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>=</operator> <call><name>BTCommuteStrategyNumber</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|=</operator> <name>addflags</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_END</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>subkey</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Mark a scankey as "required to continue the scan".
 *
 * Depending on the operator type, the key may be required for both scan
 * directions or just one.  Also, if the key is a row comparison header,
 * we have to mark its first subsidiary ScanKey as required.  (Subsequent
 * subsidiary ScanKeys are normally for lower-order columns, and thus
 * cannot be required, since they're after the first non-equality scankey.)
 *
 * Note: when we set required-key flag bits in a subsidiary scankey, we are
 * scribbling on a data structure belonging to the index AM's caller, not on
 * our private copy.  This should be OK because the marking will not change
 * from scan to scan within a query, and so we'd just re-mark the same way
 * anyway on a rescan.  Something to keep an eye on though.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_mark_scankey_required</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>addflags</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
		<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>addflags</name> <operator>=</operator> <name>SK_BT_REQFWD</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>addflags</name> <operator>=</operator> <name>SK_BT_REQFWD</name> <operator>|</operator> <name>SK_BT_REQBKWD</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
		<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>addflags</name> <operator>=</operator> <name>SK_BT_REQBKWD</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized StrategyNumber: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>addflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|=</operator> <name>addflags</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_HEADER</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanKey</name></type>		<name>subkey</name> <init>= <expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* First subkey should be same column/operator as the header */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>==</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>==</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>|=</operator> <name>addflags</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether an indextuple satisfies all the scankey conditions.
 *
 * Return true if so, false if not.  If the tuple fails to pass the qual,
 * we also determine whether there's any need to continue the scan beyond
 * this tuple, and set *continuescan accordingly.  See comments for
 * _bt_preprocess_keys(), above, about how this is done.
 *
 * Forward scan callers can pass a high key tuple in the hopes of having
 * us set *continuescan to false, and avoiding an unnecessary visit to
 * the page to the right.
 *
 * scan: index scan descriptor (containing a search-type scankey)
 * tuple: index tuple to test
 * tupnatts: number of attributes in tupnatts (high key may be truncated)
 * dir: direction we are scanning in
 * continuescan: output parameter (will be set correctly in all cases)
 */</comment>
<function><type><name>bool</name></type>
<name>_bt_checkkeys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tupnatts</name></decl></parameter>,
			  <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>continuescan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keysz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>key</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>tupnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* default assumption */</comment>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>so</name> <operator>=</operator> <operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>keysz</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>key</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>keyData</name></name></expr><operator>,</operator> <expr><name>ikey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ikey</name> <operator>&lt;</operator> <name>keysz</name></expr>;</condition> <incr><expr><name>key</name><operator>++</operator></expr><operator>,</operator> <expr><name>ikey</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>test</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>&gt;</operator> <name>tupnatts</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This attribute is truncated (must be high key).  The value for
			 * this attribute in the first non-pivot tuple on the page to the
			 * right could be any possible value.  Assume that truncated
			 * attribute passes the qual.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* row-comparison keys need special processing */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_HEADER</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>_bt_check_rowcompare</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupnatts</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>,
									 <argument><expr><name>continuescan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
							  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>,
							  <argument><expr><name>tupdesc</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Handle IS NULL/NOT NULL tests */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* tuple satisfies this qual */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* tuple satisfies this qual */</comment>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Tuple fails this qual.  If it's a required qual for the current
			 * scan direction, then we can conclude no further tuples will
			 * pass, either.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQFWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQBKWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
					 <call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * In any case, this indextuple doesn't match the qual.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Since NULLs are sorted before non-NULLs, we know we have
				 * reached the lower limit of the range of values for this
				 * index attr.  On a backward scan, we can stop if this qual
				 * is one of the "must match" subset.  We can stop regardless
				 * of whether the qual is &gt; or &lt;, so long as it's required,
				 * because it's not possible for any future tuples to pass. On
				 * a forward scan, however, we must keep going, because we may
				 * have initially positioned to the start of the index.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_BT_REQFWD</name> <operator>|</operator> <name>SK_BT_REQBKWD</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
					<call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Since NULLs are sorted after non-NULLs, we know we have
				 * reached the upper limit of the range of values for this
				 * index attr.  On a forward scan, we can stop if this qual is
				 * one of the "must match" subset.  We can stop regardless of
				 * whether the qual is &gt; or &lt;, so long as it's required,
				 * because it's not possible for any future tuples to pass. On
				 * a backward scan, however, we must keep going, because we
				 * may have initially positioned to the end of the index.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_BT_REQFWD</name> <operator>|</operator> <name>SK_BT_REQBKWD</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
					<call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * In any case, this indextuple doesn't match the qual.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
								 <argument><expr><name>datum</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Tuple fails this qual.  If it's a required qual for the current
			 * scan direction, then we can conclude no further tuples will
			 * pass, either.
			 *
			 * Note: because we stop the scan as soon as any required equality
			 * qual fails, it is critical that equality quals be used for the
			 * initial positioning in _bt_first() when they are available. See
			 * comments in _bt_first().
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQFWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQBKWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
					 <call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * In any case, this indextuple doesn't match the qual.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If we get here, the tuple passes all index quals. */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether an indextuple satisfies a row-comparison scan condition.
 *
 * Return true if so, false if not.  If not, also clear *continuescan if
 * it's not possible for any future tuples in the current scan direction
 * to pass the qual.
 *
 * This is a subroutine for _bt_checkkeys, which see for more info.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_check_rowcompare</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>skey</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tupnatts</name></decl></parameter>,
					 <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>continuescan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>subkey</name> <init>= <expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>cmpresult</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* First subkey should be same as the header says */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>==</operator> <name><name>skey</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Loop over columns of the row condition */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>&gt;</operator> <name>tupnatts</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This attribute is truncated (must be high key).  The value for
			 * this attribute in the first non-pivot tuple on the page to the
			 * right could be any possible value.  Assume that truncated
			 * attribute passes the qual.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cmpresult</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_END</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>subkey</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
							  <argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>,
							  <argument><expr><name>tupdesc</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Since NULLs are sorted before non-NULLs, we know we have
				 * reached the lower limit of the range of values for this
				 * index attr.  On a backward scan, we can stop if this qual
				 * is one of the "must match" subset.  We can stop regardless
				 * of whether the qual is &gt; or &lt;, so long as it's required,
				 * because it's not possible for any future tuples to pass. On
				 * a forward scan, however, we must keep going, because we may
				 * have initially positioned to the start of the index.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_BT_REQFWD</name> <operator>|</operator> <name>SK_BT_REQBKWD</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
					<call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Since NULLs are sorted after non-NULLs, we know we have
				 * reached the upper limit of the range of values for this
				 * index attr.  On a forward scan, we can stop if this qual is
				 * one of the "must match" subset.  We can stop regardless of
				 * whether the qual is &gt; or &lt;, so long as it's required,
				 * because it's not possible for any future tuples to pass. On
				 * a backward scan, however, we must keep going, because we
				 * may have initially positioned to the end of the index.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_BT_REQFWD</name> <operator>|</operator> <name>SK_BT_REQBKWD</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
					<call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * In any case, this indextuple doesn't match the qual.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Unlike the simple-scankey case, this isn't a disallowed case.
			 * But it can never match.  If all the earlier row comparison
			 * columns are required for the scan direction, we can stop the
			 * scan, because there can't be another tuple that will succeed.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>subkey</name> <operator>!=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>subkey</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQFWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQBKWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
					 <call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Perform the test --- three-way comparison not bool operator */</comment>
		<expr_stmt><expr><name>cmpresult</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>,
													<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
													<argument><expr><name>datum</name></expr></argument>,
													<argument><expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>INVERT_COMPARE_RESULT</name><argument_list>(<argument><expr><name>cmpresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Done comparing if unequal, else advance to next column */</comment>
		<if_stmt><if>if <condition>(<expr><name>cmpresult</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_END</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>subkey</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * At this point cmpresult indicates the overall result of the row
	 * comparison, and subkey points to the deciding column (or the last
	 * column if the result is "=").
	 */</comment>
	<switch>switch <condition>(<expr><name><name>subkey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* EQ and NE cases aren't allowed here */</comment>
		<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>cmpresult</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>cmpresult</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>cmpresult</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>cmpresult</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RowCompareType: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>subkey</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Tuple fails this qual.  If it's a required qual for the current
		 * scan direction, then we can conclude no further tuples will pass,
		 * either.  Note we have to look at the deciding column, not
		 * necessarily the first or last column of the row condition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQFWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_REQBKWD</name><operator>)</operator> <operator>&amp;&amp;</operator>
				 <call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>continuescan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_killitems - set LP_DEAD state for items an indexscan caller has
 * told us were killed
 *
 * scan-&gt;opaque, referenced locally through so, contains information about the
 * current page and killed tuples thereon (generally, this should only be
 * called if so-&gt;numKilled &gt; 0).
 *
 * The caller does not have a lock on the page and may or may not have the
 * page pinned in a buffer.  Note that read-lock is sufficient for setting
 * LP_DEAD status (which is only a hint).
 *
 * We match items by heap TID before assuming they are the right ones to
 * delete.  We cope with cases where items have moved right due to insertions.
 * If an item has moved off the current page due to a split, we'll fail to
 * find it and do nothing (this is not an error case --- we assume the item
 * will eventually get marked in a future indexscan).
 *
 * Note that if we hold a pin on the target page continuously from initially
 * reading the items until applying this function, VACUUM cannot have deleted
 * any items from the page, and so there is no need to search left from the
 * recorded offset.  (This observation also guarantees that the item is still
 * the right one to delete, which might otherwise be questionable since heap
 * TIDs can get recycled.)	This holds true even if the page has been modified
 * by inserts and page splits, so there is no need to consult the LSN.
 *
 * If the pin was released after reading the page, then we re-read it.  If it
 * has been modified since we read it (as determined by the LSN), we dare not
 * flag any entries because it is possible that the old entry was vacuumed
 * away and the TID was re-used by a completely different heap tuple.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_killitems</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>BTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>minoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numKilled</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>killedsomething</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTScanPosIsValid</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Always reset the scan state, so we don't look for same items on other
	 * pages.
	 */</comment>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BTScanPosIsPinned</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have held the pin on this page since we read the index tuples,
		 * so all we need to do is lock it.  The pin will have prevented
		 * re-use of any TID on the page, so there is no need to check the
		 * LSN.
		 */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>

		<comment type="block">/* Attempt to re-read the buffer, getting pin and lock. */</comment>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>currPage</name></name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* It might not exist anymore; in which case we can't hint it. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferGetLSNAtomic</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Modified while not pinned means hinting is not safe. */</comment>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minoff</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numKilled</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>itemIndex</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>killedItems</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTScanPosItem</name> <modifier>*</modifier></type><name>kitem</name> <init>= <expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>items</name><index>[<expr><name>itemIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name> <init>= <expr><name><name>kitem</name><operator>-&gt;</operator><name>indexOffset</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>&gt;=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>firstItem</name></name> <operator>&amp;&amp;</operator>
			   <name>itemIndex</name> <operator>&lt;=</operator> <name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>lastItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>&lt;</operator> <name>minoff</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* pure paranoia */</comment>
		<while>while <condition>(<expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>ituple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ituple</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>kitem</name><operator>-&gt;</operator><name>heapTid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* found the item */</comment>
				<expr_stmt><expr><call><name>ItemIdMarkDead</name><argument_list>(<argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>killedsomething</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>			<comment type="block">/* out of inner search loop */</comment>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Since this can be redone later if needed, mark as dirty hint.
	 *
	 * Whenever we mark anything LP_DEAD, we also set the page's
	 * BTP_HAS_GARBAGE flag, which is likewise just a hint.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>killedsomething</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_HAS_GARBAGE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirtyHint</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>currPos</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * The following routines manage a shared-memory area in which we track
 * assignment of "vacuum cycle IDs" to currently-active btree vacuuming
 * operations.  There is a single counter which increments each time we
 * start a vacuum to assign it a cycle ID.  Since multiple vacuums could
 * be active concurrently, we have to track the cycle ID for each active
 * vacuum; this requires at most MaxBackends entries (usually far fewer).
 * We assume at most one vacuum can be active for a given index.
 *
 * Access to the shared memory area is controlled by BtreeVacuumLock.
 * In principle we could use a separate lmgr locktag for each index,
 * but a single LWLock is much cheaper, and given the short time that
 * the lock is ever held, the concurrency hit should be minimal.
 */</comment>

<typedef>typedef <type><struct>struct <name>BTOneVacInfo</name>
<block>{
	<decl_stmt><decl><type><name>LockRelId</name></type>	<name>relid</name></decl>;</decl_stmt>			<comment type="block">/* global identifier of an index */</comment>
	<decl_stmt><decl><type><name>BTCycleId</name></type>	<name>cycleid</name></decl>;</decl_stmt>		<comment type="block">/* cycle ID for its active VACUUM */</comment>
}</block></struct></type> <name>BTOneVacInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>BTVacInfo</name>
<block>{
	<decl_stmt><decl><type><name>BTCycleId</name></type>	<name>cycle_ctr</name></decl>;</decl_stmt>		<comment type="block">/* cycle ID most recently assigned */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_vacuums</name></decl>;</decl_stmt>	<comment type="block">/* number of currently active VACUUMs */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_vacuums</name></decl>;</decl_stmt>	<comment type="block">/* allocated length of vacuums[] array */</comment>
	<decl_stmt><decl><type><name>BTOneVacInfo</name></type> <name><name>vacuums</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>BTVacInfo</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>BTVacInfo</name> <modifier>*</modifier></type><name>btvacinfo</name></decl>;</decl_stmt>


<comment type="block">/*
 * _bt_vacuum_cycleid --- get the active vacuum cycle ID for an index,
 *		or zero if there is no active VACUUM
 *
 * Note: for correct interlocking, the caller must already hold pin and
 * exclusive lock on each buffer it will store the cycle ID into.  This
 * ensures that even if a VACUUM starts immediately afterwards, it cannot
 * process those pages until the page split is complete.
 */</comment>
<function><type><name>BTCycleId</name></type>
<name>_bt_vacuum_cycleid</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTCycleId</name></type>	<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Share lock is enough since this is a read-only operation */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTOneVacInfo</name> <modifier>*</modifier></type><name>vac</name> <init>= <expr><operator>&amp;</operator><name><name>btvacinfo</name><operator>-&gt;</operator><name>vacuums</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>vac</name><operator>-&gt;</operator><name>relid</name><operator>.</operator><name>relId</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name> <operator>&amp;&amp;</operator>
			<name><name>vac</name><operator>-&gt;</operator><name>relid</name><operator>.</operator><name>dbId</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>vac</name><operator>-&gt;</operator><name>cycleid</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_start_vacuum --- assign a cycle ID to a just-starting VACUUM operation
 *
 * Note: the caller must guarantee that it will eventually call
 * _bt_end_vacuum, else we'll permanently leak an array slot.  To ensure
 * that this happens even in elog(FATAL) scenarios, the appropriate coding
 * is not just a PG_TRY, but
 *		PG_ENSURE_ERROR_CLEANUP(_bt_end_vacuum_callback, PointerGetDatum(rel))
 */</comment>
<function><type><name>BTCycleId</name></type>
<name>_bt_start_vacuum</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTCycleId</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTOneVacInfo</name> <modifier>*</modifier></type><name>vac</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assign the next cycle ID, being careful to avoid zero as well as the
	 * reserved high values.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>++</operator><operator>(</operator><name><name>btvacinfo</name><operator>-&gt;</operator><name>cycle_ctr</name></name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>result</name> <operator>&gt;</operator> <name>MAX_BT_CYCLE_ID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>btvacinfo</name><operator>-&gt;</operator><name>cycle_ctr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Let's just make sure there's no entry already for this index */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>vac</name> <operator>=</operator> <operator>&amp;</operator><name><name>btvacinfo</name><operator>-&gt;</operator><name>vacuums</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>vac</name><operator>-&gt;</operator><name>relid</name><operator>.</operator><name>relId</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name> <operator>&amp;&amp;</operator>
			<name><name>vac</name><operator>-&gt;</operator><name>relid</name><operator>.</operator><name>dbId</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Unlike most places in the backend, we have to explicitly
			 * release our LWLock before throwing an error.  This is because
			 * we expect _bt_end_vacuum() to be called before transaction
			 * abort cleanup can run to release LWLocks.
			 */</comment>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"multiple active vacuums for index \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* OK, add an entry */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name> <operator>&gt;=</operator> <name><name>btvacinfo</name><operator>-&gt;</operator><name>max_vacuums</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"out of btvacinfo slots"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>vac</name> <operator>=</operator> <operator>&amp;</operator><name><name>btvacinfo</name><operator>-&gt;</operator><name>vacuums</name><index>[<expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vac</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vac</name><operator>-&gt;</operator><name>cycleid</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_end_vacuum --- mark a btree VACUUM operation as done
 *
 * Note: this is deliberately coded not to complain if no entry is found;
 * this allows the caller to put PG_TRY around the start_vacuum operation.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_end_vacuum</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the array entry */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BTOneVacInfo</name> <modifier>*</modifier></type><name>vac</name> <init>= <expr><operator>&amp;</operator><name><name>btvacinfo</name><operator>-&gt;</operator><name>vacuums</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>vac</name><operator>-&gt;</operator><name>relid</name><operator>.</operator><name>relId</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>relId</name></name> <operator>&amp;&amp;</operator>
			<name><name>vac</name><operator>-&gt;</operator><name>relid</name><operator>.</operator><name>dbId</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name><operator>.</operator><name>dbId</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Remove it by shifting down the last entry */</comment>
			<expr_stmt><expr><operator>*</operator><name>vac</name> <operator>=</operator> <name><name>btvacinfo</name><operator>-&gt;</operator><name>vacuums</name><index>[<expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name><operator>--</operator></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BtreeVacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_end_vacuum wrapped as an on_shmem_exit callback function
 */</comment>
<decl_stmt><decl><type><name>void</name></type>
<name>_bt_end_vacuum_callback</name><argument_list>(<argument><expr><name>int</name> <name>code</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Datum</name> <name>arg</name></expr></argument>)</argument_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_bt_end_vacuum</name><argument_list>(<argument><expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * BTreeShmemSize --- report amount of shared memory space needed
 */</comment>
<function><type><name>Size</name></type>
<name>BTreeShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>BTVacInfo</name></expr></argument>, <argument><expr><name>vacuums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>MaxBackends</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTOneVacInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BTreeShmemInit --- initialize this module's shared memory
 */</comment>
<function><type><name>void</name></type>
<name>BTreeShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>btvacinfo</name> <operator>=</operator> <operator>(</operator><name>BTVacInfo</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"BTree Vacuum State"</literal></expr></argument>,
											  <argument><expr><call><name>BTreeShmemSize</name><argument_list>()</argument_list></call></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Initialize shared memory area */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * It doesn't really matter what the cycle counter starts at, but
		 * having it always start the same doesn't seem good.  Seed with
		 * low-order bits of time() instead.
		 */</comment>
		<expr_stmt><expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>cycle_ctr</name></name> <operator>=</operator> <operator>(</operator><name>BTCycleId</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>num_vacuums</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>btvacinfo</name><operator>-&gt;</operator><name>max_vacuums</name></name> <operator>=</operator> <name>MaxBackends</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>btoptions</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>default_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>validate</name></expr></argument>, <argument><expr><name>RELOPT_KIND_BTREE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	btproperty() -- Check boolean properties of indexes.
 *
 * This is optional, but handling AMPROP_RETURNABLE here saves opening the rel
 * to call btcanreturn.
 */</comment>
<function><type><name>bool</name></type>
<name>btproperty</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index_oid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>,
		   <parameter><decl><type><name>IndexAMProperty</name></type> <name>prop</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>propname</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>prop</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AMPROP_RETURNABLE</name></expr>:</case>
			<comment type="block">/* answer only for columns, not AM or whole index */</comment>
			<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* otherwise, btree can always return data */</comment>
			<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>

		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>		<comment type="block">/* punt to generic code */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 *	btbuildphasename() -- Return name of index build phase.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>btbuildphasename</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>phasenum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>phasenum</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PROGRESS_CREATEIDX_SUBPHASE_INITIALIZE</name></expr>:</case>
			<return>return <expr><literal type="string">"initializing"</literal></expr>;</return>
		<case>case <expr><name>PROGRESS_BTREE_PHASE_INDEXBUILD_TABLESCAN</name></expr>:</case>
			<return>return <expr><literal type="string">"scanning table"</literal></expr>;</return>
		<case>case <expr><name>PROGRESS_BTREE_PHASE_PERFORMSORT_1</name></expr>:</case>
			<return>return <expr><literal type="string">"sorting live tuples"</literal></expr>;</return>
		<case>case <expr><name>PROGRESS_BTREE_PHASE_PERFORMSORT_2</name></expr>:</case>
			<return>return <expr><literal type="string">"sorting dead tuples"</literal></expr>;</return>
		<case>case <expr><name>PROGRESS_BTREE_PHASE_LEAF_LOAD</name></expr>:</case>
			<return>return <expr><literal type="string">"loading tuples in tree"</literal></expr>;</return>
		<default>default:</default>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_truncate() -- create tuple without unneeded suffix attributes.
 *
 * Returns truncated pivot index tuple allocated in caller's memory context,
 * with key attributes copied from caller's firstright argument.  If rel is
 * an INCLUDE index, non-key attributes will definitely be truncated away,
 * since they're not part of the key space.  More aggressive suffix
 * truncation can take place when it's clear that the returned tuple does not
 * need one or more suffix key attributes.  We only need to keep firstright
 * attributes up to and including the first non-lastleft-equal attribute.
 * Caller's insertion scankey is used to compare the tuples; the scankey's
 * argument values are not considered here.
 *
 * Sometimes this routine will return a new pivot tuple that takes up more
 * space than firstright, because a new heap TID attribute had to be added to
 * distinguish lastleft from firstright.  This should only happen when the
 * caller is in the process of splitting a leaf page that has many logical
 * duplicates, where it's unavoidable.
 *
 * Note that returned tuple's t_tid offset will hold the number of attributes
 * present, so the original item pointer offset is not represented.  Caller
 * should only change truncated tuple's downlink.  Note also that truncated
 * key attributes are treated as containing "minus infinity" values by
 * _bt_compare().
 *
 * In the worst case (when a heap TID is appended) the size of the returned
 * tuple is the size of the first right tuple plus an additional MAXALIGN()'d
 * item pointer.  This guarantee is important, since callers need to stay
 * under the 1/3 of a page restriction on tuple size.  If this routine is ever
 * taught to truncate within an attribute/datum, it will need to avoid
 * returning an enlarged tuple to caller when truncation + TOAST compression
 * ends up enlarging the final datum.
 */</comment>
<function><type><name>IndexTuple</name></type>
<name>_bt_truncate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>lastleft</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>firstright</name></decl></parameter>,
			 <parameter><decl><type><name>BTScanInsert</name></type> <name>itup_key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>itupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>natts</name> <init>= <expr><call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>nkeyatts</name> <init>= <expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keepnatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>pivot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>pivotheaptid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>newsize</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We should only ever truncate leaf index tuples.  It's never okay to
	 * truncate a second time.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>lastleft</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>firstright</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Determine how many attributes must be kept in truncated tuple */</comment>
	<expr_stmt><expr><name>keepnatts</name> <operator>=</operator> <call><name>_bt_keep_natts</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lastleft</name></expr></argument>, <argument><expr><name>firstright</name></expr></argument>, <argument><expr><name>itup_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_NO_TRUNCATE</name></cpp:ifdef>
	<comment type="block">/* Force truncation to be ineffective for testing purposes */</comment>
	<expr_stmt><expr><name>keepnatts</name> <operator>=</operator> <name>nkeyatts</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>keepnatts</name> <operator>&lt;=</operator> <name>natts</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tidpivot</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pivot</name> <operator>=</operator> <call><name>index_truncate_tuple</name><argument_list>(<argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><name>firstright</name></expr></argument>, <argument><expr><name>keepnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there is a distinguishing key attribute within new pivot tuple,
		 * there is no need to add an explicit heap TID attribute
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>keepnatts</name> <operator>&lt;=</operator> <name>nkeyatts</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>BTreeTupleSetNAtts</name><argument_list>(<argument><expr><name>pivot</name></expr></argument>, <argument><expr><name>keepnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>pivot</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Only truncation of non-key attributes was possible, since key
		 * attributes are all equal.  It's necessary to add a heap TID
		 * attribute to the new pivot tuple.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>natts</name> <operator>!=</operator> <name>nkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newsize</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>pivot</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tidpivot</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tidpivot</name></expr></argument>, <argument><expr><name>pivot</name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>pivot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* cannot leak memory here */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pivot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pivot</name> <operator>=</operator> <name>tidpivot</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * No truncation was possible, since key attributes are all equal.
		 * It's necessary to add a heap TID attribute to the new pivot tuple.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>natts</name> <operator>==</operator> <name>nkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newsize</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>firstright</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pivot</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pivot</name></expr></argument>, <argument><expr><name>firstright</name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>firstright</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We have to use heap TID as a unique-ifier in the new pivot tuple, since
	 * no non-TID key attribute in the right item readily distinguishes the
	 * right side of the split from the left side.  Use enlarged space that
	 * holds a copy of first right tuple; place a heap TID value within the
	 * extra space that remains at the end.
	 *
	 * nbtree conceptualizes this case as an inability to truncate away any
	 * key attribute.  We must use an alternative representation of heap TID
	 * within pivots because heap TID is only treated as an attribute within
	 * nbtree (e.g., there is no pg_attribute entry).
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>itup_key</name><operator>-&gt;</operator><name>heapkeyspace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pivot</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;=</operator> <operator>~</operator><name>INDEX_SIZE_MASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pivot</name><operator>-&gt;</operator><name>t_info</name></name> <operator>|=</operator> <name>newsize</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lehman &amp; Yao use lastleft as the leaf high key in all cases, but don't
	 * consider suffix truncation.  It seems like a good idea to follow that
	 * example in cases where no truncation takes place -- use lastleft's heap
	 * TID.  (This is also the closest value to negative infinity that's
	 * legally usable.)
	 */</comment>
	<expr_stmt><expr><name>pivotheaptid</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pivot</name> <operator>+</operator> <name>newsize</name> <operator>-</operator>
								  <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lastleft</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><name>pivotheaptid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lehman and Yao require that the downlink to the right page, which is to
	 * be inserted into the parent page in the second phase of a page split be
	 * a strict lower bound on items on the right page, and a non-strict upper
	 * bound for items on the left page.  Assert that heap TIDs follow these
	 * invariants, since a heap TID value is apparently needed as a
	 * tiebreaker.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEBUG_NO_TRUNCATE</name></cpp:ifndef>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lastleft</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>firstright</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerCompare</name><argument_list>(<argument><expr><name>pivotheaptid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lastleft</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerCompare</name><argument_list>(<argument><expr><name>pivotheaptid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>firstright</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * Those invariants aren't guaranteed to hold for lastleft + firstright
	 * heap TID attribute values when they're considered here only because
	 * DEBUG_NO_TRUNCATE is defined (a heap TID is probably not actually
	 * needed as a tiebreaker).  DEBUG_NO_TRUNCATE must therefore use a heap
	 * TID value that always works as a strict lower bound for items to the
	 * right.  In particular, it must avoid using firstright's leading key
	 * attribute values along with lastleft's heap TID value when lastleft's
	 * TID happens to be greater than firstright's TID.
	 */</comment>
	<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>firstright</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><name>pivotheaptid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pivot heap TID should never be fully equal to firstright.  Note that
	 * the pivot heap TID will still end up equal to lastleft's heap TID when
	 * that's the only usable value.
	 */</comment>
	<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><name>pivotheaptid</name></expr></argument>,
							   <argument><expr><call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>pivotheaptid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerCompare</name><argument_list>(<argument><expr><name>pivotheaptid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>firstright</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>BTreeTupleSetNAtts</name><argument_list>(<argument><expr><name>pivot</name></expr></argument>, <argument><expr><name>nkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTreeTupleSetAltHeapTID</name><argument_list>(<argument><expr><name>pivot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pivot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_keep_natts - how many key attributes to keep when truncating.
 *
 * Caller provides two tuples that enclose a split point.  Caller's insertion
 * scankey is used to compare the tuples; the scankey's argument values are
 * not considered here.
 *
 * This can return a number of attributes that is one greater than the
 * number of key attributes for the index relation.  This indicates that the
 * caller must use a heap TID as a unique-ifier in new pivot tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_bt_keep_natts</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>lastleft</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>firstright</name></decl></parameter>,
			   <parameter><decl><type><name>BTScanInsert</name></type> <name>itup_key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkeyatts</name> <init>= <expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>itupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keepnatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>scankey</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Be consistent about the representation of BTREE_VERSION 2/3 tuples
	 * across Postgres versions; don't allow new pivot tuples to have
	 * truncated key attributes there.  _bt_compare() treats truncated key
	 * attributes as having the value minus infinity, which would break
	 * searches within !heapkeyspace indexes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>itup_key</name><operator>-&gt;</operator><name>heapkeyspace</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nkeyatts</name> <operator>!=</operator> <call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>nkeyatts</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scankey</name> <operator>=</operator> <name><name>itup_key</name><operator>-&gt;</operator><name>scankeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>keepnatts</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>attnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>nkeyatts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr><operator>,</operator> <expr><name>scankey</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum1</name></decl>,
					<decl><type ref="prev"/><name>datum2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull1</name></decl>,
					<decl><type ref="prev"/><name>isNull2</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>datum1</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>lastleft</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datum2</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>firstright</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isNull1</name> <operator>!=</operator> <name>isNull2</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull1</name> <operator>&amp;&amp;</operator>
			<call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>,
											<argument><expr><name><name>scankey</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
											<argument><expr><name>datum1</name></expr></argument>,
											<argument><expr><name>datum2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>keepnatts</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>keepnatts</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_keep_natts_fast - fast bitwise variant of _bt_keep_natts.
 *
 * This is exported so that a candidate split point can have its effect on
 * suffix truncation inexpensively evaluated ahead of time when finding a
 * split location.  A naive bitwise approach to datum comparisons is used to
 * save cycles.
 *
 * The approach taken here usually provides the same answer as _bt_keep_natts
 * will (for the same pair of tuples from a heapkeyspace index), since the
 * majority of btree opclasses can never indicate that two datums are equal
 * unless they're bitwise equal (once detoasted).  Similarly, result may
 * differ from the _bt_keep_natts result when either tuple has TOASTed datums,
 * though this is barely possible in practice.
 *
 * These issues must be acceptable to callers, typically because they're only
 * concerned about making suffix truncation as effective as possible without
 * leaving excessive amounts of free space on either side of page split.
 * Callers can rely on the fact that attributes considered equal here are
 * definitely also equal according to _bt_keep_natts.
 */</comment>
<function><type><name>int</name></type>
<name>_bt_keep_natts_fast</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>lastleft</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>firstright</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>itupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keysz</name> <init>= <expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keepnatts</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>keepnatts</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>attnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>keysz</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum1</name></decl>,
					<decl><type ref="prev"/><name>datum2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull1</name></decl>,
					<decl><type ref="prev"/><name>isNull2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>datum1</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>lastleft</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datum2</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>firstright</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isNull1</name> <operator>!=</operator> <name>isNull2</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull1</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>datumIsEqual</name><argument_list>(<argument><expr><name>datum1</name></expr></argument>, <argument><expr><name>datum2</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>keepnatts</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>keepnatts</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *  _bt_check_natts() -- Verify tuple has expected number of attributes.
 *
 * Returns value indicating if the expected number of attributes were found
 * for a particular offset on page.  This can be used as a general purpose
 * sanity check.
 *
 * Testing a tuple directly with BTreeTupleGetNAtts() should generally be
 * preferred to calling here.  That's usually more convenient, and is always
 * more explicit.  Call here instead when offnum's tuple may be a negative
 * infinity tuple that uses the pre-v11 on-disk representation, or when a low
 * context check is appropriate.  This routine is as strict as possible about
 * what is expected on each version of btree.
 */</comment>
<function><type><name>bool</name></type>
<name>_bt_check_natts</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>heapkeyspace</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>natts</name> <init>= <expr><call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>nkeyatts</name> <init>= <expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tupnatts</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We cannot reliably test a deleted or half-deleted page, since they have
	 * dummy high keys
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offnum</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator>
		   <name>offnum</name> <operator>&lt;=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mask allocated for number of keys in index tuple must be able to fit
	 * maximum possible number of index attributes
	 */</comment>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><name>BT_N_KEYS_OFFSET_MASK</name> <operator>&gt;=</operator> <name>INDEX_MAX_KEYS</name></expr></argument>,
					 <argument><expr><literal type="string">"BT_N_KEYS_OFFSET_MASK can't fit INDEX_MAX_KEYS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupnatts</name> <operator>=</operator> <call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>&gt;=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Non-pivot tuples currently never use alternative heap TID
			 * representation -- even those within heapkeyspace indexes
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;</operator> <name>INDEX_ALT_TID_MASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Leaf tuples that are not the page high key (non-pivot tuples)
			 * should never be truncated.  (Note that tupnatts must have been
			 * inferred, rather than coming from an explicit on-disk
			 * representation.)
			 */</comment>
			<return>return <expr><name>tupnatts</name> <operator>==</operator> <name>natts</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Rightmost page doesn't contain a page high key, so tuple was
			 * checked above as ordinary leaf tuple
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * !heapkeyspace high key tuple contains only key attributes. Note
			 * that tupnatts will only have been explicitly represented in
			 * !heapkeyspace indexes that happen to have non-key attributes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>heapkeyspace</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>tupnatts</name> <operator>==</operator> <name>nkeyatts</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* Use generic heapkeyspace pivot tuple handling */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else						<comment type="block">/* !P_ISLEAF(opaque) */</comment>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>==</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The first tuple on any internal page (possibly the first after
			 * its high key) is its negative infinity tuple.  Negative
			 * infinity tuples are always truncated to zero attributes.  They
			 * are a particular kind of pivot tuple.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>heapkeyspace</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>tupnatts</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * The number of attributes won't be explicitly represented if the
			 * negative infinity tuple was generated during a page split that
			 * occurred with a version of Postgres before v11.  There must be
			 * a problem when there is an explicit representation that is
			 * non-zero, or when there is no explicit representation and the
			 * tuple is evidently not a pre-pg_upgrade tuple.
			 *
			 * Prior to v11, downlinks always had P_HIKEY as their offset. Use
			 * that to decide if the tuple is a pre-v11 tuple.
			 */</comment>
			<return>return <expr><name>tupnatts</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<operator>(</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;</operator> <name>INDEX_ALT_TID_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				 <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name>P_HIKEY</name><operator>)</operator></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * !heapkeyspace downlink tuple with separator key contains only
			 * key attributes.  Note that tupnatts will only have been
			 * explicitly represented in !heapkeyspace indexes that happen to
			 * have non-key attributes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>heapkeyspace</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>tupnatts</name> <operator>==</operator> <name>nkeyatts</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* Use generic heapkeyspace pivot tuple handling */</comment>
		</block_content>}</block></else></if_stmt>

	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Handle heapkeyspace pivot tuples (excluding minus infinity items) */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>heapkeyspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Explicit representation of the number of attributes is mandatory with
	 * heapkeyspace index pivot tuples, regardless of whether or not there are
	 * non-key attributes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;</operator> <name>INDEX_ALT_TID_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Heap TID is a tiebreaker key attribute, so it cannot be untruncated
	 * when any other key attribute is truncated
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BTreeTupleGetHeapTID</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>tupnatts</name> <operator>!=</operator> <name>nkeyatts</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Pivot tuple must have at least one untruncated key attribute (minus
	 * infinity pivot tuples are the only exception).  Pivot tuples can never
	 * represent that there is a value present for a key attribute that
	 * exceeds pg_index.indnkeyatts for the index.
	 */</comment>
	<return>return <expr><name>tupnatts</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tupnatts</name> <operator>&lt;=</operator> <name>nkeyatts</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *
 *  _bt_check_third_page() -- check whether tuple fits on a btree page at all.
 *
 * We actually need to be able to fit three items on every page, so restrict
 * any one item to 1/3 the per-page available space.  Note that itemsz should
 * not include the ItemId overhead.
 *
 * It might be useful to apply TOAST methods rather than throw an error here.
 * Using out of line storage would break assumptions made by suffix truncation
 * and by contrib/amcheck, though.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_check_third_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>needheaptidspace</name></decl></parameter>,
					 <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>newtup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>itemsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Double check item size against limit */</comment>
	<if_stmt><if>if <condition>(<expr><name>itemsz</name> <operator>&lt;=</operator> <call><name>BTMaxItemSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Tuple is probably too large to fit on page, but it's possible that the
	 * index uses version 2 or version 3, or that page is an internal page, in
	 * which case a slightly higher limit applies.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>needheaptidspace</name> <operator>&amp;&amp;</operator> <name>itemsz</name> <operator>&lt;=</operator> <call><name>BTMaxItemSizeNoHeapTid</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Internal page insertions cannot fail here, because that would mean that
	 * an earlier leaf level insertion that should have failed didn't
	 */</comment>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot insert oversized tuple of size %zu on internal page of index \"%s\""</literal></expr></argument>,
			 <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row size %zu exceeds btree version %u maximum %zu for index \"%s\""</literal></expr></argument>,
					<argument><expr><name>itemsz</name></expr></argument>,
					<argument><expr><ternary><condition><expr><name>needheaptidspace</name></expr> ?</condition><then> <expr><name>BTREE_VERSION</name></expr> </then><else>: <expr><name>BTREE_NOVAC_VERSION</name></expr></else></ternary></expr></argument>,
					<argument><expr><ternary><condition><expr><name>needheaptidspace</name></expr> ?</condition><then> <expr><call><name>BTMaxItemSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr> </then><else>:
					<expr><call><name>BTMaxItemSizeNoHeapTid</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
					<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index row references tuple (%u,%u) in relation \"%s\"."</literal></expr></argument>,
					   <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Values larger than 1/3 of a buffer page cannot be indexed.\n"</literal>
					 <literal type="string">"Consider a function index of an MD5 hash of the value, "</literal>
					 <literal type="string">"or use full text indexing."</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
