<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/brin/brin_tuple.c"><comment type="block">/*
 * brin_tuple.c
 *		Method implementations for tuples in BRIN indexes.
 *
 * Intended usage is that code outside this file only deals with
 * BrinMemTuples, and convert to and from the on-disk representation through
 * functions in this file.
 *
 * NOTES
 *
 * A BRIN tuple is similar to a heap tuple, with a few key differences.  The
 * first interesting difference is that the tuple header is much simpler, only
 * containing its total length and a small area for flags.  Also, the stored
 * data does not match the relation tuple descriptor exactly: for each
 * attribute in the descriptor, the index tuple carries an arbitrary number
 * of values, depending on the opclass.
 *
 * Also, for each column of the index relation there are two null bits: one
 * (hasnulls) stores whether any tuple within the page range has that column
 * set to null; the other one (allnulls) stores whether the column values are
 * all null.  If allnulls is true, then the tuple data area does not contain
 * values for that column at all; whereas it does if the hasnulls is set.
 * Note the size of the null bitmask may not be the same as that of the
 * datum array.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/access/brin/brin_tuple.c
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/brin_tuple.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupmacs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>brin_deconstruct_tuple</name><parameter_list>(<parameter><decl><type><name>BrinDesc</name> <modifier>*</modifier></type><name>brdesc</name></decl></parameter>,
										  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tp</name></decl></parameter>, <parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>nullbits</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>,
										  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>allnulls</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasnulls</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Return a tuple descriptor used for on-disk storage of BRIN tuples.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>brtuple_disk_tupdesc</name><parameter_list>(<parameter><decl><type><name>BrinDesc</name> <modifier>*</modifier></type><name>brdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We cache these in the BrinDesc */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>brdesc</name><operator>-&gt;</operator><name>bd_disktdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

		<comment type="block">/* make sure it's in the bdesc's context */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>brdesc</name><operator>-&gt;</operator><name>bd_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name><name>brdesc</name><operator>-&gt;</operator><name>bd_totalstored</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>oi_nstored</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attno</name><operator>++</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name><name>brdesc</name><operator>-&gt;</operator><name>bd_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>oi_typcache</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>type_id</name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>brdesc</name><operator>-&gt;</operator><name>bd_disktdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>brdesc</name><operator>-&gt;</operator><name>bd_disktdesc</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a new on-disk tuple to be inserted in a BRIN index.
 *
 * See brin_form_placeholder_tuple if you touch this.
 */</comment>
<function><type><name>BrinTuple</name> <modifier>*</modifier></type>
<name>brin_form_tuple</name><parameter_list>(<parameter><decl><type><name>BrinDesc</name> <modifier>*</modifier></type><name>brdesc</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>BrinMemTuple</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>,
				<parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>anynulls</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>rettuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>idxattno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>phony_infomask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>phony_nullbitmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>,
				<decl><type ref="prev"/><name>hoff</name></decl>,
				<decl><type ref="prev"/><name>data_len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>brdesc</name><operator>-&gt;</operator><name>bd_totalstored</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_totalstored</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_totalstored</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>phony_nullbitmap</name> <operator>=</operator> <operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bits8</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name><name>brdesc</name><operator>-&gt;</operator><name>bd_totalstored</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up the values/nulls arrays for heap_fill_tuple
	 */</comment>
	<expr_stmt><expr><name>idxattno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>datumno</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * "allnulls" is set when there's no nonnull value in any row in the
		 * column; when this happens, there is no data to store.  Thus set the
		 * nullable bits for all data elements of this column and we're done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>.</operator><name>bv_allnulls</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>datumno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
				 <condition><expr><name>datumno</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_info</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>-&gt;</operator><name>oi_nstored</name></expr>;</condition>
				 <incr><expr><name>datumno</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>idxattno</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><name>anynulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The "hasnulls" bit is set when there are some null values in the
		 * data.  We still need to store a real value, but the presence of
		 * this means we need a null bitmap.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>.</operator><name>bv_hasnulls</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>anynulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>datumno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
			 <condition><expr><name>datumno</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_info</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>-&gt;</operator><name>oi_nstored</name></expr>;</condition>
			 <incr><expr><name>datumno</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>idxattno</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>.</operator><name><name>bv_values</name><index>[<expr><name>datumno</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></for>

	<comment type="block">/* Assert we did not overrun temp arrays */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>idxattno</name> <operator>&lt;=</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_totalstored</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* compute total space needed */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SizeOfBrinTuple</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>anynulls</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need a double-length bitmap on an on-disk BRIN index tuple; the
		 * first half stores the "allnulls" bits, the second stores
		 * "hasnulls".
		 */</comment>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>hoff</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><call><name>brtuple_disk_tupdesc</name><argument_list>(<argument><expr><name>brdesc</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>data_len</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rettuple</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rettuple</name><operator>-&gt;</operator><name>bt_blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rettuple</name><operator>-&gt;</operator><name>bt_info</name></name> <operator>=</operator> <name>hoff</name></expr>;</expr_stmt>

	<comment type="block">/* Assert that hoff fits in the space available */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>rettuple</name><operator>-&gt;</operator><name>bt_info</name></name> <operator>&amp;</operator> <name>BRIN_OFFSET_MASK</name><operator>)</operator> <operator>==</operator> <name>hoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The infomask and null bitmap as computed by heap_fill_tuple are useless
	 * to us.  However, that function will not accept a null infomask; and we
	 * need to pass a valid null bitmap so that it will correctly skip
	 * outputting null attributes in the data area.
	 */</comment>
	<expr_stmt><expr><call><name>heap_fill_tuple</name><argument_list>(<argument><expr><call><name>brtuple_disk_tupdesc</name><argument_list>(<argument><expr><name>brdesc</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>values</name></expr></argument>,
					<argument><expr><name>nulls</name></expr></argument>,
					<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>rettuple</name> <operator>+</operator> <name>hoff</name></expr></argument>,
					<argument><expr><name>data_len</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>phony_infomask</name></expr></argument>,
					<argument><expr><name>phony_nullbitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* done with these */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>phony_nullbitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now fill in the real null bitmasks.  allnulls first.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>anynulls</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bitP</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>bitmask</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>rettuple</name><operator>-&gt;</operator><name>bt_info</name></name> <operator>|=</operator> <name>BRIN_NULLS_MASK</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note that we reverse the sense of null bits in this module: we
		 * store a 1 for a null attribute rather than a 0.  So we must reverse
		 * the sense of the att_isnull test in brin_deconstruct_tuple as well.
		 */</comment>
		<expr_stmt><expr><name>bitP</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>rettuple</name> <operator>+</operator> <name>SizeOfBrinTuple</name><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <name>HIGHBIT</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>bitmask</name> <operator>!=</operator> <name>HIGHBIT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>bitP</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>bitP</name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tuple</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>.</operator><name>bv_allnulls</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>bitP</name> <operator>|=</operator> <name>bitmask</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="block">/* hasnulls bits follow */</comment>
		<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>bitmask</name> <operator>!=</operator> <name>HIGHBIT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>bitP</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>bitP</name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tuple</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>.</operator><name>bv_hasnulls</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>bitP</name> <operator>|=</operator> <name>bitmask</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>bitP</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>rettuple</name> <operator>+</operator> <name>SizeOfBrinTuple</name><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>bt_placeholder</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rettuple</name><operator>-&gt;</operator><name>bt_info</name></name> <operator>|=</operator> <name>BRIN_PLACEHOLDER_MASK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<return>return <expr><name>rettuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a new on-disk tuple with no data values, marked as placeholder.
 *
 * This is a cut-down version of brin_form_tuple.
 */</comment>
<function><type><name>BrinTuple</name> <modifier>*</modifier></type>
<name>brin_form_placeholder_tuple</name><parameter_list>(<parameter><decl><type><name>BrinDesc</name> <modifier>*</modifier></type><name>brdesc</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>hoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>rettuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bitP</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmask</name></decl>;</decl_stmt>

	<comment type="block">/* compute total space needed: always add nulls */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>SizeOfBrinTuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>hoff</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rettuple</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rettuple</name><operator>-&gt;</operator><name>bt_blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rettuple</name><operator>-&gt;</operator><name>bt_info</name></name> <operator>=</operator> <name>hoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rettuple</name><operator>-&gt;</operator><name>bt_info</name></name> <operator>|=</operator> <name>BRIN_NULLS_MASK</name> <operator>|</operator> <name>BRIN_PLACEHOLDER_MASK</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>bitP</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>rettuple</name> <operator>+</operator> <name>SizeOfBrinTuple</name><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <name>HIGHBIT</name></expr>;</expr_stmt>
	<comment type="block">/* set allnulls true for all attributes */</comment>
	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>bitmask</name> <operator>!=</operator> <name>HIGHBIT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>bitP</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>bitP</name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>bitP</name> <operator>|=</operator> <name>bitmask</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* no need to set hasnulls */</comment>

	<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<return>return <expr><name>rettuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free a tuple created by brin_form_tuple
 */</comment>
<function><type><name>void</name></type>
<name>brin_free_tuple</name><parameter_list>(<parameter><decl><type><name>BrinTuple</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a brin tuple of size len, create a copy of it.  If 'dest' is not
 * NULL, its size is destsz, and can be used as output buffer; if the tuple
 * to be copied does not fit, it is enlarged by repalloc, and the size is
 * updated to match.  This avoids palloc/free cycles when many brin tuples
 * are being processed in loops.
 */</comment>
<function><type><name>BrinTuple</name> <modifier>*</modifier></type>
<name>brin_copy_tuple</name><parameter_list>(<parameter><decl><type><name>BrinTuple</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>BrinTuple</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>destsz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>destsz</name> <operator>||</operator> <operator>*</operator><name>destsz</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&gt;</operator> <operator>*</operator><name>destsz</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>destsz</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dest</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return whether two BrinTuples are bitwise identical.
 */</comment>
<function><type><name>bool</name></type>
<name>brin_tuples_equal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BrinTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>alen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BrinTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>blen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>alen</name> <operator>!=</operator> <name>blen</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>alen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new BrinMemTuple from scratch, and initialize it to an empty
 * state.
 *
 * Note: we don't provide any means to free a deformed tuple, so make sure to
 * use a temporary memory context.
 */</comment>
<function><type><name>BrinMemTuple</name> <modifier>*</modifier></type>
<name>brin_new_memtuple</name><parameter_list>(<parameter><decl><type><name>BrinDesc</name> <modifier>*</modifier></type><name>brdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BrinMemTuple</name> <modifier>*</modifier></type><name>dtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>basesize</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>basesize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BrinMemTuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
						<sizeof>sizeof<argument_list>(<argument><expr><name>BrinValues</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dtup</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>basesize</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_totalstored</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dtup</name><operator>-&gt;</operator><name>bt_values</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_totalstored</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dtup</name><operator>-&gt;</operator><name>bt_allnulls</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dtup</name><operator>-&gt;</operator><name>bt_hasnulls</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dtup</name><operator>-&gt;</operator><name>bt_context</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											 <argument><expr><literal type="string">"brin dtuple"</literal></expr></argument>,
											 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>brin_memtuple_initialize</name><argument_list>(<argument><expr><name>dtup</name></expr></argument>, <argument><expr><name>brdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dtup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reset a BrinMemTuple to initial state.  We return the same tuple, for
 * notational convenience.
 */</comment>
<function><type><name>BrinMemTuple</name> <modifier>*</modifier></type>
<name>brin_memtuple_initialize</name><parameter_list>(<parameter><decl><type><name>BrinMemTuple</name> <modifier>*</modifier></type><name>dtuple</name></decl></parameter>, <parameter><decl><type><name>BrinDesc</name> <modifier>*</modifier></type><name>brdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>currdatum</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>dtuple</name><operator>-&gt;</operator><name>bt_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>currdatum</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>dtuple</name> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BrinMemTuple</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
				 <sizeof>sizeof<argument_list>(<argument><expr><name>BrinValues</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dtuple</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bv_allnulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dtuple</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bv_hasnulls</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>dtuple</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bv_attno</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dtuple</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bv_allnulls</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dtuple</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bv_hasnulls</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dtuple</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bv_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <name>currdatum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>currdatum</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>oi_nstored</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>dtuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a BrinTuple back to a BrinMemTuple.  This is the reverse of
 * brin_form_tuple.
 *
 * As an optimization, the caller can pass a previously allocated 'dMemtuple'.
 * This avoids having to allocate it here, which can be useful when this
 * function is called many times in a loop.  It is caller's responsibility
 * that the given BrinMemTuple matches what we need here.
 *
 * Note we don't need the "on disk tupdesc" here; we rely on our own routine to
 * deconstruct the tuple from the on-disk format.
 */</comment>
<function><type><name>BrinMemTuple</name> <modifier>*</modifier></type>
<name>brin_deform_tuple</name><parameter_list>(<parameter><decl><type><name>BrinDesc</name> <modifier>*</modifier></type><name>brdesc</name></decl></parameter>, <parameter><decl><type><name>BrinTuple</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>, <parameter><decl><type><name>BrinMemTuple</name> <modifier>*</modifier></type><name>dMemtuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BrinMemTuple</name> <modifier>*</modifier></type><name>dtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>allnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>hasnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>nullbits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>valueno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dtup</name> <operator>=</operator> <ternary><condition><expr><name>dMemtuple</name></expr> ?</condition><then> <expr><call><name>brin_memtuple_initialize</name><argument_list>(<argument><expr><name>dMemtuple</name></expr></argument>, <argument><expr><name>brdesc</name></expr></argument>)</argument_list></call></expr> </then><else>:
		<expr><call><name>brin_new_memtuple</name><argument_list>(<argument><expr><name>brdesc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BrinTupleIsPlaceholder</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dtup</name><operator>-&gt;</operator><name>bt_placeholder</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>dtup</name><operator>-&gt;</operator><name>bt_blkno</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>bt_blkno</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>values</name> <operator>=</operator> <name><name>dtup</name><operator>-&gt;</operator><name>bt_values</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>allnulls</name> <operator>=</operator> <name><name>dtup</name><operator>-&gt;</operator><name>bt_allnulls</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hasnulls</name> <operator>=</operator> <name><name>dtup</name><operator>-&gt;</operator><name>bt_hasnulls</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <call><name>BrinTupleDataOffset</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BrinTupleHasNulls</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nullbits</name> <operator>=</operator> <operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <name>SizeOfBrinTuple</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nullbits</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>brin_deconstruct_tuple</name><argument_list>(<argument><expr><name>brdesc</name></expr></argument>,
						   <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>nullbits</name></expr></argument>, <argument><expr><call><name>BrinTupleHasNulls</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>allnulls</name></expr></argument>, <argument><expr><name>hasnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Iterate to assign each of the values to the corresponding item in the
	 * values array of each column.  The copies occur in the tuple's context.
	 */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>dtup</name><operator>-&gt;</operator><name>bt_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>valueno</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>allnulls</name><index>[<expr><name>keyno</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>valueno</name> <operator>+=</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_info</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>-&gt;</operator><name>oi_nstored</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We would like to skip datumCopy'ing the values datum in some cases,
		 * caller permitting ...
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_info</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>-&gt;</operator><name>oi_nstored</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dtup</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>.</operator><name><name>bv_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>valueno</name><operator>++</operator></expr>]</index></name></expr></argument>,
						  <argument><expr><name><name>brdesc</name><operator>-&gt;</operator><name>bd_info</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>-&gt;</operator><name><name>oi_typcache</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>typbyval</name></expr></argument>,
						  <argument><expr><name><name>brdesc</name><operator>-&gt;</operator><name>bd_info</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>-&gt;</operator><name><name>oi_typcache</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><name><name>dtup</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>.</operator><name>bv_hasnulls</name> <operator>=</operator> <name><name>hasnulls</name><index>[<expr><name>keyno</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dtup</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>.</operator><name>bv_allnulls</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dtup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * brin_deconstruct_tuple
 *		Guts of attribute extraction from an on-disk BRIN tuple.
 *
 * Its arguments are:
 *	brdesc		BRIN descriptor for the stored tuple
 *	tp			pointer to the tuple data area
 *	nullbits	pointer to the tuple nulls bitmask
 *	nulls		"has nulls" bit in tuple infomask
 *	values		output values, array of size brdesc-&gt;bd_totalstored
 *	allnulls	output "allnulls", size brdesc-&gt;bd_tupdesc-&gt;natts
 *	hasnulls	output "hasnulls", size brdesc-&gt;bd_tupdesc-&gt;natts
 *
 * Output arrays must have been allocated by caller.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>brin_deconstruct_tuple</name><parameter_list>(<parameter><decl><type><name>BrinDesc</name> <modifier>*</modifier></type><name>brdesc</name></decl></parameter>,
					   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tp</name></decl></parameter>, <parameter><decl><type><name>bits8</name> <modifier>*</modifier></type><name>nullbits</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>allnulls</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasnulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>stored</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>diskdsc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>off</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First iterate to natts to obtain both null flags for each attribute.
	 * Note that we reverse the sense of the att_isnull test, because we store
	 * 1 for a null value (rather than a 1 for a not null value as is the
	 * att_isnull convention used elsewhere.)  See brin_form_tuple.
	 */</comment>
	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * the "all nulls" bit means that all values in the page range for
		 * this column are nulls.  Therefore there are no values in the tuple
		 * data area.
		 */</comment>
		<expr_stmt><expr><name><name>allnulls</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <name>nulls</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>att_isnull</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>nullbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * the "has nulls" bit means that some tuples have nulls, but others
		 * have not-null values.  Therefore we know the tuple contains data
		 * for this column.
		 *
		 * The hasnulls bits follow the allnulls bits in the same bitmask.
		 */</comment>
		<expr_stmt><expr><name><name>hasnulls</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator>
			<name>nulls</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>att_isnull</name><argument_list>(<argument><expr><name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>+</operator> <name>attnum</name></expr></argument>, <argument><expr><name>nullbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Iterate to obtain each attribute's stored values.  Note that since we
	 * may reuse attribute entries for more than one column, we cannot cache
	 * offsets here.
	 */</comment>
	<expr_stmt><expr><name>diskdsc</name> <operator>=</operator> <call><name>brtuple_disk_tupdesc</name><argument_list>(<argument><expr><name>brdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>stored</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>datumno</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>allnulls</name><index>[<expr><name>attnum</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>stored</name> <operator>+=</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_info</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>oi_nstored</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><expr><name>datumno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
			 <condition><expr><name>datumno</name> <operator>&lt;</operator> <name><name>brdesc</name><operator>-&gt;</operator><name>bd_info</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>oi_nstored</name></expr>;</condition>
			 <incr><expr><name>datumno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>thisatt</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>diskdsc</name></expr></argument>, <argument><expr><name>stored</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* not varlena, so safe to use att_align_nominal */</comment>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><name>stored</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>fetchatt</name><argument_list>(<argument><expr><name>thisatt</name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>off</name></expr></argument>, <argument><expr><name><name>thisatt</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>tp</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
