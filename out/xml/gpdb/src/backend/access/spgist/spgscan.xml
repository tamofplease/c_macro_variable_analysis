<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/spgist/spgscan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * spgscan.c
 *	  routines for scanning SP-GiST indexes
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *			src/backend/access/spgist/spgscan.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/float.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>storeRes_func</name>) <parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>heapPtr</name></decl></parameter>,
							   <parameter><decl><type><name>Datum</name></type> <name>leafValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recheck</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>recheckDistances</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>distances</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/*
 * Pairing heap comparison function for the SpGistSearchItem queue.
 * KNN-searches currently only support NULLS LAST.  So, preserve this logic
 * here.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pairingheap_SpGistSearchItem_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
								 <parameter><decl><type><specifier>const</specifier> <name>pairingheap_node</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>SpGistSearchItem</name> <modifier>*</modifier></type><name>sa</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>SpGistSearchItem</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>SpGistSearchItem</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>SpGistSearchItem</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>SpGistScanOpaque</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sa</name><operator>-&gt;</operator><name>isNull</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sb</name><operator>-&gt;</operator><name>isNull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>sb</name><operator>-&gt;</operator><name>isNull</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Order according to distance comparison */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name><name>sa</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* NaN == NaN */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name><name>sa</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* NaN &gt; number */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* number &lt; NaN */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sa</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>sb</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>sa</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>sb</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Leaf items go before inner pages, to ensure a depth-first search */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sa</name><operator>-&gt;</operator><name>isLeaf</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>sb</name><operator>-&gt;</operator><name>isLeaf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sa</name><operator>-&gt;</operator><name>isLeaf</name></name> <operator>&amp;&amp;</operator> <name><name>sb</name><operator>-&gt;</operator><name>isLeaf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgFreeSearchItem</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>attLeafType</name><operator>.</operator><name>attbyval</name></name> <operator>&amp;&amp;</operator>
		<call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>traversalValue</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>traversalValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add SpGistSearchItem to queue
 *
 * Called in queue context
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgAddSearchItemToQueue</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>scanQueue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>phNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SpGistSearchItem</name> <modifier>*</modifier></type>
<name>spgAllocSearchItem</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>distances</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* allocate distance array only for non-NULL items */</comment>
	<decl_stmt><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>item</name> <init>=
	<expr><call><name>palloc</name><argument_list>(<argument><expr><call><name>SizeOfSpGistSearchItem</name><argument_list>(<argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>isNull</name></name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name> <operator>&amp;&amp;</operator> <name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>distances</name></name></expr></argument>, <argument><expr><name>distances</name></expr></argument>,
			   <argument><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>item</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgAddStartItem</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>startEntry</name> <init>=
	<expr><call><name>spgAllocSearchItem</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>zeroDistances</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>startEntry</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>,
				   <argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><name>SPGIST_NULL_BLKNO</name></expr> </then><else>: <expr><name>SPGIST_ROOT_BLKNO</name></expr></else></ternary></expr></argument>,
				   <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>startEntry</name><operator>-&gt;</operator><name>isLeaf</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>startEntry</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>startEntry</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>startEntry</name><operator>-&gt;</operator><name>traversalValue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>startEntry</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>startEntry</name><operator>-&gt;</operator><name>recheckDistances</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>spgAddSearchItemToQueue</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>startEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize queue to search the root page, resetting
 * any previously active scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>resetSpGistScanOpaque</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * clear traversal context before proceeding to the next scan; this must
	 * not happen before the freeScanStack above, else we get double-free
	 * crashes.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>traversalCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>traversalCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize queue only for distance-ordered scans */</comment>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>scanQueue</name></name> <operator>=</operator> <call><name>pairingheap_allocate</name><argument_list>(<argument><expr><name>pairingheap_SpGistSearchItem_cmp</name></expr></argument>, <argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>searchNulls</name></name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Add a work item to scan the null index entries */</comment>
		<expr_stmt><expr><call><name>spgAddStartItem</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>searchNonNulls</name></name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Add a work item to scan the non-null index entries */</comment>
		<expr_stmt><expr><call><name>spgAddStartItem</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Must pfree distances to avoid memory leak */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Must pfree reconstructed tuples to avoid memory leak */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>reconTups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare scan keys in SpGistScanOpaque from caller-given scan keys
 *
 * Sets searchNulls, searchNonNulls, numberOfKeys, keyData fields of *so.
 *
 * The point here is to eliminate null-related considerations from what the
 * opclass consistent functions need to deal with.  We assume all SPGiST-
 * indexable operators are strict, so any null RHS value makes the scan
 * condition unsatisfiable.  We also pull out any IS NULL/IS NOT NULL
 * conditions; their effect is reflected into searchNulls/searchNonNulls.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgPrepareScanKeys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>SpGistScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>qual_ok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haveIsNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haveNotNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>orderByData</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>orderByData</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If no quals, whole-index scan is required */</comment>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>searchNulls</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>searchNonNulls</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Examine the given quals */</comment>
	<expr_stmt><expr><name>qual_ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>haveIsNull</name> <operator>=</operator> <name>haveNotNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanKey</name></type>		<name>skey</name> <init>= <expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>haveIsNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNOTNULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>haveNotNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>skey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ordinary qual with null argument - unsatisfiable */</comment>
			<expr_stmt><expr><name>qual_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* ordinary qual, propagate into so-&gt;keyData */</comment>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>nkeys</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>skey</name></expr>;</expr_stmt>
			<comment type="block">/* this effectively creates a not-null requirement */</comment>
			<expr_stmt><expr><name>haveNotNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* IS NULL in combination with something else is unsatisfiable */</comment>
	<if_stmt><if>if <condition>(<expr><name>haveIsNull</name> <operator>&amp;&amp;</operator> <name>haveNotNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>qual_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Emit results */</comment>
	<if_stmt><if>if <condition>(<expr><name>qual_ok</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>searchNulls</name></name> <operator>=</operator> <name>haveIsNull</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>searchNonNulls</name></name> <operator>=</operator> <name>haveNotNull</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>=</operator> <name>nkeys</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>searchNulls</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>searchNonNulls</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>IndexScanDesc</name></type>
<name>spgbeginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keysz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>orderbysz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>RelationGetIndexScan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>keysz</name></expr></argument>, <argument><expr><name>orderbysz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>so</name> <operator>=</operator> <operator>(</operator><name>SpGistScanOpaque</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistScanOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>keysz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>keyData</name></name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>keysz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>keyData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>initSpGistState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>tempCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
										<argument><expr><literal type="string">"SP-GiST search temporary context"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>traversalCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											 <argument><expr><literal type="string">"SP-GiST traversal-value context"</literal></expr></argument>,
											 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up indexTupDesc and xs_hitupdesc in case it's an index-only scan */</comment>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>indexTupDesc</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>xs_hitupdesc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate various arrays needed for order-by scans */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This will be filled in spgrescan, but allocate the space here */</comment>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>orderByTypes</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* These arrays have constant contents, so we can fill them now */</comment>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>zeroDistances</name></name> <operator>=</operator> <operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>infDistances</name></name> <operator>=</operator> <operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>zeroDistances</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>infDistances</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbyvals</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbynulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbynulls</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>innerConsistentFn</name></name></expr></argument>,
				   <argument><expr><call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SPGIST_INNER_CONSISTENT_PROC</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>leafConsistentFn</name></name></expr></argument>,
				   <argument><expr><call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SPGIST_LEAF_CONSISTENT_PROC</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>indexCollation</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>so</name></expr>;</expr_stmt>

	<return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>spgrescan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nscankeys</name></decl></parameter>,
		  <parameter><decl><type><name>ScanKey</name></type> <name>orderbys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>SpGistScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* copy scankeys into local storage */</comment>
	<if_stmt><if>if <condition>(<expr><name>scankey</name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>,
				<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* initialize order-by data if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>orderbys</name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>orderByData</name></name></expr></argument>, <argument><expr><name>orderbys</name></expr></argument>,
				<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ScanKey</name></type>		<name>skey</name> <init>= <expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>orderByData</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Look up the datatype returned by the original ordering
			 * operator. SP-GiST always uses a float8 for the distance
			 * function, but the ordering operator could be anything else.
			 *
			 * XXX: The distance function is only allowed to be lossy if the
			 * ordering operator's result type is float4 or float8.  Otherwise
			 * we don't know how to return the distance to the executor.  But
			 * we cannot check that here, as we won't know if the distance
			 * function is lossy until it returns *recheck = true for the
			 * first time.
			 */</comment>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>orderByTypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name><name>skey</name><operator>-&gt;</operator><name>sk_func</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* preprocess scankeys, set up the representation in *so */</comment>
	<expr_stmt><expr><call><name>spgPrepareScanKeys</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set up starting queue entries */</comment>
	<expr_stmt><expr><call><name>resetSpGistScanOpaque</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>spgendscan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>SpGistScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>traversalCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>keyData</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>keyData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>deadTupleStorage</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>deadTupleStorage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>orderByTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>zeroDistances</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>infDistances</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbyvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbynulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Leaf SpGistSearchItem constructor, called in queue context
 */</comment>
<function><type><specifier>static</specifier> <name>SpGistSearchItem</name> <modifier>*</modifier></type>
<name>spgNewHeapItem</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>heapPtr</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name></type> <name>leafValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recheck</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recheckDistances</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>distances</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>spgAllocSearchItem</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>distances</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>heapPtr</name></name> <operator>=</operator> <operator>*</operator><name>heapPtr</name></expr>;</expr_stmt>
	<comment type="block">/* copy value to queue cxt out of tmp cxt */</comment>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>:
		<expr><call><name>datumCopy</name><argument_list>(<argument><expr><name>leafValue</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>attLeafType</name><operator>.</operator><name>attbyval</name></name></expr></argument>,
				  <argument><expr><name><name>so</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>attLeafType</name><operator>.</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>traversalValue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>isLeaf</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name>recheck</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>recheckDistances</name></name> <operator>=</operator> <name>recheckDistances</name></expr>;</expr_stmt>

	<return>return <expr><name>item</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether a leaf tuple satisfies all the scan keys
 *
 * *reportedSome is set to true if:
 *		the scan is not ordered AND the item satisfies the scankeys
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>spgLeafTest</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>item</name></decl></parameter>,
			<parameter><decl><type><name>SpGistLeafTuple</name></type> <name>leafTuple</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
			<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>reportedSome</name></decl></parameter>, <parameter><decl><type><name>storeRes_func</name></type> <name>storeRes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>leafValue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name>	   <modifier>*</modifier></type><name>distances</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recheck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recheckDistances</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Should not have arrived on a nulls page unless nulls are wanted */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>searchNulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>leafValue</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>distances</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recheckDistances</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>spgLeafConsistentIn</name></type> <name>in</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>spgLeafConsistentOut</name></type> <name>out</name></decl>;</decl_stmt>

		<comment type="block">/* use temp context for calling leaf_consistent */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>in</name><operator>.</operator><name>scankeys</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>keyData</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>in</name><operator>.</operator><name>nkeys</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>in</name><operator>.</operator><name>orderbys</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>orderByData</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>in</name><operator>.</operator><name>norderbys</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>in</name><operator>.</operator><name>reconstructedValue</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>in</name><operator>.</operator><name>traversalValue</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>traversalValue</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>in</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>level</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>in</name><operator>.</operator><name>returnData</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>in</name><operator>.</operator><name>leafDatum</name></name> <operator>=</operator> <call><name>SGLTDATUM</name><argument_list>(<argument><expr><name>leafTuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>out</name><operator>.</operator><name>leafValue</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>.</operator><name>recheck</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>.</operator><name>distances</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>.</operator><name>recheckDistances</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>leafConsistentFn</name></name></expr></argument>,
												<argument><expr><name><name>so</name><operator>-&gt;</operator><name>indexCollation</name></name></expr></argument>,
												<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>recheck</name> <operator>=</operator> <name><name>out</name><operator>.</operator><name>recheck</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>recheckDistances</name> <operator>=</operator> <name><name>out</name><operator>.</operator><name>recheckDistances</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>leafValue</name> <operator>=</operator> <name><name>out</name><operator>.</operator><name>leafValue</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>distances</name> <operator>=</operator> <name><name>out</name><operator>.</operator><name>distances</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* item passes the scankeys */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* the scan is ordered -&gt; add the item to the queue */</comment>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>traversalCxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>heapItem</name> <init>= <expr><call><name>spgNewHeapItem</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>level</name></name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name><name>leafTuple</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>,
														<argument><expr><name>leafValue</name></expr></argument>,
														<argument><expr><name>recheck</name></expr></argument>,
														<argument><expr><name>recheckDistances</name></expr></argument>,
														<argument><expr><name>isnull</name></expr></argument>,
														<argument><expr><name>distances</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>spgAddSearchItemToQueue</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>heapItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* non-ordered scan, so report the item right away */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>recheckDistances</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>storeRes</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>leafTuple</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>, <argument><expr><name>leafValue</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
					 <argument><expr><name>recheck</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>reportedSome</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* A bundle initializer for inner_consistent methods */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgInitInnerConsistentIn</name><parameter_list>(<parameter><decl><type><name>spgInnerConsistentIn</name> <modifier>*</modifier></type><name>in</name></decl></parameter>,
						 <parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>,
						 <parameter><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>item</name></decl></parameter>,
						 <parameter><decl><type><name>SpGistInnerTuple</name></type> <name>innerTuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>scankeys</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>keyData</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>orderbys</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>orderByData</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>norderbys</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>reconstructedValue</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>traversalMemoryContext</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>traversalCxt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>traversalValue</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>traversalValue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>level</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>returnData</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>allTheSame</name></name> <operator>=</operator> <name><name>innerTuple</name><operator>-&gt;</operator><name>allTheSame</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>hasPrefix</name></name> <operator>=</operator> <operator>(</operator><name><name>innerTuple</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>prefixDatum</name></name> <operator>=</operator> <call><name>SGITDATUM</name><argument_list>(<argument><expr><name>innerTuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>=</operator> <name><name>innerTuple</name><operator>-&gt;</operator><name>nNodes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><operator>-&gt;</operator><name>nodeLabels</name></name> <operator>=</operator> <call><name>spgExtractNodeLabels</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>innerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SpGistSearchItem</name> <modifier>*</modifier></type>
<name>spgMakeInnerItem</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>,
				 <parameter><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>parentItem</name></decl></parameter>,
				 <parameter><decl><type><name>SpGistNodeTuple</name></type> <name>tuple</name></decl></parameter>,
				 <parameter><decl><type><name>spgInnerConsistentOut</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
				 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>distances</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>spgAllocSearchItem</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>distances</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>heapPtr</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <ternary><condition><expr><name><name>out</name><operator>-&gt;</operator><name>levelAdds</name></name></expr> ?</condition><then> <expr><name><name>parentItem</name><operator>-&gt;</operator><name>level</name></name> <operator>+</operator> <name><name>out</name><operator>-&gt;</operator><name>levelAdds</name><index>[<expr><name>i</name></expr>]</index></name></expr>
		</then><else>: <expr><name><name>parentItem</name><operator>-&gt;</operator><name>level</name></name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Must copy value out of temp context */</comment>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <ternary><condition><expr><name><name>out</name><operator>-&gt;</operator><name>reconstructedValues</name></name></expr>
		?</condition><then> <expr><call><name>datumCopy</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>reconstructedValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
					<argument><expr><name><name>so</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>attLeafType</name><operator>.</operator><name>attbyval</name></name></expr></argument>,
					<argument><expr><name><name>so</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>attLeafType</name><operator>.</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>
		</then><else>: <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Elements of out.traversalValues should be allocated in
	 * in.traversalMemoryContext, which is actually a long lived context of
	 * index scan.
	 */</comment>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>traversalValue</name></name> <operator>=</operator>
		<ternary><condition><expr><name><name>out</name><operator>-&gt;</operator><name>traversalValues</name></name></expr> ?</condition><then> <expr><name><name>out</name><operator>-&gt;</operator><name>traversalValues</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>isLeaf</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>recheckDistances</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>item</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgInnerTest</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>item</name></decl></parameter>,
			 <parameter><decl><type><name>SpGistInnerTuple</name></type> <name>innerTuple</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgInnerConsistentOut</name></type> <name>out</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nNodes</name> <init>= <expr><name><name>innerTuple</name><operator>-&gt;</operator><name>nNodes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>spgInnerConsistentIn</name></type> <name>in</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>spgInitInnerConsistentIn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>, <argument><expr><name>so</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>innerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* use user-defined inner consistent method */</comment>
		<expr_stmt><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>innerConsistentFn</name></name></expr></argument>,
						  <argument><expr><name><name>so</name><operator>-&gt;</operator><name>indexCollation</name></name></expr></argument>,
						  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* force all children to be visited */</comment>
		<expr_stmt><expr><name><name>out</name><operator>.</operator><name>nNodes</name></name> <operator>=</operator> <name>nNodes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>.</operator><name>nodeNumbers</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>out</name><operator>.</operator><name>nodeNumbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* If allTheSame, they should all or none of them match */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>innerTuple</name><operator>-&gt;</operator><name>allTheSame</name></name> <operator>&amp;&amp;</operator> <name><name>out</name><operator>.</operator><name>nNodes</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>out</name><operator>.</operator><name>nNodes</name></name> <operator>!=</operator> <name>nNodes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inconsistent inner_consistent results for allTheSame inner tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>out</name><operator>.</operator><name>nNodes</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* collect node pointers */</comment>
		<decl_stmt><decl><type><name>SpGistNodeTuple</name></type> <name>node</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SpGistNodeTuple</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><operator>(</operator><name>SpGistNodeTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(
															<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistNodeTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>SGITITERATE</name><argument_list>(<argument>innerTuple</argument>, <argument>i</argument>, <argument>node</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>traversalCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>out</name><operator>.</operator><name>nNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nodeN</name> <init>= <expr><name><name>out</name><operator>.</operator><name>nodeNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>innerItem</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name>	   <modifier>*</modifier></type><name>distances</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nodeN</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nodeN</name> <operator>&lt;</operator> <name>nNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>nodes</name><index>[<expr><name>nodeN</name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Use infinity distances if innerConsistent() failed to return
			 * them or if is a NULL item (their distances are really unused).
			 */</comment>
			<expr_stmt><expr><name>distances</name> <operator>=</operator> <ternary><condition><expr><name><name>out</name><operator>.</operator><name>distances</name></name></expr> ?</condition><then> <expr><name><name>out</name><operator>.</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name><name>so</name><operator>-&gt;</operator><name>infDistances</name></name></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><name>innerItem</name> <operator>=</operator> <call><name>spgMakeInnerItem</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
										 <argument><expr><name>distances</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>spgAddSearchItemToQueue</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>innerItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Returns a next item in an (ordered) scan or null if the index is exhausted */</comment>
<function><type><specifier>static</specifier> <name>SpGistSearchItem</name> <modifier>*</modifier></type>
<name>spgGetNextQueueItem</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>scanQueue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* Done when both heaps are empty */</comment>

	<comment type="block">/* Return item; caller is responsible to pfree it */</comment>
	<return>return <expr><operator>(</operator><name>SpGistSearchItem</name> <operator>*</operator><operator>)</operator> <call><name>pairingheap_remove_first</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>scanQueue</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>SpGistSpecialOffsetNumbers</name>
<block>{
	<decl><name>SpGistBreakOffsetNumber</name> <init>= <expr><name>InvalidOffsetNumber</name></expr></init></decl>,
	<decl><name>SpGistRedirectOffsetNumber</name> <init>= <expr><name>MaxOffsetNumber</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>,
	<decl><name>SpGistErrorOffsetNumber</name> <init>= <expr><name>MaxOffsetNumber</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>
}</block>;</enum>

<function><type><specifier>static</specifier> <name>OffsetNumber</name></type>
<name>spgTestLeafTuple</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>,
				 <parameter><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>item</name></decl></parameter>,
				 <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isroot</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>reportedSome</name></decl></parameter>,
				 <parameter><decl><type><name>storeRes_func</name></type> <name>storeRes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>leafTuple</name> <init>= <expr><operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator>
	<call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>leafTuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>!=</operator> <name>SPGIST_LIVE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isroot</name></expr>)</condition>			<comment type="block">/* all tuples on root should be live */</comment>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>leafTuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_REDIRECT</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* redirection tuple should be first in chain */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>==</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* transfer attention to redirect point */</comment>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>heapPtr</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SpGistDeadTuple</name><operator>)</operator> <name>leafTuple</name><operator>)</operator><operator>-&gt;</operator><name>pointer</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SPGIST_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>SpGistRedirectOffsetNumber</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>leafTuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_DEAD</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* dead tuple should be first in chain */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>==</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* No live entries on this page */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leafTuple</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>SpGistBreakOffsetNumber</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We should not arrive at a placeholder */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SPGiST tuple state: %d"</literal></expr></argument>, <argument><expr><name><name>leafTuple</name><operator>-&gt;</operator><name>tupstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>SpGistErrorOffsetNumber</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leafTuple</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>spgLeafTest</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>leafTuple</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>reportedSome</name></expr></argument>, <argument><expr><name>storeRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>leafTuple</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Walk the tree and report all tuples passing the scan quals to the storeRes
 * subroutine.
 *
 * If scanWholeIndex is true, we'll do just that.  If not, we'll stop at the
 * next page boundary once we have reported at least one tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgWalk</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>scanWholeIndex</name></decl></parameter>,
		<parameter><decl><type><name>storeRes_func</name></type> <name>storeRes</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reportedSome</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>scanWholeIndex</name> <operator>||</operator> <operator>!</operator><name>reportedSome</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpGistSearchItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>spgGetNextQueueItem</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* No more items in queue -&gt; done */</comment>

<label><name>redirect</name>:</label>
		<comment type="block">/* Check for interrupts, just in case of infinite loop */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>isLeaf</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We store heap items in the queue only in case of ordered search */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>storeRes</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>isNull</name></name></expr></argument>,
					 <argument><expr><name><name>item</name><operator>-&gt;</operator><name>recheck</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>recheckDistances</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>distances</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>reportedSome</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>blkno</name> <operator>!=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* else new pointer points to the same page, no work needed */</comment>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>isnull</name> <operator>=</operator> <ternary><condition><expr><call><name>SpGistPageStoresNulls</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>SpGistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Page is a leaf - that is, all it's tuples are heap items */</comment>
				<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>max</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* When root is a leaf, examine all its tuples */</comment>
					<for>for <control>(<init><expr><name>offset</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>offset</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>offset</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>spgTestLeafTuple</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
												<argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>reportedSome</name></expr></argument>, <argument><expr><name>storeRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Normal case: just examine the chain we arrived at */</comment>
					<while>while <condition>(<expr><name>offset</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;=</operator> <name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>spgTestLeafTuple</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
												  <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>reportedSome</name></expr></argument>, <argument><expr><name>storeRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <name>SpGistRedirectOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
							<goto>goto <name>redirect</name>;</goto></block_content></block></if></if_stmt>
					</block_content>}</block></while>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else				<comment type="block">/* page is inner */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>innerTuple</name> <init>= <expr><operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator>
				<call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>innerTuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>!=</operator> <name>SPGIST_LIVE</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>innerTuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_REDIRECT</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* transfer attention to redirect point */</comment>
						<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>heapPtr</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SpGistDeadTuple</name><operator>)</operator> <name>innerTuple</name><operator>)</operator><operator>-&gt;</operator><name>pointer</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator>
							   <name>SPGIST_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>redirect</name>;</goto>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SPGiST tuple state: %d"</literal></expr></argument>,
						 <argument><expr><name><name>innerTuple</name><operator>-&gt;</operator><name>tupstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>spgInnerTest</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>innerTuple</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* done with this scan item */</comment>
		<expr_stmt><expr><call><name>spgFreeSearchItem</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* clear temp context before proceeding to the next one */</comment>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* storeRes subroutine for getbitmap case */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>storeBitmap</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>heapPtr</name></decl></parameter>,
			<parameter><decl><type><name>Datum</name></type> <name>leafValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recheck</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recheckDistances</name></decl></parameter>,
			<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>distances</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>recheckDistances</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>distances</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tbm_add_tuples</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tbm</name></name></expr></argument>, <argument><expr><name>heapPtr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>recheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>ntids</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>spggetbitmap</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>bmNodeP</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SpGistScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>SpGistScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * GPDB specific code. Since GPDB also support StreamBitmap
	 * in bitmap index. So normally we need to create specific bitmap
	 * node in the amgetbitmap AM.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bmNodeP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bmNodeP</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* XXX should we use less than work_mem for this? */</comment>
		<expr_stmt><expr><name>tbm</name> <operator>=</operator> <call><name>tbm_create</name><argument_list>(<argument><expr><name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>bmNodeP</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tbm</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><operator>*</operator><name>bmNodeP</name></expr></argument>, <argument><expr><name>TIDBitmap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"non spgist bitmap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tbm</name> <operator>=</operator> <operator>(</operator><name>TIDBitmap</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>bmNodeP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Copy want_itup to *so so we don't need to pass it around separately */</comment>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>tbm</name></name> <operator>=</operator> <name>tbm</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>ntids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>spgWalk</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>so</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>storeBitmap</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>so</name><operator>-&gt;</operator><name>ntids</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* storeRes subroutine for gettuple case */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>storeGettuple</name><parameter_list>(<parameter><decl><type><name>SpGistScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>heapPtr</name></decl></parameter>,
			  <parameter><decl><type><name>Datum</name></type> <name>leafValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recheck</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recheckDistances</name></decl></parameter>,
			  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>distances</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name> <operator>&lt;</operator> <name>MaxIndexTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>heapPtrs</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>heapPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>recheck</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>]</index></name> <operator>=</operator> <name>recheck</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>recheckDistances</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>]</index></name> <operator>=</operator> <name>recheckDistances</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>		<name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>]</index></name> <operator>=</operator> <call><name>memcpy</name><argument_list>(<argument><expr><call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>distances</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Reconstruct index data.  We have to copy the datum out of the temp
		 * context anyway, so we may as well create the tuple here.
		 */</comment>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>reconTups</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>]</index></name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>indexTupDesc</name></name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>leafValue</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>spggettuple</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>SpGistScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>!=</operator> <name>ForwardScanDirection</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SP-GiST only supports forward scan direction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Copy want_itup to *so so we don't need to pass it around separately */</comment>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* continuing to return reported tuples */</comment>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_heaptid</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>heapPtrs</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_recheck</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>recheck</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitup</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>reconTups</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>index_store_float8_orderby_distances</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>orderByTypes</name></name></expr></argument>,
													 <argument><expr><name><name>so</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name></expr>]</index></name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name><name>so</name><operator>-&gt;</operator><name>recheckDistances</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name><operator>++</operator></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Must pfree distances to avoid memory leak */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>want_itup</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Must pfree reconstructed tuples to avoid memory leak */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>reconTups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>iPtr</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>spgWalk</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>so</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>storeGettuple</name></expr></argument>,
				<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>nPtrs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* must have completed scan */</comment>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>spgcanreturn</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistCache</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>

	<comment type="block">/* We can do it if the opclass config function says so */</comment>
	<expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>spgGetCache</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>cache</name><operator>-&gt;</operator><name>config</name><operator>.</operator><name>canReturnData</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
