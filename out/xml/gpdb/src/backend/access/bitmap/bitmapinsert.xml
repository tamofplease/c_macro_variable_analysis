<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/bitmap/bitmapinsert.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * bitmapinsert.c
 *	  Tuple insertion in the on-disk bitmap index.
 *
 * Portions Copyright (c) 2007-2010 Greenplum Inc
 * Portions Copyright (c) 2010-2012 EMC Corporation
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 2006-2008, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/bitmap/bitmapinsert.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>

<comment type="block">/*
 * The following structure along with BMTIDBuffer are used to buffer
 * words for tids * during index create -- bmbuild().
 */</comment>

<comment type="block">/*
 * BMTIDLOVBuffer represents those bitmap vectors whose LOV item would be
 * stored on the specified lov_block. The array bufs stores the TIDs for
 * a distinct vector (see above). The index of the array we're up to tell
 * us the offset number of the LOV item on the lov_block.
 */</comment>

<typedef>typedef <type><struct>struct <name>BMTIDLOVBuffer</name>
<block>{
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lov_block</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name><name>bufs</name><index>[<expr><name>BM_MAX_LOVITEMS_PER_PAGE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>BMTIDLOVBuffer</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bitmap_write_new_bitmapwords</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							  <parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>,
							  <parameter><decl><type><name>BMTIDBuffer</name><modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>_bitmap_write_bitmapwords_on_page</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>bitmapPage</name></decl></parameter>,
								  <parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startWordNo</name></decl></parameter>,
								  <parameter><decl><type><name>xl_bm_bitmapwords_perpage</name> <modifier>*</modifier></type><name>xlrec_perpage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_lovitem</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>metabuf</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>, 
						   <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>, 
						   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>attdata</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>,
						   <parameter><decl><type><name>Relation</name></type> <name>lovHeap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>lovIndex</name></decl></parameter>,
						   <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>lovBlockP</name></decl></parameter>, 
						   <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>lovOffsetP</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>build_inserttuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>,
							   <parameter><decl><type><name>ItemPointerData</name></type> <name>ht_ctid</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>, 
							   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>attdata</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><name>BMBuildState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>inserttuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>metabuf</name></decl></parameter>, 
								<parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>, <parameter><decl><type><name>ItemPointerData</name></type> <name>ht_ctid</name></decl></parameter>, 
							    <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>, <parameter><decl><type><name>Datum</name><modifier>*</modifier></type> <name>attdata</name></decl></parameter>,
							    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>lovHeap</name></decl></parameter>, 
								<parameter><decl><type><name>Relation</name></type> <name>lovIndex</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>scanKey</name></decl></parameter>, 
								<parameter><decl><type><name>IndexScanDesc</name></type> <name>scanDesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>updatesetbit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, 
						 <parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>,
						 <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>updatesetbit_inword</name><parameter_list>(<parameter><decl><type><name>BM_HRL_WORD</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>updateBitLoc</name></decl></parameter>,
								<parameter><decl><type><name>uint64</name></type> <name>firstTid</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name><modifier>*</modifier></type> <name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>updatesetbit_inpage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>,
								<parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>,
								<parameter><decl><type><name>Buffer</name></type> <name>bitmapBuffer</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>firstTidNumber</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>insertsetbit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>lovBlock</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>,
			 			 <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>findbitmappage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMLOVItem</name></type> <name>lovitem</name></decl></parameter>,
					   <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>,
					   <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>bitmapBufferP</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>firstTidNumberP</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shift_header_bits</name><parameter_list>(<parameter><decl><type><name>BM_HRL_WORD</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>numOfBits</name></decl></parameter>,
						  <parameter><decl><type><name>uint32</name></type> <name>maxNumOfWords</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>startLoc</name></decl></parameter>,
						  <parameter><decl><type><name>uint32</name></type> <name>numOfShiftingBits</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rshift_header_bits</name><parameter_list>(<parameter><decl><type><name>BM_HRL_WORD</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>nwords</name></decl></parameter>,
							   <parameter><decl><type><name>uint32</name></type> <name>bits</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lshift_header_bits</name><parameter_list>(<parameter><decl><type><name>BM_HRL_WORD</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>nwords</name></decl></parameter>,
							   <parameter><decl><type><name>uint32</name></type> <name>bits</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>insert_newwords</name><parameter_list>(<parameter><decl><type><name>BMTIDBuffer</name><modifier>*</modifier></type> <name>words</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>insertPos</name></decl></parameter>,
							<parameter><decl><type><name>BMTIDBuffer</name><modifier>*</modifier></type> <name>new_words</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name><modifier>*</modifier></type> <name>words_left</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int16</name></type> <name>mergewords</name><parameter_list>(<parameter><decl><type><name>BMTIDBuffer</name><modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lastWordFill</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>buf_make_space</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>BMTidBuildBuf</name> <modifier>*</modifier></type><name>tidLocsBuffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>verify_bitmappages</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMLOVItem</name></type> <name>lovitem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int16</name></type> <name>buf_add_tid_with_fill</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
								   <parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>,
								   <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint16</name></type> <name>buf_extend</name><parameter_list>(<parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint16</name></type> <name>buf_ensure_head_space</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
								   <parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint16</name></type> <name>buf_free_mem_block</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
			  			         <parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>,
						         <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint16</name></type> <name>buf_free_mem</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
			  			   <parameter><decl><type><name>BlockNumber</name></type> <name>lov_block</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>, 
						   <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint16</name></type> <name>_bitmap_free_tidbuf</name><parameter_list>(<parameter><decl><type><name>BMTIDBuffer</name><modifier>*</modifier></type> <name>buf</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF_INIT_WORDS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> <comment type="block">/* as good a point as any */</comment>

<comment type="block">/*
 * updatesetbit() -- update a set bit in a bitmap.
 *
 * This function finds the bit in a given bitmap vector whose bit location is
 * equal to tidnum, and changes this bit to 1.
 *
 * If this bit is already 1, then we are done. Otherwise, there are
 * two possibilities:
 * (1) This bit appears in a literal word. In this case, we simply change
 *     it to 1.
 * (2) This bit appears in a fill word with bit 0. In this case, this word
 *     may generate two or three words after changing the corresponding bit
 *     to 1, depending on the position of this bit.
 *
 * Case (2) will make the corresponding bitmap page to grow. The words after
 * this affected word in this bitmap page are shifted right to accommodate
 * the newly generated words. If this bitmap page does not have enough space
 * to hold all these words, the last few words will be shifted out of this
 * page. In this case, the next bitmap page is checked to see if there are
 * enough space for these extra words. If so, these extra words are inserted
 * into the next page. Otherwise, we create a new bitmap page to hold
 * these extra words.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>updatesetbit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>,
			 <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>lovPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMLOVItem</name></type>	<name>lovItem</name></decl>;</decl_stmt>
		
	<decl_stmt><decl><type><name>uint64</name></type>	<name>tidLocation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>	<name>insertingPos</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type>	<name>firstTidNumber</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>	<name>bitmapBuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>lovPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lovItem</name> <operator>=</operator> <operator>(</operator><name>BMLOVItem</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, 
		<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Calculate the tid location in the last bitmap page. */</comment>
	<expr_stmt><expr><name>tidLocation</name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BM_LAST_COMPWORD_IS_FILL</name><argument_list>(<argument><expr><name>lovItem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tidLocation</name> <operator>-=</operator> <operator>(</operator><call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name></expr></argument>)</argument_list></call> <operator>*</operator>
					    <name>BM_HRL_WORD_SIZE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tidLocation</name> <operator>-=</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If tidnum is in either bm_last_compword or bm_last_word,
	 * and this does not generate any new words, we simply
	 * need to update the lov item.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tidnum</name> <operator>&gt;</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><operator>(</operator><name>tidnum</name> <operator>&gt;</operator> <name>tidLocation</name><operator>)</operator> <operator>&amp;&amp;</operator>
		 <operator>(</operator><operator>(</operator><name><name>lovItem</name><operator>-&gt;</operator><name>lov_words_header</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		  <operator>(</operator><call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>tidnum</name> <operator>&gt;</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr>)</condition>   <comment type="block">/* bm_last_word */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>insertingPos</name> <operator>=</operator> <operator>(</operator><name>tidnum</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>%</operator><name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_word</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name>insertingPos</name><operator>)</operator></expr>;</expr_stmt>
			
			<if_stmt><if>if <condition>(<expr><name>Debug_bitmap_print_insert</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Bitmap Insert: updated a set bit in lovItem-&gt;bm_last_word"</literal>
					 <literal type="string">" pos %d"</literal>
					 <literal type="string">", lovBlock=%d, lovOffset=%d"</literal>
					 <literal type="string">", tidnum="</literal> <name>INT64_FORMAT</name></expr></argument>,
					 <argument><expr><name>insertingPos</name></expr></argument>,
					 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>lovOffset</name></expr></argument>,
					 <argument><expr><name>tidnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else <comment type="block">/* bm_last_compword */</comment>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>BM_LAST_COMPWORD_IS_FILL</name><argument_list>(<argument><expr><name>lovItem</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name> <operator>=</operator> <name>LITERAL_ALL_ONE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>insertingPos</name> <operator>=</operator> <operator>(</operator><name>tidnum</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>insertingPos</name><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name> <operator>==</operator> <name>LITERAL_ALL_ONE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>lov_words_header</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name> <operator>=</operator> <call><name>BM_MAKE_FILL_WORD</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>lov_words_header</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>Debug_bitmap_print_insert</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Bitmap Insert: updated a set bit in lovItem-&gt;bm_last_compword"</literal>
					 <literal type="string">" pos %d"</literal>
					 <literal type="string">", lovBlock=%d, lovOffset=%d"</literal>
					 <literal type="string">", tidnum="</literal> <name>INT64_FORMAT</name></expr></argument>,
					 <argument><expr><name>insertingPos</name></expr></argument>,
					 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>lovOffset</name></expr></argument>,
					 <argument><expr><name>tidnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bitmap_log_bitmap_lastwords</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>, <argument><expr><name>lovItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Here, if tidnum is still in bm_last_compword, we know that
	 * bm_last_compword is a fill zero words with fill length greater
	 * than 1. This update will generate new words, we insert new words
	 * into the last bitmap page and update the lov item.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tidnum</name> <operator>&gt;</operator> <name>tidLocation</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lovItem</name><operator>-&gt;</operator><name>lov_words_header</name></name> <operator>&gt;=</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We know that bm_last_compwords will be split into two
		 * or three words, depending on the splitting position.
		 */</comment>
		<decl_stmt><decl><type><name>BMTIDBuffer</name></type> <name>buf</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>buf_extend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>updatesetbit_inword</name><argument_list>(<argument><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name></expr></argument>,
							<argument><expr><name>tidnum</name> <operator>-</operator> <name>tidLocation</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
							<argument><expr><name>tidLocation</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* set the last_compword and last_word */</comment>
		<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>last_compword</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>cwords</name><index>[<expr><name><name>buf</name><operator>.</operator><name>curword</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>is_last_compword_fill</name></name> <operator>=</operator> <call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>curword</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>curword</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>last_word</name></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_word</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>last_tid</name></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_setbit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bitmap_write_new_bitmapwords</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>Debug_bitmap_print_insert</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>verify_bitmappages</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		
		<expr_stmt><expr><call><name>_bitmap_free_tidbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now, tidnum is in the middle of the bitmap vector.
	 * We try to find the bitmap page that contains this bit,
	 * and update the bit.
	 */</comment>
	<comment type="block">/* find the page that contains this bit. */</comment>
	<expr_stmt><expr><call><name>findbitmappage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovItem</name></expr></argument>, <argument><expr><name>tidnum</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>bitmapBuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>firstTidNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>updatesetbit_inpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tidnum</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>,
						<argument><expr><name>bitmapBuffer</name></expr></argument>, <argument><expr><name>firstTidNumber</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_bitmap_print_insert</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>verify_bitmappages</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * updatesetbit_inword() -- update the given bit to 1 in a given
 * 	word.
 *
 * The given word will generate at most three new words, depending on 
 * the position of the given bit to be updated. Make sure that the 
 * array 'words' has the size of 3 when you call this function. All new 
 * words will be put in this array, and the final number of new words is 
 * stored in '*numWordsP'. The bit location 'updateBitLoc' is relative to
 * the beginning of the given word, starting from 0.
 *
 * We assume that word is a fill zero word.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>updatesetbit_inword</name><parameter_list>(<parameter><decl><type><name>BM_HRL_WORD</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>updateBitLoc</name></decl></parameter>,
					<parameter><decl><type><name>uint64</name></type> <name>firstTid</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>	<name>numBits</name></decl>, <decl><type ref="prev"/><name>usedNumBits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>	<name>insertingPos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>updateBitLoc</name> <operator>&lt;</operator> <name>BM_HRL_WORD_SIZE</name><operator>*</operator><call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numBits</name> <operator>=</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>usedNumBits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>updateBitLoc</name> <operator>&gt;=</operator> <name>BM_HRL_WORD_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>firstTid</name> <operator>+=</operator> <operator>(</operator><name>updateBitLoc</name><operator>/</operator><name>BM_HRL_WORD_SIZE</name><operator>)</operator> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name></expr>]</index></name> <operator>=</operator>
			<call><name>BM_MAKE_FILL_WORD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>updateBitLoc</name><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name></expr>]</index></name> <operator>=</operator> <name>firstTid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>buf_extend</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr>]</index></name> <operator>|=</operator>
			<operator>(</operator><operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><operator>(</operator><name>BM_HRL_WORD_SIZE</name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>curword</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>usedNumBits</name> <operator>+=</operator> <operator>(</operator><name>updateBitLoc</name><operator>/</operator><name>BM_HRL_WORD_SIZE</name><operator>)</operator> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* construct the literal word */</comment>
	<expr_stmt><expr><name>insertingPos</name> <operator>=</operator> <name>updateBitLoc</name> <operator>-</operator> <name>usedNumBits</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstTid</name> <operator>+=</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name></expr>]</index></name> <operator>=</operator>
		<operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><literal type="number">0</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>insertingPos</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name></expr>]</index></name> <operator>=</operator> <name>firstTid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>buf_extend</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>usedNumBits</name> <operator>+=</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>numBits</name> <operator>&gt;</operator> <name>usedNumBits</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>fill_length</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>numBits</name> <operator>-</operator> <name>usedNumBits</name><operator>)</operator> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fill_length</name> <operator>=</operator> <operator>(</operator><name>numBits</name> <operator>-</operator> <name>usedNumBits</name><operator>)</operator> <operator>/</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>firstTid</name> <operator>+=</operator> <name>fill_length</name> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name></expr>]</index></name> <operator>=</operator> <call><name>BM_MAKE_FILL_WORD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fill_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name></expr>]</index></name> <operator>=</operator> <name>firstTid</name> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>buf_extend</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr>]</index></name> <operator>|=</operator>
			<operator>(</operator><operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>BM_HRL_WORD_SIZE</name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>curword</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * rshift_header_bits() -- 'in-place' right-shift bits in given words
 * 	'bits' bits.
 *
 * Assume that 'bits' is smaller than BM_HRL_WORD_SIZE. The right-most
 * 'bits' bits will be ignored.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rshift_header_bits</name><parameter_list>(<parameter><decl><type><name>BM_HRL_WORD</name><modifier>*</modifier></type> <name>words</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>nwords</name></decl></parameter>,
				   <parameter><decl><type><name>uint32</name></type> <name>bits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>shifting_bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>word_no</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bits</name> <operator>&lt;</operator> <name>BM_HRL_WORD_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>word_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>word_no</name> <operator>&lt;</operator> <name>nwords</name></expr>;</condition> <incr><expr><name>word_no</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>new_shifting_bits</name> <init>= 
			<expr><operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><name><name>words</name><index>[<expr><name>word_no</name></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>BM_HRL_WORD_SIZE</name> <operator>-</operator> <name>bits</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>words</name><index>[<expr><name>word_no</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>words</name><index>[<expr><name>word_no</name></expr>]</index></name> <operator>&gt;&gt;</operator> <name>bits</name><operator>)</operator> <operator>|</operator> <name>shifting_bits</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>shifting_bits</name> <operator>=</operator> <name>new_shifting_bits</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * lshift_header_bits() -- 'in-place' left-shift bits in given words
 * 	'bits' bits.
 *
 * Assume that 'bits' is smaller than BM_HRL_WORD_SIZE. The left-most
 * 'bits' bits will be ignored.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lshift_header_bits</name><parameter_list>(<parameter><decl><type><name>BM_HRL_WORD</name><modifier>*</modifier></type> <name>words</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>nwords</name></decl></parameter>,
				   <parameter><decl><type><name>uint32</name></type> <name>bits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>word_no</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bits</name> <operator>&lt;</operator> <name>BM_HRL_WORD_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>word_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>word_no</name> <operator>&lt;</operator> <name>nwords</name></expr>;</condition> <incr><expr><name>word_no</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>shifting_bits</name> <init>= 
			<expr><name><name>words</name><index>[<expr><name>word_no</name></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>BM_HRL_WORD_SIZE</name> <operator>-</operator> <name>bits</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>words</name><index>[<expr><name>word_no</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><name><name>words</name><index>[<expr><name>word_no</name></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <name>bits</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>word_no</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>words</name><index>[<expr><name>word_no</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>shifting_bits</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * shift_header_bits() -- right-shift bits after 'startLoc' for
 * 	'numofShiftingBits' bits.
 *
 * These bits are stored in an array of words with the word size of
 * BM_HRL_WORD_SIZE. This shift is done in-place. The maximum number of
 * words in this array is given. If the shifting causes the array not to
 * have enough space for all bits, the right-most overflow bits will be
 * discarded. The value 'startLoc' starts with 0.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shift_header_bits</name><parameter_list>(<parameter><decl><type><name>BM_HRL_WORD</name><modifier>*</modifier></type> <name>words</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>numOfBits</name></decl></parameter>,
						  <parameter><decl><type><name>uint32</name></type> <name>maxNumOfWords</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>startLoc</name></decl></parameter>,
						  <parameter><decl><type><name>uint32</name></type> <name>numOfShiftingBits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>	<name>startWordNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>	<name>endWordNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>	<name>wordNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>	<name>numOfFinalShiftingBits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>tmpWord</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>startLoc</name> <operator>&lt;=</operator> <name>numOfBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>numOfBits</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><name>BM_HRL_WORD_SIZE</name> <operator>&lt;</operator> <name>maxNumOfWords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>startWordNo</name> <operator>=</operator> <name>startLoc</name><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>endWordNo</name> <operator>=</operator> <operator>(</operator><name>numOfBits</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>wordNo</name> <operator>=</operator> <name>endWordNo</name></expr>;</init> <condition><expr><name>wordNo</name> <operator>&gt;</operator> <name>startWordNo</name></expr>;</condition> <incr><expr><name>wordNo</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * obtain the last 'numOfShiftingBits' bits in the words[wordNo],
		 * and store them in the high-end of a word.
		 */</comment>
		<expr_stmt><expr><name>tmpWord</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><name><name>words</name><index>[<expr><name>wordNo</name></expr>]</index></name><operator>)</operator><operator>&lt;&lt;</operator>
					<operator>(</operator><name>BM_HRL_WORD_SIZE</name><operator>-</operator><name>numOfShiftingBits</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* right-shift the original word 'numOfShiftingBits' bits. */</comment>
		<expr_stmt><expr><name><name>words</name><index>[<expr><name>wordNo</name></expr>]</index></name> <operator>=</operator>	<operator>(</operator><operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><name><name>words</name><index>[<expr><name>wordNo</name></expr>]</index></name><operator>)</operator><operator>&gt;&gt;</operator><name>numOfShiftingBits</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* OR those shifted bits into the next word in the array. */</comment>
		<if_stmt><if>if <condition>(<expr><name>wordNo</name> <operator>&lt;</operator> <name>maxNumOfWords</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>words</name><index>[<expr><name>wordNo</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>tmpWord</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		
	</block_content>}</block></for>

	<comment type="block">/* obtain bits after 'startLoc'.*/</comment>
	<expr_stmt><expr><name>tmpWord</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><operator>(</operator><name><name>words</name><index>[<expr><name>startWordNo</name></expr>]</index></name><operator>&lt;&lt;</operator>
				<operator>(</operator><name>startLoc</name><operator>%</operator><name>BM_HRL_WORD_SIZE</name><operator>)</operator><operator>)</operator><operator>)</operator><operator>&gt;&gt;</operator><operator>(</operator><name>startLoc</name><operator>%</operator><name>BM_HRL_WORD_SIZE</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * When startLoc%BM_HRL_WORD_SIZE is 0, we want to shift all 64 bits.
	 * There is no way to use the bit-shifting to shift all 64 bits out
	 * of a 64-bit integer. So just simply set the word to 0.
	 * Otherwise, use bit-shifting to shift out the bits after 'startLoc'.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>startLoc</name><operator>%</operator><name>BM_HRL_WORD_SIZE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>words</name><index>[<expr><name>startWordNo</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><operator>(</operator><name><name>words</name><index>[<expr><name>startWordNo</name></expr>]</index></name><operator>&gt;&gt;</operator>
											<operator>(</operator><name>BM_HRL_WORD_SIZE</name><operator>-</operator><name>startLoc</name><operator>%</operator><name>BM_HRL_WORD_SIZE</name><operator>)</operator><operator>)</operator><operator>)</operator><operator>&lt;&lt;</operator>
			<operator>(</operator><name>BM_HRL_WORD_SIZE</name><operator>-</operator><name>startLoc</name><operator>%</operator><name>BM_HRL_WORD_SIZE</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>words</name><index>[<expr><name>startWordNo</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>numOfFinalShiftingBits</name> <operator>=</operator> <name>numOfShiftingBits</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>BM_HRL_WORD_SIZE</name> <operator>-</operator> <name>startLoc</name> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name> <operator>&lt;</operator> <name>numOfShiftingBits</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numOfFinalShiftingBits</name> <operator>=</operator> <name>BM_HRL_WORD_SIZE</name> <operator>-</operator> <name>startLoc</name> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>words</name><index>[<expr><name>startWordNo</name></expr>]</index></name> <operator>|=</operator> <operator>(</operator><name>tmpWord</name><operator>&gt;&gt;</operator><name>numOfFinalShiftingBits</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>startWordNo</name> <operator>&lt;</operator> <name>maxNumOfWords</name><operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tmpWord</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><operator>(</operator><name>tmpWord</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>BM_HRL_WORD_SIZE</name> <operator>-</operator> <name>numOfFinalShiftingBits</name><operator>)</operator><operator>)</operator><operator>)</operator><operator>&gt;&gt;</operator>
			<operator>(</operator><name>numOfShiftingBits</name> <operator>-</operator> <name>numOfFinalShiftingBits</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>words</name><index>[<expr><name>startWordNo</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>tmpWord</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * insert_newwords() -- insert a buffer of new words into a given buffer of
 *   words at a specified position.
 *
 * The new words will be inserted into the positions starting from
 * 'insertPos'(&gt;=0). The original words from 'insertPos' will be shifted
 * to the right. If the given array does not have enough space to
 * hold all words, the last '(*numWordsP+numNewWords-maxNumWords)' words
 * will be stored in the buffer 'words_left', for which the caller should set
 * the enough space to hold these left words.
 *
 * All three buffers are specified as BMTIDBuffer objects, in which the following
 * fields are used:
 *   curword -- the number of content words in this buffer.
 *   num_cwords -- the maximum number of content words that are allowed.
 *   hwords -- the header words
 *   cwords -- the content words
 *
 * This function assumes that the number of new words is not greater than BM_HRL_WORD_SIZE.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>insert_newwords</name><parameter_list>(<parameter><decl><type><name>BMTIDBuffer</name><modifier>*</modifier></type> <name>words</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>insertPos</name></decl></parameter>,
				<parameter><decl><type><name>BMTIDBuffer</name><modifier>*</modifier></type> <name>new_words</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name><modifier>*</modifier></type> <name>words_left</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>	<name>wordNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>  <name>bitLoc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name> <operator>&lt;=</operator> <name>BM_HRL_WORD_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>insertPos</name> <operator>&lt;=</operator> <name><name>words</name><operator>-&gt;</operator><name>num_cwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>words_left</name><operator>-&gt;</operator><name>curword</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* if there are no words in the original buffer, we simply copy the new words. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>curword</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>, <argument><expr><name><name>new_words</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>, <argument><expr><name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>new_words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>,
			   <argument><expr><call><name>BM_CALC_H_WORDS</name><argument_list>(<argument><expr><name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>curword</name></name> <operator>=</operator> <name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if insertPos is pointing to the position after the maximum position
	 * in this word, we simply copy the new words to leftContentWords.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>insertPos</name> <operator>==</operator> <name><name>words</name><operator>-&gt;</operator><name>num_cwords</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>words_left</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>, <argument><expr><name><name>new_words</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>,
			   <argument><expr><name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>words_left</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>new_words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>,
			   <argument><expr><call><name>BM_CALC_H_WORDS</name><argument_list>(<argument><expr><name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>words_left</name><operator>-&gt;</operator><name>curword</name></name> <operator>=</operator> <name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>curword</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Calculate how many words left after this insert. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>curword</name></name> <operator>+</operator> <name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name> <operator>&gt;</operator> <name><name>words</name><operator>-&gt;</operator><name>num_cwords</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>words_left</name><operator>-&gt;</operator><name>curword</name></name> <operator>=</operator> <name><name>words</name><operator>-&gt;</operator><name>curword</name></name> <operator>+</operator> <name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name> <operator>-</operator> <name><name>words</name><operator>-&gt;</operator><name>num_cwords</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>words_left</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BM_NUM_OF_HEADER_WORDS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Walk from the last word in the array back to 'insertPos'.
	 * If the word no + new_words-&gt;curword is greater than words-&gt;num_cwords,
	 * we store these words in words_left.
	 */</comment>
	<for>for <control>(<init><expr><name>wordNo</name><operator>=</operator><name><name>words</name><operator>-&gt;</operator><name>curword</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>wordNo</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>wordNo</name><operator>&gt;=</operator><name>insertPos</name></expr>;</condition> <incr><expr><name>wordNo</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>wordNo</name> <operator>+</operator> <name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name> <operator>&gt;=</operator> <name><name>words</name><operator>-&gt;</operator><name>num_cwords</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>words_left</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>wordNo</name><operator>+</operator><name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name><operator>-</operator><name><name>words</name><operator>-&gt;</operator><name>num_cwords</name></name></expr>]</index></name> <operator>=</operator> 
				<name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>wordNo</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name>wordNo</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>o</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name>wordNo</name><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>n</name> <init>= <expr><name>wordNo</name> <operator>+</operator> <name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name> <operator>-</operator> <name><name>words</name><operator>-&gt;</operator><name>num_cwords</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>words_left</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <call><name>WORDNO_GET_HEADER_BIT</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><name>o</name></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><call><name>WORDNO_GET_HEADER_BIT</name><argument_list>(<argument><expr><name>wordNo</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>wordNo</name> <operator>+</operator> <name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name></expr>]</index></name> <operator>=</operator> <name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>wordNo</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* insert new words */</comment>
	<for>for <control>(<init><expr><name>wordNo</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>wordNo</name><operator>&lt;</operator><name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name></expr>;</condition> <incr><expr><name>wordNo</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>insertPos</name><operator>+</operator><name>wordNo</name><operator>&gt;=</operator> <name><name>words</name><operator>-&gt;</operator><name>num_cwords</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type> 	<name>n</name> <init>= <expr><name>insertPos</name> <operator>+</operator> <name>wordNo</name> <operator>-</operator> <name><name>words</name><operator>-&gt;</operator><name>num_cwords</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>words_left</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name><name>new_words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>wordNo</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>new_words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name>wordNo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>words_left</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <call><name>WORDNO_GET_HEADER_BIT</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>insertPos</name><operator>+</operator><name>wordNo</name></expr>]</index></name> <operator>=</operator> <name><name>new_words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>wordNo</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* right-shift the bits in the header words */</comment>
	<expr_stmt><expr><call><name>shift_header_bits</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>words</name><operator>-&gt;</operator><name>curword</name></name></expr></argument>, 
					  <argument><expr><name>BM_NUM_OF_HEADER_WORDS</name></expr></argument>, <argument><expr><name>insertPos</name></expr></argument>,
					  <argument><expr><name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set the newWords header bits */</comment>
	<for>for <control>(<init><expr><name>bitLoc</name> <operator>=</operator> <name>insertPos</name></expr>;</init>
		 <condition><expr><name>bitLoc</name> <operator>&lt;</operator> <name>insertPos</name> <operator>+</operator> <name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name> <operator>&amp;&amp;</operator> <name>bitLoc</name> <operator>&lt;</operator> <name><name>words</name><operator>-&gt;</operator><name>num_cwords</name></name></expr>;</condition>
		 <incr><expr><name>bitLoc</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>new_words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name>bitLoc</name><operator>-</operator><name>insertPos</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>off</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator><name>bitLoc</name><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><name>off</name></expr>]</index></name> <operator>|=</operator> <call><name>WORDNO_GET_HEADER_BIT</name><argument_list>(<argument><expr><name>bitLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>curword</name></name> <operator>+=</operator> <operator>(</operator><name><name>new_words</name><operator>-&gt;</operator><name>curword</name></name> <operator>-</operator> <name><name>words_left</name><operator>-&gt;</operator><name>curword</name></name><operator>)</operator></expr>;</expr_stmt>	
</block_content>}</block></function>

<comment type="block">/*
 * updatesetbit_inpage() -- update the given bit to 1 in a given
 *	bitmap page.
 *
 * The argument 'firstTidNumber' indicates the first tid location of
 * the bits stored in this page. This is necessary for locating the bit
 * of 'tidnum'.
 *
 * This update may generate new words that cause this page to overflow.
 * In this case, we will first check the next bitmap page have enough
 * space for these new words. If so, we update these two pages. Otherwise,
 * a new bitmap page is created.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>updatesetbit_inpage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>,
					<parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>,
					<parameter><decl><type><name>Buffer</name></type> <name>bitmapBuffer</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>firstTidNumber</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type> 			<name>bitmapPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBitmapOpaque</name></type>	<name>bitmapOpaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBitmap</name></type>		<name>bitmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>			<name>nextBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>			<name>nextPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBitmapOpaque</name></type>	<name>nextOpaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBitmap</name></type>		<name>nextBitmap</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type>			<name>bitNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>			<name>wordNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>          <name>free_words</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BM_HRL_WORD</name></type>		<name>word</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>BMTIDBuffer</name></type>     <name>words</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMTIDBuffer</name></type>     <name>new_words</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMTIDBuffer</name></type>     <name>words_left</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>			<name>new_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>new_lastpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>             <name>word_no</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>bitmapPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitmapOpaque</name> <operator>=</operator> <operator>(</operator><name>BMBitmapOpaque</name><operator>)</operator><call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <operator>(</operator><name>BMBitmap</name><operator>)</operator> <call><name>PageGetContentsMaxAligned</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_bitmap_print_insert</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Bitmap Insert: updating a set bit in bitmap block %d, "</literal>
			 <literal type="string">"lovBlock=%d, lovOffset=%d"</literal>
			 <literal type="string">", firstTidNumber="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", bm_last_tid_location="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", tidnum="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", idxrelid=%u"</literal></expr></argument>,
			 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name>lovOffset</name></expr></argument>,
			 <argument><expr><name>firstTidNumber</name></expr></argument>,
			 <argument><expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr></argument>,
			 <argument><expr><name>tidnum</name></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<comment type="block">/* Find the word that contains the bit of tidnum. */</comment>
	<for>for <control>(<init><expr><name>wordNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordNo</name> <operator>&lt;</operator> <name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr>;</condition> <incr><expr><name>wordNo</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>word</name> <operator>=</operator> <name><name>bitmap</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>wordNo</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name>wordNo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>bitNo</name> <operator>+=</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>bitNo</name> <operator>+=</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>firstTidNumber</name> <operator>+</operator> <name>bitNo</name> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>tidnum</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>		<comment type="block">/* find the word */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find bitmap word for tid "</literal> <name>INT64_FORMAT</name>
						<literal type="string">" in bitmap index %u"</literal>
						<literal type="string">" (relfilenode %u/%u/%u, bitmap block %d, LOV block %d, LOV offset %d)"</literal></expr></argument>,
						<argument><expr><name>tidnum</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
						<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Reindex bitmap index \"%s\"."</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>wordNo</name> <operator>&lt;=</operator> <name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the word containing the updating bit is a literal word,
	 * we simply update the word, and return.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name>wordNo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint16</name></type> <name>insertingPos</name> <init>= <expr><operator>(</operator><name>tidnum</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>bitmap</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>wordNo</name></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name>insertingPos</name><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bitmap_log_updateword</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>bitmapBuffer</name></expr></argument>, <argument><expr><name>wordNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><name>Debug_bitmap_print_insert</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Bitmap Insert: updated a set bit in bitmap block %d, "</literal>
				 <literal type="string">"lovBlock=%d, lovOffset=%d"</literal>
				 <literal type="string">", firstTidNumber="</literal> <name>INT64_FORMAT</name>
				 <literal type="string">", bm_last_tid_location="</literal> <name>INT64_FORMAT</name>
				 <literal type="string">", tidnum="</literal> <name>INT64_FORMAT</name>
				 <literal type="string">", wordNo=%d"</literal>
				 <literal type="string">", idxrelid=%u"</literal></expr></argument>,
				 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>lovOffset</name></expr></argument>,
				 <argument><expr><name>firstTidNumber</name></expr></argument>,
				 <argument><expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr></argument>,
				 <argument><expr><name>tidnum</name></expr></argument>,
				 <argument><expr><name>wordNo</name></expr></argument>,
				 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If this bit is already 1, then simply return. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Debug_bitmap_print_insert</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Bitmap Insert: no update is needed in bitmap block %d, "</literal>
				 <literal type="string">"lovBlock=%d, lovOffset=%d"</literal>
				 <literal type="string">", firstTidNumber="</literal> <name>INT64_FORMAT</name>
				 <literal type="string">", bm_last_tid_location="</literal> <name>INT64_FORMAT</name>
				 <literal type="string">", tidnum="</literal> <name>INT64_FORMAT</name>
				 <literal type="string">", wordNo=%d"</literal>
				 <literal type="string">", idxrelid=%u"</literal></expr></argument>,
				 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>lovOffset</name></expr></argument>,
				 <argument><expr><name>firstTidNumber</name></expr></argument>,
				 <argument><expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr></argument>,
				 <argument><expr><name>tidnum</name></expr></argument>,
				 <argument><expr><name>wordNo</name></expr></argument>,
				 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>firstTidNumber</name> <operator>=</operator> <name>firstTidNumber</name> <operator>+</operator> <name>bitNo</name> <operator>-</operator>
					 <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
		
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tidnum</name> <operator>&gt;=</operator> <name>firstTidNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_words</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_words</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>buf_extend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>updatesetbit_inword</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>tidnum</name> <operator>-</operator> <name>firstTidNumber</name></expr></argument>, <argument><expr><name>firstTidNumber</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>new_words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure that there are at most 3 new words. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>new_words</name><operator>.</operator><name>curword</name></name> <operator>&lt;=</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>new_words</name><operator>.</operator><name>curword</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>off</name> <init>= <expr><name>wordNo</name><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>bitmap</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>wordNo</name></expr>]</index></name> <operator>=</operator> <name><name>new_words</name><operator>.</operator><name>cwords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><name>off</name></expr>]</index></name> <operator>&amp;=</operator> <operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><operator>(</operator><operator>~</operator><call><name>WORDNO_GET_HEADER_BIT</name><argument_list>(<argument><expr><name>wordNo</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>new_words</name><operator>.</operator><name>hwords</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incorrect header bit found in bitmap index %u; expected header bit 1"</literal>
							<literal type="string">" (relfilenode %u/%u/%u, bitmap block %d, LOV block %d, LOV offset %d)"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
							<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>new_words</name><operator>.</operator><name>hwords</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator>
			   <call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name>wordNo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bitmap_log_updateword</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>bitmapBuffer</name></expr></argument>, <argument><expr><name>wordNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>Debug_bitmap_print_insert</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Bitmap Insert: updated a set bit in bitmap block %d, "</literal>
				 <literal type="string">"lovBlock=%d, lovOffset=%d"</literal>
				 <literal type="string">", firstTidNumber="</literal> <name>INT64_FORMAT</name>
				 <literal type="string">", bm_last_tid_location="</literal> <name>INT64_FORMAT</name>
				 <literal type="string">", tidnum="</literal> <name>INT64_FORMAT</name>
				 <literal type="string">", wordNo=%d, header bit=%d, idxrelid=%u"</literal></expr></argument>,
				 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>lovOffset</name></expr></argument>,
				 <argument><expr><name>firstTidNumber</name></expr></argument>,
				 <argument><expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr></argument>,
				 <argument><expr><name>tidnum</name></expr></argument>,
				 <argument><expr><name>wordNo</name></expr></argument>,
				 <argument><expr><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>		
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check if this page has enough space for all new words. If so,
	 * replace this word with new words. Otherwise,
	 * we first check if the next page has enough space for all new words.
	 * If so, insert new words to the next page, otherwise,
	 * create a new page.
	 */</comment>
	<expr_stmt><expr><name>free_words</name> <operator>=</operator> <name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name> <operator>-</operator>
			<name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>new_page</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_lastpage</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextBuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>free_words</name> <operator>&lt;</operator> <name><name>new_words</name><operator>.</operator><name>curword</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_bitmap_next</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nextBuffer</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_bitmap_next</name></name></expr></argument>,
										<argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nextPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>nextBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nextOpaque</name> <operator>=</operator> <operator>(</operator><name>BMBitmapOpaque</name><operator>)</operator><call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>nextPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>free_words</name> <operator>=</operator> <name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name> <operator>-</operator>
				<name><name>nextOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else
		<block>{<block_content>
			<expr_stmt><expr><name>new_lastpage</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>free_words</name> <operator>&lt;</operator> <name><name>new_words</name><operator>.</operator><name>curword</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>nextBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>nextBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>nextBuffer</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bitmap_init_bitmappage</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>nextBuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_page</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>free_words</name> <operator>=</operator> <name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>nextBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>nextBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>new_lastpage</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type> 		<name>lovPage</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BMLOVItem</name></type>	<name>lovItem</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lovPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lovItem</name> <operator>=</operator> <operator>(</operator><name>BMLOVItem</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, 
			<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_lov_tail</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>nextBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_bitmap_print_insert</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Bitmap Insert: updated a set bit in bitmap block %d, "</literal>
			 <literal type="string">"lovBlock=%d, lovOffset=%d"</literal>
			 <literal type="string">", firstTidNumber="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", bm_last_tid_location="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", tidnum="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", generate %d new words, %d new bitmap page"</literal>
			 <literal type="string">", idxrelid=%u"</literal></expr></argument>,
			 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name>lovOffset</name></expr></argument>,
			 <argument><expr><name>firstTidNumber</name></expr></argument>,
			 <argument><expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr></argument>,
			 <argument><expr><name>tidnum</name></expr></argument>,
			 <argument><expr><name><name>new_words</name><operator>.</operator><name>curword</name></name></expr></argument>,
			 <argument><expr><name>new_page</name></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>bitmap</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>wordNo</name></expr>]</index></name> <operator>=</operator> <name><name>new_words</name><operator>.</operator><name>cwords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tidnum</name> <operator>-</operator> <name>firstTidNumber</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>BM_HRL_WORD_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>off</name> <init>= <expr><name>wordNo</name><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><name>off</name></expr>]</index></name> <operator>&amp;=</operator> <operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><operator>(</operator><operator>~</operator><call><name>WORDNO_GET_HEADER_BIT</name><argument_list>(<argument><expr><name>wordNo</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>new_words</name><operator>.</operator><name>hwords</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incorrect header bit found in bitmap index %u; expected header bit 1"</literal>
							<literal type="string">" (relfilenode %u/%u/%u, bitmap block %d, LOV block %d, LOV offset %d)"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
							<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ignore the first word in new_words.cwords. */</comment>
	<expr_stmt><expr><name><name>new_words</name><operator>.</operator><name>hwords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><name><name>new_words</name><operator>.</operator><name>hwords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>word_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>word_no</name> <operator>&lt;</operator> <name><name>new_words</name><operator>.</operator><name>curword</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>word_no</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>new_words</name><operator>.</operator><name>cwords</name><index>[<expr><name>word_no</name></expr>]</index></name> <operator>=</operator> <name><name>new_words</name><operator>.</operator><name>cwords</name><index>[<expr><name>word_no</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>new_words</name><operator>.</operator><name>curword</name></name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* Create the buffer for the original words */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>words</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>words</name><operator>.</operator><name>cwords</name></name> <operator>=</operator> <name><name>bitmap</name><operator>-&gt;</operator><name>cwords</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>words</name><operator>.</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>,
		   <argument><expr><call><name>BM_CALC_H_WORDS</name><argument_list>(<argument><expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>words</name><operator>.</operator><name>num_cwords</name></name> <operator>=</operator> <name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>words</name><operator>.</operator><name>curword</name></name> <operator>=</operator> <name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>words_left</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>words_left</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>buf_extend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>words_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>insert_newwords</name><argument_list>(<argument><expr><operator>&amp;</operator><name>words</name></expr></argument>, <argument><expr><name>wordNo</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_words</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>words_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have to copy header words back to the page, and set the correct
	 * number of words in the page.
	 */</comment>
	<expr_stmt><expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name> <operator>=</operator> <name><name>words</name><operator>.</operator><name>curword</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>words</name><operator>.</operator><name>hwords</name></name></expr></argument>,
		   <argument><expr><call><name>BM_CALC_H_WORDS</name><argument_list>(<argument><expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>new_page</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nextPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>nextBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextOpaque</name> <operator>=</operator> <operator>(</operator><name>BMBitmapOpaque</name><operator>)</operator><call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>nextPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextBitmap</name> <operator>=</operator> <operator>(</operator><name>BMBitmap</name><operator>)</operator><call><name>PageGetContentsMaxAligned</name><argument_list>(<argument><expr><name>nextPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>nextOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>=</operator> <name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nextOpaque</name><operator>-&gt;</operator><name>bm_bitmap_next</name></name> <operator>=</operator> <name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_bitmap_next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_bitmap_next</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>nextBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>-=</operator>
		<call><name>GET_NUM_BITS</name><argument_list>(<argument><expr><name><name>words_left</name><operator>.</operator><name>cwords</name></name></expr></argument>, <argument><expr><name><name>words_left</name><operator>.</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>words_left</name><operator>.</operator><name>curword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>words_left</name><operator>.</operator><name>curword</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nextPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>nextBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextOpaque</name> <operator>=</operator> <operator>(</operator><name>BMBitmapOpaque</name><operator>)</operator><call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>nextPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextBitmap</name> <operator>=</operator> <operator>(</operator><name>BMBitmap</name><operator>)</operator><call><name>PageGetContentsMaxAligned</name><argument_list>(<argument><expr><name>nextPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create the buffer for the original words */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>words</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>words</name><operator>.</operator><name>cwords</name></name> <operator>=</operator> <name><name>nextBitmap</name><operator>-&gt;</operator><name>cwords</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>words</name><operator>.</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>nextBitmap</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>,
			   <argument><expr><call><name>BM_CALC_H_WORDS</name><argument_list>(<argument><expr><name><name>nextOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>words</name><operator>.</operator><name>num_cwords</name></name> <operator>=</operator> <name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>words</name><operator>.</operator><name>curword</name></name> <operator>=</operator> <name><name>nextOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_words</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_words</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>insert_newwords</name><argument_list>(<argument><expr><operator>&amp;</operator><name>words</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>words_left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We have to copy header words back to the page, and set the correct
		 * number of words in the page.
		 */</comment>
		<expr_stmt><expr><name><name>nextOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name> <operator>=</operator> <name><name>words</name><operator>.</operator><name>curword</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>nextBitmap</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>words</name><operator>.</operator><name>hwords</name></name></expr></argument>,
			   <argument><expr><call><name>BM_CALC_H_WORDS</name><argument_list>(<argument><expr><name><name>nextOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"rearrange_word_to_next_bitmap_page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>new_words</name><operator>.</operator><name>curword</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bitmap_log_updatewords</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>,
								<argument><expr><name>bitmapBuffer</name></expr></argument>, <argument><expr><name>nextBuffer</name></expr></argument>, <argument><expr><name>new_lastpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>nextBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>nextBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>_bitmap_free_tidbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bitmap_free_tidbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>words_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * findbitmappage() -- find the bitmap page that contains
 *	the given tid location, and obtain the first tid location
 * 	in this page.
 *
 * We assume that this tid location is not in bm_last_compword or
 * bm_last_word of its LOVItem.
 *
 * We will have write lock on the bitmap page we find.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>findbitmappage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMLOVItem</name></type> <name>lovitem</name></decl></parameter>,
					   <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>,
					   <parameter><decl><type><name>Buffer</name><modifier>*</modifier></type> <name>bitmapBufferP</name></decl></parameter>, <parameter><decl><type><name>uint64</name><modifier>*</modifier></type> <name>firstTidNumberP</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nextBlockNo</name> <init>= <expr><name><name>lovitem</name><operator>-&gt;</operator><name>bm_lov_head</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>firstTidNumberP</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>nextBlockNo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type> <name>bitmapPage</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BMBitmapOpaque</name></type> <name>bitmapOpaque</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>bitmapBufferP</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nextBlockNo</name></expr></argument>, <argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bitmapPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>bitmapBufferP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bitmapOpaque</name> <operator>=</operator> <operator>(</operator><name>BMBitmapOpaque</name><operator>)</operator>
			<call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>&gt;=</operator> <name>tidnum</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>   		<comment type="block">/* find the page */</comment>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>firstTidNumberP</name><operator>)</operator> <operator>=</operator> <name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextBlockNo</name> <operator>=</operator> <name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_bitmap_next</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><operator>*</operator><name>bitmapBufferP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * We can't find such a page. This should not happen.
	 * So we error out.
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find bitmap page containing tid "</literal> <name>INT64_FORMAT</name>
					<literal type="string">" in bitmap index %u (relfilenode %u/%u/%u"</literal>
					<literal type="string">", next block %d, LOV head %d, LOV tail %d"</literal>
					<literal type="string">", firstTidNumber "</literal> <name>INT64_FORMAT</name>
					<literal type="string">", bm_last_tid_location "</literal> <name>INT64_FORMAT</name>
					<literal type="string">", bm_last_setbit "</literal> <name>INT64_FORMAT</name>
					<literal type="string">", bm_last_compword "</literal> <name>INT64_FORMAT</name>
					<literal type="string">", bm_last_word "</literal> <name>INT64_FORMAT</name>
					<literal type="string">", lov_words_header %d)"</literal></expr></argument>,
					<argument><expr><name>tidnum</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
					<argument><expr><name>nextBlockNo</name></expr></argument>, <argument><expr><name><name>lovitem</name><operator>-&gt;</operator><name>bm_lov_head</name></name></expr></argument>,
					<argument><expr><name><name>lovitem</name><operator>-&gt;</operator><name>bm_lov_tail</name></name></expr></argument>, <argument><expr><operator>*</operator><name>firstTidNumberP</name></expr></argument>, <argument><expr><name><name>lovitem</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr></argument>,
					<argument><expr><name><name>lovitem</name><operator>-&gt;</operator><name>bm_last_setbit</name></name></expr></argument>, <argument><expr><name><name>lovitem</name><operator>-&gt;</operator><name>bm_last_compword</name></name></expr></argument>,
					<argument><expr><name><name>lovitem</name><operator>-&gt;</operator><name>bm_last_word</name></name></expr></argument>, <argument><expr><name><name>lovitem</name><operator>-&gt;</operator><name>lov_words_header</name></name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Reindex bitmap index \"%s\"."</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * verify_bitmappages() -- verify if the bm_last_tid_location values
 * 	are valid in all bitmap pages. Only used during debugging.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>verify_bitmappages</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMLOVItem</name></type> <name>lovitem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nextBlockNo</name> <init>= <expr><name><name>lovitem</name><operator>-&gt;</operator><name>bm_lov_head</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>tidnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>nextBlockNo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type> <name>bitmapPage</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BMBitmapOpaque</name></type> <name>bitmapOpaque</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type> <name>bitmapBuffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>wordNo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BMBitmap</name></type> <name>bitmap</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>bitmapBuffer</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nextBlockNo</name></expr></argument>, <argument><expr><name>BM_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bitmapPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bitmapOpaque</name> <operator>=</operator> <operator>(</operator><name>BMBitmapOpaque</name><operator>)</operator>
			<call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <operator>(</operator><name>BMBitmap</name><operator>)</operator> <call><name>PageGetContentsMaxAligned</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>wordNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordNo</name> <operator>&lt;</operator> <name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr>;</condition> <incr><expr><name>wordNo</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>word</name> <init>= <expr><name><name>bitmap</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>wordNo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name>wordNo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tidnum</name> <operator>+=</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>tidnum</name> <operator>+=</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>!=</operator> <name>tidnum</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected bm_last_tid_location "</literal> <name>INT64_FORMAT</name>
				 <literal type="string">" found for bitmap block %d in bitmap index %u (relfilenode %u/%u/%u);"</literal>
				 <literal type="string">" expected tid "</literal> <name>INT64_FORMAT</name></expr></argument>,
				 <argument><expr><name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr></argument>, <argument><expr><name>nextBlockNo</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>, <argument><expr><name>tidnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>nextBlockNo</name> <operator>=</operator> <name><name>bitmapOpaque</name><operator>-&gt;</operator><name>bm_bitmap_next</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * mergewords() -- merge last two bitmap words based on the HRL compression
 * 	scheme. If these two words can not be merged, the last complete
 * 	word will be appended into the word array in the buffer.
 *
 * If the buffer is extended, this function returns the number
 * of bytes used.
 */</comment>
<function><type><specifier>static</specifier> <name>int16</name></type>
<name>mergewords</name><parameter_list>(<parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lastWordFill</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type> <name>bytes_used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* the last_tid in the complete word */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>last_tid</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name><operator>%</operator><name>BM_HRL_WORD_SIZE</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If last_compword is LITERAL_ALL_ONE, it is not set yet.
	 * We move last_word to it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name> <operator>==</operator> <name>LITERAL_ALL_ONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>is_last_compword_fill</name></name> <operator>=</operator> <name>lastWordFill</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lastWordFill</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>last_tid</name> <operator>=</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>last_tid</name> <operator>=</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name> <operator>=</operator> <name>last_tid</name></expr>;</expr_stmt>

		<return>return <expr><name>bytes_used</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * If both words are fill words, and have the same fill bit,
	 * we increment the fill length of the last complete word by
	 * the fill length stored in the last word.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>is_last_compword_fill</name></name> <operator>&amp;&amp;</operator> <name>lastWordFill</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
		 <call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>lengthMerged</name></decl>;</decl_stmt>
			
		<if_stmt><if>if <condition>(<expr><call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator>
			<name>MAX_FILL_LENGTH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>last_tid</name> <operator>+=</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name></expr></argument>)</argument_list></call><operator>*</operator><name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name> <operator>+=</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name> <operator>=</operator> <name>LITERAL_ALL_ZERO</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name> <operator>=</operator> <name>last_tid</name></expr>;</expr_stmt>

			<return>return <expr><name>bytes_used</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>lengthMerged</name> <operator>=</operator>
			<name>MAX_FILL_LENGTH</name> <operator>-</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name> <operator>-=</operator> <name>lengthMerged</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_tid</name> <operator>+=</operator> <name>lengthMerged</name> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name> <operator>+=</operator> <name>lengthMerged</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Here, these two words can not be merged together. We
	 * move the last complete word to the array, and set it to be the
	 * last word.
	 */</comment>

	<comment type="block">/*
	 * When there are not enough space in the array of new words,
	 * we re-allocate a bigger space.
	 */</comment>
	<expr_stmt><expr><name>bytes_used</name> <operator>+=</operator> <call><name>buf_extend</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name></expr>]</index></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name></expr>]</index></name> <operator>=</operator> <name>last_tid</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>is_last_compword_fill</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr>]</index></name> <operator>|=</operator>
			<operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>BM_HRL_WORD_SIZE</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator>
								 <name><name>buf</name><operator>-&gt;</operator><name>curword</name></name> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name> <operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>is_last_compword_fill</name></name> <operator>=</operator> <name>lastWordFill</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>is_last_compword_fill</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_tid</name> <operator>+=</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_tid</name> <operator>+=</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name> <operator>=</operator> <name>last_tid</name></expr>;</expr_stmt>

	<return>return <expr><name>bytes_used</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_write_new_bitmapwords() -- write a given buffer of new bitmap words
 * 	into the end of bitmap page(s).
 *
 * If the last bitmap page does not have enough space for all these new
 * words, new pages will be allocated here.
 *
 * We consider a write to one bitmap page as one atomic-action WAL
 * record. The WAL record for the write to the last bitmap page also
 * includes updates on the lov item. Writes to the non-last
 * bitmap page are not self-consistent. We need to do some fix-up
 * during WAL logic replay.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bitmap_write_new_bitmapwords</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							  <parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>,
							  <parameter><decl><type><name>BMTIDBuffer</name><modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>lovPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMLOVItem</name></type>	<name>lovItem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first_page_needs_init</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>perpage_buffers</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>perpage_xlrecs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcb</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lovPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lovItem</name> <operator>=</operator> <operator>(</operator><name>BMLOVItem</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>,
									  <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Write changes to bitmap pages, if needed. (We might get away by
	 * updating just the last words stored on the LOV item.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>first_blkno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>last_blkno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>perpage_tmppages</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_first</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>buffer_cell</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>start_wordno</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Write bitmap words, one page at a time, allocating new pages as
		 * required.
		 */</comment>
		<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>start_wordno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<do>do
		<block>{<block_content>
			<decl_stmt><decl><type><name>Buffer</name></type>		<name>bitmapBuffer</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>bitmapBufferNeedsInit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Page</name></type>		<name>bitmapPage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BMBitmapOpaque</name></type>	<name>bitmapPageOpaque</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>numFreeWords</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>words_written</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>xl_bm_bitmapwords_perpage</name> <modifier>*</modifier></type><name>xlrec_perpage</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Page</name></type>		<name>tmppage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>is_first</name> <operator>&amp;&amp;</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_lov_head</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>bitmapBuffer</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_lov_tail</name></name></expr></argument>, <argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Append to an existing LOV page as much as fits */</comment>
				<expr_stmt><expr><name>bitmapPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitmapPageOpaque</name> <operator>=</operator>
					<operator>(</operator><name>BMBitmapOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>numFreeWords</name> <operator>=</operator> <name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name> <operator>-</operator>
					<name><name>bitmapPageOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Allocate new page */</comment>
				<expr_stmt><expr><name>bitmapBuffer</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitmapBufferNeedsInit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>numFreeWords</name> <operator>=</operator> <name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Remember information about the first page, needed
			 * for updating the LOV and for the WAL record.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>is_first</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>first_blkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>first_page_needs_init</name> <operator>=</operator> <name>bitmapBufferNeedsInit</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>xlrec_perpage</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_bm_bitmapwords_perpage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>xlrec_perpage</name><operator>-&gt;</operator><name>bmp_blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>xlrec_perpage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>perpage_buffers</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>perpage_buffers</name></expr></argument>, <argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>perpage_xlrecs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>perpage_xlrecs</name></expr></argument>, <argument><expr><name>xlrec_perpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>perpage_buffers</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAX_BITMAP_PAGES_PER_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many bitmap pages in one insert batch into bitmap index %u"</literal>
					 <literal type="string">" (relfilenode %u/%u/%u, LOV block %d, LOV offset %d)"</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
					 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Allocate a new temporary page to operate on, in case we fail
			 * half-way through the updates (because of running out of memory
			 * or disk space, most likely). If this is the last bitmap page,
			 * i.e. we can fit all the remaining words on this bitmap page,
			 * though, we can skip that, and modify the page directly.
			 *
			 * If this is not the last page, we will need to allocate more
			 * pages. That in turn might fail, so we must not modify the
			 * existing pages yet.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>numFreeWords</name> <operator>&lt;</operator> <name><name>buf</name><operator>-&gt;</operator><name>curword</name></name> <operator>-</operator> <name>start_wordno</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Does not fit, we will need to expand.
				 *
				 * Note: we don't write to the page until we're sure we get
				 * all of them. We do all the action on temp copies.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>bitmapBufferNeedsInit</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>tmppage</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>_bitmap_init_bitmappage</name><argument_list>(<argument><expr><name>tmppage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>tmppage</name> <operator>=</operator> <call><name>PageGetTempPageCopy</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>bitmapPage</name> <operator>=</operator> <name>tmppage</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>perpage_tmppages</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>perpage_tmppages</name></expr></argument>, <argument><expr><name>tmppage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * This is the last page. Now that we have successfully
				 * fetched/allocated it, none of the things we do should
				 * ereport(), so we can make the changes directly to the
				 * buffer.
				 */</comment>
				<expr_stmt><expr><name>bitmapPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>bitmapBufferNeedsInit</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>_bitmap_init_bitmappage</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>words_written</name> <operator>=</operator>
				<call><name>_bitmap_write_bitmapwords_on_page</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
												  <argument><expr><name>start_wordno</name></expr></argument>, <argument><expr><name>xlrec_perpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>is_first</name> <operator>||</operator> <name>words_written</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>start_wordno</name> <operator>+=</operator> <name>words_written</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>bitmapPage</name> <operator>!=</operator> <name>tmppage</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>last_blkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name> <operator>-</operator> <name>start_wordno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>start_wordno</name> <operator>==</operator> <name><name>buf</name><operator>-&gt;</operator><name>curword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Ok, we have locked all the pages we need. Apply any changes we had made on
		 * temporary pages.
		 *
		 * NOTE: there is one fewer temppage.
		 */</comment>
		<expr_stmt><expr><name>buffer_cell</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>perpage_buffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lcp</argument>, <argument>perpage_tmppages</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>tmppage</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name> <init>= <expr><operator>(</operator><name>Buffer</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>buffer_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nextBlkNo</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BMBitmapOpaque</name></type>	<name>bitmapPageOpaque</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>PageRestoreTempPage</name><argument_list>(<argument><expr><name>tmppage</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Update the 'next' pointer on this page, before moving on */</comment>
			<expr_stmt><expr><name>buffer_cell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>buffer_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nextBlkNo</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><operator>(</operator><name>Buffer</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>buffer_cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>bitmapPageOpaque</name> <operator>=</operator>
				<operator>(</operator><name>BMBitmapOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>bitmapPageOpaque</name><operator>-&gt;</operator><name>bm_bitmap_next</name></name> <operator>=</operator> <name>nextBlkNo</name></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>perpage_tmppages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the bitmap page pointers in the LOV item */</comment>
		<if_stmt><if>if <condition>(<expr><name>first_page_needs_init</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_lov_head</name></name> <operator>=</operator> <name>first_blkno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_lov_tail</name></name> <operator>=</operator> <name>last_blkno</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Update LOV item (lov_head/tail were updated above already) */</comment>
	<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_word</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>lov_words_header</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>is_last_compword_fill</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_setbit</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Write WAL record */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bitmap_log_bitmapwords</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
									<argument><expr><name>first_page_needs_init</name></expr></argument>, <argument><expr><name>perpage_xlrecs</name></expr></argument>, <argument><expr><name>perpage_buffers</name></expr></argument>,
									<argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bitmap_log_bitmap_lastwords</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>, <argument><expr><name>lovItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_bitmap_print_insert</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Bitmap Insert: write bitmapwords: numwords=%d"</literal>
			 <literal type="string">", last_tid="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", lov_blkno=%d, lov_offset=%d, lovItem-&gt;bm_last_setbit="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", lovItem-&gt;bm_last_tid_location="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", idxrelid=%u"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>curword</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name></expr></argument>,
			 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>,
			 <argument><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_setbit</name></name></expr></argument>, <argument><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* release all bitmap buffers. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lcb</argument>, <argument>perpage_buffers</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><operator>(</operator><name>Buffer</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lcb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * _bitmap_write_bitmapwords_on_page() -- Write an array of bitmap words into
 * the given bitmap page. Returns the number of words that have been written
 * in this call.
 *
 * The number of bitmap words writing to a given bitmap page is the maximum
 * number of words that can be appended into the page.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>_bitmap_write_bitmapwords_on_page</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>bitmapPage</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startWordNo</name></decl></parameter>,
								  <parameter><decl><type><name>xl_bm_bitmapwords_perpage</name> <modifier>*</modifier></type><name>xlrec_perpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMBitmapOpaque</name></type>	<name>bitmapPageOpaque</name> <init>= <expr><operator>(</operator><name>BMBitmapOpaque</name><operator>)</operator><call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBitmap</name></type>		<name>bitmap</name> <init>= <expr><operator>(</operator><name>BMBitmap</name><operator>)</operator> <call><name>PageGetContentsMaxAligned</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>			<name>cwords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> 			<name>words_written</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>			<name>start_hword_no</name></decl>, <decl><type ref="prev"/><name>end_hword_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>			<name>final_start_hword_no</name></decl>, <decl><type ref="prev"/><name>final_end_hword_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BM_HRL_WORD</name></type>		<name><name>hwords</name><index>[<expr><name>BM_MAX_NUM_OF_HEADER_WORDS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>			<name>num_hwords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>			<name>start_hword_bit</name></decl>, <decl><type ref="prev"/><name>end_hword_bit</name></decl>, <decl><type ref="prev"/><name>final_start_hword_bit</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cwords</name> <operator>=</operator> <name><name>bitmapPageOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>words_written</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>curword</name></name> <operator>-</operator> <name>startWordNo</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>words_written</name> <operator>&gt;</operator> <name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name> <operator>-</operator> <name>cwords</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>words_written</name> <operator>=</operator> <name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name> <operator>-</operator> <name>cwords</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>words_written</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This page is full. We still include it in the WAL record, to keep this
		 * case the same as the general case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>xlrec_perpage</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>xlrec_perpage</name><operator>-&gt;</operator><name>bmp_last_tid</name></name> <operator>=</operator> <name><name>bitmapPageOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec_perpage</name><operator>-&gt;</operator><name>bmp_start_hword_no</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec_perpage</name><operator>-&gt;</operator><name>bmp_num_hwords</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec_perpage</name><operator>-&gt;</operator><name>bmp_start_cword_no</name></name> <operator>=</operator> <name>cwords</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec_perpage</name><operator>-&gt;</operator><name>bmp_num_cwords</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Copy the content words */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>bitmap</name><operator>-&gt;</operator><name>cwords</name></name> <operator>+</operator> <name>cwords</name></expr></argument>,
		   <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>cwords</name></name> <operator>+</operator> <name>startWordNo</name></expr></argument>,
		   <argument><expr><name>words_written</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* and make note of what we changed for the WAL record */</comment>
	<if_stmt><if>if <condition>(<expr><name>xlrec_perpage</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xlrec_perpage</name><operator>-&gt;</operator><name>bmp_start_cword_no</name></name> <operator>=</operator> <name>cwords</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec_perpage</name><operator>-&gt;</operator><name>bmp_num_cwords</name></name> <operator>=</operator> <name>words_written</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Shift the header words in 'words' to match with the bit positions
	 * in the header words in this page, and then copy them.
	 */</comment>
	<expr_stmt><expr><name>start_hword_no</name> <operator>=</operator> <name>startWordNo</name><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_hword_no</name> <operator>=</operator> <operator>(</operator><name>startWordNo</name> <operator>+</operator> <name>words_written</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_hwords</name> <operator>=</operator> <name>end_hword_no</name> <operator>-</operator> <name>start_hword_no</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_hwords</name> <operator>&lt;</operator> <name>BM_MAX_NUM_OF_HEADER_WORDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>hwords</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>hwords</name></name> <operator>+</operator> <name>start_hword_no</name></expr></argument>,
			<argument><expr><name>num_hwords</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hwords</name><index>[<expr><name>num_hwords</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* clean up the first and last header words */</comment>
	<expr_stmt><expr><name>start_hword_bit</name> <operator>=</operator> <name>startWordNo</name> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_hword_bit</name> <operator>=</operator> <operator>(</operator><name>startWordNo</name> <operator>+</operator> <name>words_written</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hwords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><operator>(</operator><name><name>hwords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <name>start_hword_bit</name><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator>
				<name>start_hword_bit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hwords</name><index>[<expr><name>num_hwords</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>hwords</name><index>[<expr><name>num_hwords</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator>
			<operator>(</operator><name>BM_HRL_WORD_SIZE</name> <operator>-</operator> <name>end_hword_bit</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator>
			<operator>(</operator><name>BM_HRL_WORD_SIZE</name> <operator>-</operator> <name>end_hword_bit</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>final_start_hword_bit</name> <operator>=</operator> <name>cwords</name> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>final_start_hword_bit</name> <operator>&gt;</operator> <name>start_hword_bit</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* right-shift 'final-start_hword_bit - start_hword_bit' */</comment>
		<expr_stmt><expr><call><name>rshift_header_bits</name><argument_list>(<argument><expr><name>hwords</name></expr></argument>, <argument><expr><name>num_hwords</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
						   <argument><expr><name>final_start_hword_bit</name> <operator>-</operator> <name>start_hword_bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
		
	<if type="elseif">else if <condition>(<expr><name>final_start_hword_bit</name> <operator>&lt;</operator> <name>start_hword_bit</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* left-shift 'start_hword_bit - final_start_hword_bit' */</comment>
		<expr_stmt><expr><call><name>lshift_header_bits</name><argument_list>(<argument><expr><name>hwords</name></expr></argument>, <argument><expr><name>num_hwords</name></expr></argument>,
						   <argument><expr><name>start_hword_bit</name> <operator>-</operator> <name>final_start_hword_bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* copy the header bits */</comment>
	<expr_stmt><expr><name>final_start_hword_no</name> <operator>=</operator> <name>cwords</name> <operator>/</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>final_end_hword_no</name> <operator>=</operator> <operator>(</operator><name>cwords</name> <operator>+</operator> <name>words_written</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><name>final_start_hword_no</name></expr>]</index></name> <operator>|=</operator> <name><name>hwords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name></name> <operator>+</operator> <operator>(</operator><name>final_start_hword_no</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
		   <argument><expr><name>hwords</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
		   <argument><expr><operator>(</operator><name>final_end_hword_no</name> <operator>-</operator> <name>final_start_hword_no</name><operator>)</operator> <operator>*</operator>
			<sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* and make note of what we changed for the WAL record */</comment>
	<if_stmt><if>if <condition>(<expr><name>xlrec_perpage</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xlrec_perpage</name><operator>-&gt;</operator><name>bmp_start_hword_no</name></name> <operator>=</operator> <name>final_start_hword_no</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec_perpage</name><operator>-&gt;</operator><name>bmp_num_hwords</name></name> <operator>=</operator> <operator>(</operator><name>final_end_hword_no</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>final_start_hword_no</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>bitmapPageOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name> <operator>+=</operator> <name>words_written</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_bitmap_print_insert</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Bitmap Insert: insert bitmapwords: "</literal>
			 <literal type="string">", old bm_last_tid_location="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", new bm_last_tid_location="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", first last_tid="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", last_compword="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", is_last_compword_fill=%s"</literal>
			 <literal type="string">", last_word="</literal> <name>INT64_FORMAT</name>
			 <literal type="string">", last_setbit="</literal> <name>INT64_FORMAT</name></expr></argument>,
			 <argument><expr><name><name>bitmapPageOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name><index>[<expr><name>startWordNo</name> <operator>+</operator> <name>words_written</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name><index>[<expr><name>startWordNo</name></expr>]</index></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>buf</name><operator>-&gt;</operator><name>is_last_compword_fill</name></name></expr> ?</condition><then> <expr><literal type="string">"yes"</literal></expr> </then><else>: <expr><literal type="string">"no"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name></expr></argument>,
			 <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bitmapPageOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>&lt;=</operator>
		   <name><name>buf</name><operator>-&gt;</operator><name>last_tids</name><index>[<expr><name>startWordNo</name> <operator>+</operator> <name>words_written</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bitmapPageOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>=</operator>
		<name><name>buf</name><operator>-&gt;</operator><name>last_tids</name><index>[<expr><name>startWordNo</name> <operator>+</operator> <name>words_written</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xlrec_perpage</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>xlrec_perpage</name><operator>-&gt;</operator><name>bmp_last_tid</name></name> <operator>=</operator> <name><name>bitmapPageOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>words_written</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_lovitem() -- create a new LOV item.
 *
 * Create a new LOV item and append this item into the last LOV page.
 * Each LOV item is associated with one distinct value for attributes
 * to be indexed. This function also inserts this distinct value along
 * with this new LOV item's block number and offsetnumber into the
 * auxiliary heap and its b-tree of this bitmap index.
 *
 * This function returns the block number and offset number of this
 * new LOV item.
 *
 * The caller should have an exclusive lock on metabuf.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_lovitem</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>metabuf</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>,
			   <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>attdata</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>,
			   <parameter><decl><type><name>Relation</name></type> <name>lovHeap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>lovIndex</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>lovBlockP</name></decl></parameter>, 
			   <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>lovOffsetP</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMMetaPage</name></type>		<name>metapage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>			<name>currLovBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>			<name>currLovPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name><modifier>*</modifier></type>			<name>lovDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name><modifier>*</modifier></type>			<name>lovNulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type>	<name>itemSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMLOVItem</name></type>		<name>lovitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>numOfAttrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>is_new_lov_blkno</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>numOfAttrs</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<comment type="block">/* Get the last LOV page. Meta page should be locked. */</comment>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>_bitmap_get_metapage_data</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>lovBlockP</name> <operator>=</operator> <name><name>metapage</name><operator>-&gt;</operator><name>bm_lov_lastpage</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>currLovBuffer</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>lovBlockP</name></expr></argument>, <argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>currLovPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>currLovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lovitem</name> <operator>=</operator> <call><name>_bitmap_formitem</name><argument_list>(<argument><expr><name>tidnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>lovOffsetP</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>currLovPage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemSize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BMLOVItemData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is not enough space in the last LOV page for
	 * a new item, create a new LOV page, and update the metapage.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>itemSize</name> <operator>&gt;</operator> <call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>currLovPage</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>newLovBuffer</name></decl>;</decl_stmt>

		<comment type="block">/* create a new LOV page */</comment>
		<expr_stmt><expr><name>newLovBuffer</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bitmap_init_lovpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>newLovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>currLovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>currLovBuffer</name> <operator>=</operator> <name>newLovBuffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>currLovPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>currLovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>is_new_lov_blkno</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* First create the LOV item. */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_new_lov_blkno</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>metapage</name><operator>-&gt;</operator><name>bm_lov_lastpage</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>currLovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>lovOffsetP</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>currLovPage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>lovBlockP</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>currLovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>currLovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>currLovPage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator><name>lovitem</name></expr></argument>, <argument><expr><name>itemSize</name></expr></argument>, <argument><expr><operator>*</operator><name>lovOffsetP</name></expr></argument>,
					<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to add LOV item in bitmap index \"%s\""</literal>
						<literal type="string">" (relfilenode %u/%u/%u, LOV block %d, LOV offset %d)"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
						<argument><expr><operator>*</operator><name>lovBlockP</name></expr></argument>, <argument><expr><operator>*</operator><name>lovOffsetP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>use_wal</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bitmap_log_lovitem</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>currLovBuffer</name></expr></argument>, <argument><expr><operator>*</operator><name>lovOffsetP</name></expr></argument>, <argument><expr><name>lovitem</name></expr></argument>,
							<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>is_new_lov_blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * .. and then create the entry in the auxiliary LOV heap and index for it.
	 *
	 * This could still fail for various reasons, e.g. if you run out of disk
	 * space. In that case, we'll leave behind an "orphan" LOV item, with no
	 * corresponding item in the LOV heap. That's a bit sloppy and leaky, but
	 * harmless; the orphaned LOV item won't be encountered by any scans.
	 */</comment>
	<expr_stmt><expr><name>lovDatum</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>numOfAttrs</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lovNulls</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>numOfAttrs</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lovDatum</name></expr></argument>, <argument><expr><name>attdata</name></expr></argument>, <argument><expr><name>numOfAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>lovNulls</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>numOfAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lovDatum</name><index>[<expr><name>numOfAttrs</name></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>*</operator><name>lovBlockP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lovNulls</name><index>[<expr><name>numOfAttrs</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lovDatum</name><index>[<expr><name>numOfAttrs</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><operator>*</operator><name>lovOffsetP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lovNulls</name><index>[<expr><name>numOfAttrs</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bitmap_insert_lov</name><argument_list>(<argument><expr><name>lovHeap</name></expr></argument>, <argument><expr><name>lovIndex</name></expr></argument>, <argument><expr><name>lovDatum</name></expr></argument>, <argument><expr><name>lovNulls</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>currLovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_bitmap_print_insert</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Bitmap Insert: create a lov item: "</literal>
			 <literal type="string">"lovBlock=%d, lovOffset=%d, is_new_lovblock=%d, idxrelid=%u"</literal></expr></argument>,
			 <argument><expr><operator>*</operator><name>lovBlockP</name></expr></argument>, <argument><expr><operator>*</operator><name>lovOffsetP</name></expr></argument>, <argument><expr><name>is_new_lov_blkno</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lovitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lovDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lovNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * When building an index we try and buffer calls to write tids to disk
 * as it will result in lots of I/Os.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>buf_add_tid</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMTidBuildBuf</name> <modifier>*</modifier></type><name>tids</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>, 
			<parameter><decl><type><name>BMBuildState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>lov_block</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMTIDLOVBuffer</name> <modifier>*</modifier></type><name>lov_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If we surpass maintenance_work_mem, free some space from the buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tids</name><operator>-&gt;</operator><name>byte_size</name></name> <operator>&gt;=</operator> <name>maintenance_work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>buf_make_space</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tids</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>use_wal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * tids is lazily initialized. If we do not have a current LOV block 
	 * buffer, initialize one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name><name>tids</name><operator>-&gt;</operator><name>max_lov_block</name></name></expr></argument>)</argument_list></call> <operator>||</operator> 
		<name><name>tids</name><operator>-&gt;</operator><name>max_lov_block</name></name> <operator>&lt;</operator> <name>lov_block</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * XXX: We're currently not including the size of this data structure
		 * in out byte_size count... should we?
		 */</comment>
		<expr_stmt><expr><name>lov_buf</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMTIDLOVBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lov_buf</name><operator>-&gt;</operator><name>lov_block</name></name> <operator>=</operator> <name>lov_block</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>lov_buf</name><operator>-&gt;</operator><name>bufs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BM_MAX_LOVITEMS_PER_PAGE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BMTIDBuffer</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tids</name><operator>-&gt;</operator><name>max_lov_block</name></name> <operator>=</operator> <name>lov_block</name></expr>;</expr_stmt>
		
		<comment type="block">/*
		 * Add the new LOV buffer to the list head. It seems reasonable that
		 * future calls to this function will want this lov_block rather than
		 * older lov_blocks.
		 */</comment>
		<expr_stmt><expr><name><name>tids</name><operator>-&gt;</operator><name>lov_blocks</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>lov_buf</name></expr></argument>, <argument><expr><name><name>tids</name><operator>-&gt;</operator><name>lov_blocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>tids-&gt;lov_blocks</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BMTIDLOVBuffer</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>lov_block</name></name> <operator>==</operator> <name>lov_block</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>lov_buf</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>
	
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lov_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>off</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>BM_MAX_LOVITEMS_PER_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lov_buf</name><operator>-&gt;</operator><name>bufs</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>lov_buf</name><operator>-&gt;</operator><name>bufs</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Buffer</name></type> <name>lovbuf</name> <init>= <expr><call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lov_block</name></expr></argument>, <argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>buf_add_tid_with_fill</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lovbuf</name></expr></argument>, <argument><expr><name>off</name></expr></argument>,
							  <argument><expr><name>tidnum</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>use_wal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>lovbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no pre-existing buffer found, create a new one */</comment>
		<decl_stmt><decl><type><name>Buffer</name></type> <name>lovbuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type> <name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BMLOVItem</name></type> <name>lovitem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint16</name></type> <name>bytes_added</name></decl>;</decl_stmt>
		
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>BMTIDBuffer</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMTIDBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>lovbuf</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lov_block</name></expr></argument>, <argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lovbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lovitem</name> <operator>=</operator> <operator>(</operator><name>BMLOVItem</name><operator>)</operator><call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name> <operator>=</operator> <name><name>lovitem</name><operator>-&gt;</operator><name>bm_last_setbit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name> <operator>=</operator> <name><name>lovitem</name><operator>-&gt;</operator><name>bm_last_compword</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name> <operator>=</operator> <name><name>lovitem</name><operator>-&gt;</operator><name>bm_last_word</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>is_last_compword_fill</name></name> <operator>=</operator> <operator>(</operator><name><name>lovitem</name><operator>-&gt;</operator><name>lov_words_header</name></name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BM_NUM_OF_HEADER_WORDS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>bytes_added</name> <operator>=</operator> <call><name>buf_extend</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>buf_add_tid_with_fill</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lovbuf</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>tidnum</name></expr></argument>,
							  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>use_wal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>lovbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>lov_buf</name><operator>-&gt;</operator><name>bufs</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tids</name><operator>-&gt;</operator><name>byte_size</name></name> <operator>+=</operator> <name>bytes_added</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * buf_add_tid_with_fill() -- Worker for buf_add_tid().
 *
 * Return how many bytes are used. Since we move words to disk when
 * there is no space left for new header words, this returning number
 * can be negative.
 */</comment>
<function><type><specifier>static</specifier> <name>int16</name></type>
<name>buf_add_tid_with_fill</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
					  <parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>zeros</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type> <name>inserting_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>bytes_used</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute how many zeros between this set bit and the last inserted
	 * set bit.
	 */</comment>
	<expr_stmt><expr><name>zeros</name> <operator>=</operator> <name>tidnum</name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If zeros is less than 0, the incoming tids are not
	 * sorted. Currently, this is not allowed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>zeros</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tids are not in order when building bitmap index %u (relfilenode %u/%u/%u):"</literal>
						<literal type="string">" new tidnum "</literal> <name>INT64_FORMAT</name> <literal type="string">", last tidnum "</literal> <name>INT64_FORMAT</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
						<argument><expr><name>tidnum</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>zeros</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>zerosNeeded</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>numOfTotalFillWords</name></decl>;</decl_stmt>

		<comment type="block">/* 
		 * Calculate how many bits are needed to fill up the existing last
		 * bitmap word.
		 */</comment>
		<expr_stmt><expr><name>zerosNeeded</name> <operator>=</operator>
			<name>BM_HRL_WORD_SIZE</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>zerosNeeded</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zeros</name> <operator>&gt;=</operator> <name>zerosNeeded</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The last bitmap word is complete now. We merge it with the
			 * last bitmap complete word.
			 */</comment>
			<expr_stmt><expr><name>bytes_used</name> <operator>-=</operator>
				<call><name>buf_ensure_head_space</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>bytes_used</name> <operator>+=</operator> <call><name>mergewords</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>zeros</name> <operator>-=</operator> <name>zerosNeeded</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the remaining zeros are more than BM_HRL_WORD_SIZE,
		 * We construct the last bitmap word to be a fill word, and merge it
		 * with the last complete bitmap word.
		 */</comment>
		<expr_stmt><expr><name>numOfTotalFillWords</name> <operator>=</operator> <name>zeros</name><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>numOfTotalFillWords</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> 	<name>numOfFillWords</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>numOfTotalFillWords</name> <operator>&gt;=</operator> <name>MAX_FILL_LENGTH</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>numOfFillWords</name> <operator>=</operator> <name>MAX_FILL_LENGTH</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>numOfFillWords</name> <operator>=</operator> <name>numOfTotalFillWords</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name> <operator>=</operator> <call><name>BM_MAKE_FILL_WORD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numOfFillWords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>bytes_used</name> <operator>-=</operator> 
				<call><name>buf_ensure_head_space</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bytes_used</name> <operator>+=</operator> <call><name>mergewords</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>numOfTotalFillWords</name> <operator>-=</operator> <name>numOfFillWords</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>zeros</name> <operator>-=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator><name>numOfFillWords</name> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>zeros</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>zeros</name><operator>&lt;</operator><name>BM_HRL_WORD_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>inserting_pos</name> <operator>=</operator> <operator>(</operator><name>tidnum</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>%</operator><name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>inserting_pos</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tidnum</name> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>lastWordFill</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name> <operator>==</operator> <name>LITERAL_ALL_ZERO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name> <operator>=</operator> <call><name>BM_MAKE_FILL_WORD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lastWordFill</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>

		<if type="elseif">else if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name> <operator>==</operator> <name>LITERAL_ALL_ONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name> <operator>=</operator> <call><name>BM_MAKE_FILL_WORD</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lastWordFill</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>bytes_used</name> <operator>-=</operator>
			<call><name>buf_ensure_head_space</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytes_used</name> <operator>+=</operator> <call><name>mergewords</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lastWordFill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name> <operator>=</operator> <name>tidnum</name></expr>;</expr_stmt>

	<return>return <expr><name>bytes_used</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * buf_ensure_head_space() -- If there is no space in the header words,
 * move words in the given buffer to disk and free the existing space,
 * and then allocate new space for future new words.
 *
 * The number of bytes freed are returned.
 */</comment>
<function><type><specifier>static</specifier> <name>uint16</name></type>
<name>buf_ensure_head_space</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, 
					  <parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint16</name></type> <name>bytes_freed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name> <operator>&gt;=</operator> <operator>(</operator><name>BM_NUM_OF_HEADER_WORDS</name> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bytes_freed</name> <operator>=</operator> <call><name>buf_free_mem_block</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytes_freed</name> <operator>-=</operator> <call><name>buf_extend</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>bytes_freed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * buf_extend() -- Enlarge the memory allocated to a buffer.
 * Return how many bytes are added to the buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>uint16</name></type>
<name>buf_extend</name><parameter_list>(<parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint16</name></type> <name>bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type> <name>size</name></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>-&gt;</operator><name>curword</name></name> <operator>&lt;</operator> <name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* already large enough */</comment>

	<if_stmt><if>if<condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <name>BUF_INIT_WORDS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>cwords</name></name> <operator>=</operator> <operator>(</operator><name>BM_HRL_WORD</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>BUF_INIT_WORDS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name></name> <operator>=</operator> <operator>(</operator><name>uint64</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>BUF_INIT_WORDS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytes</name> <operator>=</operator> <name>BUF_INIT_WORDS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
			<name>BUF_INIT_WORDS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>cwords</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>cwords</name></name> <operator>+</operator> <name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name></name> <operator>+</operator> <name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytes</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
			<literal type="number">2</literal> <operator>*</operator> <name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
	<return>return <expr><name>bytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Spill some HRL compressed tids to disk
 *
 * Use buf_free_mem_block if the caller already holds a BM_WRITE lock
 * on lovbuf (Buffer item). Else, buf_free_mem will get and lock lovBuffer
 * by its block number, internally call buf_free_mem_block and finally
 * release lovBuffer.
 */</comment>

<function><type><specifier>static</specifier> <name>uint16</name></type>
<name>buf_free_mem</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>lov_block</name></decl></parameter>,
			 <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>lovbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type> <name>bytes_freed</name></decl>;</decl_stmt>

	<comment type="block">/* already done */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>lovbuf</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lov_block</name></expr></argument>, <argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bytes_freed</name> <operator>=</operator> <call><name>buf_free_mem_block</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lovbuf</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>lovbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>bytes_freed</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint16</name></type>
<name>buf_free_mem_block</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lovbuf</name></decl></parameter>,
			 <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* already done */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>_bitmap_write_new_bitmapwords</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovbuf</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>_bitmap_free_tidbuf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Spill some data out of the buffer to free up space.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>buf_make_space</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMTidBuildBuf</name> <modifier>*</modifier></type><name>locbuf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Now, we could just pull the head of lov_blocks but there'd be no
	 * guarantee that we'd free up enough space.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>locbuf-&gt;lov_blocks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BMTIDLOVBuffer</name> <modifier>*</modifier></type><name>lov_buf</name> <init>= <expr><operator>(</operator><name>BMTIDLOVBuffer</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lov_block</name> <init>= <expr><name><name>lov_buf</name><operator>-&gt;</operator><name>lov_block</name></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BM_MAX_LOVITEMS_PER_PAGE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><name>BMTIDBuffer</name> <operator>*</operator><operator>)</operator><name><name>lov_buf</name><operator>-&gt;</operator><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>

			<comment type="block">/* return if we've freed enough space */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>locbuf</name><operator>-&gt;</operator><name>byte_size</name></name> <operator>&lt;</operator> <operator>(</operator><name>maintenance_work_mem</name> <operator>*</operator> <literal type="number">1024L</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name> <operator>||</operator> <name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>off</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>locbuf</name><operator>-&gt;</operator><name>byte_size</name></name> <operator>-=</operator> <call><name>buf_free_mem</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lov_block</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>QueryCancelPending</name> <operator>||</operator> <name>ProcDiePending</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>locbuf</name><operator>-&gt;</operator><name>byte_size</name></name> <operator>&lt;</operator> <operator>(</operator><name>maintenance_work_mem</name> <operator>*</operator> <literal type="number">1024L</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_free_tidbuf() -- release the space.
 */</comment>
<function><type><specifier>static</specifier> <name>uint16</name></type>
<name>_bitmap_free_tidbuf</name><parameter_list>(<parameter><decl><type><name>BMTIDBuffer</name><modifier>*</modifier></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint16</name></type> <name>bytes_freed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>cwords</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bytes_freed</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Paranoia */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>BM_NUM_OF_HEADER_WORDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>bytes_freed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * insertsetbit() -- insert a given set bit into a bitmap
 * 	specified by lovBlock and lovOffset.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>insertsetbit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>lovBlock</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>,
			 <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>, <parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>lovPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMLOVItem</name></type>	<name>lovItem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lovBuffer</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovBlock</name></expr></argument>, <argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lovPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lovItem</name> <operator>=</operator> <operator>(</operator><name>BMLOVItem</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, 
									  <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_word</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>is_last_compword_fill</name></name> <operator>=</operator> <operator>(</operator><name><name>lovItem</name><operator>-&gt;</operator><name>lov_words_header</name></name> <operator>&gt;=</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tid</name></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_setbit</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>cwords</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><call><name>BM_CALC_H_WORDS</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>last_tids</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>curword</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Usually, tidnum is greater than lovItem-&gt;bm_last_setbit.
	 * However, if this is not the case, this should be called while
	 * doing 'vacuum full' or doing insertion after 'vacuum'. In this
	 * case, we try to update this bit in the corresponding bitmap
	 * vector.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tidnum</name> <operator>&lt;=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_setbit</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Scan through the bitmap vector, and update the bit in
		 * tidnum.
		 */</comment>
		<expr_stmt><expr><call><name>updatesetbit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>, <argument><expr><name>tidnum</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * To insert this new set bit, we also need to add all zeros between
	 * this set bit and last set bit. We construct all new words here.
	 */</comment>
	<expr_stmt><expr><call><name>buf_add_tid_with_fill</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>, <argument><expr><name>tidnum</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/*
	 * If there are only updates to the last bitmap complete word and
	 * last bitmp word, we simply needs to update the lov buffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_word</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>lov_words_header</name></name> <operator>=</operator>
			<ternary><condition><expr><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>is_last_compword_fill</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_setbit</name></name> <operator>=</operator> <name>tidnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>=</operator> <name>tidnum</name> <operator>-</operator> <name>tidnum</name> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bitmap_log_bitmap_lastwords</name>
				<argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>, <argument><expr><name>lovItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		
		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>Debug_bitmap_print_insert</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Bitmap Insert: insert to last two words"</literal>
				 <literal type="string">", bm_last_setbit="</literal> <name>INT64_FORMAT</name>
				 <literal type="string">", bm_last_tid_location="</literal> <name>INT64_FORMAT</name>
				 <literal type="string">", idxrelid=%u"</literal></expr></argument>,
				 <argument><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_setbit</name></name></expr></argument>,
				 <argument><expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr></argument>,
				 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
 		
		<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Write bitmap words to bitmap pages. When there are no enough
	 * space for all these bitmap words, new bitmap pages are created.
	 */</comment>
	<expr_stmt><expr><call><name>_bitmap_write_new_bitmapwords</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>,
								  <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_write_alltids() -- write all tids in the given buffer into disk.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_write_alltids</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BMTidBuildBuf</name> <modifier>*</modifier></type><name>tids</name></decl></parameter>, 
					  <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>tids-&gt;lov_blocks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BMTIDLOVBuffer</name> <modifier>*</modifier></type><name>lov_buf</name> <init>= <expr><operator>(</operator><name>BMTIDLOVBuffer</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lov_block</name> <init>= <expr><name><name>lov_buf</name><operator>-&gt;</operator><name>lov_block</name></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BM_MAX_LOVITEMS_PER_PAGE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><name>BMTIDBuffer</name> <operator>*</operator><operator>)</operator><name><name>lov_buf</name><operator>-&gt;</operator><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name> <operator>||</operator> <name><name>buf</name><operator>-&gt;</operator><name>num_cwords</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>off</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>buf_free_mem</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lov_block</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>lov_buf</name><operator>-&gt;</operator><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>tids</name><operator>-&gt;</operator><name>lov_blocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tids</name><operator>-&gt;</operator><name>lov_blocks</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tids</name><operator>-&gt;</operator><name>byte_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * build_inserttuple() -- insert a new tuple into the bitmap index
 *	during the bitmap index construction.
 *
 * Each new tuple has an assigned number -- tidnum, called a
 * tid location, which represents the bit location for this tuple in
 * a bitmap vector. To speed up the construction, this function does not
 * write this tid location into its bitmap vector immediately. We maintain
 * a buffer -- BMTidBuildBuf to keep an array of tid locations
 * for each distinct attribute value.
 *
 * If this insertion causes the buffer to overflow, we write tid locations
 * for enough distinct values to disk to accommodate this new tuple.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>build_inserttuple</name><argument_list>(<argument><expr><name>Relation</name> <name>rel</name></expr></argument>, <argument><expr><name>uint64</name> <name>tidnum</name></expr></argument>,
				  <argument><expr><name>ItemPointerData</name> <name>ht_ctid</name>  <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TupleDesc</name> <name>tupDesc</name></expr></argument>,
				  <argument><expr><name>Datum</name> <operator>*</operator><name>attdata</name></expr></argument>, <argument><expr><name>bool</name> <operator>*</operator><name>nulls</name></expr></argument>, <argument><expr><name>BMBuildState</name> <operator>*</operator><name>state</name></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type> 			<name>metabuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type>		<name>lovBlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type>	<name>lovOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>blockNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>offsetNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMTidBuildBuf</name> <modifier>*</modifier></type><name>tidLocsBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>allNulls</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBuildHashKey</name>  <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tidLocsBuffer</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>bm_tidLocsBuffer</name></name></expr>;</expr_stmt>

	<comment type="block">/* Check if all attributes have value of NULL. */</comment>
	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><name>attno</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>allNulls</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BM_METAPAGE</name></expr></argument>, <argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/*
	 * if the inserting tuple has the value of NULL, then
	 * the corresponding tid array is the first.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>allNulls</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lovBlock</name> <operator>=</operator> <name>BM_LOV_STARTPAGE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lovOffset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BMBuildLovData</name> <modifier>*</modifier></type><name>lov</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>lovitem_hash</name></name></expr>)</condition>
		<block>{<block_content>
		    <decl_stmt><decl><type><name>BMBuildHashKey</name></type> <name>toLookup</name></decl>;</decl_stmt>
		    <expr_stmt><expr><name><name>toLookup</name><operator>.</operator><name>attributeValueArr</name></name> <operator>=</operator> <name>attdata</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>toLookup</name><operator>.</operator><name>isNullArr</name></name> <operator>=</operator> <name>nulls</name></expr>;</expr_stmt>

			<comment type="block">/* look up the hash to see if we can find the lov data that way */</comment>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>BMBuildHashKey</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>lovitem_hash</name></name></expr></argument>,
												  <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>toLookup</name></expr></argument>,
												  <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Copy the key values in case someone modifies them */</comment>
				<for>for<control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>at</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>isNullArr</name><index>[<expr><name>attno</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>attributeValueArr</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>attributeValueArr</name><index>[<expr><name>attno</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>attributeValueArr</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>at</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>,
																	<argument><expr><name><name>at</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/*
				 * If the inserting tuple has a new value, then we create a new
				 * LOV item.
				 */</comment>
				<expr_stmt><expr><call><name>create_lovitem</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>tidnum</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attdata</name></expr></argument>, 
							   <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bm_lov_heap</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bm_lov_index</name></name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>lovBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovOffset</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>use_wal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>lov</name> <operator>=</operator> <operator>(</operator><name>BMBuildLovData</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>entry</name><operator>)</operator> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>lovitem_hashKeySize</name></name> <operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lov</name><operator>-&gt;</operator><name>lov_block</name></name> <operator>=</operator> <name>lovBlock</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lov</name><operator>-&gt;</operator><name>lov_off</name></name> <operator>=</operator> <name>lovOffset</name></expr>;</expr_stmt>
			</block_content>}</block></if>

			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>lov</name> <operator>=</operator> <operator>(</operator><name>BMBuildLovData</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>entry</name><operator>)</operator> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>lovitem_hashKeySize</name></name> <operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>lovBlock</name> <operator>=</operator> <name><name>lov</name><operator>-&gt;</operator><name>lov_block</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>lovOffset</name> <operator>=</operator> <name><name>lov</name><operator>-&gt;</operator><name>lov_off</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>

		<else>else <block>{<block_content>
			<comment type="block">/*
			 * Search the btree to find the right bitmap vector to append
			 * this bit. Here, we reset the scan key and call index_rescan.
			 */</comment>
			<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name><operator>&lt;</operator><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScanKey</name></type> <name>theScanKey</name> <init>= <expr><operator>(</operator><name>ScanKey</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>state</name><operator>-&gt;</operator><name>bm_lov_scanKeys</name></name><operator>)</operator> <operator>+</operator>
											   <name>attno</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>attno</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>theScanKey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>=</operator> <name>SK_ISNULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>theScanKey</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <name><name>attdata</name><index>[<expr><name>attno</name></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>theScanKey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>theScanKey</name><operator>-&gt;</operator><name>sk_argument</name></name> <operator>=</operator> <name><name>attdata</name><index>[<expr><name>attno</name></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bm_lov_scanDesc</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bm_lov_scanKeys</name></name></expr></argument>, <argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>_bitmap_findvalue</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bm_lov_heap</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bm_lov_index</name></name></expr></argument>,
									  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bm_lov_scanKeys</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bm_lov_scanDesc</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>lovBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blockNull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offsetNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If the inserting tuple has a new value, then we create a new
				 * LOV item.
				 */</comment>
				<expr_stmt><expr><call><name>create_lovitem</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>tidnum</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attdata</name></expr></argument>, 
							   <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bm_lov_heap</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bm_lov_index</name></name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>lovBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovOffset</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>use_wal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>buf_add_tid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tidLocsBuffer</name></expr></argument>, <argument><expr><name>tidnum</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>lovBlock</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bitmap_wrtbuf</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * inserttuple() -- insert a new tuple into the bitmap index.
 *
 * This function finds the corresponding bitmap vector associated with
 * the given attribute value, and inserts a set bit into this bitmap
 * vector. Each distinct attribute value is stored as a LOV item, which
 * is stored in a list of LOV pages.
 *
 * If there is no LOV item associated with the given attribute value,
 * a new LOV item is created and appended into the last LOV page.
 *
 * For support the high-cardinality case for attributes to be indexed,
 * we also maintain an auxiliary heap and a btree structure for all
 * the distinct attribute values so that the search for the
 * corresponding bitmap vector can be done faster. The heap
 * contains all attributes to be indexed and 2 more attributes --
 * the block number of the offset number of the block that stores
 * the corresponding LOV item. The b-tree index is on this new heap
 * and the key contains all attributes to be indexed.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>inserttuple</name><argument_list>(<argument><expr><name>Relation</name> <name>rel</name></expr></argument>, <argument><expr><name>Buffer</name> <name>metabuf</name></expr></argument>, <argument><expr><name>uint64</name> <name>tidnum</name></expr></argument>, 
			<argument><expr><name>ItemPointerData</name> <name>ht_ctid</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TupleDesc</name> <name>tupDesc</name></expr></argument>, <argument><expr><name>Datum</name> <operator>*</operator><name>attdata</name></expr></argument>,
			<argument><expr><name>bool</name> <operator>*</operator><name>nulls</name></expr></argument>, <argument><expr><name>Relation</name> <name>lovHeap</name></expr></argument>, <argument><expr><name>Relation</name> <name>lovIndex</name></expr></argument>, <argument><expr><name>ScanKey</name> <name>scanKey</name></expr></argument>,
		   	<argument><expr><name>IndexScanDesc</name> <name>scanDesc</name></expr></argument>, <argument><expr><name>bool</name> <name>use_wal</name></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type>		<name>lovBlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type>	<name>lovOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>blockNull</name></decl>, <decl><type ref="prev"/><name>offsetNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>allNulls</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 			<name>attno</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>BMTIDBuffer</name></type>     <name>buf</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check if the values of given attributes are all NULL. */</comment>
	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nulls</name><index>[<expr><name>attno</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>allNulls</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * if the inserting tuple has the value NULL, then the LOV item is
	 * the first item in the lovBuffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>allNulls</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lovBlock</name> <operator>=</operator> <name>BM_LOV_STARTPAGE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lovOffset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
 		<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		
		<comment type="block">/*
		 * Search through the lov heap and index to find the LOV item which
		 * has the same value as the inserting tuple. If such an item is
		 * not found, then we create a new LOV item, and insert it into the
		 * lov heap and index.
		 */</comment>

		<comment type="block">/*
		 * XXX: We lock the meta page to guarantee that only one writer
		 * will create a new lovItem at once. However, this does not
		 * guard against a race condition where a concurrent writer is
		 * inserting the same key as us. So we do another search with
		 * SnapshotDirty. If such a key is found, we have to wait for
		 * the other guy, and try again. However, this may cause
		 * distributed deadlock (see MPP-3155). The fix is to use
		 * FrozenTransactionId for tuples in the LOV heap so that
		 * all tuples are always visible to any transactions.
		 *
		 * The problem is, locking the metapage is pretty heavy handed 
		 * because the read routines need a read lock on it. There are a
		 * few other things we could do instead: use a BM insert lock or
		 * wrap the code below in a PG_TRY and try and catch the unique
		 * constraint violation from the btree code.
		 */</comment>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_bitmap_findvalue</name><argument_list>(<argument><expr><name>lovHeap</name></expr></argument>, <argument><expr><name>lovIndex</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>, <argument><expr><name>scanDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovBlock</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>blockNull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offsetNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><operator>!</operator><name>res</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>create_lovitem</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>tidnum</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>,
						   <argument><expr><name>attdata</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>lovHeap</name></expr></argument>, <argument><expr><name>lovIndex</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>lovBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovOffset</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Here, we have found the block number and offset number of the
	 * LOV item that points to the bitmap page, to which we will
	 * append the set bit.
	 */</comment>

	<expr_stmt><expr><call><name>insertsetbit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovBlock</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>, <argument><expr><name>tidnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bitmap_free_tidbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * _bitmap_buildinsert() -- insert an index tuple during index creation.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_buildinsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ItemPointerData</name></type> <name>ht_ctid</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>attdata</name></decl></parameter>, 
					<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><name>BMBuildState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>tidOffset</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tidOffset</name> <operator>=</operator> <call><name>BM_IPTR_TO_INT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ht_ctid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* insert a new bit into the corresponding bitmap */</comment>
	<expr_stmt><expr><call><name>build_inserttuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tidOffset</name></expr></argument>, <argument><expr><name>ht_ctid</name></expr></argument>,
							  <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attdata</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_doinsert() -- insert an index tuple for a given tuple.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_doinsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ItemPointerData</name></type> <name>ht_ctid</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>attdata</name></decl></parameter>, 
				 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>			<name>tidOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>		<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>			<name>metabuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMMetaPage</name></type>		<name>metapage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>		<name>lovHeap</name></decl>, <decl><type ref="prev"/><name>lovIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>			<name>scanKeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type>	<name>scanDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>attno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return ;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tidOffset</name> <operator>=</operator> <call><name>BM_IPTR_TO_INT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ht_ctid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* insert a new bit into the corresponding bitmap using the HRL scheme */</comment>
	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BM_METAPAGE</name></expr></argument>, <argument><expr><name>BM_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>_bitmap_get_metapage_data</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bitmap_open_lov_heapandindex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metapage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovHeap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovIndex</name></expr></argument>, 
								  <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scanKeys</name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_opr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RegProcedure</name></type> <name>opfuncid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKey</name></type>		<name>scanKey</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eq_opr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opfuncid</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>eq_opr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>scanKey</name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>scanKeys</name><operator>)</operator> <operator>+</operator> <name>attno</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><name>scanKey</name></expr></argument>,
							   <argument><expr><ternary><condition><expr><name><name>nulls</name><index>[<expr><name>attno</name></expr>]</index></name></expr> ?</condition><then> <expr><name>SK_ISNULL</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
							   <argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
							   <argument><expr><name>InvalidOid</name></expr></argument>,
							   <argument><expr><name><name>lovIndex</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
							   <argument><expr><name>opfuncid</name></expr></argument>,
							   <argument><expr><name><name>attdata</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>scanDesc</name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name>lovHeap</name></expr></argument>, <argument><expr><name>lovIndex</name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>,
							   <argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>, <argument><expr><name>scanKeys</name></expr></argument>, <argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* insert this new tuple into the bitmap index. */</comment>
	<expr_stmt><expr><call><name>inserttuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>tidOffset</name></expr></argument>, <argument><expr><name>ht_ctid</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>attdata</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, 
				<argument><expr><name>lovHeap</name></expr></argument>, <argument><expr><name>lovIndex</name></expr></argument>, <argument><expr><name>scanKeys</name></expr></argument>, <argument><expr><name>scanDesc</name></expr></argument>, <argument><expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bitmap_close_lov_heapandindex</name><argument_list>(<argument><expr><name>lovHeap</name></expr></argument>, <argument><expr><name>lovIndex</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scanKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
