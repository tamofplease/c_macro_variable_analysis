<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/bitmap/bitmaputil.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * bitmaputil.c
 *	  Utility routines for on-disk bitmap index access method.
 *
 * Portions Copyright (c) 2007-2010 Greenplum Inc
 * Portions Copyright (c) 2010-2012 EMC Corporation
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 2006-2008, PostgreSQL Global Development Group
 * 
 *
 * IDENTIFICATION
 *	  src/backend/access/bitmap/bitmaputil.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bitmap_findnextword</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name><modifier>*</modifier></type> <name>words</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>nextReadNo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bitmap_resetWord</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>prevStartNo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint8</name></type> <name>_bitmap_find_bitset</name><parameter_list>(<parameter><decl><type><name>BM_HRL_WORD</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>lastPos</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * _bitmap_formitem() -- construct a LOV entry.
 *
 * If the given tid number is greater than BM_HRL_WORD_SIZE, we
 * construct the first fill word for this bitmap vector.
 */</comment>
<function><type><name>BMLOVItem</name></type>
<name>_bitmap_formitem</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>currTidNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMLOVItem</name></type>	<name>bmitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>bmitem</name> <operator>=</operator> <operator>(</operator><name>BMLOVItem</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMLOVItemData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>bm_lov_head</name></name> <operator>=</operator> <name><name>bmitem</name><operator>-&gt;</operator><name>bm_lov_tail</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>bm_last_setbit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>bm_last_compword</name></name> <operator>=</operator> <name>LITERAL_ALL_ONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>bm_last_word</name></name> <operator>=</operator> <name>LITERAL_ALL_ZERO</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>lov_words_header</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* fill up all existing bits with 0. */</comment>
	<if_stmt><if>if <condition>(<expr><name>currTidNumber</name> <operator>&lt;=</operator> <name>BM_HRL_WORD_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>bm_last_compword</name></name> <operator>=</operator> <name>LITERAL_ALL_ONE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>bm_last_word</name></name> <operator>=</operator> <name>LITERAL_ALL_ZERO</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>lov_words_header</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>numOfTotalFillWords</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type>	<name>numOfFillWords</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>numOfTotalFillWords</name> <operator>=</operator> <operator>(</operator><name>currTidNumber</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>numOfFillWords</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>numOfTotalFillWords</name> <operator>&gt;=</operator> <name>MAX_FILL_LENGTH</name><operator>)</operator></expr> ?</condition><then> 
			<expr><name>MAX_FILL_LENGTH</name></expr> </then><else>: <expr><name>numOfTotalFillWords</name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>bm_last_compword</name></name> <operator>=</operator> <call><name>BM_MAKE_FILL_WORD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numOfFillWords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>bm_last_word</name></name> <operator>=</operator> <name>LITERAL_ALL_ZERO</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>lov_words_header</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>=</operator> <name>numOfFillWords</name> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>bmitem</name><operator>-&gt;</operator><name>bm_last_setbit</name></name> <operator>=</operator> <name>numOfFillWords</name><operator>*</operator><name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>bmitem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_get_metapage_data() -- return the metadata info stored
 * in the given metapage buffer.
 */</comment>
<function><type><name>BMMetaPage</name></type>
<name>_bitmap_get_metapage_data</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>metabuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type> <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMMetaPage</name></type> <name>metapage</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <operator>(</operator><name>BMMetaPage</name><operator>)</operator><call><name>PageGetContents</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this metapage is from the pre 3.4 version of the bitmap
	 * index, we print "require to reindex" message, and error
	 * out.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>metapage</name><operator>-&gt;</operator><name>bm_version</name></name> <operator>!=</operator> <name>BITMAP_VERSION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the disk format for \"%s\" is not valid for this version of Greenplum Database"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use REINDEX to update this index."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>metapage</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * _bitmap_init_batchwords() -- initialize a BMBatchWords in a given
 * memory context.
 *
 * Allocate spaces for bitmap header words and bitmap content words.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_init_batchwords</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name><modifier>*</modifier></type> <name>words</name></decl></parameter>,
						<parameter><decl><type><name>uint32</name></type> <name>maxNumOfWords</name></decl></parameter>,
						<parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>	<name>numOfHeaderWords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nextread</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>startNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>numOfHeaderWords</name> <operator>=</operator> <call><name>BM_CALC_H_WORDS</name><argument_list>(<argument><expr><name>maxNumOfWords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>maxNumOfWords</name></name> <operator>=</operator> <name>maxNumOfWords</name></expr>;</expr_stmt>

	<comment type="block">/* Make sure that we have at least one page of words */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>maxNumOfWords</name></name> <operator>&gt;=</operator> <name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>numOfHeaderWords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>words</name><operator>-&gt;</operator><name>maxNumOfWords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_copy_batchwords() -- copy a given BMBatchWords to another
 *	BMBatchWords.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_copy_batchwords</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name><modifier>*</modifier></type> <name>words</name></decl></parameter>, <parameter><decl><type><name>BMBatchWords</name><modifier>*</modifier></type> <name>copyWords</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>	<name>numOfHeaderWords</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>copyWords</name><operator>-&gt;</operator><name>maxNumOfWords</name></name> <operator>=</operator> <name><name>words</name><operator>-&gt;</operator><name>maxNumOfWords</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyWords</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>=</operator> <name><name>words</name><operator>-&gt;</operator><name>nwordsread</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyWords</name><operator>-&gt;</operator><name>nextread</name></name> <operator>=</operator> <name><name>words</name><operator>-&gt;</operator><name>nextread</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyWords</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>=</operator> <name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyWords</name><operator>-&gt;</operator><name>startNo</name></name> <operator>=</operator> <name><name>words</name><operator>-&gt;</operator><name>startNo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>=</operator> <name><name>words</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>numOfHeaderWords</name> <operator>=</operator> <call><name>BM_CALC_H_WORDS</name><argument_list>(<argument><expr><name><name>copyWords</name><operator>-&gt;</operator><name>maxNumOfWords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>copyWords</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>,
			<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>numOfHeaderWords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>copyWords</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>, <argument><expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>,
			<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>copyWords</name><operator>-&gt;</operator><name>maxNumOfWords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_reset_batchwords() -- reset the BMBatchWords for re-use.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_reset_batchwords</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>words</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>startNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>BM_CALC_H_WORDS</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>maxNumOfWords</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_cleanup_batchwords() -- release spaces allocated for the BMBatchWords.
 */</comment>
<function><type><name>void</name></type> <name>_bitmap_cleanup_batchwords</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name><modifier>*</modifier></type> <name>words</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>words</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_cleanup_scanpos() -- release space allocated for
 * 	BMVector.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_cleanup_scanpos</name><parameter_list>(<parameter><decl><type><name>BMVector</name></type> <name>bmScanPos</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>numBitmapVectors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>keyNo</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>numBitmapVectors</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
		
	<for>for <control>(<init><expr><name>keyNo</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>keyNo</name><operator>&lt;</operator><name>numBitmapVectors</name></expr>;</condition> <incr><expr><name>keyNo</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>keyNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_lovBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>keyNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>_bitmap_cleanup_batchwords</name><argument_list>(<argument><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>keyNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_batchWords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>bmScanPos</name><index>[<expr><name>keyNo</name></expr>]</index></name><operator>.</operator><name>bm_batchWords</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>keyNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_batchWords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>bmScanPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_findnexttid() -- find the next tid location in a given batch
 *  of bitmap words.
 */</comment>
<function><type><name>uint64</name></type>
<name>_bitmap_findnexttid</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>BMIterateResult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If there is not tids from previous computation, then we
	 * try to find next set of tids.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>nextTidLoc</name></name> <operator>&gt;=</operator> <name><name>result</name><operator>-&gt;</operator><name>numOfTids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bitmap_findnexttids</name><argument_list>(<argument><expr><name>words</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>BM_BATCH_TIDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* if find more tids, then return the first one */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>nextTidLoc</name></name> <operator>&lt;</operator> <name><name>result</name><operator>-&gt;</operator><name>numOfTids</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nextTidLoc</name></name><operator>++</operator></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>nextTids</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>nextTidLoc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* no more tids */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_findnexttids() -- find the next set of tids from a given
 *  batch of bitmap words.
 *
 * The maximum number of tids to be found is defined in 'maxTids'.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_findnexttids</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>BMIterateResult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
					 <parameter><decl><type><name>uint32</name></type> <name>maxTids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nextTidLoc</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>numOfTids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Only in the situation that there have concurrent read/write on two
	 * adjacent bitmap index pages, and inserting a tid into PAGE_FULL cause expand
	 * compressed words to new words, and rearrange those words into PAGE_NEXT,
	 * and we ready to read a new page, we should adjust result-&gt; lastScanWordNo
	 * to the current position.
	 *
	 * The value of words-&gt;startNo will always be 0, this value will only used at
	 * _bitmap_union to union a bunch of bitmaps, the union result will be stored
	 * at words. result-&gt;lastScanWordNo indicates the location in words-&gt;cwords that
	 * BMIterateResult will read the word next, it's start from 0, and will
	 * self-incrementing during the scan. So if result-&gt;lastScanWordNo equals to
	 * words-&gt;startNo, means we will scan a new bitmap index pages.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name> <operator>==</operator> <name><name>words</name><operator>-&gt;</operator><name>startNo</name></name> <operator>&amp;&amp;</operator>
			<name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>&lt;</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bitmap_catchup_to_next_tid</name><argument_list>(<argument><expr><name>words</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>numOfTids</name></name> <operator>&lt;</operator> <name>maxTids</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>done</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint8</name></type> <name>oldScanPos</name> <init>= <expr><name><name>result</name><operator>-&gt;</operator><name>lastScanPos</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>word</name> <init>= <expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* new word, zero filled */</comment>
		<if_stmt><if>if <condition>(<expr><name>oldScanPos</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> 
			  <call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name>word</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BM_HRL_WORD</name></type>	<name>fillLength</name></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>word</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>fillLength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>fillLength</name> <operator>=</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* skip over non-matches */</comment>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>+=</operator> <name>fillLength</name> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr></argument>)</argument_list></call>
				 <operator>&amp;&amp;</operator> <call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type>	<name>nfillwords</name> <init>= <expr><call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint8</name></type> 	<name>bitNo</name></decl>;</decl_stmt>

			<while>while <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>numOfTids</name></name> <operator>+</operator> <name>BM_HRL_WORD_SIZE</name> <operator>&lt;=</operator> <name>maxTids</name> <operator>&amp;&amp;</operator>
				   <name>nfillwords</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* explain the fill word */</comment>
				<for>for <control>(<init><expr><name>bitNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>bitNo</name> <operator>&lt;</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</condition> <incr><expr><name>bitNo</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nextTids</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>numOfTids</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

				<expr_stmt><expr><name>nfillwords</name><operator>--</operator></expr>;</expr_stmt>
				<comment type="block">/* update fill word to reflect expansion */</comment>
				<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><name>nfillwords</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>oldScanPos</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>oldScanPos</name> <operator>=</operator> <name>BM_HRL_WORD_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<while>while <condition>(<expr><name>oldScanPos</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>numOfTids</name></name> <operator>&lt;</operator> <name>maxTids</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BM_HRL_WORD</name></type>		<name>w</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>oldScanPos</name> <operator>==</operator> <name>BM_HRL_WORD_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>oldScanPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanPos</name></name> <operator>=</operator> <call><name>_bitmap_find_bitset</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>oldScanPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* did we find a bit set in this word? */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>lastScanPos</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>uint64</name></type> <name>tid</name> <init>= <expr><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>+</operator> <name><name>result</name><operator>-&gt;</operator><name>lastScanPos</name></name> <operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nextTids</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>numOfTids</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>tid</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>+=</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
					<comment type="block">/* start scanning a new word */</comment>
					<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>oldScanPos</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>lastScanPos</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_catchup_to_next_tid - Catch up to the nextTid we need to check
 * from last iteration, in the following cases:
 *
 * 1: When the concurrent insert causes bitmap items from previous full page
 * to spill over to current page in the window when we (the read transaction)
 * had released the lock on the previous page and not locked the current page.
 * More details see read_words in bitmapsearch.c.
 * Related to issue: https://github.com/greenplum-db/gpdb/issues/11308
 * 2. Or when running bitmap heap scan path on bitmap index, since we always
 * try to read from a table block's start tid. See pull_stream.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_catchup_to_next_tid</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>BMIterateResult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>&gt;=</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Iterate each word until catch up to the next tid to search.
	 */</comment>
	<for>for<control>(<init>;</init> <condition><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>&lt;</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name></expr>;</condition>
		<incr><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>word</name> <init>= <expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type>	<name>fillLength</name> <init>= <expr><call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * XXX: weird, why the word marks as compresed but the word is 0?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>word</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>fillLength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<comment type="block">/* Skip all empty bits, this may cause words-&gt;firstTid &gt; result-&gt;nextTid */</comment>
				<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>+=</operator> <name>fillLength</name> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>

				<comment type="block">/* reset next tid to skip all empty words */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>&gt;</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>=</operator> <name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<while>while <condition>(<expr><name>fillLength</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>&lt;</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* update fill word to reflect expansion */</comment>
					<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>+=</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>fillLength</name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></while>

				<comment type="block">/* comsume all the fill words, try to fetch next words */</comment>
				<if_stmt><if>if <condition>(<expr><name>fillLength</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				* Catch up the next tid to search, but there still fill words.
				* Return current state.
				*/</comment>
				<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>&gt;=</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>+=</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_intesect() is dead code because streaming intersects
 * PagetableEntry structures, not raw batch words. It's possible we may
 * want to intersect batches later though -- it would definitely improve
 * streaming of intersections.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>

<comment type="block">/*
 * _bitmap_intersect() -- intersect 'numBatches' bitmap words.
 *
 * All 'numBatches' bitmap words are HRL compressed. The result
 * bitmap words HRL compressed, except that fill set words(1s) may
 * be lossily compressed.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_intersect</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier><modifier>*</modifier></type><name>batches</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>numBatches</name></decl></parameter>,
				  <parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name>	<modifier>*</modifier></type><name>prevStartNos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>	<name>nextReadNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>	<name>batchNo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numBatches</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>prevStartNos</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>numBatches</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextReadNo</name> <operator>=</operator> <name><name>batches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nextread</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><name>done</name> <operator>&amp;&amp;</operator>	<name><name>result</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&lt;</operator> <name><name>result</name><operator>-&gt;</operator><name>maxNumOfWords</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>andWord</name> <init>= <expr><name>LITERAL_ALL_ONE</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type>	<name>word</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type>		<name>andWordIsLiteral</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
    	 * We walk through the bitmap word in each list one by one
         * without de-compress the bitmap words. 'nextReadNo' defines
         * the position of the next word that should be read in an
         * uncompressed format.
         */</comment>
		<for>for <control>(<init><expr><name>batchNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>batchNo</name> <operator>&lt;</operator> <name>numBatches</name></expr>;</condition> <incr><expr><name>batchNo</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type> <name>offs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>bch</name> <init>= <expr><name><name>batches</name><index>[<expr><name>batchNo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* skip nextReadNo - nwordsread - 1 words */</comment>
			<expr_stmt><expr><call><name>_bitmap_findnextword</name><argument_list>(<argument><expr><name>bch</name></expr></argument>, <argument><expr><name>nextReadNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>bch</name><operator>-&gt;</operator><name>nwords</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bch</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>==</operator> <name>nextReadNo</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Here, startNo should point to the word to be read. */</comment>
			<expr_stmt><expr><name>offs</name> <operator>=</operator> <name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>word</name> <operator>=</operator> <name><name>bch</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>offs</name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CUR_WORD_IS_FILL</name><argument_list>(<argument><expr><name>bch</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>n</name></decl>;</decl_stmt>
				
				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>+=</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>bch</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>-</operator> <name>nextReadNo</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>andWord</name> <operator>=</operator> <call><name>BM_MAKE_FILL_WORD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>andWordIsLiteral</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>nextReadNo</name> <operator>=</operator> <name><name>bch</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CUR_WORD_IS_FILL</name><argument_list>(<argument><expr><name>bch</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>nwordsread</name></name><operator>++</operator></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>prevStartNos</name><index>[<expr><name>batchNo</name></expr>]</index></name> <operator>=</operator> <name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>uint32</name></type> <name>s</name> <init>= <expr><name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>s</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>andWordIsLiteral</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>CUR_WORD_IS_FILL</name><argument_list>(<argument><expr><name>bch</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>prevStartNos</name><index>[<expr><name>batchNo</name></expr>]</index></name> <operator>=</operator> <name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name>andWord</name> <operator>&amp;=</operator> <name>word</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>nwordsread</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>andWordIsLiteral</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Since there are not enough words in this attribute break this loop */</comment>
		<if_stmt><if>if <condition>(<expr><name>done</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type> <name>preBatchNo</name></decl>;</decl_stmt>

			<comment type="block">/* reset the attributes before batchNo */</comment>
			<for>for <control>(<init><expr><name>preBatchNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>preBatchNo</name> <operator>&lt;</operator> <name>batchNo</name></expr>;</condition> <incr><expr><name>preBatchNo</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>_bitmap_resetWord</name><argument_list>(<argument><expr><name><name>batches</name><index>[<expr><name>preBatchNo</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>prevStartNos</name><index>[<expr><name>preBatchNo</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>andWordIsLiteral</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type>	<name>off</name> <init>= <expr><name><name>result</name><operator>-&gt;</operator><name>nwords</name></name><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint32</name></type>	<name>w</name> <init>= <expr><name><name>result</name><operator>-&gt;</operator><name>nwords</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><name>off</name></expr>]</index></name> <operator>|=</operator> <call><name>WORDNO_GET_HEADER_BIT</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>nwords</name></name></expr>]</index></name> <operator>=</operator> <name>andWord</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nwords</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>andWordIsLiteral</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextReadNo</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>batchNo</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>bch</name><operator>-&gt;</operator><name>nwords</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* set the nextReadNo */</comment>
	<for>for <control>(<init><expr><name>batchNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>batchNo</name> <operator>&lt;</operator> <name>numBatches</name></expr>;</condition> <incr><expr><name>batchNo</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>batches</name><index>[<expr><name>batchNo</name></expr>]</index></name><operator>-&gt;</operator><name>nextread</name> <operator>=</operator> <name>nextReadNo</name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prevStartNos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NOT_USED */</comment>

<comment type="block">/*
 * Fast forward to the next read position by skipping the common compressed
 * zeros that appear in all batches. These skipped zeros are also copied into
 * the result words.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>fast_forward</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>nbatches</name></decl></parameter>, <parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier><modifier>*</modifier></type><name>batches</name></decl></parameter>, <parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>min_fill_len</name> <init>= <expr><name>MAX_FILL_LENGTH</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>fast_forward_words</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nbatches</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>batches</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbatches</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>word</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Fast forward the read batch from a rearrage bitmap index page.
		 * Since words-&gt;nwordsread may get set to a new value in read_words().
		 * See bitmapsearch.c read_words for more details.
		 */</comment>
		<expr_stmt><expr><call><name>_bitmap_findnextword</name><argument_list>(<argument><expr><name><name>batches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>batches</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nextread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>word</name> <operator>=</operator> <name><name>batches</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>cwords</name><index>[<expr><name><name>batches</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>startNo</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* if we find a matching tid in one of the batches, nothing to do */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CUR_WORD_IS_FILL</name><argument_list>(<argument><expr><name><name>batches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>batches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nextread</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>CUR_WORD_IS_FILL</name><argument_list>(<argument><expr><name><name>batches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>batches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nextread</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>CUR_WORD_IS_FILL</name><argument_list>(<argument><expr><name><name>batches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type> <name>fill_len</name> <init>= <expr><call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* adjust down */</comment>
			<if_stmt><if>if <condition>(<expr><name>fill_len</name> <operator>&lt;</operator> <name>min_fill_len</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>min_fill_len</name> <operator>=</operator> <name>fill_len</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>fast_forward_words</name> <operator>=</operator> <name>fill_len</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>fast_forward_words</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>offset</name></decl>;</decl_stmt>
		
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbatches</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>batches</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nextread</name> <operator>=</operator> <name><name>batches</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nwordsread</name> <operator>+</operator> 
				<name>fast_forward_words</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/*
		 * Copy these fast-forwarded words to
		 * the result.
		 */</comment>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nwords</name></name><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>|=</operator> <call><name>WORDNO_GET_HEADER_BIT</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>nwords</name></name></expr>]</index></name> <operator>=</operator> <name>fast_forward_words</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nwords</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>batches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nextread</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_union() -- union 'numBatches' bitmaps
 *
 * All bitmap words are HRL compressed. The result bitmap words are also
 * HRL compressed, except that fill unset words may be lossily compressed.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_union</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier><modifier>*</modifier></type><name>batches</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>numBatches</name></decl></parameter>, <parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> 		<name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name> 	   <modifier>*</modifier></type><name>prevstarts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>nextReadNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>batchNo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>numBatches</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>numBatches</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* save batch-&gt;startNo for each input bitmap vector */</comment>
	<expr_stmt><expr><name>prevstarts</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>numBatches</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the real firstTid for the bachwords with unioned batches.
	 * This is required because we may result-&gt;firstTid is set to nextTid
	 * to fetch in _bitmap_nextbatchwords for bitmap index scan, but the
	 * read words may not reach this position yet, the below calculation
	 * will set it back to the real first tid of current result batch.
	 */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>batches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nextread</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* 
	 * Compute the next read offset. We fast forward compressed
	 * zero words when possible.
	 */</comment>
	<expr_stmt><expr><name>nextReadNo</name> <operator>=</operator> <call><name>fast_forward</name><argument_list>(<argument><expr><name>numBatches</name></expr></argument>, <argument><expr><name>batches</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><name>done</name> <operator>&amp;&amp;</operator>	<name><name>result</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&lt;</operator> <name><name>result</name><operator>-&gt;</operator><name>maxNumOfWords</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>orWord</name> <init>= <expr><name>LITERAL_ALL_ZERO</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type>	<name>word</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>orWordIsLiteral</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>batchNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>batchNo</name> <operator>&lt;</operator> <name>numBatches</name></expr>;</condition> <incr><expr><name>batchNo</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>bch</name> <init>= <expr><name><name>batches</name><index>[<expr><name>batchNo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* skip nextReadNo - nwordsread - 1 words */</comment>
			<expr_stmt><expr><call><name>_bitmap_findnextword</name><argument_list>(<argument><expr><name>bch</name></expr></argument>, <argument><expr><name>nextReadNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>bch</name><operator>-&gt;</operator><name>nwords</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bch</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>==</operator> <name>nextReadNo</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Here, startNo should point to the word to be read. */</comment>
			<expr_stmt><expr><name>word</name> <operator>=</operator> <name><name>bch</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CUR_WORD_IS_FILL</name><argument_list>(<argument><expr><name>bch</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Fill word represents matches */</comment>
				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>+=</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>orWord</name> <operator>=</operator> <call><name>BM_MAKE_FILL_WORD</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>bch</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>-</operator> <name>nextReadNo</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>orWordIsLiteral</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>nextReadNo</name> <operator>=</operator> <name><name>bch</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CUR_WORD_IS_FILL</name><argument_list>(<argument><expr><name>bch</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Fill word represents no matches */</comment>

				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>nwordsread</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>prevstarts</name><index>[<expr><name>batchNo</name></expr>]</index></name> <operator>=</operator> <name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>orWordIsLiteral</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>CUR_WORD_IS_FILL</name><argument_list>(<argument><expr><name>bch</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* word is literal */</comment>
				<expr_stmt><expr><name><name>prevstarts</name><index>[<expr><name>batchNo</name></expr>]</index></name> <operator>=</operator> <name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>orWord</name> <operator>|=</operator> <name>word</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>nwordsread</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>startNo</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bch</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>orWordIsLiteral</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>done</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type> <name>i</name></decl>;</decl_stmt>

			<comment type="block">/* reset the attributes before batchNo */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>batchNo</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>_bitmap_resetWord</name><argument_list>(<argument><expr><name><name>batches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>prevstarts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>orWordIsLiteral</name></expr>)</condition>
			<block>{<block_content>
				 <comment type="block">/* Word is not literal, update the result header */</comment>
				<decl_stmt><decl><type><name>uint32</name></type> 	<name>offs</name> <init>= <expr><name><name>result</name><operator>-&gt;</operator><name>nwords</name></name><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint32</name></type>	<name>n</name> <init>= <expr><name><name>result</name><operator>-&gt;</operator><name>nwords</name></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><name>offs</name></expr>]</index></name> <operator>|=</operator> <call><name>WORDNO_GET_HEADER_BIT</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>nwords</name></name></expr>]</index></name> <operator>=</operator> <name>orWord</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nwords</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>orWordIsLiteral</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextReadNo</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* we just processed the last batch and it was empty */</comment>
		<if_stmt><if>if <condition>(<expr><name>batchNo</name> <operator>==</operator> <name>numBatches</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>batches</name><index>[<expr><name>batchNo</name></expr>]</index></name><operator>-&gt;</operator><name>nwords</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* set the next word to read for all input vectors */</comment>
	<for>for <control>(<init><expr><name>batchNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>batchNo</name> <operator>&lt;</operator> <name>numBatches</name></expr>;</condition> <incr><expr><name>batchNo</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>batches</name><index>[<expr><name>batchNo</name></expr>]</index></name><operator>-&gt;</operator><name>nextread</name> <operator>=</operator> <name>nextReadNo</name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prevstarts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_findnextword() -- Find the next word whose position is
 *        	                'nextReadNo' in an uncompressed format.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bitmap_findnextword</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>nextReadNo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* 
     * 'words-&gt;nwordsread' defines how many un-compressed words
     * have been read in this bitmap. We read from
     * position 'startNo', and increment 'words-&gt;nwordsread'
     * differently based on the type of words that are read, until
     * 'words-&gt;nwordsread' is equal to 'nextReadNo'.
     */</comment>
	<while>while <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>words</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>&lt;</operator> <name>nextReadNo</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get the current word */</comment>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>word</name> <init>= <expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>words</name><operator>-&gt;</operator><name>startNo</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CUR_WORD_IS_FILL</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name>nextReadNo</name> <operator>-</operator> <name><name>words</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>+=</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>startNo</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>words</name><operator>-&gt;</operator><name>startNo</name></name></expr>]</index></name> <operator>-=</operator> <operator>(</operator><name>nextReadNo</name> <operator>-</operator> <name><name>words</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>=</operator> <name>nextReadNo</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwordsread</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>startNo</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_resetWord() -- Reset the read position in an BMBatchWords
 *       	              to its previous value.
 *
 * Reset the read position in an BMBatchWords to its previous value,
 * which is given in 'prevStartNo'. Based on different type of words read,
 * the actual bitmap word may need to be changed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bitmap_resetWord</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>prevStartNo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>startNo</name></name> <operator>&gt;</operator> <name>prevStartNo</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>startNo</name></name> <operator>==</operator> <name>prevStartNo</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>startNo</name></name> <operator>=</operator> <name>prevStartNo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>startNo</name></name> <operator>==</operator> <name>prevStartNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CUR_WORD_IS_FILL</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>words</name><operator>-&gt;</operator><name>startNo</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwordsread</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * _bitmap_find_bitset() -- find the rightmost set bit (bit=1) in the 
 * 		given word since 'lastPos', not including 'lastPos'.
 *
 * The rightmost bit in the given word is considered the position 1, and
 * the leftmost bit is considered the position BM_HRL_WORD_SIZE.
 *
 * If such set bit does not exist in this word, 0 is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>uint8</name></type>
<name>_bitmap_find_bitset</name><parameter_list>(<parameter><decl><type><name>BM_HRL_WORD</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>lastPos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type> <name>pos</name> <init>= <expr><name>lastPos</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BM_HRL_WORD</name></type>	<name>rightmostBitWord</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <name>BM_HRL_WORD_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rightmostBitWord</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>pos</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>pos</name> <operator>&lt;=</operator> <name>BM_HRL_WORD_SIZE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>word</name> <operator>&amp;</operator> <name>rightmostBitWord</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rightmostBitWord</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <name>BM_HRL_WORD_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>pos</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_begin_iterate() -- initialize the given BMIterateResult instance.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_begin_iterate</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>BMIterateResult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name> <operator>=</operator> <name><name>words</name><operator>-&gt;</operator><name>startNo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>numOfTids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nextTidLoc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_log_metapage() -- log the changes to the metapage
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_log_metapage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>fork</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMMetaPage</name></type> <name>metapage</name> <init>= <expr><operator>(</operator><name>BMMetaPage</name><operator>)</operator> <call><name>PageGetContents</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>xl_bm_metapage</name><modifier>*</modifier></type>		<name>xlMeta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>			<name>recptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xlMeta</name> <operator>=</operator> <operator>(</operator><name>xl_bm_metapage</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_bm_metapage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlMeta</name><operator>-&gt;</operator><name>bm_node</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlMeta</name><operator>-&gt;</operator><name>bm_fork</name></name> <operator>=</operator> <name>fork</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlMeta</name><operator>-&gt;</operator><name>bm_lov_heapId</name></name> <operator>=</operator> <name><name>metapage</name><operator>-&gt;</operator><name>bm_lov_heapId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlMeta</name><operator>-&gt;</operator><name>bm_lov_indexId</name></name> <operator>=</operator> <name><name>metapage</name><operator>-&gt;</operator><name>bm_lov_indexId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlMeta</name><operator>-&gt;</operator><name>bm_lov_lastpage</name></name> <operator>=</operator> <name><name>metapage</name><operator>-&gt;</operator><name>bm_lov_lastpage</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>xlMeta</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_bm_metapage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BITMAP_ID</name></expr></argument>, <argument><expr><name>XLOG_BITMAP_INSERT_META</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>xlMeta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_log_bitmap_lastwords() -- log the last two words in a bitmap.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_log_bitmap_lastwords</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, 
							 <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>, <parameter><decl><type><name>BMLOVItem</name></type> <name>lovItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_bm_bitmap_lastwords</name></type>	<name>xlLastwords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>				<name>recptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>xlLastwords</name><operator>.</operator><name>bm_node</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlLastwords</name><operator>.</operator><name>bm_last_compword</name></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlLastwords</name><operator>.</operator><name>bm_last_word</name></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_word</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlLastwords</name><operator>.</operator><name>lov_words_header</name></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>lov_words_header</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlLastwords</name><operator>.</operator><name>bm_last_setbit</name></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_setbit</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlLastwords</name><operator>.</operator><name>bm_last_tid_location</name></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlLastwords</name><operator>.</operator><name>bm_lov_blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlLastwords</name><operator>.</operator><name>bm_lov_offset</name></name> <operator>=</operator> <name>lovOffset</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlLastwords</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_bm_bitmap_lastwords</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BITMAP_ID</name></expr></argument>, <argument><expr><name>XLOG_BITMAP_INSERT_BITMAP_LASTWORDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * WAL consistency checking
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUMP_BITMAPAM_INSERT_RECORDS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>_dump_page</name><argument_list>(<argument><expr><literal type="string">"insert"</literal></expr></argument>, <argument><expr><name>XactLastRecEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_log_lovitem() -- log adding a new lov item to a lov page.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_log_lovitem</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>fork</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>,
					<parameter><decl><type><name>BMLOVItem</name></type> <name>lovItem</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>metabuf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_new_lov_blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type> <name>lovPage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>xl_bm_lovitem</name></type>	<name>xlLovItem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>		<name>recptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xlLovItem</name><operator>.</operator><name>bm_node</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlLovItem</name><operator>.</operator><name>bm_fork</name></name> <operator>=</operator> <name>fork</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlLovItem</name><operator>.</operator><name>bm_lov_blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlLovItem</name><operator>.</operator><name>bm_lov_offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>xlLovItem</name><operator>.</operator><name>bm_lovItem</name></name><operator>)</operator></expr></argument>, <argument><expr><name>lovItem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMLOVItemData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlLovItem</name><operator>.</operator><name>bm_is_new_lov_blkno</name></name> <operator>=</operator> <name>is_new_lov_blkno</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlLovItem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_bm_lovitem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_new_lov_blkno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BITMAP_ID</name></expr></argument>, 
						<argument><expr><name>XLOG_BITMAP_INSERT_LOVITEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_new_lov_blkno</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type> <name>metapage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Insert a new lovItem at (blockno, offset): (%d,%d)"</literal></expr></argument>,
		 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_log_bitmapwords() -- log new bitmap words to be inserted.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_log_bitmapwords</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						<parameter><decl><type><name>BMTIDBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>init_first_page</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>xl_bm_bitmapword_pages</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapBuffers</name></decl></parameter>,
						<parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tidnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rdata_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>lovPage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_bm_bitmapwords</name></type> <name>xlBitmapWords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>init_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_bm_pages</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>xl_bm_bitmapword_pages</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>bitmapBuffers</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>num_bm_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>num_bm_pages</name> <operator>&gt;</operator> <name>MAX_BITMAP_PAGES_PER_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many bitmap pages in one insert batch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlBitmapWords</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlBitmapWords</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_node</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_num_pages</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>xl_bm_bitmapword_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_init_first_page</name></name> <operator>=</operator> <name>init_first_page</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_lov_blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_lov_offset</name></name> <operator>=</operator> <name>lovOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_last_compword</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_compword</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_last_word</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>last_word</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>lov_words_header</name></name> <operator>=</operator>
		<ternary><condition><expr><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>is_last_compword_fill</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_last_setbit</name></name> <operator>=</operator> <name>tidnum</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlBitmapWords</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_bm_bitmapwords</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rdata_no</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Write per-page structs */</comment>
	<expr_stmt><expr><name>init_page</name> <operator>=</operator> <name>init_first_page</name></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>lcp</argument>, <argument>xl_bm_bitmapword_pages</argument>, <argument>lcb</argument>, <argument>bitmapBuffers</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_bm_bitmapwords_perpage</name> <modifier>*</modifier></type><name>xlBitmapwordsPage</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>bitmapBuffer</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lcb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>bitmapPage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BMBitmap</name></type>	<name>bitmap</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <operator>(</operator><name>BMBitmap</name><operator>)</operator> <call><name>PageGetContentsMaxAligned</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><name>rdata_no</name></expr></argument>, <argument><expr><name>bitmapBuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><name>rdata_no</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>xlBitmapwordsPage</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_bm_bitmapwords_perpage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><name>rdata_no</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><name><name>xlBitmapwordsPage</name><operator>-&gt;</operator><name>bmp_start_hword_no</name></name></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>xlBitmapwordsPage</name><operator>-&gt;</operator><name>bmp_num_hwords</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><name>rdata_no</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>bitmap</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>xlBitmapwordsPage</name><operator>-&gt;</operator><name>bmp_start_cword_no</name></name></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>xlBitmapwordsPage</name><operator>-&gt;</operator><name>bmp_num_cwords</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rdata_no</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BITMAP_ID</name></expr></argument>, <argument><expr><name>XLOG_BITMAP_INSERT_WORDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lcb</argument>, <argument>bitmapBuffers</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>bitmapBuffer</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lcb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * WAL consistency checking
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUMP_BITMAPAM_INSERT_RECORDS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>_dump_page</name><argument_list>(<argument><expr><literal type="string">"insert"</literal></expr></argument>, <argument><expr><name>XactLastRecEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lcb</argument>, <argument>bitmapBuffers</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>_dump_page</name><argument_list>(<argument><expr><literal type="string">"insert"</literal></expr></argument>, <argument><expr><name>XactLastRecEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Buffer</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lcb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_log_updateword() -- log updating a single word in a given
 * 	bitmap page.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_log_updateword</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>bitmapBuffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>word_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>				<name>bitmapPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBitmap</name></type>			<name>bitmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_bm_updateword</name></type>	<name>xlBitmapWord</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>			<name>recptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>bitmapPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <operator>(</operator><name>BMBitmap</name><operator>)</operator> <call><name>PageGetContentsMaxAligned</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xlBitmapWord</name><operator>.</operator><name>bm_node</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWord</name><operator>.</operator><name>bm_blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWord</name><operator>.</operator><name>bm_word_no</name></name> <operator>=</operator> <name>word_no</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWord</name><operator>.</operator><name>bm_cword</name></name> <operator>=</operator> <name><name>bitmap</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name>word_no</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWord</name><operator>.</operator><name>bm_hword</name></name> <operator>=</operator> <name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><name>word_no</name><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"_bitmap_log_updateword: (blkno, word_no, cword, hword)="</literal>
		 <literal type="string">"(%d, %d, "</literal> <name>INT64_FORMAT</name> <literal type="string">", "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>, <argument><expr><name><name>xlBitmapWord</name><operator>.</operator><name>bm_blkno</name></name></expr></argument>,
		 <argument><expr><name><name>xlBitmapWord</name><operator>.</operator><name>bm_word_no</name></name></expr></argument>, <argument><expr><name><name>xlBitmapWord</name><operator>.</operator><name>bm_cword</name></name></expr></argument>,
		 <argument><expr><name><name>xlBitmapWord</name><operator>.</operator><name>bm_hword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlBitmapWord</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_bm_updateword</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bitmapBuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BITMAP_ID</name></expr></argument>, <argument><expr><name>XLOG_BITMAP_UPDATEWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
						

<comment type="block">/*
 * _bitmap_log_updatewords() -- log updating bitmap words in one or
 * 	two bitmap pages.
 *
 * If nextBuffer is Invalid, we only update one page.
 *
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_log_updatewords</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						<parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>,
						<parameter><decl><type><name>Buffer</name></type> <name>firstBuffer</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>secondBuffer</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>new_lastpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>				<name>firstPage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>				<name>secondPage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBitmap</name></type>			<name>firstBitmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBitmap</name></type>			<name>secondBitmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBitmapOpaque</name></type>		<name>firstOpaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBitmapOpaque</name></type>		<name>secondOpaque</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>xl_bm_updatewords</name></type>	<name>xlBitmapWords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>			<name>recptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>firstPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>firstBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstBitmap</name> <operator>=</operator> <operator>(</operator><name>BMBitmap</name><operator>)</operator> <call><name>PageGetContentsMaxAligned</name><argument_list>(<argument><expr><name>firstPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstOpaque</name> <operator>=</operator> <operator>(</operator><name>BMBitmapOpaque</name><operator>)</operator><call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>firstPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_two_pages</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_first_blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>firstBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xlBitmapWords</name><operator>.</operator><name>bm_first_cwords</name></name></expr></argument>,
			<argument><expr><name><name>firstBitmap</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>,
			<argument><expr><name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xlBitmapWords</name><operator>.</operator><name>bm_first_hwords</name></name></expr></argument>,
			<argument><expr><name><name>firstBitmap</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>,
			<argument><expr><name>BM_NUM_OF_HEADER_WORDS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_first_last_tid</name></name> <operator>=</operator> <name><name>firstOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_first_num_cwords</name></name> <operator>=</operator>
		<name><name>firstOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_next_blkno</name></name> <operator>=</operator> <name><name>firstOpaque</name><operator>-&gt;</operator><name>bm_bitmap_next</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>secondBuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>secondPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>secondBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>secondBitmap</name> <operator>=</operator> <operator>(</operator><name>BMBitmap</name><operator>)</operator> <call><name>PageGetContentsMaxAligned</name><argument_list>(<argument><expr><name>secondPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>secondOpaque</name> <operator>=</operator> <operator>(</operator><name>BMBitmapOpaque</name><operator>)</operator><call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>secondPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_two_pages</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_second_blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>secondBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xlBitmapWords</name><operator>.</operator><name>bm_second_cwords</name></name></expr></argument>,
				<argument><expr><name><name>secondBitmap</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>,
				<argument><expr><name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>xlBitmapWords</name><operator>.</operator><name>bm_second_hwords</name></name></expr></argument>,
				<argument><expr><name><name>secondBitmap</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>,
				<argument><expr><name>BM_NUM_OF_HEADER_WORDS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_second_last_tid</name></name> <operator>=</operator> <name><name>secondOpaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_second_num_cwords</name></name> <operator>=</operator>
			<name><name>secondOpaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_next_blkno</name></name> <operator>=</operator> <name><name>secondOpaque</name><operator>-&gt;</operator><name>bm_bitmap_next</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_node</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_lov_blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_lov_offset</name></name> <operator>=</operator> <name>lovOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlBitmapWords</name><operator>.</operator><name>bm_new_lastpage</name></name> <operator>=</operator> <name>new_lastpage</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>xlBitmapWords</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_bm_updatewords</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>firstBuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>secondBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>secondBuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>new_lastpage</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>secondBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BITMAP_ID</name></expr></argument>, <argument><expr><name>XLOG_BITMAP_UPDATEWORDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>firstPage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>secondBuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>secondPage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>new_lastpage</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type> <name>lovPage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WAL consistency checking helper.
 *
 * This can be used to dump an image of a page to a file, after inserting
 * or replaying a WAL record. The output is *extremely* voluminous, but
 * it's a very useful tool for tracking WAL-related bugs. To use, create
 * a cluster with mirroring enabled. Add _dump_page() calls in the routine
 * that writes a certain WAL record type, and in the corresponding WAL
 * replay routine. Run a test workload. This produces a bmdump_* file
 * in the master and the mirror. Run 'diff' to compare them: if the WAL
 * replay recreated the same changes that were made on the master, the
 * files should be identical.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUMP_BITMAPAM_INSERT_RECORDS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>dump_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function><type><name>void</name></type>
<name>_dump_page</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>recptr</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>relfilenode</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>zerossince</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dump_file</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dump_file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"bmdump_%d_%s"</literal></expr></argument>, <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dump_file</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"could not open dump file %s"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>dump_file</name></expr></argument>, <argument><expr><literal type="string">"LSN %X/%08X relfilenode %u/%u/%u blk %u\n"</literal></expr></argument>,
			<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recptr</name></expr></argument>,
			<argument><expr><name><name>relfilenode</name><operator>-&gt;</operator><name>spcNode</name></name></expr></argument>,
			<argument><expr><name><name>relfilenode</name><operator>-&gt;</operator><name>dbNode</name></name></expr></argument>,
			<argument><expr><name><name>relfilenode</name><operator>-&gt;</operator><name>relNode</name></name></expr></argument>,
			<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>zerossince</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BLCKSZ</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">32</literal></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>allzeros</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>allzeros</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><name>j</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>allzeros</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>allzeros</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>zerossince</name> <operator>&lt;</operator> <name>i</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>dump_file</name></expr></argument>, <argument><expr><literal type="string">"LSN %X/%08X %04x-%04x: zeros\n"</literal></expr></argument>,
					<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recptr</name></expr></argument>,
					<argument><expr><name>zerossince</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>dump_file</name></expr></argument>,
				<argument><expr><literal type="string">"LSN %X/%08X %04x: "</literal>
				<literal type="string">"%02x%02x%02x%02x %02x%02x%02x%02x "</literal>
				<literal type="string">"%02x%02x%02x%02x %02x%02x%02x%02x "</literal>
				<literal type="string">"%02x%02x%02x%02x %02x%02x%02x%02x "</literal>
				<literal type="string">"%02x%02x%02x%02x %02x%02x%02x%02x\n"</literal></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recptr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
				<argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator> <literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator> <literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator> <literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator> <literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator> <literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator> <literal type="number">7</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator> <literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator> <literal type="number">9</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">10</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">11</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">13</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">14</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">15</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">17</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">18</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">19</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">20</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">21</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">22</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">23</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">24</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">25</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">26</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">27</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">29</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">30</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">31</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>zerossince</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">32</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>zerossince</name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>dump_file</name></expr></argument>, <argument><expr><literal type="string">"LSN %X/%08X %02x-%02x: zeros\n"</literal></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recptr</name></expr></argument>,
				<argument><expr><name>zerossince</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>dump_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
