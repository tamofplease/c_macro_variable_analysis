<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/bitmap/bitmappages.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * bitmappages.c
 *	  Bitmap index page management code for the bitmap index.
 *
 * Portions Copyright (c) 2007-2010 Greenplum Inc
 * Portions Copyright (c) 2010-2012 EMC Corporation
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 2006-2008, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/bitmap/bitmappages.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/* 
 * Helper functions for hashing and matching build data. At this stage, the
 * hash API doesn't know about complex keys like those use during index
 * creation (the key is an array of key attributes). c.f. execGrouping.c.
 */</comment>
<typedef>typedef <type><struct>struct <name>BMBuildHashData</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>hash_funcs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>hash_func_is_strict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>eq_funcs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>        <modifier>*</modifier></type><name>ind_collations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>hash_cxt</name></decl>;</decl_stmt>
}</block></struct></type> <name>BMBuildHashData</name>;</typedef>


<decl_stmt><decl><type><specifier>static</specifier> <name>BMBuildHashData</name> <modifier>*</modifier></type><name>cur_bmbuild</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>build_hash_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>build_match_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>build_keycopy</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
 * _bitmap_getbuf() -- return the buffer for the given block number and
 * 					   the access method.
 */</comment>
<function><type><name>Buffer</name></type>
<name>_bitmap_getbuf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>access</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>!=</operator> <name>P_NEW</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>access</name> <operator>!=</operator> <name>BM_NOLOCK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>

	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>needLock</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>access</name> <operator>==</operator> <name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Extend the relation by one page.
		 *
		 * We have to use a lock to ensure no one else is extending the rel at
		 * the same time, else we will both try to initialize the same new
		 * page.  We can skip locking for new or temp relations, however,
		 * since no one else could be accessing them.
		 */</comment>
		<expr_stmt><expr><name>needLock</name> <operator>=</operator> <operator>!</operator><call><name>RELATION_IS_LOCAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Acquire buffer lock on new page */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BM_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Release the file-extension lock; it's now OK for someone else to
		 * extend the relation some more.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_wrtbuf() -- write a buffer page to disk.
 *
 * Release the lock and the pin held on the buffer.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_wrtbuf</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_relbuf() -- release the buffer without writing.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_relbuf</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_init_lovpage -- initialize a new LOV page.
 */</comment>
<decl_stmt><decl><type><name>void</name></type>
<name>_bitmap_init_lovpage</name><argument_list>(<argument><expr><name>Relation</name> <name>rel</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Buffer</name> <name>buf</name></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>			<name>page</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * _bitmap_init_bitmappage() -- initialize a new page to store the bitmap.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_init_bitmappage</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMBitmapOpaque</name></type>	<name>opaque</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMBitmapOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* even though page may not be new, reset all values */</comment>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BMBitmapOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>bm_bitmap_next</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_init_buildstate() -- initialize the build state before building
 *	a bitmap index.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_init_buildstate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>BMBuildState</name> <modifier>*</modifier></type><name>bmstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMMetaPage</name></type>	<name>mp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hash_flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>


	<comment type="block">/* initialize the build state */</comment>
	<expr_stmt><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_tupDesc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_tidLocsBuffer</name></name> <operator>=</operator> <operator>(</operator><name>BMTidBuildBuf</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMTidBuildBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_tidLocsBuffer</name><operator>-&gt;</operator><name>byte_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_tidLocsBuffer</name><operator>-&gt;</operator><name>lov_blocks</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_tidLocsBuffer</name><operator>-&gt;</operator><name>max_lov_block</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>BM_METAPAGE</name></expr></argument>, <argument><expr><name>BM_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mp</name> <operator>=</operator> <call><name>_bitmap_get_metapage_data</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bitmap_open_lov_heapandindex</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>mp</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_heap</name></name><operator>)</operator></expr></argument>,
								  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_index</name></name><operator>)</operator></expr></argument>, 
								  <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>cur_bmbuild</name> <operator>=</operator> <operator>(</operator><name>BMBuildHashData</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMBuildHashData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>hash_funcs</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator>
						<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>bmstate</name><operator>-&gt;</operator><name>bm_tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>eq_funcs</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator>
                        <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>bmstate</name><operator>-&gt;</operator><name>bm_tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>hash_func_is_strict</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator>
                        <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>bmstate</name><operator>-&gt;</operator><name>bm_tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>ind_collations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bmstate</name><operator>-&gt;</operator><name>bm_tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_tupDesc</name></name></expr></argument>,  <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_opr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_function</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>left_hash_function</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>right_hash_function</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hashable</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>typid</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eq_opr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hashable</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cur_bmbuild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur_bmbuild</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>eq_function</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>eq_opr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_op_hash_functions</name><argument_list>(<argument><expr><name>eq_opr</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>left_hash_function</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>right_hash_function</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find hash functions for operator %u"</literal></expr></argument>, <argument><expr><name>eq_opr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>left_hash_function</name> <operator>==</operator> <name>right_hash_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>eq_function</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>eq_funcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>right_hash_function</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>hash_funcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>hash_func_is_strict</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>func_strict</name><argument_list>(<argument><expr><name>right_hash_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>cur_bmbuild</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>natts</name></name> <operator>=</operator> <name><name>bmstate</name><operator>-&gt;</operator><name>bm_tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>ind_collations</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>tmpcxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
        	                      <argument><expr><literal type="string">"Bitmap build temp space"</literal></expr></argument>,
            	                  <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                	              <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                    	          <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* setup the hash table */</comment>
	    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <comment type="block" format="doxygen">/**
	     * Reserve enough space for the hash key header and then the data segments (values followed by nulls)
	     */</comment>
    	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMBuildHashKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
                           <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>cur_bmbuild</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
                           <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>cur_bmbuild</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BMBuildLovData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">200</literal></expr>;</expr_stmt> 
    	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>build_hash_key</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>build_match_key</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keycopy</name></name> <operator>=</operator> <name>build_keycopy</name></expr>;</expr_stmt>
    	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
        	                      <argument><expr><literal type="string">"Bitmap build hash table"</literal></expr></argument>,
            	                  <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
                	              <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
                    	          <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>hash_cxt</name></name> <operator>=</operator> <name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>hash_flags</name> <operator>=</operator> <name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_KEYCOPY</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>bmstate</name><operator>-&gt;</operator><name>lovitem_hash</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Bitmap index build lov item hash"</literal></expr></argument>,
											<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><name>hash_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>bmstate</name><operator>-&gt;</operator><name>lovitem_hashKeySize</name></name> <operator>=</operator> <name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>attno</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>bmstate</name><operator>-&gt;</operator><name>lovitem_hash</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bmstate</name><operator>-&gt;</operator><name>lovitem_hashKeySize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_scanKeys</name></name> <operator>=</operator>
			<operator>(</operator><name>ScanKey</name><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_tupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name><name>bmstate</name><operator>-&gt;</operator><name>bm_tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_opr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RegProcedure</name></type> <name>opfuncid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>atttypid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>atttypid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_tupDesc</name></name></expr></argument>,  <argument><expr><name>attno</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eq_opr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opfuncid</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>eq_opr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_scanKeys</name><index>[<expr><name>attno</name></expr>]</index></name><operator>)</operator></expr></argument>,
								   <argument><expr><name>SK_ISNULL</name></expr></argument>,
								   <argument><expr><name>attno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
								   <argument><expr><name>InvalidOid</name></expr></argument>,
								   <argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_index</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name>opfuncid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_scanDesc</name></name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_heap</name></name></expr></argument>,
							 <argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_index</name></name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, 
							 <argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_scanDesc</name></name></expr></argument>,
					 <argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_scanKeys</name></name></expr></argument>, <argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We need to log index creation in WAL iff WAL archiving is enabled
	 * AND it's not a temp index. Currently, since building an index
	 * writes page to the shared buffer, we can't disable WAL archiving.
	 * We will add this shortly.
	 */</comment>	
	<expr_stmt><expr><name><name>bmstate</name><operator>-&gt;</operator><name>use_wal</name></name> <operator>=</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_cleanup_buildstate() -- clean up the build state after
 *	inserting all rows in the heap into the bitmap index.
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_cleanup_buildstate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>BMBuildState</name> <modifier>*</modifier></type><name>bmstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* write out remaining tids in bmstate-&gt;bm_tidLicsBuffer */</comment>
	<decl_stmt><decl><type><name>BMTidBuildBuf</name>	<modifier>*</modifier></type><name>tidLocsBuffer</name> <init>= <expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_tidLocsBuffer</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>_bitmap_write_alltids</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>tidLocsBuffer</name></expr></argument>, <argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>use_wal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_tidLocsBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cur_bmbuild</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>tmpcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>hash_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>hash_funcs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>eq_funcs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cur_bmbuild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cur_bmbuild</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* 
		 * We might have build an index on a non-hashable data type, in
		 * which case we will have searched the btree manually. Free associated
		 * memory.
		 */</comment>
		<expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_scanDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_scanKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>_bitmap_close_lov_heapandindex</name><argument_list>(<argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_heap</name></name></expr></argument>,<argument><expr><name><name>bmstate</name><operator>-&gt;</operator><name>bm_lov_index</name></name></expr></argument>,
						 		   <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_init() -- initialize the bitmap index.
 *
 * Create the meta page, a new heap which stores the distinct values for
 * the attributes to be indexed, a btree index on this new heap for searching
 * those distinct values, and the first LOV page.
 *
 * for_empty: true means build for '_init' file.
 * Create bitmap index for a 'unlogged' table will call bmbuildempty(), which
 * initialize the meta page and first LOV page for INIT_FORKNUM (the '_init' file).
 * As bmbuildempty() is called after bmbuild(), it's safe to get the OIDs of the
 * new heap and its index from meta page through GetBitmapIndexAuxOids().
 */</comment>
<function><type><name>void</name></type>
<name>_bitmap_init</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexrel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>for_empty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMMetaPage</name></type>		<name>metapage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>			<name>metabuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>			<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>			<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMLOVItem</name></type> 		<name>lovItem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type>	<name>newOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>			<name>currLovPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type>	<name>o</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>lovHeapOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>lovIndexOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>fork</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fork</name> <operator>=</operator> <ternary><condition><expr><name>for_empty</name></expr> ?</condition><then>  <expr><name>INIT_FORKNUM</name></expr> </then><else>: <expr><name>MAIN_FORKNUM</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* sanity check */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetNumberOfBlocksInFork</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><name>fork</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot initialize non-empty bitmap index \"%s\""</literal></expr></argument>,
				<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* create the metapage */</comment>
	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><name>fork</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize the LOV metadata */</comment>
	<if_stmt><if>if <condition>(<expr><name>for_empty</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>GetBitmapIndexAuxOids</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovHeapOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovIndexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bitmap_create_lov_heapandindex</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovHeapOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovIndexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize the metapage */</comment>
	<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <operator>(</operator><name>BMMetaPage</name><operator>)</operator> <call><name>PageGetContents</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>metapage</name><operator>-&gt;</operator><name>bm_magic</name></name> <operator>=</operator> <name>BITMAP_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>-&gt;</operator><name>bm_version</name></name> <operator>=</operator> <name>BITMAP_VERSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>-&gt;</operator><name>bm_lov_heapId</name></name> <operator>=</operator> <name>lovHeapOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>-&gt;</operator><name>bm_lov_indexId</name></name> <operator>=</operator> <name>lovIndexOid</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bitmap_log_metapage</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><name>fork</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* allocate the first LOV page. */</comment>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><name>fork</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bitmap_init_lovpage</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>currLovPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set the first item to support NULL value */</comment>
	<expr_stmt><expr><name>lovItem</name> <operator>=</operator> <call><name>_bitmap_formitem</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newOffset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>currLovPage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX: perhaps this could be a special page, with more efficient storage
	 * after all, we have fixed size data
	 */</comment>
	<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>currLovPage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator><name>lovItem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMLOVItemData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                    <argument><expr><name>newOffset</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to add LOV item to \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>metapage</name><operator>-&gt;</operator><name>bm_lov_lastpage</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>use_wal</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bitmap_log_lovitem</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><name>fork</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>newOffset</name></expr></argument>, <argument><expr><name>lovItem</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bitmap_wrtbuf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bitmap_wrtbuf</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lovItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build a hash of the key we're indexing.
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type>
<name>build_hash_key</name><argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>key</name></expr></argument>, <argument><expr><name>Size</name> <name>keysize</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>BMBuildHashKey</name> <modifier>*</modifier></type><name>keyData</name> <init>= <expr><operator>(</operator><name>BMBuildHashKey</name><operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>k</name> <init>= <expr><name><name>keyData</name><operator>-&gt;</operator><name>attributeValueArr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name> <init>= <expr><name><name>keyData</name><operator>-&gt;</operator><name>isNullArr</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hashkey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cur_bmbuild</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* rotate hashkey left 1 bit at each step */</comment>
		<expr_stmt><expr><name>hashkey</name> <operator>=</operator> <operator>(</operator><name>hashkey</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>hashkey</name> <operator>&amp;</operator> <literal type="number">0x80000000</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>( <expr><name><name>isNull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>cur_bmbuild</name><operator>-&gt;</operator><name>hash_func_is_strict</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* leave hashkey unmodified, equivalent to hashcode 0 */</comment>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>	<name>collation</name> <init>= <expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>ind_collations</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name>DEFAULT_COLLATION_OID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>hashkey</name> <operator>^=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>FunctionCall1Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>hash_funcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
														<argument><expr><name>collation</name></expr></argument>,
														<argument><expr><name><name>k</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>hashkey</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * Test whether key1 matches key2. Since the equality functions may leak,
 * reset the temporary context at each call and do all equality calculation
 * in that context.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>
<name>build_match_key</name><argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>key1</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>key2</name></expr></argument>, <argument><expr><name>Size</name> <name>keysize</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>key1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>BMBuildHashKey</name> <modifier>*</modifier></type><name>keyData1</name> <init>= <expr><operator>(</operator><name>BMBuildHashKey</name><operator>*</operator><operator>)</operator><name>key1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>k1</name> <init>= <expr><name><name>keyData1</name><operator>-&gt;</operator><name>attributeValueArr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull1</name> <init>= <expr><name><name>keyData1</name><operator>-&gt;</operator><name>isNullArr</name></name></expr></init></decl>;</decl_stmt>
	
	<decl_stmt><decl><type><name>BMBuildHashKey</name> <modifier>*</modifier></type><name>keyData2</name> <init>= <expr><operator>(</operator><name>BMBuildHashKey</name><operator>*</operator><operator>)</operator><name>key2</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>k2</name> <init>= <expr><name><name>keyData2</name><operator>-&gt;</operator><name>attributeValueArr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull2</name> <init>= <expr><name><name>keyData2</name><operator>-&gt;</operator><name>isNullArr</name></name></expr></init></decl>;</decl_stmt>
	
    <decl_stmt><decl><type><name>int</name></type> <name>numKeys</name> <init>= <expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>tmpcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>tmpcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numKeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><name><name>isNull1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>isNull2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* both nulls -- treat as equal so we group them together */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>( <expr><name><name>isNull1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>isNull2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* one is null and one non-null -- this is inequal */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* do the real comparison */</comment>
            <decl_stmt><decl><type><name>Datum</name></type> <name>attr1</name> <init>= <expr><name><name>k1</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>attr2</name> <init>= <expr><name><name>k2</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>	<name>collation</name> <init>= <expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>ind_collations</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>collation</name> <operator>=</operator> <name>DEFAULT_COLLATION_OID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>eq_funcs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												<argument><expr><name>collation</name></expr></argument>,
												<argument><expr><name>attr1</name></expr></argument>,
												<argument><expr><name>attr2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>     <comment type="block">/* they aren't equal */</comment>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>build_keycopy</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BMBuildHashKey</name> <modifier>*</modifier></type><name>destKey</name> <init>= <expr><operator>(</operator><name>BMBuildHashKey</name><operator>*</operator><operator>)</operator> <name>dest</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BMBuildHashKey</name> <modifier>*</modifier></type><name>srcKey</name> <init>= <expr><operator>(</operator><name>BMBuildHashKey</name><operator>*</operator><operator>)</operator> <name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numKeys</name> <init>= <expr><name><name>cur_bmbuild</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datumsOut</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dest</name><operator>)</operator> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMBuildHashKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNullsOut</name> <init>= <expr><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dest</name><operator>)</operator> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMBuildHashKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numKeys</name></expr></argument> )</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for <control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numKeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>datumsOut</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>srcKey</name><operator>-&gt;</operator><name>attributeValueArr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>isNullsOut</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>srcKey</name><operator>-&gt;</operator><name>isNullArr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* we've copied the datums into the data segment, now set up final output */</comment> 
    <expr_stmt><expr><name><name>destKey</name><operator>-&gt;</operator><name>attributeValueArr</name></name> <operator>=</operator> <name>datumsOut</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>destKey</name><operator>-&gt;</operator><name>isNullArr</name></name>  <operator>=</operator> <name>isNullsOut</name></expr>;</expr_stmt>

    <comment type="block" format="doxygen">/**
     * build_keycopy must meet the spec of the keycopy function, which requires a return value even though
     * the return value is ignored 
     */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


</unit>
