<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/bitmap/bitmap.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * bitmap.c
 *	  Implementation of the Hybrid Run-Length (HRL) on-disk bitmap index.
 *
 * Portions Copyright (c) 2007-2010 Greenplum Inc
 * Portions Copyright (c) 2010-2012 EMC Corporation
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 2006-2008, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/bitmap/bitmap.c
 *
 * NOTES
 *	This file contains only the public interface routines.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amvalidate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>		<comment type="block">/* for btree_or_bitmap_validate() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/tidbitmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/index_selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bmbuildCallback</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,	<parameter><decl><type><name>ItemPointer</name></type> <name>tupleId</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>attdata</name></decl></parameter>,
							<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tupleIsAlive</name></decl></parameter>,	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>words_get_match</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>BMIterateResult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
                            <parameter><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl></parameter>, <parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>newentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>IndexScanDesc</name></type> <name>copy_scan_desc</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>indexstream_free</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pull_stream</name><parameter_list>(<parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cleanup_pos</name><parameter_list>(<parameter><decl><type><name>BMScanPosition</name></type> <name>pos</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* type to hide BM specific stream state */</comment>
<typedef>typedef <type><struct>struct <name>BMStreamOpaque</name>
<block>{
	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<comment type="block">/* Indicate that this stream contains no more bitmap words. */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_done</name></decl>;</decl_stmt>
}</block></struct></type> <name>BMStreamOpaque</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>stream_free</name><parameter_list>(<parameter><decl><type><name>BMStreamOpaque</name> <modifier>*</modifier></type><name>so</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Bitmap index handler function: return IndexAmRoutine with access method parameters
 * and callbacks.
 */</comment>
<function><type><name>Datum</name></type>
<name>bmhandler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexAmRoutine</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* these are mostly the same as B-tree */</comment>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amstrategies</name></name> <operator>=</operator> <name>BTMaxStrategyNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsupport</name></name> <operator>=</operator> <name>BTNProcs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorder</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorderbyop</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanbackward</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanunique</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanmulticol</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amoptionalkey</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsearcharray</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsearchnulls</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amstorage</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amclusterable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ampredlocks</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amkeytype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambuild</name></name> <operator>=</operator> <name>bmbuild</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambuildempty</name></name> <operator>=</operator> <name>bmbuildempty</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>aminsert</name></name> <operator>=</operator> <name>bminsert</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambulkdelete</name></name> <operator>=</operator> <name>bmbulkdelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amvacuumcleanup</name></name> <operator>=</operator> <name>bmvacuumcleanup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanreturn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcostestimate</name></name> <operator>=</operator> <name>bmcostestimate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amoptions</name></name> <operator>=</operator> <name>bmoptions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amproperty</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amvalidate</name></name> <operator>=</operator> <name>bmvalidate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambeginscan</name></name> <operator>=</operator> <name>bmbeginscan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amrescan</name></name> <operator>=</operator> <name>bmrescan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amgettuple</name></name> <operator>=</operator> <name>bmgettuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amgetbitmap</name></name> <operator>=</operator> <name>bmgetbitmap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amendscan</name></name> <operator>=</operator> <name>bmendscan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ammarkpos</name></name> <operator>=</operator> <name>bmmarkpos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amrestrpos</name></name> <operator>=</operator> <name>bmrestrpos</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>amroutine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bmbuild() -- Build a new bitmap index.
 */</comment>
<function><type><name>IndexBuildResult</name> <modifier>*</modifier></type>
<name>bmbuild</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>      <name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBuildState</name></type> <name>bmstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexBuildResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CONCURRENTLY is not supported when creating bitmap indexes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We expect this to be called exactly once. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name> <argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDEX_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" already contains data"</literal></expr></argument>,
				<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize the bitmap index for MAIN_FORKNUM. */</comment>
	<expr_stmt><expr><call><name>_bitmap_init</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize the build state. */</comment>
	<expr_stmt><expr><call><name>_bitmap_init_buildstate</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bmstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do the heap scan */</comment>
	<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <call><name>table_index_build_scan</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									   <argument><expr><name>bmbuildCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>bmstate</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* clean up the build state */</comment>
	<expr_stmt><expr><call><name>_bitmap_cleanup_buildstate</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bmstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* return statistics */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>IndexBuildResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBuildResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>heap_tuples</name></name> <operator>=</operator> <name>reltuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>index_tuples</name></name> <operator>=</operator> <name><name>bmstate</name><operator>.</operator><name>ituples</name></name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	bmbuildempty() -- build an empty bitmap index in the initialization fork
 */</comment>
<function><type><name>void</name></type>
<name>bmbuildempty</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* initialize meta page and first LOV page for INIT_FORKNUM */</comment>
	<expr_stmt><expr><call><name>_bitmap_init</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bminsert() -- insert an index tuple into a bitmap index.
 */</comment>
<function><type><name>bool</name></type>
<name>bminsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
		 <parameter><decl><type><name>ItemPointer</name></type> <name>ht_ctid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>,
		 <parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>,
		 <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_bitmap_doinsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>ht_ctid</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bmgettuple() -- return the next tuple in a scan.
 */</comment>
<function><type><name>bool</name></type>
<name>bmgettuple</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMScanOpaque</name></type>  <name>so</name> <init>= <expr><operator>(</operator><name>BMScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>res</name></decl>;</decl_stmt>

	<comment type="block">/* This implementation of a bitmap index is never lossy */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_recheck</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* 
	 * If we have already begun our scan, continue in the same direction.
	 * Otherwise, start up the scan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name> <operator>&amp;&amp;</operator> <name><name>so</name><operator>-&gt;</operator><name>cur_pos_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_bitmap_next</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_bitmap_first</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>stream_end_iterate</name><parameter_list>(<parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* opaque may be NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>opaque</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>stream_free</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>opaque</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>stream_begin_iterate</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMStreamOpaque</name> <modifier>*</modifier></type><name>so</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>pull</name></name> <operator>=</operator> <name>pull_stream</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>end_iterate</name></name> <operator>=</operator> <name>stream_end_iterate</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>scan</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>so</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMStreamOpaque</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>scan</name></name> <operator>=</operator> <call><name>copy_scan_desc</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>is_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>so</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bminitbitmap() -- return an empty bitmap.
 * */</comment>
<function><type><name>void</name></type>
<name>bminitbitmap</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>bmNodeP</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexStream</name>  <modifier>*</modifier></type><name>is</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>is</name> <operator>=</operator> <operator>(</operator><name>IndexStream</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexStream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>BMS_INDEX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>begin_iterate</name></name> <operator>=</operator> <name>stream_begin_iterate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>indexstream_free</name></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>StreamBitmap</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>StreamBitmap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>streamNode</name></name> <operator>=</operator> <name>is</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>bmNodeP</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sb</name></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bmgetbitmap() -- return a stream bitmap.
 */</comment>
<function><type><name>int64</name></type>
<name>bmgetbitmap</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>bmNodeP</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexStream</name>	 <modifier>*</modifier></type><name>is</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMScanPosition</name></type>	<name>scanPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_bitmap_firstbatchwords</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scanPos</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BMScanOpaque</name><operator>)</operator><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name><operator>)</operator><operator>-&gt;</operator><name>bm_currPos</name></expr>;</expr_stmt>

	<comment type="block">/* perhaps this should be in a special context? */</comment>
	<expr_stmt><expr><name>is</name> <operator>=</operator> <operator>(</operator><name>IndexStream</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexStream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>BMS_INDEX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>begin_iterate</name></name> <operator>=</operator> <name>stream_begin_iterate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>indexstream_free</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>set_instrument</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>upd_instrument</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>vec</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <call><name>copy_scan_desc</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since we have made a copy for this scan, we reset the lov buffers
		 * in the original scan to make sure that these buffers will not
		 * be released.
		 */</comment>
		<for>for <control>(<init><expr><name>vec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>vec</name> <operator>&lt;</operator> <name><name>scanPos</name><operator>-&gt;</operator><name>nvec</name></name></expr>;</condition> <incr><expr><name>vec</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BMVector</name></type> <name>bmvec</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>scanPos</name><operator>-&gt;</operator><name>posvecs</name><index>[<expr><name>vec</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>bmvec</name><operator>-&gt;</operator><name>bm_lovBuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * GPDB specific code. Since GPDB also support StreamBitmap
	 * in bitmap index. So normally we need to create specific bitmap
	 * node in the amgetbitmap AM.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bmNodeP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bmNodeP</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StreamBitmap</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>StreamBitmap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>streamNode</name></name> <operator>=</operator> <name>is</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>bmNodeP</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sb</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><operator>*</operator><name>bmNodeP</name></expr></argument>, <argument><expr><name>StreamBitmap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>stream_add_node</name><argument_list>(<argument><expr><operator>(</operator><name>StreamBitmap</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>bmNodeP</name></expr></argument>, <argument><expr><name>is</name></expr></argument>, <argument><expr><name>BMS_OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"non stream bitmap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * XXX We don't have a precise idea of the number of heap tuples
	 * involved.
	 */</comment>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bmbeginscan() -- start a scan on the bitmap index.
 */</comment>
<function><type><name>IndexScanDesc</name></type>
<name>bmbeginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMScanOpaque</name></type>	<name>so</name></decl>;</decl_stmt>

	<comment type="block">/* no order by operators allowed */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>norderbys</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get the scan */</comment>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>RelationGetIndexScan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>norderbys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* allocate private workspace */</comment>
	<expr_stmt><expr><name>so</name> <operator>=</operator> <operator>(</operator><name>BMScanOpaque</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMScanOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>cur_pos_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>mark_pos_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_itupdesc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>so</name></expr>;</expr_stmt>

	<return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bmrescan() -- restart a scan on the bitmap index.
 */</comment>
<function><type><name>void</name></type>
<name>bmrescan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nscankeys</name></decl></parameter>,
		 <parameter><decl><type><name>ScanKey</name></type> <name>orderbys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMScanOpaque</name></type>	<name>so</name> <init>= <expr><operator>(</operator><name>BMScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>cleanup_pos</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMScanPositionData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>cur_pos_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>cleanup_pos</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMScanPositionData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>cur_pos_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* reset the scan key */</comment>
	<if_stmt><if>if <condition>(<expr><name>scankey</name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>,
				<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bmendscan() -- close a scan.
 */</comment>
<function><type><name>void</name></type>
<name>bmendscan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMScanOpaque</name></type>	<name>so</name> <init>= <expr><operator>(</operator><name>BMScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* free the space */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * release the buffers that have been stored for each related 
		 * bitmap vector.
		 */</comment>
		<expr_stmt><expr><call><name>cleanup_pos</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>cleanup_pos</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bmmarkpos() -- save the current scan position.
 */</comment>
<function><type><name>void</name></type>
<name>bmmarkpos</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMScanOpaque</name></type>	<name>so</name> <init>= <expr><operator>(</operator><name>BMScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMVector</name></type>	<name>bmScanPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>vectorNo</name></decl>;</decl_stmt>

	<comment type="block">/* free the space */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>mark_pos_valid</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * release the buffers that have been stored for each
		 * related bitmap.
		 */</comment>
		<expr_stmt><expr><name>bmScanPos</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name><operator>-&gt;</operator><name>posvecs</name></name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>vectorNo</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>vectorNo</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name><operator>-&gt;</operator><name>nvec</name></name></expr>;</condition> <incr><expr><name>vectorNo</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>vectorNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_lovBuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>vectorNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>vectorNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_lovBuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>mark_pos_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>cur_pos_valid</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>	<name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMScanPositionData</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>


		<comment type="block">/* set the mark position */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name></name> <operator>=</operator> <operator>(</operator><name>BMScanPosition</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>bmScanPos</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>posvecs</name></name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>vectorNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>vectorNo</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>nvec</name></name></expr>;</condition> <incr><expr><name>vectorNo</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>vectorNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_lovBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>IncrBufferRefCount</name><argument_list>(<argument><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>vectorNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name><operator>-&gt;</operator><name>posvecs</name></name></expr></argument>, <argument><expr><name>bmScanPos</name></expr></argument>,
			   <argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>nvec</name></name> <operator>*</operator>
			   <sizeof>sizeof<argument_list>(<argument><expr><name>BMVectorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name></name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>mark_pos_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bmrestrpos() -- restore a scan to the last saved position.
 */</comment>
<function><type><name>void</name></type>
<name>bmrestrpos</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMScanOpaque</name></type>	<name>so</name> <init>= <expr><operator>(</operator><name>BMScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>BMVector</name></type>	<name>bmScanPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>vectorNo</name></decl>;</decl_stmt>

	<comment type="block">/* free space */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>cur_pos_valid</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* release the buffers that have been stored for each related bitmap.*/</comment>
		<expr_stmt><expr><name>bmScanPos</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>posvecs</name></name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>vectorNo</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>vectorNo</name><operator>&lt;</operator><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name><operator>-&gt;</operator><name>nvec</name></name></expr>;</condition>
			 <incr><expr><name>vectorNo</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>vectorNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_lovBuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>vectorNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>vectorNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_lovBuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>cur_pos_valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>mark_pos_valid</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>	<name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMScanPositionData</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

		<comment type="block">/* set the current position */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name> <operator>=</operator> <operator>(</operator><name>BMScanPosition</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>bmScanPos</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name><operator>-&gt;</operator><name>posvecs</name></name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>vectorNo</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>vectorNo</name><operator>&lt;</operator><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>nvec</name></name></expr>;</condition>
			 <incr><expr><name>vectorNo</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>vectorNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_lovBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>IncrBufferRefCount</name><argument_list>(<argument><expr><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>vectorNo</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>bm_lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>		

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>posvecs</name></name></expr></argument>, <argument><expr><name>bmScanPos</name></expr></argument>,
			   <argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name><operator>-&gt;</operator><name>nvec</name></name> <operator>*</operator>
			   <sizeof>sizeof<argument_list>(<argument><expr><name>BMVectorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_markPos</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>cur_pos_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bmbulkdelete() -- bulk delete index entries
 *
 * Re-index is performed before retrieving the number of tuples
 * indexed in this index.
 */</comment>
<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>bmbulkdelete</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>,
			 <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
			 <parameter><decl><type><name>IndexBulkDeleteCallback</name></type> <name>callback</name></decl></parameter>,
			 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* allocate stats if first time through, else re-use existing struct */</comment>
	<if_stmt><if>if <condition>(<expr><name>stats</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>IndexBulkDeleteResult</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBulkDeleteResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	

	<expr_stmt><expr><call><name>reindex_index</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>num_pages</name></name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Since we re-build the index, set this to number of heap tuples. */</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>num_index_tuples</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>num_heap_tuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>tuples_removed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bmvacuumcleanup() -- post-vacuum cleanup.
 *
 * We do nothing useful here.
 */</comment>
<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>bmvacuumcleanup</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>,
				<parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>stats</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>IndexBulkDeleteResult</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBulkDeleteResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* update statistics */</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>num_pages</name></name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>pages_deleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>pages_free</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* XXX: dodgy hack to shutup index_scan() and vacuum_index() */</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>num_index_tuples</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>num_heap_tuples</name></name></expr>;</expr_stmt>

	<return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Per-tuple callback from IndexBuildHeapScan
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>bmbuildCallback</name><argument_list>(<argument><expr><name>Relation</name> <name>index</name></expr></argument>, <argument><expr><name>ItemPointer</name> <name>tupleId</name></expr></argument>, <argument><expr><name>Datum</name> <operator>*</operator><name>attdata</name></expr></argument>,
				<argument><expr><name>bool</name> <operator>*</operator><name>nulls</name></expr></argument>, <argument><expr><name>bool</name> <name>tupleIsAlive</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>,	<argument><expr><name>void</name> <operator>*</operator><name>state</name></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMBuildState</name> <modifier>*</modifier></type><name>bstate</name> <init>= <expr><operator>(</operator><name>BMBuildState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>_bitmap_buildinsert</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><operator>*</operator><name>tupleId</name></expr></argument>, <argument><expr><name>attdata</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>bstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bstate</name><operator>-&gt;</operator><name>ituples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>bstate</name><operator>-&gt;</operator><name>ituples</name></name><operator>)</operator> <operator>%</operator> <literal type="number">1000</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * Free an IndexScanDesc created by copy_scan_desc(). If releaseBuffers is true,
 * any Buffers pointed to by the BMScanPositions will be released as well.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_scan_desc</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>releaseBuffers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMScanOpaque</name></type> <name>s</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>vec</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bm_currPos</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>releaseBuffers</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>vec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>vec</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>nvec</name></name></expr>;</condition> <incr><expr><name>vec</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BMVector</name></type> <name>bmvec</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>posvecs</name><index>[<expr><name>vec</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>bmvec</name><operator>-&gt;</operator><name>bm_lovBuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>cleanup_pos</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>bm_currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>bm_currPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bm_currPos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>bm_markPos</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>releaseBuffers</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>vec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>vec</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>bm_markPos</name><operator>-&gt;</operator><name>nvec</name></name></expr>;</condition> <incr><expr><name>vec</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BMVector</name></type> <name>bmvec</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>bm_markPos</name><operator>-&gt;</operator><name>posvecs</name><index>[<expr><name>vec</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>bmvec</name><operator>-&gt;</operator><name>bm_lovBuffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>cleanup_pos</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>bm_markPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>bm_markPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>bm_markPos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * free the memory associated with the stream
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>stream_free</name><parameter_list>(<parameter><decl><type><name>BMStreamOpaque</name> <modifier>*</modifier></type><name>so</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* opaque may be NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>so</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free_scan_desc</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* we can't release the underlying
										  Buffers yet as there may be other
										  iterators in operation */</comment>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>entry</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * free the memory associated with an IndexStream
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>indexstream_free</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>scan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free_scan_desc</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* we can release the scanned Buffers now */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup_pos</name><parameter_list>(<parameter><decl><type><name>BMScanPosition</name></type> <name>pos</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>pos</name><operator>-&gt;</operator><name>nvec</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	
	<comment type="block">/*
	 * Only cleanup bm_batchWords if we have more than one vector since
	 * _bitmap_cleanup_scanpos() will clean it up for the single vector
	 * case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pos</name><operator>-&gt;</operator><name>nvec</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>_bitmap_cleanup_batchwords</name><argument_list>(<argument><expr><name><name>pos</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pos</name><operator>-&gt;</operator><name>bm_batchWords</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pos</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>_bitmap_cleanup_scanpos</name><argument_list>(<argument><expr><name><name>pos</name><operator>-&gt;</operator><name>posvecs</name></name></expr></argument>, <argument><expr><name><name>pos</name><operator>-&gt;</operator><name>nvec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pull the next block of tids from a bitmap stream
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type> 
<name>pull_stream</name><parameter_list>(<parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>			<name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 			<name>newentry</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMScanPosition</name></type>	<name>scanPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type>	<name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMStreamOpaque</name> <modifier>*</modifier></type><name>so</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* empty bitmap vector */</comment>
	<if_stmt><if>if<condition>(<expr><name>so</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>entry</name></name></expr>;</expr_stmt>

	<comment type="block">/* have we already got an entry? */</comment>
	<if_stmt><if>if<condition>(<expr><name>next</name> <operator>&amp;&amp;</operator> <name><name>iterator</name><operator>-&gt;</operator><name>nextblock</name></name> <operator>&lt;=</operator> <name><name>next</name><operator>-&gt;</operator><name>blockno</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>is_done</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Just free opaque state early so that we could short circuit. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>opaque</name></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>stream_free</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>opaque</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>scan</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scanPos</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BMScanOpaque</name><operator>)</operator><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name><operator>)</operator><operator>-&gt;</operator><name>bm_currPos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name><name>iterator</name><operator>-&gt;</operator><name>nextblock</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>is_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<while>while<condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><name>scanPos</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>_bitmap_nextbatchwords</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<comment type="block">/* we should be initialised! */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"scan position uninitialized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>words_get_match</name><argument_list>(<argument><expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>scanPos</name><operator>-&gt;</operator><name>bm_result</name></name><operator>)</operator></expr></argument>,
							   <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>nextblock</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>newentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Are there any more words available from the index itself? */</comment>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><name>res</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>is_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We didn't have enough words to match the whole page, so
				 * tell words_get_match() to continue looking at the page
				 * it finished at
				 */</comment>
				<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>nextblock</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>blockno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>newentry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Set the next block number. We want to skip those blocks that do not
	 * contain possible query results, since in AO index cases, this range
	 * can be very large.
	 */</comment>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>nextblock</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>blockno</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_result</name><operator>.</operator><name>nextTid</name></name> <operator>/</operator> <name>BM_MAX_TUPLES_PER_PAGE</name> <operator>&gt;</operator> <name><name>e</name><operator>-&gt;</operator><name>blockno</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>nextblock</name></name> <operator>=</operator> <name><name>scanPos</name><operator>-&gt;</operator><name>bm_result</name><operator>.</operator><name>nextTid</name></name> <operator>/</operator> <name>BM_MAX_TUPLES_PER_PAGE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>entry</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <operator>(</operator><name>PagetableEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make a copy of an index scan descriptor as well as useful fields in
 * the opaque structure
 */</comment>

<function><type><specifier>static</specifier> <name>IndexScanDesc</name></type>
<name>copy_scan_desc</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMScanOpaque</name></type> <name>so</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMScanPosition</name></type> <name>sp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMScanPosition</name></type> <name>spcopy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMVector</name></type> <name>bsp</name></decl>;</decl_stmt>

	<comment type="block">/* we only need a few fields */</comment>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>IndexScanDesc</name><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMScanOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>indexRelation</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>so</name> <operator>=</operator> <operator>(</operator><name>BMScanOpaque</name><operator>)</operator><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>sp</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>vec</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>spcopy</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMScanPositionData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>spcopy</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>done</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>spcopy</name><operator>-&gt;</operator><name>nvec</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>nvec</name></name></expr>;</expr_stmt>

		<comment type="block">/* now the batch words */</comment>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>BMBatchWords</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMBatchWords</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>hwords</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> 
					<call><name>BM_CALC_H_WORDS</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>bm_batchWords</name><operator>-&gt;</operator><name>maxNumOfWords</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>cwords</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> 
					<name><name>sp</name><operator>-&gt;</operator><name>bm_batchWords</name><operator>-&gt;</operator><name>maxNumOfWords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_bitmap_copy_batchwords</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>spcopy</name><operator>-&gt;</operator><name>bm_batchWords</name></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spcopy</name><operator>-&gt;</operator><name>bm_result</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sp</name><operator>-&gt;</operator><name>bm_result</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMIterateResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>bsp</name> <operator>=</operator> <operator>(</operator><name>BMVector</name><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMVectorData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>sp</name><operator>-&gt;</operator><name>nvec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>spcopy</name><operator>-&gt;</operator><name>posvecs</name></name> <operator>=</operator> <name>bsp</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>nvec</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>bsp</name><operator>-&gt;</operator><name>bm_lovBuffer</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>posvecs</name><operator>-&gt;</operator><name>bm_lovBuffer</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bsp</name><operator>-&gt;</operator><name>bm_lovOffset</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>posvecs</name><operator>-&gt;</operator><name>bm_lovOffset</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bsp</name><operator>-&gt;</operator><name>bm_nextBlockNo</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>posvecs</name><operator>-&gt;</operator><name>bm_nextBlockNo</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bsp</name><operator>-&gt;</operator><name>bm_readLastWords</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>posvecs</name><operator>-&gt;</operator><name>bm_readLastWords</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bsp</name><operator>-&gt;</operator><name>bm_batchWords</name></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<for>for <control>(<init><expr><name>vec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>vec</name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>nvec</name></name></expr>;</condition> <incr><expr><name>vec</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BMVector</name></type> <name>bmScanPos</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>bsp</name><index>[<expr><name>vec</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BMVector</name></type> <name>spp</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>posvecs</name><index>[<expr><name>vec</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_lovBuffer</name></name> <operator>=</operator> <name><name>spp</name><operator>-&gt;</operator><name>bm_lovBuffer</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_lovOffset</name></name> <operator>=</operator> <name><name>spp</name><operator>-&gt;</operator><name>bm_lovOffset</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_nextBlockNo</name></name> <operator>=</operator> <name><name>spp</name><operator>-&gt;</operator><name>bm_nextBlockNo</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_readLastWords</name></name> <operator>=</operator> <name><name>spp</name><operator>-&gt;</operator><name>bm_readLastWords</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name> <operator>=</operator> 
					<operator>(</operator><name>BMBatchWords</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMBatchWords</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>_bitmap_init_batchwords</name><argument_list>(<argument><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>,
									<argument><expr><name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name></expr></argument>,
									<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>_bitmap_copy_batchwords</name><argument_list>(<argument><expr><name><name>spp</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>,
									<argument><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>spcopy</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>BMScanOpaque</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>opaque</name></name><operator>)</operator><operator>-&gt;</operator><name>bm_currPos</name> <operator>=</operator> <name>spcopy</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>BMScanOpaque</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>opaque</name></name><operator>)</operator><operator>-&gt;</operator><name>bm_markPos</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a set of bitmap words and our current position, get the next
 * page with matches on it.
 *
 * If newentry is false, we're calling the function with a partially filled
 * page table entry. Otherwise, the entry is empty.
 *
 * This function is only used in stream bitmap scan, more specifically, it's
 * BitmapIndexScan + BitmapHeapScan.
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>words_get_match</name><parameter_list>(<parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>words</name></decl></parameter>, <parameter><decl><type><name>BMIterateResult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
				<parameter><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl></parameter>, <parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>tbm_bitmapword</name></type> <name>newWord</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nhrlwords</name> <init>= <expr><operator>(</operator><name>TBM_BITS_PER_BITMAPWORD</name><operator>/</operator><name>BM_HRL_WORD_SIZE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hrlwordno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>newwordno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * XXX: We assume that BM_HRL_WORD_SIZE is not greater than
	 * TBM_BITS_PER_BITMAPWORD for tidbitmap.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>BM_HRL_WORD_SIZE</name> <operator>&lt;=</operator> <name>TBM_BITS_PER_BITMAPWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nhrlwords</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>restart</name>:</label>
	<comment type="block">/* compute the first and last tid location for 'blockno' */</comment>
	<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator><name>blockno</name><operator>)</operator> <operator>*</operator> <name>BM_MAX_TUPLES_PER_PAGE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator><operator>(</operator><name>blockno</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <name>BM_MAX_TUPLES_PER_PAGE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newwordno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hrlwordno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* If we have read past the requested block, simple return true. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name> <operator>&gt;=</operator> <name><name>words</name><operator>-&gt;</operator><name>maxNumOfWords</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>&lt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
		
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>-</operator> <name>start</name><operator>)</operator> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the next tid we expected to check */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If words-&gt;firstTid &lt; result-&gt;nextTid, we need to catch up the words
	 * firstTid for checking to the next tid(start of current block).
	 * words-&gt;firstTid will keep set as result-&gt;nextTid before each
	 * iteration to mark the scanned tids in _bitmap_nextbatchwords.
	 * Note here that when we read new batchwords from bitmap page, the
	 * words-&gt;firstTid may get set to a tid we already scanned.
	 * See read_words in bitmapsearch.c.
	 *
	 * If the words-&gt;firstTid already pass the result-&gt;nextTid, then
	 * we should scan from the words-&gt;firstTid. Since the new batchwords's
	 * start tid exceeds block's start tid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>&lt;</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bitmap_catchup_to_next_tid</name><argument_list>(<argument><expr><name>words</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>&gt;</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>=</operator> <name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Current words may not contain the expected nextTid, since the
	 * blockno may skiped several blocks if BitmapAdd choose to skip
	 * the blockno that can not be matched.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>&lt;</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the catch up processd all unmatch words that exceed current block's
	 * end. Then restart for a new block.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>&gt;</operator> <name>end</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>blockno</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>/</operator> <name>BM_MAX_TUPLES_PER_PAGE</name></expr>;</expr_stmt>
		<goto>goto <name>restart</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if there are no such a bitmap in the given batch words, then
	 * return false.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the the nextTid is the firstTid, then we exam the leading
	 * 0 fill words. And skip them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>filllen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>word</name> <init>= <expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if<condition>(<expr><name>word</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>filllen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>filllen</name> <operator>=</operator> <call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Check if the fill word would take us past the end of the block
		 * we're currently interested in.
		 */</comment>
		<if_stmt><if>if<condition>(<expr><name>filllen</name> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name> <operator>&gt;</operator> <name>end</name> <operator>-</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>+=</operator> <name>filllen</name> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>blockno</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>/</operator> <name>BM_MAX_TUPLES_PER_PAGE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
			
			<if_stmt><if>if<condition>(<expr><name>newentry</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Mark the scanned tids */</comment>
				<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name></expr>;</expr_stmt>
				<goto>goto <name>restart</name>;</goto>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* copy the bitmap for tuples in the given heap page. */</comment>
	<expr_stmt><expr><name>newWord</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hrlwordno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>-</operator> <name>start</name><operator>)</operator> <operator>/</operator> <name>BM_HRL_WORD_SIZE</name><operator>)</operator> <operator>%</operator> <name>nhrlwords</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newwordno</name> <operator>=</operator> <operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>-</operator> <name>start</name><operator>)</operator> <operator>/</operator> <name>TBM_BITS_PER_BITMAPWORD</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>&lt;</operator> <name>end</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BM_HRL_WORD</name></type> <name>word</name> <init>= <expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_FILL_WORD</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>GET_FILL_BIT</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>newWord</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>tbm_bitmapword</name><operator>)</operator><operator>(</operator><name>LITERAL_ALL_ONE</name><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator>
					<operator>(</operator><name>hrlwordno</name> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
					
			<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>FILL_LENGTH</name><argument_list>(<argument><expr><name><name>words</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>newWord</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>tbm_bitmapword</name><operator>)</operator><name>word</name><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>hrlwordno</name> <operator>*</operator> <name>BM_HRL_WORD_SIZE</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>hrlwordno</name> <operator>=</operator> <operator>(</operator><name>hrlwordno</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>nhrlwords</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>+=</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>hrlwordno</name> <operator>%</operator> <name>nhrlwords</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newwordno</name> <operator>&lt;</operator> <name>WORDS_PER_PAGE</name> <operator>||</operator> <name>newwordno</name> <operator>&lt;</operator> <name>WORDS_PER_CHUNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>newwordno</name></expr>]</index></name> <operator>|=</operator> <name>newWord</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newwordno</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* reset newWord */</comment>
			<expr_stmt><expr><name>newWord</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>hrlwordno</name> <operator>%</operator> <name>nhrlwords</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newwordno</name> <operator>&lt;</operator> <name>WORDS_PER_PAGE</name> <operator>||</operator> <name>newwordno</name> <operator>&lt;</operator> <name>WORDS_PER_CHUNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>newwordno</name></expr>]</index></name> <operator>|=</operator> <name>newWord</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name>blockno</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>-&gt;</operator><name>nwords</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>lastScanWordNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>nextTid</name></name> <operator>&lt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetBitmapIndexAuxOids - Given an open index, fetch and return the oids for
 * the bitmap subobjects (pg_bm_xxxx + pg_bm_xxxx_index).
 *
 * Note: Currently this information is not stored directly in the catalog, but
 * is hidden away inside the metadata page of the index.  Future versions should
 * move this information into the catalog.
 */</comment>
<function><type><name>void</name></type> 
<name>GetBitmapIndexAuxOids</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>heapId</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>indexId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>     <name>metabuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMMetaPage</name></type> <name>metapage</name></decl>;</decl_stmt>
	

	<comment type="block">/* Only Bitmap Indexes have bitmap related sub-objects */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsBitmapIndex</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>heapId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>indexId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>BM_METAPAGE</name></expr></argument>, <argument><expr><name>BM_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>_bitmap_get_metapage_data</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>heapId</name>  <operator>=</operator> <name><name>metapage</name><operator>-&gt;</operator><name>bm_lov_heapId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexId</name> <operator>=</operator> <name><name>metapage</name><operator>-&gt;</operator><name>bm_lov_indexId</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>bmoptions</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>default_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>validate</name></expr></argument>, <argument><expr><name>RELOPT_KIND_BITMAP</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ask appropriate access method to validate the specified opclass.
 */</comment>
<function><type><name>bool</name></type>
<name>bmvalidate</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclassoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Bitmap indexes use the same opclass support functions and strategies
	 * as B-tree indexes. In fact, we use a real B-tree index for the LOV
	 * tree. So borrow B-tree's validate function.
	 */</comment>
	<return>return <expr><call><name>btree_or_bitmap_validate</name><argument_list>(<argument><expr><name>opclassoid</name></expr></argument>, <argument><expr><literal type="string">"bitmap"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
