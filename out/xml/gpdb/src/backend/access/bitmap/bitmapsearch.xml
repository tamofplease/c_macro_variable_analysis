<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/bitmap/bitmapsearch.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * bitmapsearch.c
 *	  Search routines for on-disk bitmap index access method.
 *
 * Portions Copyright (c) 2007-2010 Greenplum Inc
 * Portions Copyright (c) 2010-2012 EMC Corporation
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Porions Copyright (c) 2006-2008, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/bitmap/bitmapsearch.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct <name>ItemPos</name>
<block>{
	<decl_stmt><decl><type><name>BlockNumber</name></type>		<name>blockNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type>	<name>offset</name></decl>;</decl_stmt>
}</block></struct></type> <name>ItemPos</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>next_batch_words</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>read_words</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>,
					   <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>lockLovBuffer</name></decl></parameter>,
					   <parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>bachWords</name></decl></parameter> <comment type="block">/* out */</comment>,
					   <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>nextBlockNoP</name></decl></parameter> <comment type="block">/* out */</comment>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>readLastWords</name></decl></parameter> <comment type="block">/* out */</comment>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_scanpos</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>BMVector</name></type> <name>bmScanPos</name></decl></parameter>,
					 <parameter><decl><type><name>BlockNumber</name></type> <name>lovBlock</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * _bitmap_first() -- find the first tuple that satisfies a given scan.
 */</comment>
<function><type><name>bool</name></type>
<name>_bitmap_first</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMScanOpaque</name></type> <name>so</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMScanPosition</name></type> <name>scanpos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>_bitmap_findbitmaps</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>so</name> <operator>=</operator> <operator>(</operator><name>BMScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scanpos</name> <operator>=</operator> <operator>(</operator><name>BMScanPosition</name><operator>)</operator> <name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>scanpos</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Bitmap indexes don't currently support Index Only Scans.
	 * It would be pretty straightforward to return the index tuples from the
	 * LOV index, but we haven't implemented it.
	 *
	 * However, even though the 'amcanreturn' function is not implemented,
	 * the planner still chooses an Index Only Scan for some queries where
	 * no attribute from the index are needed. Be prepared for that, by
	 * filling xs_itup with a dummy IndexTuple with all NULL values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_itup</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>idesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>nulldatums</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnulls</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nulldatums</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnulls</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>idesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulldatums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isnulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_itup</name></name> <operator>=</operator> <call><name>index_form_tuple</name><argument_list>(<argument><expr><name>idesc</name></expr></argument>, <argument><expr><name>nulldatums</name></expr></argument>, <argument><expr><name>isnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulldatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>isnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>_bitmap_next</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_next() -- return the next tuple that satisfies a given scan.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>
<name>_bitmap_next</name><argument_list>(<argument><expr><name>IndexScanDesc</name> <name>scan</name></expr></argument>, <argument><expr><name>ScanDirection</name> <name>dir</name>  <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMScanOpaque</name></type>	<name>so</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMScanPosition</name></type>	<name>scanPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>			<name>nextTid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>so</name> <operator>=</operator> <operator>(</operator><name>BMScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scanPos</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scanPos</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * If there are no more words left from the previous scan, we
		 * try to compute the next batch of words.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>scanPos</name><operator>-&gt;</operator><name>bm_result</name><operator>.</operator><name>nextTidLoc</name></name> <operator>&gt;=</operator> <name><name>scanPos</name><operator>-&gt;</operator><name>bm_result</name><operator>.</operator><name>numOfTids</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_bitmap_reset_batchwords</name><argument_list>(<argument><expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_batchWords</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>=</operator> <name><name>scanPos</name><operator>-&gt;</operator><name>bm_result</name><operator>.</operator><name>nextTid</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"IndexScan next batch words start Tid: "</literal> <name>INT64_FORMAT</name></expr></argument>,
				 <argument><expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_batchWords</name><operator>-&gt;</operator><name>firstTid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>next_batch_words</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>_bitmap_begin_iterate</name><argument_list>(<argument><expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>scanPos</name><operator>-&gt;</operator><name>bm_result</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If we can not find more words, then this scan is over. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scanPos</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>nextTid</name> <operator>=</operator> <call><name>_bitmap_findnexttid</name><argument_list>(<argument><expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>scanPos</name><operator>-&gt;</operator><name>bm_result</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nextTid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>nextTid</name> <operator>%</operator> <name>BM_MAX_TUPLES_PER_PAGE</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_heaptid</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>BM_INT_GET_BLOCKNO</name><argument_list>(<argument><expr><name>nextTid</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>BM_INT_GET_OFFSET</name><argument_list>(<argument><expr><name>nextTid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>cur_pos_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * _bitmap_firstbatchwords() -- find the first batch of bitmap words
 *  in a bitmap vector for a given scan.
 */</comment>
<function><type><name>bool</name></type>
<name>_bitmap_firstbatchwords</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>,
						<parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_bitmap_findbitmaps</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>_bitmap_nextbatchwords</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_nextbatchwords() -- find the next batch of bitmap words
 *  in a bitmap vector for a given scan.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>
<name>_bitmap_nextbatchwords</name><argument_list>(<argument><expr><name>IndexScanDesc</name> <name>scan</name></expr></argument>,
					   <argument><expr><name>ScanDirection</name> <name>dir</name>  <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMScanOpaque</name></type>	<name>so</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>so</name> <operator>=</operator> <operator>(</operator><name>BMScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr>;</expr_stmt>

	<comment type="block">/* check if this scan if over */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set firstTid to retrun for the remain batch words. tid &lt; nextTid should
	 * already scanned. So move firstTid to nextTid.
	 * The firstTid may get updated when read new batch words if there only one
	 * bitmap vector matched, see read_words.
	 */</comment>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>bm_batchWords</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>bm_result</name><operator>.</operator><name>nextTid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"BitmapIndexScan next batch words start Tid: "</literal> <name>INT64_FORMAT</name></expr></argument>,
		 <argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>bm_batchWords</name><operator>-&gt;</operator><name>firstTid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are some leftover words from the previous scan, simply
	 * return them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>bm_batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute the next list of batch words. Before that,
	 * reset the previous list of batch words, especially the
	 * content and header bitmap words.
	 */</comment>
	<expr_stmt><expr><call><name>_bitmap_reset_batchwords</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>next_batch_words</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * next_batch_words() -- compute the next batch of bitmap words
 * 	from a given scan position.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>next_batch_words</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMScanPosition</name></type>			<name>scanPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMVector</name></type>	<name>bmScanPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMBatchWords</name>		  <modifier>*</modifier><modifier>*</modifier></type><name>batches</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>numBatches</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>scanPos</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BMScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name><operator>)</operator><operator>-&gt;</operator><name>bm_currPos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bmScanPos</name> <operator>=</operator> <name><name>scanPos</name><operator>-&gt;</operator><name>posvecs</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we read a new batch of words, we need to reset 
	 * lastScanWordNo in result words. Otherwise, we may miss
	 * some words in this new batch.
	 */</comment>
	<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_result</name><operator>.</operator><name>lastScanWordNo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>batches</name> <operator>=</operator> <operator>(</operator><name>BMBatchWords</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><name><name>scanPos</name><operator>-&gt;</operator><name>nvec</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BMBatchWords</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numBatches</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/*
	 * Obtains the next batch of words for each bitmap vector.
	 * Ignores those bitmap vectors that contain no new words.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>scanPos</name><operator>-&gt;</operator><name>nvec</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BMBatchWords</name>	<modifier>*</modifier></type><name>batchWords</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>batchWords</name> <operator>=</operator> <name><name>bmScanPos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bm_batchWords</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there are no words left from previous scan, read the next
		 * batch of words.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>bmScanPos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>bm_batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bm_readLastWords</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>

			<expr_stmt><expr><call><name>_bitmap_reset_batchwords</name><argument_list>(<argument><expr><name>batchWords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>read_words</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>,
					   <argument><expr><name><name>bmScanPos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bm_lovBuffer</name></expr></argument>,
					   <argument><expr><name><name>bmScanPos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bm_lovOffset</name></expr></argument>,
					   <argument><expr><name>true</name></expr></argument> <comment type="block">/* lockLocBuffer */</comment>,
					   <argument><expr><name>batchWords</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bm_nextBlockNo</name><operator>)</operator></expr></argument>,
					   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>bmScanPos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bm_readLastWords</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>bmScanPos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>bm_batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>batches</name><index>[<expr><name>numBatches</name></expr>]</index></name> <operator>=</operator> <name>batchWords</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>numBatches</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We handle the case where only one bitmap vector contributes to
	 * the scan separately with other cases. This is because 
	 * bmScanPos-&gt;bm_batchWords and scanPos-&gt;bm_batchWords
	 * are the same.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scanPos</name><operator>-&gt;</operator><name>nvec</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>batches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name> <operator>=</operator> <name><name>scanPos</name><operator>-&gt;</operator><name>posvecs</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * At least two bitmap vectors contribute to this scan, we
	 * ORed these bitmap vectors.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numBatches</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>batches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>_bitmap_union</name><argument_list>(<argument><expr><name>batches</name></expr></argument>, <argument><expr><name>numBatches</name></expr></argument>, <argument><expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>batches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * read_words() -- read one-block of bitmap words from
 *	the bitmap page.
 *
 * If nextBlockNo is an invalid block number, then the two last words
 * are stored in lovItem. Otherwise, read words from nextBlockNo.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>read_words</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lovBuffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>lockLovBuffer</name></decl></parameter>, <parameter><decl><type><name>BMBatchWords</name> <modifier>*</modifier></type><name>batchWords</name></decl></parameter> <comment type="block">/* out */</comment>,
		   <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>nextBlockNoP</name></decl></parameter> <comment type="block">/* out */</comment>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>readLastWords</name></decl></parameter> <comment type="block">/* out */</comment>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>nextBlockNoP</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>			<name>bitmapBuffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>			<name>bitmapPage</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BMBitmap</name></type>		<name>bitmap</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BMBitmapOpaque</name></type>	<name>bo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>			<name>totalTidsInPage</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>			<name>readLOV</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>lockLovBuffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>BM_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>bitmapBuffer</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>*</operator><name>nextBlockNoP</name></expr></argument>, <argument><expr><name>BM_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bitmapPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <operator>(</operator><name>BMBitmap</name><operator>)</operator> <call><name>PageGetContentsMaxAligned</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bo</name> <operator>=</operator> <operator>(</operator><name>BMBitmapOpaque</name><operator>)</operator><call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>bitmapPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>nextBlockNoP</name> <operator>=</operator> <name><name>bo</name><operator>-&gt;</operator><name>bm_bitmap_next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>=</operator> <name><name>bo</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this is the last bitmap page and the total number of words
		 * in this page is less than or equal to
		 * BM_NUM_OF_HRL_WORDS_PER_PAGE - 2, we read the last two words from LOV
		 * and append them into 'batchWords-&gt;hwords' and 'batchWords-&gt;cwords'.
		 * This requires hold lock on the lovBuffer to avoid concurrent changes
		 * on it. Otherwise, release the lock ASAP.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>nextBlockNoP</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>&lt;=</operator> <name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>readLOV</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>lockLovBuffer</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Get real next tid and nwordsread in uncompressed order for a
		 * bitmap index scan on a bitmap page.
		 * If current bitmap page get rearranged words from previous page
		 * after release the previous bitmap page and before acquire lock
		 * on it for read. The expected next tid for current bitmap scan
		 * will not equal to the current page's start tid. So set to correct
		 * value.
		 * The rearrange happens when doing insert on the table and it will
		 * update a full bitmap pages(except the last page) and generate
		 * new words.
		 * Since the page is full, so it'll rearrange the words and move
		 * the unfit words to next bitmap page.
		 * This related to issue: https://github.com/greenplum-db/gpdb/issues/11308.
		 */</comment>
		<expr_stmt><expr><name>totalTidsInPage</name> <operator>=</operator> <call><name>GET_NUM_BITS</name><argument_list>(<argument><expr><name><name>bitmap</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>, <argument><expr><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>,
									   <argument><expr><name><name>bo</name><operator>-&gt;</operator><name>bm_hrl_words_used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>batchWords</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>=</operator> <name><name>bo</name><operator>-&gt;</operator><name>bm_last_tid_location</name></name> <operator>-</operator> <name>totalTidsInPage</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>batchWords</name><operator>-&gt;</operator><name>nwordsread</name></name> <operator>=</operator> <name><name>batchWords</name><operator>-&gt;</operator><name>firstTid</name></name> <operator>/</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>batchWords</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>, <argument><expr><name><name>bitmap</name><operator>-&gt;</operator><name>hwords</name></name></expr></argument>,
			   <argument><expr><name>BM_NUM_OF_HEADER_WORDS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>batchWords</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>, <argument><expr><name><name>bitmap</name><operator>-&gt;</operator><name>cwords</name></name></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>batchWords</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>bitmapBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"after_read_one_bitmap_idx_page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>readLastWords</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readLOV</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BMBatchWords</name></type>	<name>tempBWord</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BM_HRL_WORD</name></type>		<name><name>cwords</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BM_HRL_WORD</name></type>		<name>hword</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BM_HRL_WORD</name></type>		<name>tmp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>				<name>offs</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tempBWord</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMBatchWords</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tempBWord</name><operator>.</operator><name>cwords</name></name> <operator>=</operator> <name>cwords</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tempBWord</name><operator>.</operator><name>hwords</name></name> <operator>=</operator> <operator>&amp;</operator><name>hword</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>read_words</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* lockLovBuffer */</comment>,
					   <argument><expr><operator>&amp;</operator><name>tempBWord</name></expr></argument>, <argument><expr><name>nextBlockNoP</name></expr></argument>, <argument><expr><name>readLastWords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tempBWord</name><operator>.</operator><name>nwords</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>tempBWord</name><operator>.</operator><name>nwords</name></name> <operator>&lt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="line">// release lock on lovBuffer once we read words from it.</comment>
			<if_stmt><if>if <condition>(<expr><name>lockLovBuffer</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>batchWords</name><operator>-&gt;</operator><name>cwords</name></name> <operator>+</operator> <name><name>batchWords</name><operator>-&gt;</operator><name>nwords</name></name></expr></argument>, <argument><expr><name>cwords</name></expr></argument>,
				   <argument><expr><name><name>tempBWord</name><operator>.</operator><name>nwords</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BM_HRL_WORD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>offs</name> <operator>=</operator> <name><name>batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>/</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>hword</name> <operator>&gt;&gt;</operator> <name><name>batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>batchWords</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><name>offs</name></expr>]</index></name> <operator>|=</operator> <name>tmp</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>%</operator> <name>BM_HRL_WORD_SIZE</name> <operator>==</operator> <name>BM_HRL_WORD_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>offs</name> <operator>=</operator> <operator>(</operator><name><name>batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><name>BM_HRL_WORD_SIZE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>batchWords</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><name>offs</name></expr>]</index></name> <operator>|=</operator> <name>hword</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>+=</operator> <name><name>tempBWord</name><operator>.</operator><name>nwords</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>BMLOVItem</name></type>	<name>lovItem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>lovPage</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>lockLovBuffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>BM_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>lovPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lovItem</name> <operator>=</operator> <operator>(</operator><name>BMLOVItem</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, 
										  <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, <argument><expr><name>lovOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name> <operator>!=</operator> <name>LITERAL_ALL_ONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>batchWords</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><name><name>lovItem</name><operator>-&gt;</operator><name>lov_words_header</name></name><operator>)</operator> <operator>&lt;&lt;</operator>
							  <operator>(</operator><name>BM_HRL_WORD_SIZE</name><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>batchWords</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_compword</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>batchWords</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_word</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>batchWords</name><operator>-&gt;</operator><name>nwords</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>batchWords</name><operator>-&gt;</operator><name>hwords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>BM_HRL_WORD</name><operator>)</operator><name><name>lovItem</name><operator>-&gt;</operator><name>lov_words_header</name></name><operator>)</operator> <operator>&lt;&lt;</operator>
									<operator>(</operator><name>BM_HRL_WORD_SIZE</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>batchWords</name><operator>-&gt;</operator><name>cwords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_last_word</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>lockLovBuffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>lovBuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>readLastWords</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bitmap_findbitmaps() -- find the bitmap vectors that satisfy the
 * index predicate.
 */</comment>
<decl_stmt><decl><type><name>void</name></type>
<name>_bitmap_findbitmaps</name><argument_list>(<argument><expr><name>IndexScanDesc</name> <name>scan</name></expr></argument>, <argument><expr><name>ScanDirection</name> <name>dir</name>  <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BMScanOpaque</name></type>			<name>so</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMScanPosition</name></type>			<name>scanPos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>					<name>metabuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMMetaPage</name></type>				<name>metapage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type>				<name>lovBlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type>			<name>lovOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>					<name>blockNull</name></decl>, <decl><type ref="prev"/><name>offsetNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>vectorNo</name></decl>, <decl><type ref="prev"/><name>keyNo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>so</name> <operator>=</operator> <operator>(</operator><name>BMScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr>;</expr_stmt>

	<comment type="block">/* allocate space and initialize values for so-&gt;bm_currPos */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name> <operator>=</operator> <operator>(</operator><name>BMScanPosition</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMScanPositionData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>scanPos</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>bm_currPos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>nvec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanPos</name><operator>-&gt;</operator><name>bm_result</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMIterateResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The tid to return always start from 1 which is the first tid of
	 * first uncompressed word.
	 */</comment>
	<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_result</name><operator>.</operator><name>nextTid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>keyNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyNo</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr>;</condition> <incr><expr><name>keyNo</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>keyNo</name></expr>]</index></name><operator>.</operator><name>sk_flags</name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Null key passed to bitmap index scan. Return empty result */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scanPos</name><operator>-&gt;</operator><name>nvec</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>BM_METAPAGE</name></expr></argument>, <argument><expr><name>BM_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>_bitmap_get_metapage_data</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>		<name>lovHeap</name></decl>, <decl><type ref="prev"/><name>lovIndex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKey</name></type>			<name>scanKeys</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexScanDesc</name></type>	<name>scanDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name><modifier>*</modifier></type>			<name>lovItemPoss</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>		<modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We haven't locked the metapage but that's okay... if these
		 * values change underneath us there's something much more
		 * fundamentally wrong. This could change when we have VACUUM
		 * support, of course.
		 */</comment>
		<expr_stmt><expr><call><name>_bitmap_open_lov_heapandindex</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>metapage</name></expr></argument>, 
				 <argument><expr><operator>&amp;</operator><name>lovHeap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovIndex</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>scanKeys</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>keyNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyNo</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr>;</condition> <incr><expr><name>keyNo</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ScanKey</name></type>	<name>scanKey</name> <init>= <expr><operator>(</operator><name>ScanKey</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>scanKeys</name><operator>)</operator> <operator>+</operator> 
										 <name>keyNo</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><name>scanKey</name></expr></argument>,
								   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>keyNo</name></expr>]</index></name><operator>.</operator><name>sk_flags</name></expr></argument>,
								   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>keyNo</name></expr>]</index></name><operator>.</operator><name>sk_attno</name></expr></argument>,
								   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>keyNo</name></expr>]</index></name><operator>.</operator><name>sk_strategy</name></expr></argument>,
								   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>keyNo</name></expr>]</index></name><operator>.</operator><name>sk_subtype</name></expr></argument>,
								   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>keyNo</name></expr>]</index></name><operator>.</operator><name>sk_collation</name></expr></argument>,
								   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>keyNo</name></expr>]</index></name><operator>.</operator><name><name>sk_func</name><operator>.</operator><name>fn_oid</name></name></expr></argument>,
								   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>keyNo</name></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* When there are no scan keys, all bitmap vectors are included,
		 * including the one for the NULL value.
		 * This can happen when the index is created with predicates.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemPos</name> <modifier>*</modifier></type><name>itemPos</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>itemPos</name> <operator>=</operator> <operator>(</operator><name>ItemPos</name><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>itemPos</name><operator>-&gt;</operator><name>blockNo</name></name> <operator>=</operator> <name>BM_LOV_STARTPAGE</name></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
			<expr_stmt><expr><name><name>itemPos</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>lovItemPoss</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lovItemPoss</name></expr></argument>, <argument><expr><name>itemPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>nvec</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>scanDesc</name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name>lovHeap</name></expr></argument>, <argument><expr><name>lovIndex</name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>,
								   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>, <argument><expr><name>scanKeys</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * finds all lov items for this scan through lovHeap and lovIndex.
		 */</comment>
		<while>while <condition>(<expr><name>true</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemPos</name>			<modifier>*</modifier></type><name>itemPos</name></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><call><name>_bitmap_findvalue</name><argument_list>(<argument><expr><name>lovHeap</name></expr></argument>, <argument><expr><name>lovIndex</name></expr></argument>, <argument><expr><name>scanKeys</name></expr></argument>, <argument><expr><name>scanDesc</name></expr></argument>,
							  	         <argument><expr><operator>&amp;</operator><name>lovBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blockNull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lovOffset</name></expr></argument>, 
										 <argument><expr><operator>&amp;</operator><name>offsetNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if<condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We find the position for one LOV item. Append it into
			 * the list.
			 */</comment>
			<expr_stmt><expr><name>itemPos</name> <operator>=</operator> <operator>(</operator><name>ItemPos</name><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>itemPos</name><operator>-&gt;</operator><name>blockNo</name></name> <operator>=</operator> <name>lovBlock</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>itemPos</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>lovOffset</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lovItemPoss</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lovItemPoss</name></expr></argument>, <argument><expr><name>itemPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>nvec</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name><name>scanPos</name><operator>-&gt;</operator><name>nvec</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>posvecs</name></name> <operator>=</operator>
				<operator>(</operator><name>BMVector</name><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMVectorData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>scanPos</name><operator>-&gt;</operator><name>nvec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>vectorNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>lovItemPoss</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemPos</name>		<modifier>*</modifier></type><name>itemPos</name> <init>= <expr><operator>(</operator><name>ItemPos</name><operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>BMVector</name></type> <name>bmScanPos</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>scanPos</name><operator>-&gt;</operator><name>posvecs</name><index>[<expr><name>vectorNo</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>init_scanpos</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>bmScanPos</name></expr></argument>, <argument><expr><name><name>itemPos</name><operator>-&gt;</operator><name>blockNo</name></name></expr></argument>, <argument><expr><name><name>itemPos</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>vectorNo</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>lovItemPoss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bitmap_close_lov_heapandindex</name><argument_list>(<argument><expr><name>lovHeap</name></expr></argument>, <argument><expr><name>lovIndex</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scanKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>_bitmap_relbuf</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scanPos</name><operator>-&gt;</operator><name>nvec</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since there is only one related bitmap vector, we have
	 * the scan position's batch words structure point directly to
	 * the vector's batch words.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scanPos</name><operator>-&gt;</operator><name>nvec</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name> <operator>=</operator> <name><name>scanPos</name><operator>-&gt;</operator><name>posvecs</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name> <operator>=</operator> <operator>(</operator><name>BMBatchWords</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMBatchWords</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bitmap_init_batchwords</name><argument_list>(<argument><expr><name><name>scanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>,
								<argument><expr><name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name></expr></argument>,
								<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	</block_content>}</block></else></if_stmt>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * init_scanpos() -- initialize a BMScanPosition for a given
 *	bitmap vector.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_scanpos</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>BMVector</name></type> <name>bmScanPos</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>lovBlock</name></decl></parameter>,
			 <parameter><decl><type><name>OffsetNumber</name></type> <name>lovOffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type> 					<name>lovPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BMLOVItem</name></type>				<name>lovItem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_lovOffset</name></name> <operator>=</operator> <name>lovOffset</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_lovBuffer</name></name> <operator>=</operator> <call><name>_bitmap_getbuf</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>lovBlock</name></expr></argument>, 
										     <argument><expr><name>BM_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lovPage</name>	<operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_lovBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lovItem</name> <operator>=</operator> <operator>(</operator><name>BMLOVItem</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, 
					<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>lovPage</name></expr></argument>, <argument><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_lovOffset</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
	<expr_stmt><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_nextBlockNo</name></name> <operator>=</operator> <name><name>lovItem</name><operator>-&gt;</operator><name>bm_lov_head</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_readLastWords</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name> <operator>=</operator> <operator>(</operator><name>BMBatchWords</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BMBatchWords</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bitmap_init_batchwords</name><argument_list>(<argument><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_batchWords</name></name></expr></argument>,
							<argument><expr><name>BM_NUM_OF_HRL_WORDS_PER_PAGE</name></expr></argument>,
							<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>bmScanPos</name><operator>-&gt;</operator><name>bm_lovBuffer</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
