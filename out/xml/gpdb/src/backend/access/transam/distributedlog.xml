<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/transam/distributedlog.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * distributedlog.c
 *     A GP parallel log to the Postgres clog that records the full distributed
 * xid information for each local transaction id.
 *
 * It is used to determine if the committed xid for a transaction we want to
 * determine the visibility of is for a distributed transaction or a
 * local transaction.
 *
 * By default, entries in the SLRU (Simple LRU) module used to implement this
 * log will be set to zero.  A non-zero entry indicates a committed distributed
 * transaction.
 *
 * We must persist this log and the DTM does reuse the DistributedTransactionId
 * between restarts, so we will be storing the upper half of the whole
 * distributed transaction identifier -- the timestamp -- also so we can
 * be sure which distributed transaction we are looking at.
 *
 * Portions Copyright (c) 2007-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/access/transam/distributedlog.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/distributedlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/slru.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-be.h"</cpp:file></cpp:include> <comment type="block">/* struct Port */</comment>

<comment type="block">/* We need 8 bytes per xact */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTRIES_PER_PAGE</name></cpp:macro> <cpp:value>(BLCKSZ / sizeof(DistributedLogEntry))</cpp:value></cpp:define>

<comment type="block">/*
 * XXX: This should match the value in slru.c. It's only used to decide when
 * to try truncating the log, so it's not critical, but if it doesn't match,
 * we'll try to truncate the log more often than necessary, or won't truncate
 * it as often as we could.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLRU_PAGES_PER_SEGMENT</name></cpp:macro>	<cpp:value>32</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TransactionIdToPage</name><parameter_list>(<parameter><type><name>localXid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((localXid) / (TransactionId) ENTRIES_PER_PAGE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TransactionIdToEntry</name><parameter_list>(<parameter><type><name>localXid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((localXid) % (TransactionId) ENTRIES_PER_PAGE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TransactionIdToSegment</name><parameter_list>(<parameter><type><name>localXid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((localXid) / (ENTRIES_PER_PAGE * SLRU_PAGES_PER_SEGMENT))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>AdvanceTransactionIdToNextPage</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Advance to next page. */</comment>
	<expr_stmt><expr><name>xid</name> <operator>+=</operator> <name>ENTRIES_PER_PAGE</name></expr>;</expr_stmt>

	<comment type="block">/* Retreat to beginning of the page */</comment>
	<expr_stmt><expr><name>xid</name> <operator>-=</operator> <operator>(</operator><name>xid</name> <operator>%</operator> <name>ENTRIES_PER_PAGE</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Skip over the special XIDs */</comment>
	<while>while <condition>(<expr><name>xid</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xid</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<return>return <expr><name>xid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Link to shared-memory data structures for DistributedLog control
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SlruCtlData</name></type> <name>DistributedLogCtlData</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DistributedLogCtl</name></cpp:macro> <cpp:value>(&amp;DistributedLogCtlData)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>DistributedLogShmem</name>
<block>{
	<comment type="block">/*
	 * Oldest local XID that is still visible to some distributed snapshot.
	 *
	 * This is initialized by DistributedLog_InitOldestXmin() after
	 * postmaster startup, and advanced whenever we receive a new
	 * distributed snapshot from the QD (or in the QD itself, whenever
	 * we compute a new snapshot).
	 */</comment>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>TransactionId</name></type>	<name>oldestXmin</name></decl>;</decl_stmt>

}</block></struct></type> <name>DistributedLogShmem</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>DistributedLogShmem</name> <modifier>*</modifier></type><name>DistributedLogShared</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>DistributedLog_ZeroPage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>writeXlog</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DistributedLog_PagePrecedes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>page2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DistributedLog_WriteZeroPageXlogRec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DistributedLog_WriteTruncateXlogRec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DistributedLog_Truncate</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>oldestXmin</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Initialize the value for oldest local XID that might still be visible
 * to a distributed snapshot.
 *
 * This gets called once, after postmaster startup. We scan the
 * distributed log, starting from the smallest datfrozenxid, until
 * we find a page that exists.
 *
 * The caller is expected to hold DistributedLogControlLock on entry.
 */</comment>
<function><type><name>void</name></type>
<name>DistributedLog_InitOldestXmin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestXmin</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestXid</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedXid</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Start scanning from oldest datfrozenxid, until we find a
	 * valid page.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>page</name> <init>= <expr><call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SimpleLruDoesPhysicalPageExist</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found the beginning of valid distributedlog */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Advance to the first XID on the next page */</comment>
		<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>AdvanceTransactionIdToNextPage</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* but don't go past oldestLocalXmin */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oldestXmin</name> <operator>=</operator> <name>latestXid</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>oldestXmin</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>DistributedLogShared</name><operator>-&gt;</operator><name>oldestXmin</name></name></expr></argument>, <argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Advance the "oldest xmin" among distributed snapshots.
 *
 * We track an "oldest xmin" value, which is the oldest XID that is still
 * considered visible by any distributed snapshot in the cluster. The
 * value is a local TransactionId, not a DistributedTransactionId. But
 * it takes into account any snapshots that might still be active in the
 * QD node, even if there are no processes belonging to that distributed
 * transaction running in this segment at the moment.
 *
 * Call this function in the QE, whenever a new distributed snapshot is
 * received from the QD. Pass the 'distribTransactionTimeStamp' and
 * 'xminAllDistributedSnapshots' values from the DistributedSnapshot.
 * 'oldestLocalXmin' is the oldest xmin that is still visible according
 * to local snapshots. (That is the upper bound of how far we can advance
 * the oldest xmin)
 *
 * As a courtesy to callers, this function also returns the new "oldest
 * xmin" value (same as old value, if it was not advanced), just like
 * DistributedLog_GetOldestXmin() would.
 *
 */</comment>
<function><type><name>TransactionId</name></type>
<name>DistributedLog_AdvanceOldestXmin</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>oldestLocalXmin</name></decl></parameter>,
								 <parameter><decl><type><name>DistributedTransactionId</name></type> <name>xminAllDistributedSnapshots</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestXmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>oldOldestXmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>currPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>DistributedLogControlLockHeldByMe</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedLogEntry</name> <modifier>*</modifier></type><name>entries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>oldestLocalXmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dbname</name> <operator>=</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>database_name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(<argument><expr><literal type="string">"distributedlog_advance_oldest_xmin"</literal></expr></argument>, <argument><expr><name>DDLNotSpecified</name></expr></argument>,
								   <argument><expr><ternary><condition><expr><name>dbname</name></expr>?</condition><then><expr><name>dbname</name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DistributedLogTruncateLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldestXmin</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>DistributedLogShared</name><operator>-&gt;</operator><name>oldestXmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldOldestXmin</name> <operator>=</operator> <name>oldestXmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldestXmin</name> <operator>!=</operator> <name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * oldestXmin (DistributedLogShared-&gt;oldestXmin) can be higher than
	 * oldestLocalXmin (globalXmin in GetSnapshotData()) in concurrent
	 * work-load. This happens due to fact that GetSnapshotData() loops over
	 * procArray and releases the ProcArrayLock before reaching here. So, if
	 * oldestXmin has already bumped ahead of oldestLocalXmin its safe to just
	 * return oldestXmin, as some other process already checked the
	 * distributed log for us.
	 */</comment>
	<expr_stmt><expr><name>currPage</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>, <argument><expr><name>oldestLocalXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>page</name> <init>= <expr><call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>entryno</name> <init>= <expr><call><name>TransactionIdToEntry</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DistributedLogEntry</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>page</name> <operator>!=</operator> <name>currPage</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * SimpleLruReadPage_ReadOnly will acquire a lwlock, it is the
			 * caller's responsibility to release this lock.
			 * But we cannot release the lock immediately in one run of the
			 * loop, since the entries of current buffer will still be used
			 * by other items in the same page.
			 * So we release the lock when encountering a new page.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>DistributedLogControlLockHeldByMe</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage_ReadOnly</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>DistributedLogControlLockHeldByMe</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>currPage</name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>
			<comment type="block">/* entries is protected by the DistributedLogControl shared lock */</comment>
			<expr_stmt><expr><name>entries</name> <operator>=</operator> <operator>(</operator><name>DistributedLogEntry</name> <operator>*</operator><operator>)</operator> <name><name>DistributedLogCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>entries</name><index>[<expr><name>entryno</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/*
		 * If this XID is already visible to all distributed snapshots, we can
		 * advance past it. Otherwise stop here. (Local-only transactions will
		 * have zeros in distribXid and distribTimeStamp; this test will also
		 * skip over those.)
		 *
		 * And the distributed xid is just a plain counter, so we just use the `&gt;=` for
		 * the comparison of gxid
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>distribXid</name></name> <operator>&gt;=</operator> <name>xminAllDistributedSnapshots</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>DistributedLogControlLockHeldByMe</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The shared oldestXmin (DistributedLogShared-&gt;oldestXmin) may be updated
	 * concurrently. It should be set to a higher value, because a higher xmin
	 * can belong to another distributed log segment, its older segments might
	 * already be truncated.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>oldOldestXmin</name></expr></argument>, <argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>expected</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator><name>oldOldestXmin</name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>DistributedLogShared</name><operator>-&gt;</operator><name>oldestXmin</name></name></expr></argument>, 
											<argument><expr><operator>&amp;</operator><name>expected</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>oldestXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If we got here, other processes must have updated the oldestXmin.
				 * Return the more accurate value.
				 */</comment>
				<expr_stmt><expr><name>oldestXmin</name> <operator>=</operator> <name>expected</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogTruncateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdToSegment</name><argument_list>(<argument><expr><name>oldOldestXmin</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>TransactionIdToSegment</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DistributedLog_Truncate</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>oldestXmin</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the "oldest xmin" among distributed snapshots.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>DistributedLog_GetOldestXmin</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>oldestLocalXmin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>DistributedLogShared</name><operator>-&gt;</operator><name>oldestXmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_print_full_dtm</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"distributed oldestXmin is '%u'"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Like in DistributedLog_AdvanceOldestXmin(), the shared oldestXmin
	 * might already have been advanced past oldestLocalXmin.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>oldestLocalXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>oldestLocalXmin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Record that a distributed transaction committed in the distributed log for
 * all transaction ids on a single page. This function is similar to clog
 * function TransactionIdSetTreeStatus().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DistributedLog_SetCommittedWithinAPage</name><parameter_list>(
	<parameter><decl><type><name>int</name></type>                                 <name>numLocIds</name></decl></parameter>,
	<parameter><decl><type><name>TransactionId</name> 						<modifier>*</modifier></type><name>localXid</name></decl></parameter>,
	<parameter><decl><type><name>DistributedTransactionId</name></type> 			<name>distribXid</name></decl></parameter>,
	<parameter><decl><type><name>bool</name></type>								<name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedLogEntry</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numLocIds</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>localXid</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>localXid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name><name>localXid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isRedo</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
			 <argument><expr><literal type="string">"DistributedLog_SetCommitted check if page %d is present"</literal></expr></argument>,
			 <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SimpleLruDoesPhysicalPageExist</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DistributedLog_ZeroPage</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <comment type="block">/* writeXLog */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
				 <argument><expr><literal type="string">"DistributedLog_SetCommitted zeroed page %d"</literal></expr></argument>,
				 <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>localXid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>DistributedLogEntry</name> <operator>*</operator><operator>)</operator> <name><name>DistributedLogCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numLocIds</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>alreadyThere</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name><name>localXid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>localXid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>int</name></type>	<name>entryno</name> <init>= <expr><call><name>TransactionIdToEntry</name><argument_list>(<argument><expr><name><name>localXid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><name>entryno</name></expr>]</index></name><operator>.</operator><name>distribXid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><name>entryno</name></expr>]</index></name><operator>.</operator><name>distribXid</name> <operator>!=</operator> <name>distribXid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					 <argument><expr><literal type="string">"Current distributed xid = "</literal><name>UINT64_FORMAT</name><literal type="string">" does not match"</literal>
					 <literal type="string">" input distributed xid = "</literal><name>UINT64_FORMAT</name><literal type="string">" for "</literal>
					 <literal type="string">"local xid = %u in distributed log (page = %d, entryno = %d)"</literal></expr></argument>,
					 <argument><expr><name><name>ptr</name><index>[<expr><name>entryno</name></expr>]</index></name><operator>.</operator><name>distribXid</name></expr></argument>, <argument><expr><name>distribXid</name></expr></argument>, <argument><expr><name><name>localXid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>entryno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>alreadyThere</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>entryno</name></expr>]</index></name><operator>.</operator><name>distribXid</name> <operator>=</operator> <name>distribXid</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>DistributedLogCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
			 <argument><expr><literal type="string">"DistributedLog_SetCommitted with local xid = %d (page = %d, entryno = %d) and distributed transaction xid = "</literal><name>UINT64_FORMAT</name><literal type="string">" status = %s"</literal></expr></argument>,
			 <argument><expr><name><name>localXid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>entryno</name></expr></argument>, <argument><expr><name>distribXid</name></expr></argument>,
			 <argument><expr><operator>(</operator><ternary><condition><expr><name>alreadyThere</name></expr> ?</condition><then> <expr><literal type="string">"already there"</literal></expr> </then><else>: <expr><literal type="string">"set"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set committed for a bunch of transactions, chunking in the separate DLOG
 * pages involved. This function is similar to clog function
 * TransactionIdSetTreeStatus().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DistributedLog_SetCommittedByPages</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nsubxids</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>subxids</name></decl></parameter>,
								   <parameter><decl><type><name>DistributedTransactionId</name></type> <name>distribXid</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>nsubxids</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>	<name>num_on_page</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<comment type="block">/* This points in subxids array the start of transaction ids on a given page */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>start_of_range</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>pageno</name> <init>= <expr><call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name><name>subxids</name><index>[<expr><name>start_of_range</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name><name>subxids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>nsubxids</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>num_on_page</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>DistributedLog_SetCommittedWithinAPage</name><argument_list>(<argument><expr><name>num_on_page</name></expr></argument>, <argument><expr><name>subxids</name> <operator>+</operator> <name>start_of_range</name></expr></argument>,
											   <argument><expr><name>distribXid</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Record that a distributed transaction and its possible sub-transactions
 * committed, in the distributed log.
 */</comment>
<function><type><name>void</name></type>
<name>DistributedLog_SetCommittedTree</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nxids</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xids</name></decl></parameter>,
								<parameter><decl><type><name>DistributedTransactionId</name></type> <name>distribXid</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DistributedLog_SetCommittedWithinAPage</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>xid</name></expr></argument>, <argument><expr><name>distribXid</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* add entry for sub-transaction page at time */</comment>
		<expr_stmt><expr><call><name>DistributedLog_SetCommittedByPages</name><argument_list>(<argument><expr><name>nxids</name></expr></argument>, <argument><expr><name>xids</name></expr></argument>, <argument><expr><name>distribXid</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the corresponding distributed xid and timestamp of a local xid.
 */</comment>
<function><type><name>void</name></type>
<name>DistributedLog_GetDistributedXid</name><parameter_list>(
	<parameter><decl><type><name>TransactionId</name></type> 						<name>localXid</name></decl></parameter>,
	<parameter><decl><type><name>DistributedTransactionId</name> 			<modifier>*</modifier></type><name>distribXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>page</name> <init>= <expr><call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>entryno</name> <init>= <expr><call><name>TransactionIdToEntry</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedLogEntry</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage_ReadOnly</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>localXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>DistributedLogEntry</name> <operator>*</operator><operator>)</operator> <name><name>DistributedLogCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>entryno</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>distribXid</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>distribXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine if a distributed transaction committed in the distributed log.
 */</comment>
<function><type><name>bool</name></type>
<name>DistributedLog_CommittedCheck</name><parameter_list>(
	<parameter><decl><type><name>TransactionId</name></type> 						<name>localXid</name></decl></parameter>,
	<parameter><decl><type><name>DistributedTransactionId</name> 			<modifier>*</modifier></type><name>distribXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>page</name> <init>= <expr><call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>entryno</name> <init>= <expr><call><name>TransactionIdToEntry</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>DistributedLogEntry</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestXmin</name></decl>;</decl_stmt>


	<expr_stmt><expr><name>oldestXmin</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>DistributedLogShared</name><operator>-&gt;</operator><name>oldestXmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldestXmin</name> <operator>==</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"DistributedLog's OldestXmin not initialized yet"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>, <argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>distribXid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DistributedLogTruncateLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage_ReadOnly</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>localXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>DistributedLogEntry</name> <operator>*</operator><operator>)</operator> <name><name>DistributedLogCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>entryno</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>distribXid</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>distribXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogTruncateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>distribXid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="line">// Not found.</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find the next lowest transaction with a logged or recorded status.
 * Currently on distributed commits are recorded.
 */</comment>
<function><type><name>bool</name></type>
<name>DistributedLog_ScanForPrevCommitted</name><parameter_list>(
	<parameter><decl><type><name>TransactionId</name> 						<modifier>*</modifier></type><name>indexXid</name></decl></parameter>,
	<parameter><decl><type><name>DistributedTransactionId</name> 			<modifier>*</modifier></type><name>distribXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>highXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>pageno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>lowXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>distribXid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>indexXid</name><operator>)</operator> <operator>==</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>highXid</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>indexXid</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>highXid</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name>highXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute the xid floor for the page.
		 */</comment>
		<expr_stmt><expr><name>lowXid</name> <operator>=</operator> <name>pageno</name> <operator>*</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <name>ENTRIES_PER_PAGE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lowXid</name> <operator>==</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lowXid</name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Peek to see if page exists.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SimpleLruDoesPhysicalPageExist</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>indexXid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>distribXid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>highXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>xid</name> <operator>=</operator> <name>highXid</name></expr>;</init> <condition><expr><name>xid</name> <operator>&gt;=</operator> <name>lowXid</name></expr>;</condition> <incr><expr><name>xid</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>						<name>entryno</name> <init>= <expr><call><name>TransactionIdToEntry</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DistributedLogEntry</name> 	<modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>DistributedLogEntry</name> <operator>*</operator><operator>)</operator> <name><name>DistributedLogCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>entryno</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>distribXid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>indexXid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>distribXid</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>distribXid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>lowXid</name> <operator>==</operator> <name>FirstNormalTransactionId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>indexXid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>distribXid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>highXid</name> <operator>=</operator> <name>lowXid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="line">// Go to last xid of previous page.</comment>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>	<comment type="line">// We'll never reach this.</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>DistributedLog_SharedShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedLogShmem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Number of shared Distributed Log buffers.
 *
 * On larger multi-processor systems, it is possible to have many distributed
 * log page requests in flight at one time which could lead to disk access for
 * distributed log page if the required page is not found in memory.  Testing
 * revealed that we can get the best performance by having 128 distributed log
 * buffers, more than that it doesn't improve performance.
 *
 * Unconditionally keeping the number of distributed log buffers to 128 did
 * not seem like a good idea, because it would increase the minimum amount of
 * shared memory required to start, which could be a problem for people
 * running very small configurations.  The following formula seems to
 * represent a reasonable compromise: people with very low values for
 * shared_buffers will get fewer distributed log buffers as well, and everyone
 * else will get 128.
 *
 * This logic is exactly same as used for CLOG buffers. Except the minimum
 * used for CLOG buffers is 4 whereas we use 8 here, as that was the previous
 * default and hence lets be conservative and not go below that number.
 */</comment>
<function><type><name>Size</name></type>
<name>DistributedLog_ShmemBuffers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>Min</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>NBuffers</name> <operator>/</operator> <literal type="number">512</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialization of shared memory for the distributed log.
 */</comment>
<function><type><name>Size</name></type>
<name>DistributedLog_ShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>SimpleLruShmemSize</name><argument_list>(<argument><expr><call><name>DistributedLog_ShmemBuffers</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>DistributedLog_SharedShmemSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DistributedLog_ShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Set up SLRU for the distributed log. */</comment>
	<expr_stmt><expr><name><name>DistributedLogCtl</name><operator>-&gt;</operator><name>PagePrecedes</name></name> <operator>=</operator> <name>DistributedLog_PagePrecedes</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SimpleLruInit</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><literal type="string">"DistributedLogCtl"</literal></expr></argument>, <argument><expr><call><name>DistributedLog_ShmemBuffers</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				  <argument><expr><name>DistributedLogControlLock</name></expr></argument>, <argument><expr><literal type="string">"pg_distributedlog"</literal></expr></argument>,
				  <argument><expr><name>LWTRANCHE_DISTRIBUTEDLOG_BUFFERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create or attach to the shared structure */</comment>
	<expr_stmt><expr><name>DistributedLogShared</name> <operator>=</operator>
		<operator>(</operator><name>DistributedLogShmem</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(
										<argument><expr><literal type="string">"DistributedLogShmem"</literal></expr></argument>,
										<argument><expr><call><name>DistributedLog_SharedShmemSize</name><argument_list>()</argument_list></call></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>DistributedLogShared</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not initialize Distributed Log shared memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>DistributedLogShared</name><operator>-&gt;</operator><name>oldestXmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This func must be called ONCE on system install.  It creates
 * the initial DistributedLog segment.  (The pg_distributedlog directory is
 * assumed to have been created by the initdb shell script, and
 * DistributedLog_ShmemInit must have been called already.)
 */</comment>
<function><type><name>void</name></type>
<name>DistributedLog_BootStrap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create and zero the first page of the commit log */</comment>
	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>DistributedLog_ZeroPage</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure it's written out */</comment>
	<expr_stmt><expr><call><name>SimpleLruWritePage</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>DistributedLogCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize (or reinitialize) a page of DistributedLog to zeroes.
 * If writeXlog is TRUE, also emit an XLOG record saying we did this.
 *
 * The page is not actually written, just set up in shared memory.
 * The slot number of the new page is returned.
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>DistributedLog_ZeroPage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>writeXlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><literal type="string">"DistributedLog_ZeroPage zero page %d"</literal></expr></argument>,
		 <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruZeroPage</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>writeXlog</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DistributedLog_WriteZeroPageXlogRec</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>slotno</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This must be called ONCE during postmaster or standalone-backend startup,
 * after StartupXLOG has initialized ShmemVariableCache-&gt;nextXid.
 */</comment>
<function><type><name>void</name></type>
<name>DistributedLog_Startup</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>oldestActiveXid</name></decl></parameter>,
					   <parameter><decl><type><name>TransactionId</name></type> <name>nextXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>startPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>endPage</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * UNDONE: We really need oldest frozen xid.  If we can't get it, then
	 * we will need to tolerate not finding a page in
	 * DistributedLog_SetCommitted and DistributedLog_IsCommitted.
	 */</comment>
	<expr_stmt><expr><name>startPage</name> <operator>=</operator> <call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name>oldestActiveXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>endPage</name> <operator>=</operator> <call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name>nextXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><literal type="string">"DistributedLog_Startup startPage %d, endPage %d"</literal></expr></argument>,
		 <argument><expr><name>startPage</name></expr></argument>, <argument><expr><name>endPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize our idea of the latest page number.
	 */</comment>
	<expr_stmt><expr><name><name>DistributedLogCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name> <operator>=</operator> <name>endPage</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * In situations where new segments' data directories are copied from the
	 * master (such as binary upgrade), the distributed logs inherited by the
	 * segment will be incomplete. This is because master doesn't maintain these
	 * logs past their initial creation. In these cases (and these cases only!),
	 * we need to initialize and zero out log pages in memory for the range of
	 * active XIDs.
	 *
	 * TODO: Turn off distributed logging during binary upgrade to avoid the
	 * issue mentioned above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsBinaryUpgrade</name> <operator>||</operator> <name>ConvertMasterDataDirToSegment</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>currentPage</name> <init>= <expr><name>startPage</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The below loop has a defined exit condition as long as our pages are
		 * within a sane range.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>currentPage</name> <operator>&lt;=</operator> <call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name>MaxTransactionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>endPage</name> <operator>&lt;=</operator> <call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name>MaxTransactionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Clean the pg_distributedlog directory
		 */</comment>
		<expr_stmt><expr><call><name>SimpleLruTruncateWithLock</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>currentPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<do>do
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>currentPage</name> <operator>&gt;</operator> <call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name>MaxTransactionId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>currentPage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>DistributedLog_ZeroPage</name><argument_list>(<argument><expr><name>currentPage</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		while <condition>(<expr><name>currentPage</name><operator>++</operator> <operator>!=</operator> <name>endPage</name></expr>)</condition>;</do>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Zero out the remainder of the current DistributedLog page.  Under normal
	 * circumstances it should be zeroes already, but it seems at least
	 * theoretically possible that XLOG replay will have settled on a nextXID
	 * value that is less than the last XID actually used and marked by the
	 * previous database lifecycle (since subtransaction commit writes clog
	 * but makes no WAL entry).  Let's just be safe. (We need not worry about
	 * pages beyond the current one, since those will be zeroed when first
	 * used.  For the same reason, there is no need to do anything when
	 * nextXid is exactly at a page boundary; and it's likely that the
	 * "current" page doesn't exist yet in that case.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdToEntry</name><argument_list>(<argument><expr><name>nextXid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>entryno</name> <init>= <expr><call><name>TransactionIdToEntry</name><argument_list>(<argument><expr><name>nextXid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DistributedLogEntry</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>remainingEntries</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>endPage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>nextXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>DistributedLogEntry</name> <operator>*</operator><operator>)</operator> <name><name>DistributedLogCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>entryno</name></expr>;</expr_stmt>

		<comment type="block">/* Zero the rest of the page */</comment>
		<expr_stmt><expr><name>remainingEntries</name> <operator>=</operator> <name>ENTRIES_PER_PAGE</name> <operator>-</operator> <name>entryno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>remainingEntries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedLogEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>DistributedLogCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>DistributedLog_InitOldestXmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This must be called ONCE during postmaster or standalone-backend shutdown
 */</comment>
<function><type><name>void</name></type>
<name>DistributedLog_Shutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><literal type="string">"DistributedLog_Shutdown"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Flush dirty DistributedLog pages to disk */</comment>
	<expr_stmt><expr><call><name>SimpleLruFlush</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Perform a checkpoint --- either during shutdown, or on-the-fly
 */</comment>
<function><type><name>void</name></type>
<name>DistributedLog_CheckPoint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><literal type="string">"DistributedLog_CheckPoint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Flush dirty DistributedLog pages to disk */</comment>
	<expr_stmt><expr><call><name>SimpleLruFlush</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Make sure that DistributedLog has room for a newly-allocated XID.
 *
 * NB: this is called while holding XidGenLock.  We want it to be very fast
 * most of the time; even when it's not so fast, no actual I/O need happen
 * unless we're forced to write out a dirty DistributedLog or xlog page
 * to make room in shared memory.
 */</comment>
<function><type><name>void</name></type>
<name>DistributedLog_Extend</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>newestXact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>page</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No work except at first XID of a page.  But beware: just after
	 * wraparound, the first XID of page zero is FirstNormalTransactionId.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdToEntry</name><argument_list>(<argument><expr><name>newestXact</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>newestXact</name></expr></argument>, <argument><expr><name>FirstNormalTransactionId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name>newestXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><literal type="string">"DistributedLog_Extend page %d"</literal></expr></argument>,
		 <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Zero the page and make an XLOG entry about it */</comment>
	<expr_stmt><expr><call><name>DistributedLog_ZeroPage</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><literal type="string">"DistributedLog_Extend with newest local xid = %d to page = %d"</literal></expr></argument>,
		 <argument><expr><name>newestXact</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Remove all DistributedLog segments that are no longer needed.
 * DistributedLog is consulted for transactions that are committed but appear
 * as in-progress to a snapshot.  Segments that hold status of transactions
 * older than the oldest xmin of all distributed snapshots are no longer
 * needed.
 *
 * Before removing any DistributedLog data, we must flush XLOG to disk, to
 * ensure that any recently-emitted HEAP_FREEZE records have reached disk;
 * otherwise a crash and restart might leave us with some unfrozen tuples
 * referencing removed DistributedLog data.  We choose to emit a special
 * TRUNCATE XLOG record too.
 *
 * Replaying the deletion from XLOG is not critical, since the files could
 * just as well be removed later, but doing so prevents a long-running hot
 * standby server from acquiring an unreasonably bloated DistributedLog directory.
 *
 * Since DistributedLog segments hold a large number of transactions, the
 * opportunity to actually remove a segment is fairly rare, and so it seems
 * best not to do the XLOG flush unless we have confirmed that there is
 * a removable segment.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DistributedLog_Truncate</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>oldestXmin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cutoffPage</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DistributedLogTruncateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * The cutoff point is the start of the segment containing oldestXact. We
	 * pass the *page* containing oldestXact to SimpleLruTruncate.
	 */</comment>
	<expr_stmt><expr><name>cutoffPage</name> <operator>=</operator> <call><name>TransactionIdToPage</name><argument_list>(<argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><literal type="string">"DistributedLog_Truncate with oldest local xid = %d to cutoff page = %d"</literal></expr></argument>,
		 <argument><expr><name>oldestXmin</name></expr></argument>, <argument><expr><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check to see if there's any files that could be removed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SlruScanDirectory</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>SlruScanDirCbReportPresence</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogTruncateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>					<comment type="block">/* nothing to remove */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Write XLOG record and flush XLOG to disk */</comment>
	<expr_stmt><expr><call><name>DistributedLog_WriteTruncateXlogRec</name><argument_list>(<argument><expr><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now we can remove the old DistributedLog segment(s) */</comment>
	<expr_stmt><expr><call><name>SimpleLruTruncate</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogTruncateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Decide which of two DistributedLog page numbers is "older" for
 * truncation purposes.
 *
 * We need to use comparison of TransactionIds here in order to do the right
 * thing with wraparound XID arithmetic.  However, if we are asked about
 * page number zero, we don't want to hand InvalidTransactionId to
 * TransactionIdPrecedes: it'll get weird about permanent xact IDs.  So,
 * offset both xids by FirstNormalTransactionId to avoid that.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DistributedLog_PagePrecedes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>page2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xid1</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>TransactionId</name><operator>)</operator> <name>page1</name><operator>)</operator> <operator>*</operator> <name>ENTRIES_PER_PAGE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xid1</name> <operator>+=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xid2</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>TransactionId</name><operator>)</operator> <name>page2</name><operator>)</operator> <operator>*</operator> <name>ENTRIES_PER_PAGE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xid2</name> <operator>+=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt>

	<return>return <expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid1</name></expr></argument>, <argument><expr><name>xid2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write a ZEROPAGE xlog record
 *
 * Note: xlog record is marked as outside transaction control, since we
 * want it to be redone whether the invoking transaction commits or not.
 * (Besides which, this is normally done just before entering a transaction.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DistributedLog_WriteZeroPageXlogRec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>page</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_DISTRIBUTEDLOG_ID</name></expr></argument>, <argument><expr><name>DISTRIBUTEDLOG_ZEROPAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write a TRUNCATE xlog record
 *
 * We must flush the xlog record to disk before returning --- see notes
 * in DistributedLog_Truncate().
 *
 * Note: xlog record is marked as outside transaction control, since we
 * want it to be redone whether the invoking transaction commits or not.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DistributedLog_WriteTruncateXlogRec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>page</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_DISTRIBUTEDLOG_ID</name></expr></argument>, <argument><expr><name>DISTRIBUTEDLOG_TRUNCATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DistributedLog resource manager's routines
 */</comment>
<function><type><name>void</name></type>
<name>DistributedLog_redo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>DISTRIBUTEDLOG_ZEROPAGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>page</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
			 <argument><expr><literal type="string">"Redo DISTRIBUTEDLOG_ZEROPAGE page %d"</literal></expr></argument>,
			 <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>DistributedLog_ZeroPage</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SimpleLruWritePage</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>DistributedLogCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DistributedLogControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
			 <argument><expr><literal type="string">"DistributedLog_redo zero page = %d"</literal></expr></argument>,
			 <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>DISTRIBUTEDLOG_TRUNCATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>page</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>page</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
			 <argument><expr><literal type="string">"Redo DISTRIBUTEDLOG_TRUNCATE page %d"</literal></expr></argument>,
			 <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * During XLOG replay, latest_page_number isn't set up yet; insert
		 * a suitable value to bypass the sanity test in SimpleLruTruncate.
		 */</comment>
		<expr_stmt><expr><name><name>DistributedLogCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SimpleLruTruncate</name><argument_list>(<argument><expr><name>DistributedLogCtl</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
			 <argument><expr><literal type="string">"DistributedLog_redo truncate to cutoff page = %d"</literal></expr></argument>,
			 <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"DistributedLog_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
