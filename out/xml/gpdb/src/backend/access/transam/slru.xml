<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/transam/slru.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * slru.c
 *		Simple LRU buffering for transaction status logfiles
 *
 * We use a simple least-recently-used scheme to manage a pool of page
 * buffers.  Under ordinary circumstances we expect that write
 * traffic will occur mostly to the latest page (and to the just-prior
 * page, soon after a page transition).  Read traffic will probably touch
 * a larger span of pages, but in any case a fairly small number of page
 * buffers should be sufficient.  So, we just search the buffers using plain
 * linear search; there's no need for a hashtable or anything fancy.
 * The management algorithm is straight LRU except that we will never swap
 * out the latest page (since we know it's going to be hit again eventually).
 *
 * We use a control LWLock to protect the shared data structures, plus
 * per-buffer LWLocks that synchronize I/O for each buffer.  The control lock
 * must be held to examine or modify any shared state.  A process that is
 * reading in or writing out a page buffer does not hold the control lock,
 * only the per-buffer lock for the buffer it is working on.
 *
 * "Holding the control lock" means exclusive lock in all cases except for
 * SimpleLruReadPage_ReadOnly(); see comments for SlruRecentlyUsed() for
 * the implications of that.
 *
 * When initiating I/O on a buffer, we acquire the per-buffer lock exclusively
 * before releasing the control lock.  The per-buffer lock is released after
 * completing the I/O, re-acquiring the control lock, and updating the shared
 * state.  (Deadlock is not possible here, because we never try to initiate
 * I/O when someone else is already doing I/O on the same buffer.)
 * To wait for I/O to complete, release the control lock, acquire the
 * per-buffer lock in shared mode, immediately release the per-buffer lock,
 * reacquire the control lock, and then recheck state (since arbitrary things
 * could have happened while we didn't have the lock).
 *
 * As with the regular buffer manager, it is possible for another process
 * to re-dirty a page that is currently being written out.  This is handled
 * by re-setting the page's page_dirty flag.
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/backend/access/transam/slru.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/slru.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlruFileName</name><parameter_list>(<parameter><type><name>ctl</name></type></parameter>, <parameter><type><name>path</name></type></parameter>, <parameter><type><name>seg</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>snprintf(path, MAXPGPATH, "%s/%04X", (ctl)-&gt;Dir, seg)</cpp:value></cpp:define>

<comment type="block">/*
 * During SimpleLruFlush(), we will usually not need to write/fsync more
 * than one or two physical files, but we may need to write several pages
 * per file.  We can consolidate the I/O requests by leaving files open
 * until control returns to SimpleLruFlush().  This data structure remembers
 * which files are open.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FLUSH_BUFFERS</name></cpp:macro>	<cpp:value>16</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>SlruFlushData</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>num_files</name></decl>;</decl_stmt>		<comment type="block">/* # files actually open */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>fd</name><index>[<expr><name>MAX_FLUSH_BUFFERS</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* their FD's */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>segno</name><index>[<expr><name>MAX_FLUSH_BUFFERS</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* their log seg#s */</comment>
}</block></struct></type> <name>SlruFlushData</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>SlruFlushData</name></name> <modifier>*</modifier></type><name>SlruFlush</name>;</typedef>

<comment type="block">/*
 * Macro to mark a buffer slot "most recently used".  Note multiple evaluation
 * of arguments!
 *
 * The reason for the if-test is that there are often many consecutive
 * accesses to the same page (particularly the latest page).  By suppressing
 * useless increments of cur_lru_count, we reduce the probability that old
 * pages' counts will "wrap around" and make them appear recently used.
 *
 * We allow this code to be executed concurrently by multiple processes within
 * SimpleLruReadPage_ReadOnly().  As long as int reads and writes are atomic,
 * this should not cause any completely-bogus values to enter the computation.
 * However, it is possible for either cur_lru_count or individual
 * page_lru_count entries to be "reset" to lower values than they should have,
 * in case a process is delayed while it executes this macro.  With care in
 * SlruSelectLRUPage(), this does little harm, and in any case the absolute
 * worst possible consequence is a nonoptimal choice of page to evict.  The
 * gain from allowing concurrent reads of SLRU pages seems worth it.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlruRecentlyUsed</name><parameter_list>(<parameter><type><name>shared</name></type></parameter>, <parameter><type><name>slotno</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>do { \
		int		new_lru_count = (shared)-&gt;cur_lru_count; \
		if (new_lru_count != (shared)-&gt;page_lru_count[slotno]) { \
			(shared)-&gt;cur_lru_count = ++new_lru_count; \
			(shared)-&gt;page_lru_count[slotno] = new_lru_count; \
		} \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Saved info for SlruReportIOError */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>SLRU_OPEN_FAILED</name></decl>,
	<decl><name>SLRU_SEEK_FAILED</name></decl>,
	<decl><name>SLRU_READ_FAILED</name></decl>,
	<decl><name>SLRU_WRITE_FAILED</name></decl>,
	<decl><name>SLRU_FSYNC_FAILED</name></decl>,
	<decl><name>SLRU_CLOSE_FAILED</name></decl>
}</block></enum></type> <name>SlruErrorCause</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>SlruErrorCause</name></type> <name>slru_errcause</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>slru_errno</name></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SimpleLruZeroLSNs</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SimpleLruWaitIO</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SlruInternalWritePage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>SlruFlush</name></type> <name>fdata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SlruPhysicalReadPage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SlruPhysicalWritePage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>,
								  <parameter><decl><type><name>SlruFlush</name></type> <name>fdata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SlruReportIOError</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>SlruSelectLRUPage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SlruScanDirCbDeleteCutoff</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>segpage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SlruInternalDeleteSegment</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Initialization of shared memory
 */</comment>

<function><type><name>Size</name></type>
<name>SimpleLruShmemSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nslots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlsns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>sz</name></decl>;</decl_stmt>

	<comment type="block">/* we assume nslots isn't so large as to risk overflow */</comment>
	<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SlruSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_buffer[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SlruPageStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_status[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_dirty[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_number[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_lru_count[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LWLockPadded</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* buffer_locks[] */</comment>

	<if_stmt><if>if <condition>(<expr><name>nlsns</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <name>nlsns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* group_lsn[] */</comment>

	<return>return <expr><call><name>BUFFERALIGN</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>BLCKSZ</name> <operator>*</operator> <name>nslots</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SimpleLruInit</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nslots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlsns</name></decl></parameter>,
			  <parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>ctllock</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subdir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tranche_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>shared</name> <operator>=</operator> <operator>(</operator><name>SlruShared</name><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
										  <argument><expr><call><name>SimpleLruShmemSize</name><argument_list>(<argument><expr><name>nslots</name></expr></argument>, <argument><expr><name>nlsns</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Initialize locks and shared memory area */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>offset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SlruSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name> <operator>=</operator> <name>ctllock</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name> <operator>=</operator> <name>nslots</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>lsn_groups_per_page</name></name> <operator>=</operator> <name>nlsns</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>cur_lru_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* shared-&gt;latest_page_number will be set later */</comment>

		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>shared</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SlruSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name></name> <operator>=</operator> <operator>(</operator><name>SlruPageStatus</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SlruPageStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize LWLocks */</comment>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name></name> <operator>=</operator> <operator>(</operator><name>LWLockPadded</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LWLockPadded</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nlsns</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>group_lsn</name></name> <operator>=</operator> <operator>(</operator><name>XLogRecPtr</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <name>nlsns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>SLRU_MAX_NAME_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>lwlock_tranche_name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>SLRU_MAX_NAME_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name> <operator>=</operator> <name>tranche_id</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>BUFFERALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name>nslots</name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>,
							 <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>SLRU_PAGE_EMPTY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Should fit to estimated shmem size */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>shared</name> <operator>&lt;=</operator> <call><name>SimpleLruShmemSize</name><argument_list>(<argument><expr><name>nslots</name></expr></argument>, <argument><expr><name>nlsns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Register SLRU tranche in the main tranches array */</comment>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name></expr></argument>,
						  <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>lwlock_tranche_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the unshared control struct, including directory path. We
	 * assume caller set PagePrecedes.
	 */</comment>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name> <operator>=</operator> <name>shared</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>do_fsync</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* default behavior */</comment>
	<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>subdir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize (or reinitialize) a page to zeroes.
 *
 * The page is not actually written, just set up in shared memory.
 * The slot number of the new page is returned.
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><name>int</name></type>
<name>SimpleLruZeroPage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<comment type="block">/* Find a suitable buffer slot for the page */</comment>
	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SlruSelectLRUPage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name> <operator>||</operator>
		   <operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator> <operator>||</operator>
		   <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the slot as containing this page */</comment>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>SLRU_PAGE_VALID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the buffer to zeroes */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the LSNs for this new page to zero */</comment>
	<expr_stmt><expr><call><name>SimpleLruZeroLSNs</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assume this page is now the latest active page */</comment>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>

	<return>return <expr><name>slotno</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Zero all the LSNs we store for this slru page.
 *
 * This should be called each time we create a new page, and each time we read
 * in a page from disk into an existing buffer.  (Such an old page cannot
 * have any interesting LSNs, since we'd have flushed them before writing
 * the page in the first place.)
 *
 * This assumes that InvalidXLogRecPtr is bitwise-all-0.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SimpleLruZeroLSNs</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>lsn_groups_per_page</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>group_lsn</name><index>[<expr><name>slotno</name> <operator>*</operator> <name><name>shared</name><operator>-&gt;</operator><name>lsn_groups_per_page</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>lsn_groups_per_page</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for any active I/O on a page slot to finish.  (This does not
 * guarantee that new I/O hasn't been started before we return, though.
 * In fact the slot might not even contain the same page anymore.)
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SimpleLruWaitIO</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* See notes at top of file */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the slot is still in an io-in-progress state, then either someone
	 * already started a new I/O on the slot, or a previous I/O failed and
	 * neglected to reset the page state.  That shouldn't happen, really, but
	 * it seems worth a few extra cycles to check and recover from it. We can
	 * cheaply test for failure by seeing if the buffer lock is still held (we
	 * assume that transaction abort would release the lock).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name> <operator>||</operator>
		<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* indeed, the I/O must have failed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>SLRU_PAGE_EMPTY</name></expr>;</expr_stmt></block_content></block></if>
			<else>else				<comment type="block">/* write_in_progress */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>SLRU_PAGE_VALID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find a page in a shared buffer, reading it in if necessary.
 * The page number must correspond to an already-initialized page.
 *
 * If write_ok is true then it is OK to return a page that is in
 * WRITE_IN_PROGRESS state; it is the caller's responsibility to be sure
 * that modification of the page is safe.  If write_ok is false then we
 * will not return the page until it is not undergoing active I/O.
 *
 * The passed-in xid is used only for error reporting, and may be
 * InvalidTransactionId if no specific xid is associated with the action.
 *
 * Return value is the shared-buffer slot number now holding the page.
 * The buffer's LRU access info is updated.
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><name>int</name></type>
<name>SimpleLruReadPage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>write_ok</name></decl></parameter>,
				  <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Outer loop handles restart if we must wait for someone else's I/O */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name></decl>;</decl_stmt>

		<comment type="block">/* See if page already is in memory; if not, pick victim slot */</comment>
		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SlruSelectLRUPage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Did we find the page in memory? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
			<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If page is still being read in, we must wait for I/O.  Likewise
			 * if the page is being written and the caller said that's not OK.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name> <operator>||</operator>
				<operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><name>write_ok</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SimpleLruWaitIO</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Now we must recheck state from the top */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Otherwise, it's ready to use */</comment>
			<expr_stmt><expr><call><name>SlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>slotno</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We found no match; assert we selected a freeable slot */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name> <operator>||</operator>
			   <operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark the slot read-busy */</comment>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Acquire per-buffer lock (cannot deadlock, see notes at top) */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Release control lock while doing I/O */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do the read */</comment>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>SlruPhysicalReadPage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set the LSNs for this newly read-in page to zero */</comment>
		<expr_stmt><expr><call><name>SimpleLruZeroLSNs</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Re-acquire control lock and update page state */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
			   <name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name> <operator>&amp;&amp;</operator>
			   <operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>ok</name></expr> ?</condition><then> <expr><name>SLRU_PAGE_VALID</name></expr> </then><else>: <expr><name>SLRU_PAGE_EMPTY</name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now it's okay to ereport if we failed */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SlruReportIOError</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>SlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>slotno</name></expr>;</return>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Find a page in a shared buffer, reading it in if necessary.
 * The page number must correspond to an already-initialized page.
 * The caller must intend only read-only access to the page.
 *
 * The passed-in xid is used only for error reporting, and may be
 * InvalidTransactionId if no specific xid is associated with the action.
 *
 * Return value is the shared-buffer slot number now holding the page.
 * The buffer's LRU access info is updated.
 *
 * Control lock must NOT be held at entry, but will be held at exit.
 * It is unspecified whether the lock will be shared or exclusive.
 */</comment>
<function><type><name>int</name></type>
<name>SimpleLruReadPage_ReadOnly</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<comment type="block">/* Try to find the page while holding only shared lock */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* See if page is already in a buffer */</comment>
	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
			<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name> <operator>&amp;&amp;</operator>
			<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* See comments for SlruRecentlyUsed macro */</comment>
			<expr_stmt><expr><call><name>SlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>slotno</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* No luck, so switch to normal exclusive lock and do regular read */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write a page from a shared buffer, if necessary.
 * Does nothing if the specified slot is not dirty.
 *
 * NOTE: only one write attempt is made here.  Hence, it is possible that
 * the page is still dirty at exit (if someone else re-dirtied it during
 * the write).  However, we *do* attempt a fresh write even if the page
 * is already being written; this is for checkpoints.
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SlruInternalWritePage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>SlruFlush</name></type> <name>fdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name> <init>= <expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name></decl>;</decl_stmt>

	<comment type="block">/* If a write is in progress, wait for it to finish */</comment>
	<while>while <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name> <operator>&amp;&amp;</operator>
		   <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SimpleLruWaitIO</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Do nothing if page is not dirty, or if buffer no longer contains the
	 * same page we were called for.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>||</operator>
		<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_VALID</name> <operator>||</operator>
		<name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>pageno</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Mark the slot write-busy, and clear the dirtybit.  After this point, a
	 * transaction status update on this page will mark it dirty again.
	 */</comment>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Acquire per-buffer lock (cannot deadlock, see notes at top) */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release control lock while doing I/O */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do the write */</comment>
	<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>SlruPhysicalWritePage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>fdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we failed, and we're in a flush, better close the files */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name> <operator>&amp;&amp;</operator> <name>fdata</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fdata</name><operator>-&gt;</operator><name>num_files</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name><name>fdata</name><operator>-&gt;</operator><name>fd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Re-acquire control lock and update page state */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
		   <name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we failed to write, mark the page dirty again */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>SLRU_PAGE_VALID</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now it's okay to ereport if we failed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SlruReportIOError</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wrapper of SlruInternalWritePage, for external callers.
 * fdata is always passed a NULL here.
 */</comment>
<function><type><name>void</name></type>
<name>SimpleLruWritePage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SlruInternalWritePage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return whether the given page exists on disk.
 *
 * A false return means that either the file does not exist, or that it's not
 * large enough to contain the given page.
 */</comment>
<function><type><name>bool</name></type>
<name>SimpleLruDoesPhysicalPageExist</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>pageno</name> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rpageno</name> <init>= <expr><name>pageno</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name>rpageno</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>endpos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SlruFileName</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* expected: file doesn't exist */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* report error normally */</comment>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_OPEN_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SlruReportIOError</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>endpos</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_SEEK_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SlruReportIOError</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>endpos</name> <operator>&gt;=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <operator>(</operator><name>offset</name> <operator>+</operator> <name>BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_CLOSE_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Physical read of a (previously existing) page into a buffer slot
 *
 * On failure, we cannot just ereport(ERROR) since caller has put state in
 * shared memory that must be undone.  So, we return false and save enough
 * info in static variables to let SlruReportIOError make the report.
 *
 * For now, assume it's not worth keeping a file pointer open across
 * read/write operations.  We could cache one virtual file pointer ...
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SlruPhysicalReadPage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>pageno</name> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rpageno</name> <init>= <expr><name>pageno</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name>rpageno</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SlruFileName</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In a crash-and-restart situation, it's possible for us to receive
	 * commands to set the commit status of transactions whose bits are in
	 * already-truncated segments of the commit log (see notes in
	 * SlruPhysicalWritePage).  Hence, if we are InRecovery, allow the case
	 * where the file doesn't exist, and return zeroes instead.
	 */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name> <operator>||</operator> <operator>!</operator><name>InRecovery</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_OPEN_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"file \"%s\" doesn't exist, reading as zeroes"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_SEEK_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SLRU_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_READ_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_CLOSE_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Physical write of a page from a buffer slot
 *
 * On failure, we cannot just ereport(ERROR) since caller has put state in
 * shared memory that must be undone.  So, we return false and save enough
 * info in static variables to let SlruReportIOError make the report.
 *
 * For now, assume it's not worth keeping a file pointer open across
 * independent read/write operations.  We do batch operations during
 * SimpleLruFlush, though.
 *
 * fdata is NULL for a standalone write, pointer to open-file info during
 * SimpleLruFlush.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SlruPhysicalWritePage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>SlruFlush</name></type> <name>fdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>pageno</name> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rpageno</name> <init>= <expr><name>pageno</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name>rpageno</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Honor the write-WAL-before-data rule, if appropriate, so that we do not
	 * write out data before associated WAL records.  This is the same action
	 * performed during FlushBuffer() in the main buffer manager.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>group_lsn</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We must determine the largest async-commit LSN for the page. This
		 * is a bit tedious, but since this entire function is a slow path
		 * anyway, it seems better to do this here than to maintain a per-page
		 * LSN variable (which'd need an extra comparison in the
		 * transaction-commit path).
		 */</comment>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>max_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>lsnindex</name></decl>,
					<decl><type ref="prev"/><name>lsnoff</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lsnindex</name> <operator>=</operator> <name>slotno</name> <operator>*</operator> <name><name>shared</name><operator>-&gt;</operator><name>lsn_groups_per_page</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>max_lsn</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>group_lsn</name><index>[<expr><name>lsnindex</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>lsnoff</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lsnoff</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>lsn_groups_per_page</name></name></expr>;</condition> <incr><expr><name>lsnoff</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>this_lsn</name> <init>= <expr><name><name>shared</name><operator>-&gt;</operator><name>group_lsn</name><index>[<expr><name>lsnindex</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>max_lsn</name> <operator>&lt;</operator> <name>this_lsn</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>max_lsn</name> <operator>=</operator> <name>this_lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>max_lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * As noted above, elog(ERROR) is not acceptable here, so if
			 * XLogFlush were to fail, we must PANIC.  This isn't much of a
			 * restriction because XLogFlush is just about all critical
			 * section anyway, but let's make sure.
			 */</comment>
			<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>max_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * During a Flush, we may already have the desired file open.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fdata</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fdata</name><operator>-&gt;</operator><name>num_files</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>fdata</name><operator>-&gt;</operator><name>segno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>segno</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>fd</name> <operator>=</operator> <name><name>fdata</name><operator>-&gt;</operator><name>fd</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the file doesn't already exist, we should create it.  It is
		 * possible for this to need to happen when writing a page that's not
		 * first in its segment; we assume the OS can cope with that. (Note:
		 * it might seem that it'd be okay to create files only when
		 * SimpleLruZeroPage is called for the first page of a segment.
		 * However, if after a crash and restart the REDO logic elects to
		 * replay the log from a checkpoint before the latest one, then it's
		 * possible that we will get commands to set transaction status of
		 * transactions that have already been truncated from the commit log.
		 * Easiest way to deal with that is to accept references to
		 * nonexistent files here and in SlruPhysicalReadPage.)
		 *
		 * Note: it is possible for more than one backend to be executing this
		 * code simultaneously for different pages of the same file. Hence,
		 * don't use O_EXCL or O_TRUNC or anything like that.
		 */</comment>
		<expr_stmt><expr><call><name>SlruFileName</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_OPEN_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>fdata</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>fdata</name><operator>-&gt;</operator><name>num_files</name></name> <operator>&lt;</operator> <name>MAX_FLUSH_BUFFERS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fdata</name><operator>-&gt;</operator><name>fd</name><index>[<expr><name><name>fdata</name><operator>-&gt;</operator><name>num_files</name></name></expr>]</index></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fdata</name><operator>-&gt;</operator><name>segno</name><index>[<expr><name><name>fdata</name><operator>-&gt;</operator><name>num_files</name></name></expr>]</index></name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fdata</name><operator>-&gt;</operator><name>num_files</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * In the unlikely event that we exceed MAX_FLUSH_BUFFERS,
				 * fall back to treating it as a standalone write.
				 */</comment>
				<expr_stmt><expr><name>fdata</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_SEEK_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fdata</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SLRU_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_WRITE_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fdata</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If not part of Flush, need to fsync now.  We assume this happens
	 * infrequently enough that it's not a performance issue.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fdata</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SLRU_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ctl</name><operator>-&gt;</operator><name>do_fsync</name></name> <operator>&amp;&amp;</operator> <call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_FSYNC_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_CLOSE_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Issue the error message after failure of SlruPhysicalReadPage or
 * SlruPhysicalWritePage.  Call this after cleaning up shared-memory state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SlruReportIOError</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>pageno</name> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rpageno</name> <init>= <expr><name>pageno</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name>rpageno</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SlruFileName</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>slru_errno</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>slru_errcause</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SLRU_OPEN_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access status of transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not open file \"%s\": %m."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLRU_SEEK_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access status of transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not seek in file \"%s\" to offset %u: %m."</literal></expr></argument>,
							   <argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLRU_READ_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access status of transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not read from file \"%s\" at offset %u: %m."</literal></expr></argument>,
							   <argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLRU_WRITE_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access status of transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not write to file \"%s\" at offset %u: %m."</literal></expr></argument>,
							   <argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLRU_FSYNC_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>data_sync_elevel</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access status of transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not fsync file \"%s\": %m."</literal></expr></argument>,
							   <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLRU_CLOSE_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access status of transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not close file \"%s\": %m."</literal></expr></argument>,
							   <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* can't get here, we trust */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized SimpleLru error cause: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>slru_errcause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Select the slot to re-use when we need a free slot.
 *
 * The target page number is passed because we need to consider the
 * possibility that some other process reads in the target page while
 * we are doing I/O to free a slot.  Hence, check or recheck to see if
 * any slot already holds the target page, and return that slot if so.
 * Thus, the returned slot is *either* a slot already holding the pageno
 * (could be any state except EMPTY), *or* a freeable slot (state EMPTY
 * or CLEAN).
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>SlruSelectLRUPage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Outer loop handles restart after I/O */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cur_count</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>bestvalidslot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* keep compiler quiet */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_valid_delta</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_valid_page_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* keep compiler quiet */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>bestinvalidslot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* keep compiler quiet */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_invalid_delta</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_invalid_page_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* keep compiler quiet */</comment>

		<comment type="block">/* See if page already has a buffer assigned */</comment>
		<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
				<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>slotno</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If we find any EMPTY slot, just select that one. Else choose a
		 * victim page to replace.  We normally take the least recently used
		 * valid page, but we will never take the slot containing
		 * latest_page_number, even if it appears least recently used.  We
		 * will select a slot that is already I/O busy only if there is no
		 * other choice: a read-busy slot will not be least recently used once
		 * the read finishes, and waiting for an I/O on a write-busy slot is
		 * inferior to just picking some other slot.  Testing shows the slot
		 * we pick instead will often be clean, allowing us to begin a read at
		 * once.
		 *
		 * Normally the page_lru_count values will all be different and so
		 * there will be a well-defined LRU page.  But since we allow
		 * concurrent execution of SlruRecentlyUsed() within
		 * SimpleLruReadPage_ReadOnly(), it is possible that multiple pages
		 * acquire the same lru_count values.  In that case we break ties by
		 * choosing the furthest-back page.
		 *
		 * Notice that this next line forcibly advances cur_lru_count to a
		 * value that is certainly beyond any value that will be in the
		 * page_lru_count array after the loop finishes.  This ensures that
		 * the next execution of SlruRecentlyUsed will mark the page newly
		 * used, even if it's for a page that has the current counter value.
		 * That gets us back on the path to having good data when there are
		 * multiple pages with the same lru_count.
		 */</comment>
		<expr_stmt><expr><name>cur_count</name> <operator>=</operator> <operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>cur_lru_count</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>this_delta</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>this_page_number</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>slotno</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>this_delta</name> <operator>=</operator> <name>cur_count</name> <operator>-</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>this_delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Clean up in case shared updates have caused cur_count
				 * increments to get "lost".  We back off the page counts,
				 * rather than trying to increase cur_count, to avoid any
				 * question of infinite loops or failure in the presence of
				 * wrapped-around counts.
				 */</comment>
				<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>cur_count</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>this_delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>this_page_number</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>this_page_number</name> <operator>==</operator> <name><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>this_delta</name> <operator>&gt;</operator> <name>best_valid_delta</name> <operator>||</operator>
					<operator>(</operator><name>this_delta</name> <operator>==</operator> <name>best_valid_delta</name> <operator>&amp;&amp;</operator>
					 <call><name><name>ctl</name><operator>-&gt;</operator><name>PagePrecedes</name></name><argument_list>(<argument><expr><name>this_page_number</name></expr></argument>,
									   <argument><expr><name>best_valid_page_number</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>bestvalidslot</name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_valid_delta</name> <operator>=</operator> <name>this_delta</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_valid_page_number</name> <operator>=</operator> <name>this_page_number</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>this_delta</name> <operator>&gt;</operator> <name>best_invalid_delta</name> <operator>||</operator>
					<operator>(</operator><name>this_delta</name> <operator>==</operator> <name>best_invalid_delta</name> <operator>&amp;&amp;</operator>
					 <call><name><name>ctl</name><operator>-&gt;</operator><name>PagePrecedes</name></name><argument_list>(<argument><expr><name>this_page_number</name></expr></argument>,
									   <argument><expr><name>best_invalid_page_number</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>bestinvalidslot</name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_invalid_delta</name> <operator>=</operator> <name>this_delta</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_invalid_page_number</name> <operator>=</operator> <name>this_page_number</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If all pages (except possibly the latest one) are I/O busy, we'll
		 * have to wait for an I/O to complete and then retry.  In that
		 * unhappy case, we choose to wait for the I/O on the least recently
		 * used slot, on the assumption that it was likely initiated first of
		 * all the I/Os in progress and may therefore finish first.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>best_valid_delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SimpleLruWaitIO</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>bestinvalidslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the selected page is clean, we're set.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>bestvalidslot</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>bestvalidslot</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Write the page.
		 */</comment>
		<expr_stmt><expr><call><name>SlruInternalWritePage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>bestvalidslot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now loop back and try again.  This is the easiest way of dealing
		 * with corner cases such as the victim page being re-dirtied while we
		 * wrote it.
		 */</comment>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Flush dirty pages to disk during checkpoint or database shutdown
 */</comment>
<function><type><name>void</name></type>
<name>SimpleLruFlush</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_redirtied</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlruFlushData</name></type> <name>fdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find and write dirty pages
	 */</comment>
	<expr_stmt><expr><name><name>fdata</name><operator>.</operator><name>num_files</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SlruInternalWritePage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In some places (e.g. checkpoints), we cannot assert that the slot
		 * is clean now, since another process might have re-dirtied it
		 * already.  That's okay.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>allow_redirtied</name> <operator>||</operator>
			   <name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name> <operator>||</operator>
			   <operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now fsync and close any files that were open
	 */</comment>
	<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fdata</name><operator>.</operator><name>num_files</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SLRU_FLUSH_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ctl</name><operator>-&gt;</operator><name>do_fsync</name></name> <operator>&amp;&amp;</operator> <call><name>pg_fsync</name><argument_list>(<argument><expr><name><name>fdata</name><operator>.</operator><name>fd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_FSYNC_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pageno</name> <operator>=</operator> <name><name>fdata</name><operator>.</operator><name>segno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name><name>fdata</name><operator>.</operator><name>fd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_CLOSE_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pageno</name> <operator>=</operator> <name><name>fdata</name><operator>.</operator><name>segno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SlruReportIOError</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove all segments before the one holding the passed page number
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SimpleLruTruncate_internal</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cutoffPage</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lockHeld</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The cutoff point is the start of the segment containing cutoffPage.
	 */</comment>
	<expr_stmt><expr><name>cutoffPage</name> <operator>-=</operator> <name>cutoffPage</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan shared memory and remove any pages preceding the cutoff page, to
	 * ensure we won't rewrite them later.  (Since this is normally called in
	 * or just after a checkpoint, any dirty pages should have been flushed
	 * already ... we're just being extra careful here.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockHeld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>restart</name>:</label><empty_stmt>;</empty_stmt>

	<comment type="block">/*
	 * While we are holding the lock, make an important safety check: the
	 * planned cutoff point must be &lt;= the current endpoint page. Otherwise we
	 * have already wrapped around, and proceeding with the truncation would
	 * risk removing the current segment.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name><name>ctl</name><operator>-&gt;</operator><name>PagePrecedes</name></name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name></expr></argument>, <argument><expr><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockHeld</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not truncate directory \"%s\": apparent wraparound"</literal></expr></argument>,
						<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ctl</name><operator>-&gt;</operator><name>PagePrecedes</name></name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If page is clean, just change state to EMPTY (expected case).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>SLRU_PAGE_EMPTY</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Hmm, we have (or may have) I/O operations acting on the page, so
		 * we've got to wait for them to finish and then start again. This is
		 * the same logic as in SlruSelectLRUPage.  (XXX if page is dirty,
		 * wouldn't it be OK to just discard it without writing it?  For now,
		 * keep the logic the same as it was.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SlruInternalWritePage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SimpleLruWaitIO</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<goto>goto <name>restart</name>;</goto>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockHeld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now we can remove the old segment(s) */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>SlruScanDirectory</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>SlruScanDirCbDeleteCutoff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>SimpleLruTruncate</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cutoffPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SimpleLruTruncate_internal</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>cutoffPage</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* Like SimpleLruTruncate, but we're already holding the control lock */</comment>
<function><type><name>void</name></type>
<name>SimpleLruTruncateWithLock</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cutoffPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SimpleLruTruncate_internal</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>cutoffPage</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete an individual SLRU segment, identified by the filename.
 *
 * NB: This does not touch the SLRU buffers themselves, callers have to ensure
 * they either can't yet contain anything, or have already been cleaned out.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SlruInternalDeleteSegment</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete an individual SLRU segment, identified by the segment number.
 */</comment>
<function><type><name>void</name></type>
<name>SlruDeleteSegment</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>did_write</name></decl>;</decl_stmt>

	<comment type="block">/* Clean out any possibly existing references to the segment. */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>restart</name>:</label>
	<expr_stmt><expr><name>did_write</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>pagesegno</name> <init>= <expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* not the segment we're looking for */</comment>
		<if_stmt><if>if <condition>(<expr><name>pagesegno</name> <operator>!=</operator> <name>segno</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* If page is clean, just change state to EMPTY (expected case). */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>SLRU_PAGE_EMPTY</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Same logic as SimpleLruTruncate() */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SlruInternalWritePage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SimpleLruWaitIO</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>did_write</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Be extra careful and re-check. The IO functions release the control
	 * lock, so new pages could have been read in.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>did_write</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>restart</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%04X"</literal></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SlruScanDirectory callback
 *		This callback reports true if there's any segment prior to the one
 *		containing the page passed as "data".
 */</comment>
<function><type><name>bool</name></type>
<name>SlruScanDirCbReportPresence</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segpage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cutoffPage</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>cutoffPage</name> <operator>-=</operator> <name>cutoffPage</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name><name>ctl</name><operator>-&gt;</operator><name>PagePrecedes</name></name><argument_list>(<argument><expr><name>segpage</name></expr></argument>, <argument><expr><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* found one; don't iterate any more */</comment>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* keep going */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * SlruScanDirectory callback.
 *		This callback deletes segments prior to the one passed in as "data".
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SlruScanDirCbDeleteCutoff</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segpage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cutoffPage</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name><name>ctl</name><operator>-&gt;</operator><name>PagePrecedes</name></name><argument_list>(<argument><expr><name>segpage</name></expr></argument>, <argument><expr><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SlruInternalDeleteSegment</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* keep going */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * SlruScanDirectory callback.
 *		This callback deletes all segments.
 */</comment>
<function><type><name>bool</name></type>
<name>SlruScanDirCbDeleteAll</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segpage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SlruInternalDeleteSegment</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* keep going */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Scan the SimpleLRU directory and apply a callback to each file found in it.
 *
 * If the callback returns true, the scan is stopped.  The last return value
 * from the callback is returned.
 *
 * The callback receives the following arguments: 1. the SlruCtl struct for the
 * slru being truncated; 2. the filename being considered; 3. the page number
 * for the first page of that file; 4. a pointer to the opaque data given to us
 * by the caller.
 *
 * Note that the ordering in which the directory is scanned is not guaranteed.
 *
 * Note that no locking is applied.
 */</comment>
<function><type><name>bool</name></type>
<name>SlruScanDirectory</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>SlruScanCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>cldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>clde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segpage</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cldir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>clde</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>cldir</name></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name>len</name> <operator>==</operator> <literal type="number">5</literal> <operator>||</operator> <name>len</name> <operator>==</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>strspn</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"0123456789ABCDEF"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>segpage</name> <operator>=</operator> <name>segno</name> <operator>*</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"SlruScanDirectory invoking callback on %s/%s"</literal></expr></argument>,
				 <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>callback</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>segpage</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>retval</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>cldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>
</unit>
