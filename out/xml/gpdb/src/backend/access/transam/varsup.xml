<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/transam/varsup.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * varsup.c
 *	  postgres OID &amp; XID variables support routines
 *
 * Copyright (c) 2000-2019, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/access/transam/varsup.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/clog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/commit_ts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/subtrans.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/distributedlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>

<comment type="block">/* Number of OIDs to prefetch (preallocate) per XLOG write */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAR_OID_PREFETCH</name></cpp:macro>		<cpp:value>8192</cpp:value></cpp:define>

<comment type="block">/* pointer to "variable cache" in shared memory (set up by shmem.c) */</comment>
<decl_stmt><decl><type><name>VariableCache</name></type> <name>ShmemVariableCache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>xid_stop_limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>xid_warn_limit</name></decl>;</decl_stmt>

<comment type="block">/*
 * Allocate the next FullTransactionId for a new transaction or
 * subtransaction.
 *
 * The new XID is also stored into MyPgXact before returning.
 *
 * Note: when this is called, we are actually already inside a valid
 * transaction, since XIDs are now not allocated until the transaction
 * does something.  So it is safe to do a database lookup if we want to
 * issue a warning about XID wrap.
 */</comment>
<function><type><name>FullTransactionId</name></type>
<name>GetNewTransactionId</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isSubXact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>full_xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Workers synchronize transaction state at the beginning of each parallel
	 * operation, so we can't account for new XIDs after that point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot assign TransactionIds during a parallel operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * During bootstrap initialization, we return the special bootstrap
	 * transaction id.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isSubXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>BootstrapTransactionId</name></expr>;</expr_stmt>
		<return>return <expr><call><name>FullTransactionIdFromEpochAndXid</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BootstrapTransactionId</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* safety check, we should never get this far in a HS standby */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot assign TransactionIds during recovery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>full_xid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name>full_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*----------
	 * Check to see if it's safe to assign another XID.  This protects against
	 * catastrophic data loss due to XID wraparound.  The basic rules are:
	 *
	 * If we're past xidVacLimit, start trying to force autovacuum cycles.
	 * If we're past xidWarnLimit, start issuing warnings.
	 * If we're past xidStopLimit, refuse to execute transactions, unless
	 * we are running in single-user mode (which gives an escape hatch
	 * to the DBA who somehow got past the earlier defenses).
	 *
	 * Note that this coding also appears in GetNewMultiXactId.
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidVacLimit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For safety's sake, we release XidGenLock while sending signals,
		 * warnings, etc.  This is not so much because we care about
		 * preserving concurrency in this situation, as to avoid any
		 * possibility of deadlock while doing get_database_name(). First,
		 * copy all the shared values we'll need in this path.
		 */</comment>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidWarnLimit</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidWarnLimit</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidStopLimit</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidStopLimit</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidWrapLimit</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidWrapLimit</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>oldest_datoid</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXidDB</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * To avoid swamping the postmaster with signals, we issue the autovac
		 * request only once per 64K transaction starts.  This still gives
		 * plenty of chances before we get into real trouble.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>xid</name> <operator>%</operator> <literal type="number">65536</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_LAUNCHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator>
			<call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>xidStopLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldest_datname</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			 <comment type="block">/*
			  * In GPDB, don't say anything about old prepared transactions, because the system
			  * only uses prepared transactions internally. PREPARE TRANSACTION is not available
			  * to users.
			  */</comment>

			<comment type="block">/* complain even if that DB has disappeared */</comment>
			<if_stmt><if>if <condition>(<expr><name>oldest_datname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database is not accepting commands to avoid wraparound data loss in database \"%s\""</literal></expr></argument>,
								<argument><expr><name>oldest_datname</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Shutdown Greenplum Database. Lower the xid_stop_limit GUC. Execute a database-wide VACUUM in that database. Reset the xid_stop_limit GUC."</literal></expr></argument>
								 )</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database is not accepting commands to avoid wraparound data loss in database with OID %u"</literal></expr></argument>,
								<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Shutdown Greenplum Database. Lower the xid_stop_limit GUC. Execute a database-wide VACUUM in that database. Reset the xid_stop_limit GUC."</literal></expr></argument>
								 )</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>xidWarnLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldest_datname</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			 <comment type="block">/*
			  * In GPDB, don't say anything about old prepared transactions, because the system
			  * only uses prepared transactions internally. PREPARE TRANSACTION is not available
			  * to users.
			  */</comment>

			<comment type="block">/* complain even if that DB has disappeared */</comment>
			<if_stmt><if>if <condition>(<expr><name>oldest_datname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" must be vacuumed within %u transactions"</literal></expr></argument>,
								<argument><expr><name>oldest_datname</name></expr></argument>,
								<argument><expr><name>xidWrapLimit</name> <operator>-</operator> <name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
								 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database with OID %u must be vacuumed within %u transactions"</literal></expr></argument>,
								<argument><expr><name>oldest_datoid</name></expr></argument>,
								<argument><expr><name>xidWrapLimit</name> <operator>-</operator> <name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
								 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Re-acquire lock and start over */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>full_xid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name>full_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we are allocating the first XID of a new page of the commit log,
	 * zero out that commit-log page before returning. We must do this while
	 * holding XidGenLock, else another xact could acquire and commit a later
	 * XID before we zero the page.  Fortunately, a page of the commit log
	 * holds 32K or more transactions, so we don't have to do this very often.
	 *
	 * Extend pg_subtrans and pg_commit_ts too.
	 */</comment>
	<expr_stmt><expr><call><name>ExtendCLOG</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExtendCommitTs</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExtendSUBTRANS</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DistributedLog_Extend</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now advance the nextFullXid counter.  This must not happen until after
	 * we have successfully completed ExtendCLOG() --- if that routine fails,
	 * we want the next incoming transaction to try it again.  We cannot
	 * assign more XIDs until there is CLOG space for them.
	 */</comment>
	<expr_stmt><expr><call><name>FullTransactionIdAdvance</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To aid testing, you can set the debug_burn_xids GUC, to consume XIDs
	 * faster. If set, we bump the XID counter to the next value divisible by
	 * 4096, minus one. The idea is to skip over "boring" XID ranges, but
	 * still step through XID wraparound, CLOG page boundaries etc. one XID
	 * at a time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Debug_burn_xids</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>xx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>r</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Based on the minimum of ENTRIES_PER_PAGE (DistributedLog),
		 * SUBTRANS_XACTS_PER_PAGE, CLOG_XACTS_PER_PAGE.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>uint64</name></type>      <name>page_extend_limit</name> <init>= <expr><literal type="number">4</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>xx</name> <operator>=</operator> <call><name>U64FromFullTransactionId</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <name>xx</name> <operator>%</operator> <name>page_extend_limit</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>r</name> <operator>&lt;</operator> <operator>(</operator><name>page_extend_limit</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>xx</name> <operator>+=</operator> <name>page_extend_limit</name> <operator>-</operator> <name>r</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>xx</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We must store the new XID into the shared ProcArray before releasing
	 * XidGenLock.  This ensures that every active XID older than
	 * latestCompletedXid is present in the ProcArray, which is essential for
	 * correct OldestXmin tracking; see src/backend/access/transam/README.
	 *
	 * Note that readers of PGXACT xid fields should be careful to fetch the
	 * value only once, rather than assume they can read a value multiple
	 * times and get the same answer each time.  Note we are assuming that
	 * TransactionId and int fetch/store are atomic.
	 *
	 * The same comments apply to the subxact xid count and overflow fields.
	 *
	 * Use of a write barrier prevents dangerous code rearrangement in this
	 * function; other backends could otherwise e.g. be examining my subxids
	 * info concurrently, and we don't want them to see an invalid
	 * intermediate state, such as an incremented nxids before the array entry
	 * is filled.
	 *
	 * Other processes that read nxids should do so before reading xids
	 * elements with a pg_read_barrier() in between, so that they can be sure
	 * not to read an uninitialized array element; see
	 * src/backend/storage/lmgr/README.barrier.
	 *
	 * If there's no room to fit a subtransaction XID into PGPROC, set the
	 * cache-overflowed flag instead.  This forces readers to look in
	 * pg_subtrans to map subtransaction XIDs up to top-level XIDs. There is a
	 * race-condition window, in that the new XID will not appear as running
	 * until its parent link has been placed into pg_subtrans. However, that
	 * will happen before anyone could possibly have a reason to inquire about
	 * the status of the XID, so it seems OK.  (Snapshots taken during this
	 * window *will* include the parent XID, so they will deliver the correct
	 * answer later on when someone does have a reason to inquire.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSubXact</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* LWLockRelease acts as barrier */</comment>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nxids</name> <init>= <expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>nxids</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>nxids</name> <operator>&lt;</operator> <name>PGPROC_MAX_CACHED_SUBXIDS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name><index>[<expr><name>nxids</name></expr>]</index></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>=</operator> <name>nxids</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>overflowed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereportif</name> <argument_list>(<argument><expr><name>gp_log_suboverflow_statement</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Statement caused suboverflow: %s"</literal></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>full_xid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read nextFullXid but don't allocate it.
 */</comment>
<function><type><name>FullTransactionId</name></type>
<name>ReadNextFullTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>fullXid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fullXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>fullXid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Advance nextFullXid to the value after a given xid.  The epoch is inferred.
 * This must only be called during recovery or from two-phase start-up code.
 */</comment>
<function><type><name>void</name></type>
<name>AdvanceNextFullTransactionIdPastXid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>newNextFullXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>next_xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>epoch</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * It is safe to read nextFullXid without a lock, because this is only
	 * called from the startup process or single-process mode, meaning that no
	 * other process can modify it.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AmStartupProcess</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fast return if this isn't an xid high enough to move the needle. */</comment>
	<expr_stmt><expr><name>next_xid</name> <operator>=</operator> <call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>next_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute the FullTransactionId that comes after the given xid.  To do
	 * this, we preserve the existing epoch, but detect when we've wrapped
	 * into a new epoch.  This is necessary because WAL records and 2PC state
	 * currently contain 32 bit xids.  The wrap logic is safe in those cases
	 * because the span of active xids cannot exceed one epoch at any given
	 * point in the WAL stream.
	 */</comment>
	<expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>epoch</name> <operator>=</operator> <call><name>EpochFromFullTransactionId</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>xid</name> <operator>&lt;</operator> <name>next_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>++</operator><name>epoch</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>newNextFullXid</name> <operator>=</operator> <call><name>FullTransactionIdFromEpochAndXid</name><argument_list>(<argument><expr><name>epoch</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We still need to take a lock to modify the value when there are
	 * concurrent readers.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name> <operator>=</operator> <name>newNextFullXid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Advance the cluster-wide value for the oldest valid clog entry.
 *
 * We must acquire CLogTruncationLock to advance the oldestClogXid. It's not
 * necessary to hold the lock during the actual clog truncation, only when we
 * advance the limit, as code looking up arbitrary xids is required to hold
 * CLogTruncationLock from when it tests oldestClogXid through to when it
 * completes the clog lookup.
 */</comment>
<function><type><name>void</name></type>
<name>AdvanceOldestClogXid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>oldest_datfrozenxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>CLogTruncationLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestClogXid</name></name></expr></argument>,
							  <argument><expr><name>oldest_datfrozenxid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestClogXid</name></name> <operator>=</operator> <name>oldest_datfrozenxid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CLogTruncationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the last safe XID to allocate using the currently oldest
 * datfrozenxid (ie, the oldest XID that might exist in any database
 * of our cluster), and the OID of the (or a) database with that value.
 */</comment>
<function><type><name>void</name></type>
<name>SetTransactionIdLimit</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>oldest_datfrozenxid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldest_datoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidVacLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidWarnLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidStopLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidWrapLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>curXid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>oldest_datfrozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The place where we actually get into deep trouble is halfway around
	 * from the oldest potentially-existing XID.  (This calculation is
	 * probably off by one or two counts, because the special XIDs reduce the
	 * size of the loop a little bit.  But we throw in plenty of slop below,
	 * so it doesn't matter.)
	 */</comment>
	<expr_stmt><expr><name>xidWrapLimit</name> <operator>=</operator> <name>oldest_datfrozenxid</name> <operator>+</operator> <operator>(</operator><name>MaxTransactionId</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xidWrapLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xidWrapLimit</name> <operator>+=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We'll refuse to continue assigning XIDs in interactive mode once we get
	 * within xid_stop_limit transactions of data loss.  This leaves lots of
	 * room for the DBA to fool around fixing things in a standalone backend,
	 * while not being significant compared to total XID space. (Note that since
	 * vacuuming requires one transaction per table cleaned, we had better be
	 * sure there's lots of XIDs left...)
	 */</comment>
	<expr_stmt><expr><name>xidStopLimit</name> <operator>=</operator> <name>xidWrapLimit</name> <operator>-</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator><name>xid_stop_limit</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xidStopLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xidStopLimit</name> <operator>-=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We'll start complaining loudly when we get within xid_warn_limit of
	 * the stop point.  This is kind of arbitrary, but if you let your gas
	 * gauge get down to 1% of full, would you be looking for the next gas
	 * station?  We need to be fairly liberal about this number because there
	 * are lots of scenarios where most transactions are done by automatic
	 * clients that won't pay attention to warnings. (No, we're not gonna make
	 * this configurable.  If you know enough to configure it, you know enough
	 * to not get in this kind of trouble in the first place.)
	 */</comment>
	<expr_stmt><expr><name>xidWarnLimit</name> <operator>=</operator> <name>xidStopLimit</name>  <operator>-</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator><name>xid_warn_limit</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xidWarnLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xidWarnLimit</name> <operator>-=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We'll start trying to force autovacuums when oldest_datfrozenxid gets
	 * to be more than autovacuum_freeze_max_age transactions old.
	 *
	 * Note: guc.c ensures that autovacuum_freeze_max_age is in a sane range,
	 * so that xidVacLimit will be well before xidWarnLimit.
	 *
	 * Note: autovacuum_freeze_max_age is a PGC_POSTMASTER parameter so that
	 * we don't have to worry about dealing with on-the-fly changes in its
	 * value.  It doesn't look practical to update shared state from a GUC
	 * assign hook (too many processes would try to execute the hook,
	 * resulting in race conditions as well as crashes of those not connected
	 * to shared memory).  Perhaps this can be improved someday.  See also
	 * SetMultiXactIdLimit.
	 */</comment>
	<expr_stmt><expr><name>xidVacLimit</name> <operator>=</operator> <name>oldest_datfrozenxid</name> <operator>+</operator> <name>autovacuum_freeze_max_age</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xidVacLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xidVacLimit</name> <operator>+=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Grab lock for just long enough to set the new limit values */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXid</name></name> <operator>=</operator> <name>oldest_datfrozenxid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidVacLimit</name></name> <operator>=</operator> <name>xidVacLimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidWarnLimit</name></name> <operator>=</operator> <name>xidWarnLimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidStopLimit</name></name> <operator>=</operator> <name>xidStopLimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidWrapLimit</name></name> <operator>=</operator> <name>xidWrapLimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXidDB</name></name> <operator>=</operator> <name>oldest_datoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>curXid</name> <operator>=</operator> <call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Log the info */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction ID wrap limit is %u, limited by database with OID %u"</literal></expr></argument>,
					<argument><expr><name>xidWrapLimit</name></expr></argument>, <argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If past the autovacuum force point, immediately signal an autovac
	 * request.  The reason for this is that autovac only processes one
	 * database per invocation.  Once it's finished cleaning up the oldest
	 * database, it'll call here, and we'll signal the postmaster to start
	 * another iteration immediately if there are still any old databases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>curXid</name></expr></argument>, <argument><expr><name>xidVacLimit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>InRecovery</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_LAUNCHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Give an immediate warning if past the wrap warn point */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>curXid</name></expr></argument>, <argument><expr><name>xidWarnLimit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>InRecovery</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldest_datname</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We can be called when not inside a transaction, for example during
		 * StartupXLOG().  In such a case we cannot do database access, so we
		 * must just report the oldest DB's OID.
		 *
		 * Note: it's also possible that get_database_name fails and returns
		 * NULL, for example because the database just got dropped.  We'll
		 * still warn, even though the warning might now be unnecessary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldest_datname</name> <operator>=</operator> <call><name>get_database_name</name><argument_list>(<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldest_datname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>oldest_datname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" must be vacuumed within %u transactions"</literal></expr></argument>,
							<argument><expr><name>oldest_datname</name></expr></argument>,
							<argument><expr><name>xidWrapLimit</name> <operator>-</operator> <name>curXid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
							 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database with OID %u must be vacuumed within %u transactions"</literal></expr></argument>,
							<argument><expr><name>oldest_datoid</name></expr></argument>,
							<argument><expr><name>xidWrapLimit</name> <operator>-</operator> <name>curXid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
							 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ForceTransactionIdLimitUpdate -- does the XID wrap-limit data need updating?
 *
 * We primarily check whether oldestXidDB is valid.  The cases we have in
 * mind are that that database was dropped, or the field was reset to zero
 * by pg_resetwal.  In either case we should force recalculation of the
 * wrap limit.  Also do it if oldestXid is old enough to be forcing
 * autovacuums or other actions; this ensures we update our state as soon
 * as possible once extra overhead is being incurred.
 */</comment>
<function><type><name>bool</name></type>
<name>ForceTransactionIdLimitUpdate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>nextXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidVacLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldestXidDB</name></decl>;</decl_stmt>

	<comment type="block">/* Locking is probably not really necessary, but let's be careful */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextXid</name> <operator>=</operator> <call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextFullXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xidVacLimit</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidVacLimit</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldestXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldestXidDB</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXidDB</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>oldestXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* shouldn't happen, but just in case */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xidVacLimit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* this shouldn't happen anymore either */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>nextXid</name></expr></argument>, <argument><expr><name>xidVacLimit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* past VacLimit, don't delay updating */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>DATABASEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oldestXidDB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* could happen, per comments above */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Requires OidGenLock to be held by caller.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>GetNewObjectIdUnderLock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* safety check, we should never get this far in a HS standby */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot assign OIDs during recovery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for wraparound of the OID counter.  We *must* not return 0
	 * (InvalidOid), and in normal operation we mustn't return anything below
	 * FirstNormalObjectId since that range is reserved for initdb (see
	 * IsCatalogRelationOid()).  Note we are relying on unsigned comparison.
	 *
	 * During initdb, we start the OID generator at FirstBootstrapObjectId, so
	 * we only wrap if before that point when in bootstrap or standalone mode.
	 * The first time through this routine after normal postmaster start, the
	 * counter will be forced up to FirstNormalObjectId.  This mechanism
	 * leaves the OIDs between FirstBootstrapObjectId and FirstNormalObjectId
	 * available for automatic assignment during initdb, while ensuring they
	 * will never conflict with user-assigned OIDs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstNormalObjectId</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>IsPostmasterEnvironment</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* wraparound, or first post-initdb assignment, in normal mode */</comment>
			<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>=</operator> <name>FirstNormalObjectId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* we may be bootstrapping, so don't enforce the full range */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstBootstrapObjectId</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* wraparound in standalone mode (unlikely but possible) */</comment>
				<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>=</operator> <name>FirstNormalObjectId</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we run out of logged for use oids then we must log more */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogPutNextOid</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>+</operator> <name>VAR_OID_PREFETCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <name>VAR_OID_PREFETCH</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"bump_oid"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * CDB: we encounter high oid issues several times, we should
		 * have some test-utils to verify logic under larger oid.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <name>PG_INT32_MAX</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>PG_INT32_MAX</name> <operator>+</operator> <name>result</name> <operator>%</operator> <operator>(</operator><name>PG_UINT32_MAX</name> <operator>-</operator> <name>PG_INT32_MAX</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetNewObjectId -- allocate a new OID
 *
 * OIDs are generated by a cluster-wide counter. Since they are only
 * 32 bits wide, counter wraparound will occur eventually, and
 * therefore it is unwise to assume they are unique unless precautions
 * are taken to make them so. Hence, this routine should generally not
 * be used directly. The only direct callers should be GetNewOid() and
 * GetNewOidWithIndex() in catalog/catalog.c. It's also called from
 * cdb_sync_oid_to_segments() in cdb/cdboidsync.c to synchronize the
 * OID counter on the QD with its QEs.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetNewObjectId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>GetNewObjectIdUnderLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AdvanceObjectId -- advance object id counter for QD and QE nodes
 *
 * When advancing the Oid counter of a QD, it should only be for the purpose
 * of syncing Oid counters logically compared with the numeric maximum Oid
 * counter value among the primary segments.
 *
 * When advancing the Oid counter of a QE, the QD provides the preassigned OID
 * to the QE nodes which will be used as the relation's OID. QE nodes do not
 * use this OID as the relfilenode value anymore so the OID counter is not
 * incremented. This function forcefully increments the QE node's OID counter
 * to be about the same as the OID provided by the QD node.
 */</comment>
<function><type><name>void</name></type>
<name>AdvanceObjectId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>newOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidFollowsNextOid</name><argument_list>(<argument><expr><name>newOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type> <name>nextOidDifference</name> <init>= <expr><operator>(</operator><name>int32</name><operator>)</operator><operator>(</operator><name>newOid</name> <operator>-</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We directly set the nextOid counter to the given OID instead of
		 * doing incremental calls to GetNewObjectIdUnderLock(). Update the
		 * oidCount to VAR_OID_PREFETCH and create an xlog if we have
		 * exhausted the current oidCount. We should always be moving forward
		 * and never backwards.
		 */</comment>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>=</operator> <name>newOid</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nextOidDifference</name> <operator>&gt;=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogPutNextOid</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>+</operator> <name>VAR_OID_PREFETCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <name>VAR_OID_PREFETCH</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>-=</operator> <name>nextOidDifference</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Requires RelfilenodeGenLock to be held by caller.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>GetNewSegRelfilenodeUnderLock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>RelfilenodeGenLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextRelfilenode</name></name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstNormalObjectId</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>IsPostmasterEnvironment</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* wraparound in normal environment */</comment>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextRelfilenode</name></name> <operator>=</operator> <name>FirstNormalObjectId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>relfilenodeCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>relfilenodeCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogPutNextRelfilenode</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextRelfilenode</name></name> <operator>+</operator> <name>VAR_OID_PREFETCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>relfilenodeCount</name></name> <operator>=</operator> <name>VAR_OID_PREFETCH</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextRelfilenode</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextRelfilenode</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>relfilenodeCount</name></name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetNewSegRelfilenode -- allocate a new relfilenode value
 *
 * Similar to GetNewObjectId but for relfilenodes. This function has its own
 * separate counter and is used to allocate relfilenode values instead of
 * trying to use the newly generated OIDs (QD) or preassigned OIDs (QE) as the
 * relfilenode.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetNewSegRelfilenode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>RelfilenodeGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>GetNewSegRelfilenodeUnderLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>RelfilenodeGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Is the given Oid logically &gt; ShmemVariableCache-&gt;nextOid?
 */</comment>
<function><type><name>bool</name></type>
<name>OidFollowsNextOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>diff</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>diff</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>id</name> <operator>-</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>diff</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
