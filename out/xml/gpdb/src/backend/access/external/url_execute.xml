<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/external/url_execute.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * url_execute.c
 *	  Core support for opening external relations via a URL execute
 *
 * Portions Copyright (c) 2007-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 * IDENTIFICATION
 *	  src/backend/access/external/url_execute.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/url.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/execute_pipe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbtimer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_DATA_P</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> <comment type="block">/* index to data pipe */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_ERR_P</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> <comment type="block">/* index to error pipe  */</comment>

<comment type="block">/*
 * This struct encapsulates the resources that need to be explicitly cleaned up
 * on error. We use the resource owner mechanism to make sure
 * these are not leaked. When a ResourceOwner is released, our hook will
 * walk the list of open curlhandles, and releases any that were owned by
 * the released resource owner.
 *
 * On abort, we need to close the pipe FDs, and wait for the subprocess to
 * exit.
 */</comment>
<typedef>typedef <type><struct>struct <name>execute_handle_t</name>
<block>{
	<comment type="block">/*
	 * PID of the open sub-process, and pipe FDs to communicate with it.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>pipes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* only out and err needed */</comment>

	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl>;</decl_stmt>	<comment type="block">/* owner of this handle */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>execute_handle_t</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>execute_handle_t</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
}</block></struct></type> <name>execute_handle_t</name>;</typedef>

<comment type="block">/*
 * Private state for an EXECUTE external table.
 */</comment>
<typedef>typedef <type><struct>struct <name>URL_EXECUTE_FILE</name>
<block>{
	<decl_stmt><decl><type><name>URL_FILE</name></type>	<name>common</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>shexec</name></decl>;</decl_stmt>			<comment type="block">/* shell command-line */</comment>

	<decl_stmt><decl><type><name>execute_handle_t</name> <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>	<comment type="block">/* ResourceOwner-tracked stuff */</comment>
}</block></struct></type> <name>URL_EXECUTE_FILE</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pclose_without_stderr</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rwepipe</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>interpretError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>exitCode</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buflen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>errlen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getSignalNameFromCode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cleanup_execute_handle</name><parameter_list>(<parameter><decl><type><name>execute_handle_t</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Linked list of open "handles". These are allocated in TopMemoryContext,
 * and tracked by resource owners.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>execute_handle_t</name> <modifier>*</modifier></type><name>open_execute_handles</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>execute_resowner_callback_registered</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>execute_handle_t</name> <modifier>*</modifier></type>
<name>create_execute_handle</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>execute_handle_t</name> <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>execute_handle_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><name>EXEC_DATA_P</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><name>EXEC_ERR_P</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>open_execute_handles</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>open_execute_handles</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>open_execute_handles</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>open_execute_handles</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>

	<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close any open handles on abort.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>destroy_execute_handle</name><parameter_list>(<parameter><decl><type><name>execute_handle_t</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>hpid</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>pid</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cleanup_execute_handle</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>waitpid</name><argument_list>(<argument><expr><name>hpid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * Cleanup open handles.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup_execute_handle</name><parameter_list>(<parameter><decl><type><name>execute_handle_t</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* unlink from linked list first */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>open_execute_handles</name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><name>EXEC_DATA_P</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><name>EXEC_DATA_P</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We don't bother reading possible error message from the pipe */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><name>EXEC_ERR_P</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><name>EXEC_ERR_P</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Close any open handles on abort.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>execute_abort_callback</name><parameter_list>(<parameter><decl><type><name>ResourceReleasePhase</name></type> <name>phase</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>,
					   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>execute_handle_t</name> <modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>execute_handle_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>phase</name> <operator>!=</operator> <name>RESOURCE_RELEASE_AFTER_LOCKS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>next</name> <operator>=</operator> <name>open_execute_handles</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>next</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>curr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>curr</name><operator>-&gt;</operator><name>owner</name></name> <operator>==</operator> <name>CurrentResourceOwner</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"execute-type external table reference leak: %p still referenced"</literal></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>destroy_execute_handle</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_export</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>ch</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Shell-quote the value so that we don't need to escape other special char
	 * except single quote and backslash. (We assume the variable name doesn't contain
	 * funny characters.
	 *
	 * Every single-quote is replaced with '\''. For example, value
	 * foo'bar becomes 'foo'\''bar'.
	 *
	 * Don't need to escape backslash, although using echo will behave differently on
	 * different platforms. It's better to write as: /usr/bin/env bash -c 'echo -E "$VAR"'.
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s='"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>( <init>;</init> <condition><expr><literal type="number">0</literal> <operator>!=</operator> <operator>(</operator><name>ch</name> <operator>=</operator> <operator>*</operator><name>value</name><operator>)</operator></expr>;</condition> <incr><expr><name>value</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\'\\\'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"' &amp;&amp; export %s &amp;&amp; "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>char</name> <modifier>*</modifier></type>
<name>make_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>extvar_t</name> <modifier>*</modifier></type><name>ev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_MASTER_HOST"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_MASTER_HOST</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_MASTER_PORT"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_MASTER_PORT</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_SEG_PG_CONF"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_SEG_PG_CONF</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_SEG_DATADIR"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_SEG_DATADIR</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_DATABASE"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_DATABASE</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_USER"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_USER</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_DATE"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_DATE</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_TIME"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_TIME</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_XID"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_XID</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_CID"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_CID</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_SN"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_SN</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_SEGMENT_ID"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_SEGMENT_ID</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_SEG_PORT"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_SEG_PORT</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_SESSION_ID"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_SESSION_ID</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_SEGMENT_COUNT"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_SEGMENT_COUNT</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_export</name><argument_list>(<argument><expr><literal type="string">"GP_QUERY_STRING"</literal></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>GP_QUERY_STRING</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * execute_fopen()
 *
 * refactor the fopen code for execute into this routine
 */</comment>
<function><type><name>URL_FILE</name> <modifier>*</modifier></type>
<name>url_execute_fopen</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>url</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forwrite</name></decl></parameter>, <parameter><decl><type><name>extvar_t</name> <modifier>*</modifier></type><name>ev</name></decl></parameter>, <parameter><decl><type><name>CopyState</name></type> <name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>URL_EXECUTE_FILE</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>itimers</name></name></type> <name>savetimers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pqsigfunc</name></type>	<name>save_SIGPIPE</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>

	<comment type="block">/* Execute command */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>EXEC_URL_PREFIX</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>EXEC_URL_PREFIX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmd</name>  <operator>=</operator> <name>url</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>EXEC_URL_PREFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>URL_EXECUTE_FILE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>file</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>CFTYPE_EXEC</name></expr>;</expr_stmt>	<comment type="block">/* marked as a EXEC */</comment>
	<expr_stmt><expr><name><name>file</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>url</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>file</name><operator>-&gt;</operator><name>shexec</name></name> <operator>=</operator> <call><name>make_command</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* Execute command */</comment>

	<comment type="block">/* Clear process interval timers */</comment>
	<expr_stmt><expr><call><name>resetTimers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>savetimers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>execute_resowner_callback_registered</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RegisterResourceReleaseCallback</name><argument_list>(<argument><expr><name>execute_abort_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>execute_resowner_callback_registered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>file</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <call><name>create_execute_handle</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Preserve the SIGPIPE handler and set to default handling.  This
	 * allows "normal" SIGPIPE handling in the command pipeline.  Normal
	 * for PG is to *ignore* SIGPIPE.
	 */</comment>
	<expr_stmt><expr><name>save_SIGPIPE</name> <operator>=</operator> <call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* execute the user command */</comment>
	<expr_stmt><expr><name><name>file</name><operator>-&gt;</operator><name>handle</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <call><name>popen_with_stderr</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>handle</name><operator>-&gt;</operator><name>pipes</name></name></expr></argument>,
										  <argument><expr><name><name>file</name><operator>-&gt;</operator><name>shexec</name></name></expr></argument>,
										  <argument><expr><name>forwrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

	<comment type="block">/* Restore the SIGPIPE handler */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>save_SIGPIPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore process interval timers */</comment>
	<expr_stmt><expr><call><name>restoreTimers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>savetimers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"EXTERNAL TABLE EXECUTE Command: %s"</literal></expr></argument>, <argument><expr><name><name>file</name><operator>-&gt;</operator><name>shexec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>file</name><operator>-&gt;</operator><name>handle</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot start external table command: %m"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Command: %s"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>URL_FILE</name> <operator>*</operator><operator>)</operator> <name>file</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>url_execute_fclose</name><parameter_list>(<parameter><decl><type><name>URL_FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>failOnError</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>URL_EXECUTE_FILE</name> <modifier>*</modifier></type><name>efile</name> <init>= <expr><operator>(</operator><name>URL_EXECUTE_FILE</name> <operator>*</operator><operator>)</operator> <name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>url</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* close the child process and related pipes */</comment>
	<if_stmt><if>if<condition>(<expr><name>failOnError</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pclose_with_stderr</name><argument_list>(<argument><expr><name><name>efile</name><operator>-&gt;</operator><name>handle</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>efile</name><operator>-&gt;</operator><name>handle</name><operator>-&gt;</operator><name>pipes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pclose_without_stderr</name><argument_list>(<argument><expr><name><name>efile</name><operator>-&gt;</operator><name>handle</name><operator>-&gt;</operator><name>pipes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>cleanup_execute_handle</name><argument_list>(<argument><expr><name><name>efile</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>efile</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>url</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>file</name><operator>-&gt;</operator><name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pclose() ended successfully; no errors to reflect */</comment>
		<empty_stmt>;</empty_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pclose()/wait4() ended with an error; errno should be valid */</comment>
		<if_stmt><if>if <condition>(<expr><name>failOnError</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>failOnError</name></expr> ?</condition><then> <expr><name>ERROR</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary><operator>)</operator></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot close external table %s command: %m"</literal></expr></argument>,
						<argument><expr><operator>(</operator><ternary><condition><expr><name>relname</name></expr> ?</condition><then> <expr><name>relname</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"command: %s"</literal></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * pclose() returned the process termination state.  The interpretExitCode() function
		 * generates a descriptive message from the exit code.
		 */</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>failOnError</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>failOnError</name></expr> ?</condition><then> <expr><name>ERROR</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary><operator>)</operator></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_EXTERNAL_ROUTINE_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"external table %s command ended with %s"</literal></expr></argument>,
						<argument><expr><operator>(</operator><ternary><condition><expr><name>relname</name></expr> ?</condition><then> <expr><name>relname</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						<argument><expr><call><name>interpretError</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>sinfo</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>sinfo</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Command: %s"</literal></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sinfo</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>url_execute_feof</name><parameter_list>(<parameter><decl><type><name>URL_FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bytesread</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>bytesread</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>url_execute_ferror</name><parameter_list>(<parameter><decl><type><name>URL_FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bytesread</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ebuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ebuflen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>URL_EXECUTE_FILE</name> <modifier>*</modifier></type><name>efile</name> <init>= <expr><operator>(</operator><name>URL_EXECUTE_FILE</name> <operator>*</operator><operator>)</operator> <name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nread</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>bytesread</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>ret</name> <operator>==</operator> <name>true</name> <operator>&amp;&amp;</operator> <name>ebuflen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ebuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Read one byte less than the maximum size to ensure zero
		 * termination of the buffer.
		 */</comment>
<label><name>reread</name>:</label>
		<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>efile</name><operator>-&gt;</operator><name>handle</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><name>EXEC_ERR_P</name></expr>]</index></name></expr></argument>, <argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>ebuflen</name> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>nread</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>reread</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name>nread</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ebuf</name><index>[<expr><name>nread</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>,<argument><expr><literal type="string">"error string unavailable due to read error"</literal></expr></argument>,<argument><expr><name>ebuflen</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>url_execute_fread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>URL_FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>CopyState</name></type> <name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>URL_EXECUTE_FILE</name> <modifier>*</modifier></type><name>efile</name> <init>= <expr><operator>(</operator><name>URL_EXECUTE_FILE</name> <operator>*</operator><operator>)</operator> <name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>rerun</name></decl>;</decl_stmt>

	<do>do <block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>efile</name><operator>-&gt;</operator><name>handle</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><name>EXEC_DATA_P</name></expr>]</index></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rerun</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>rerun</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>rerun</name></expr>)</condition>;</do>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>url_execute_fwrite</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>URL_FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>CopyState</name></type> <name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>URL_EXECUTE_FILE</name> <modifier>*</modifier></type><name>efile</name> <init>= <expr><operator>(</operator><name>URL_EXECUTE_FILE</name> <operator>*</operator><operator>)</operator> <name>file</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><name><name>efile</name><operator>-&gt;</operator><name>handle</name><operator>-&gt;</operator><name>pipes</name><index>[<expr><name>EXEC_DATA_P</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator> <operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
    <comment type="block">/* ensure all data in buffer is send out to pipe*/</comment>
    <while>while<condition>(<expr><name>size</name> <operator>&gt;</operator> <name>offset</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>size</name> <operator>-</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>ptr</name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>(<expr><name>offset</name> <operator>&lt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,<argument><expr><literal type="string">"partial write, expected %lu, written %lu"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * interpretError - formats a brief message and/or the exit code from pclose()
 * 		(or wait4()).
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>interpretError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buflen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>errlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>exitCode</name> <init>= <expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>exitCode</name> <operator>&gt;=</operator> <literal type="number">128</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the exit code has the 128-bit set, the exit code represents
			 * a shell exited by signal where the signal number is exitCode - 128.
			 */</comment>
			<expr_stmt><expr><name>exitCode</name> <operator>-=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><literal type="string">"SHELL TERMINATED by signal %s (%d)"</literal></expr></argument>, <argument><expr><call><name>getSignalNameFromCode</name><argument_list>(<argument><expr><name>exitCode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exitCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>exitCode</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><literal type="string">"EXITED; rc=%d"</literal></expr></argument>, <argument><expr><name>exitCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Exit codes from commands rarely map to strerror() strings. In here
			 * we show the error string returned from pclose, and omit the non
			 * friendly exit code interpretation */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><literal type="string">"error. %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>signalCode</name> <init>= <expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><literal type="string">"TERMINATED by signal %s (%d)"</literal></expr></argument>, <argument><expr><call><name>getSignalNameFromCode</name><argument_list>(<argument><expr><name>signalCode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>signalCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if type="elseif">else if <condition>(<expr><call><name>WIFSTOPPED</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>signalCode</name> <init>= <expr><call><name>WSTOPSIG</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><literal type="string">"STOPPED by signal %s (%d)"</literal></expr></argument>, <argument><expr><call><name>getSignalNameFromCode</name><argument_list>(<argument><expr><name>signalCode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>signalCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><literal type="string">"UNRECOGNIZED termination; rc=%#x"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>


<struct>struct <name>signalDef</name> <block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>			<name>signalCode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>		   <modifier>*</modifier></type><name>signalName</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Table mapping signal numbers to signal identifiers (names).
 */</comment>
<decl_stmt><decl><type><name><name>struct</name> <name>signalDef</name></name></type> <name><name>signals</name><index>[]</index></name> <init>= <expr><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGHUP</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGHUP</name></expr>,    <expr><literal type="string">"SIGHUP"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGINT</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGINT</name></expr>,    <expr><literal type="string">"SIGINT"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGQUIT</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGQUIT</name></expr>,   <expr><literal type="string">"SIGQUIT"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGILL</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGILL</name></expr>,    <expr><literal type="string">"SIGILL"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGTRAP</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGTRAP</name></expr>,   <expr><literal type="string">"SIGTRAP"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGABRT</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGABRT</name></expr>,   <expr><literal type="string">"SIGABRT"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGEMT</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGEMT</name></expr>,    <expr><literal type="string">"SIGEMT"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGFPE</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGFPE</name></expr>,    <expr><literal type="string">"SIGFPE"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGKILL</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGKILL</name></expr>,   <expr><literal type="string">"SIGKILL"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGBUS</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGBUS</name></expr>,    <expr><literal type="string">"SIGBUS"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGSEGV</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGSEGV</name></expr>,   <expr><literal type="string">"SIGSEGV"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGSYS</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGSYS</name></expr>,    <expr><literal type="string">"SIGSYS"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGPIPE</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGPIPE</name></expr>,   <expr><literal type="string">"SIGPIPE"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGALRM</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGALRM</name></expr>,   <expr><literal type="string">"SIGALRM"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGTERM</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGTERM</name></expr>,   <expr><literal type="string">"SIGTERM"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGURG</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGURG</name></expr>,    <expr><literal type="string">"SIGURG"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGSTOP</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGSTOP</name></expr>,   <expr><literal type="string">"SIGSTOP"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGTSTP</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGTSTP</name></expr>,   <expr><literal type="string">"SIGTSTP"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGCONT</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGCONT</name></expr>,   <expr><literal type="string">"SIGCONT"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGCHLD</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGCHLD</name></expr>,   <expr><literal type="string">"SIGCHLD"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGTTIN</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGTTIN</name></expr>,   <expr><literal type="string">"SIGTTIN"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGTTOU</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGTTOU</name></expr>,   <expr><literal type="string">"SIGTTOU"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGIO</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGIO</name></expr>,     <expr><literal type="string">"SIGIO"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGXCPU</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGXCPU</name></expr>,   <expr><literal type="string">"SIGXCPU"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGXFSZ</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGXFSZ</name></expr>,   <expr><literal type="string">"SIGXFSZ"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGVTALRM</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGVTALRM</name></expr>, <expr><literal type="string">"SIGVTALRM"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGPROF</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGPROF</name></expr>,   <expr><literal type="string">"SIGPROF"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGWINCH</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGWINCH</name></expr>,  <expr><literal type="string">"SIGWINCH"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGINFO</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGINFO</name></expr>,   <expr><literal type="string">"SIGINFO"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGUSR1</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGUSR1</name></expr>,   <expr><literal type="string">"SIGUSR1"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGUSR2</name></cpp:ifdef>
		<expr><block>{ <expr><name>SIGUSR2</name></expr>,   <expr><literal type="string">"SIGUSR2"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><block>{ <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="string">""</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * getSignalNameFromCode - gets the signal name given the signal number.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getSignalNameFromCode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>signals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>signalCode</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>signals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>signalCode</name> <operator>==</operator> <name>signo</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>signals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>signalName</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><literal type="string">"UNRECOGNIZED"</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pclose_without_stderr
 *
 * close our data and error pipes
 * we don't probe for any error message or suspend the current process.
 * this function is meant for scenarios when the current slice doesn't
 * need to wait for the error message available at the completion of
 * the child process.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pclose_without_stderr</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pipes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>pipes</name><index>[<expr><name>EXEC_DATA_P</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>pipes</name><index>[<expr><name>EXEC_ERR_P</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
