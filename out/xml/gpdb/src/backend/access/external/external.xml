<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/external/external.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * external.c
 *	  routines for getting external info from external table fdw.
 *
 * Portions Copyright (c) 2020-Present VMware, Inc. or its affiliates.
 *
 * IDENTIFICATION
 *	    src/backend/access/external/external.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fstream/gfile.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/external.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsreh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/uri.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>create_external_scan_uri_list</name><parameter_list>(<parameter><decl><type><name>ExtTableEntry</name> <modifier>*</modifier></type><name>ext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>ismasteronly</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>
<name>gfile_printf_then_putc_newline</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>va</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"gfile_printf_then_putc_newline vsnprintf failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>a</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"gfile_printf_then_putc_newline palloc failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>gfile_malloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>gfile_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* transform the locations string to a list */</comment>
<function><type><name>List</name><modifier>*</modifier></type>
<name>TokenizeLocationUris</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>uris</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>uri</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>uris</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>uri</name> <operator>=</operator> <call><name>strsep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uris</name></expr></argument>, <argument><expr><literal type="string">"|"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the entry for an exttable relation (from pg_foreign_table)
 */</comment>
<function><type><name>ExtTableEntry</name><modifier>*</modifier></type>
<name>GetExtTableEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtTableEntry</name> <modifier>*</modifier></type><name>extentry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>extentry</name> <operator>=</operator> <call><name>GetExtTableEntryIfExists</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extentry</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing pg_foreign_table entry for relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>extentry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Like GetExtTableEntry(Oid), but returns NULL instead of throwing
 * an error if no pg_foreign_table entry is found.
 */</comment>
<function><type><name>ExtTableEntry</name><modifier>*</modifier></type>
<name>GetExtTableEntryIfExists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_foreign_table_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>ftkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>ftscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>fttuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtTableEntry</name> <modifier>*</modifier></type><name>extentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>ftoptions_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt><empty_stmt>;</empty_stmt>

	<expr_stmt><expr><name>pg_foreign_table_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ftkey</name></expr></argument>,
				<argument><expr><name>Anum_pg_foreign_table_ftrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ftscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_foreign_table_rel</name></expr></argument>, <argument><expr><name>ForeignTableRelidIndexId</name></expr></argument>,
								<argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ftkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fttuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>ftscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>fttuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>ftscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_foreign_table_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get the foreign table options */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name>ftoptions</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>fttuple</name></expr></argument>,
						   <argument><expr><name>Anum_pg_foreign_table_ftoptions</name></expr></argument>,
						   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_foreign_table_rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* options array is always populated, {} if no options set */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find options for external protocol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>ftoptions_list</name> <operator>=</operator> <call><name>untransformRelOptions</name><argument_list>(<argument><expr><name>ftoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>extentry</name> <operator>=</operator> <call><name>GetExtFromForeignTableOptions</name><argument_list>(<argument><expr><name>ftoptions_list</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Finish up scan and close catalogs */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>ftscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_foreign_table_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>extentry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExtTableEntry</name> <modifier>*</modifier></type>
<name>GetExtFromForeignTableOptions</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ftoptons</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtTableEntry</name>	   <modifier>*</modifier></type><name>extentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>		   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>			   <modifier>*</modifier></type><name>entryOptions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>			   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>fmtcode_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>rejectlimit_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>rejectlimittype_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>logerrors_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>encoding_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>iswritable_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>locationuris_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>command_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>extentry</name> <operator>=</operator> <operator>(</operator><name>ExtTableEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExtTableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ftoptons</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"location_uris"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>extentry</name><operator>-&gt;</operator><name>urilocations</name></name> <operator>=</operator> <call><name>TokenizeLocationUris</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>locationuris_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"execute_on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>extentry</name><operator>-&gt;</operator><name>execlocations</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"command"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>extentry</name><operator>-&gt;</operator><name>command</name></name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>command_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"format_type"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>extentry</name><operator>-&gt;</operator><name>fmtcode</name></name> <operator>=</operator> <name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>fmtcode_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* only CSV format needs this for ProcessCopyOptions(), will do it later */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"reject_limit"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>extentry</name><operator>-&gt;</operator><name>rejectlimit</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rejectlimit_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"reject_limit_type"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>extentry</name><operator>-&gt;</operator><name>rejectlimittype</name></name> <operator>=</operator> <name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rejectlimittype_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"log_errors"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>extentry</name><operator>-&gt;</operator><name>logerrors</name></name> <operator>=</operator> <name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>logerrors_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>extentry</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>encoding_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"is_writable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>extentry</name><operator>-&gt;</operator><name>iswritable</name></name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>iswritable_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>entryOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entryOptions</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* If CSV format was chosen, make it visible to ProcessCopyOptions. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fmttype_is_csv</name><argument_list>(<argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>fmtcode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>entryOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entryOptions</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"format"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"csv"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * external table syntax does have these for sure, but errors could happen
	 * if using foreign table syntax
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fmtcode_found</name> <operator>||</operator> <operator>!</operator><name>logerrors_found</name> <operator>||</operator> <operator>!</operator><name>encoding_found</name> <operator>||</operator> <operator>!</operator><name>iswritable_found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing format, logerrors, encoding or iswritable options for relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>locationuris_found</name> <operator>&amp;&amp;</operator> <name>command_found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"locationuris and command options conflict with each other"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fmttype_is_custom</name><argument_list>(<argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>fmtcode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>fmttype_is_csv</name><argument_list>(<argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>fmtcode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>fmttype_is_text</name><argument_list>(<argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>fmtcode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported format type %d for external table"</literal></expr></argument>, <argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>fmtcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rejectlimit_found</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* mark that no SREH requested */</comment>
		<expr_stmt><expr><name><name>extentry</name><operator>-&gt;</operator><name>rejectlimit</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rejectlimittype_found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>extentry</name><operator>-&gt;</operator><name>rejectlimittype</name></name> <operator>!=</operator> <literal type="char">'r'</literal> <operator>&amp;&amp;</operator> <name><name>extentry</name><operator>-&gt;</operator><name>rejectlimittype</name></name> <operator>!=</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported reject limit type %c for external table"</literal></expr></argument>,
				 <argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>rejectlimittype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extentry</name><operator>-&gt;</operator><name>rejectlimittype</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_VALID_ENCODING</name><argument_list>(<argument><expr><name><name>extentry</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid encoding found for external table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>extentry</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>entryOptions</name></expr>;</expr_stmt>

	<return>return <expr><name>extentry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExternalScanInfo</name> <modifier>*</modifier></type>
<name>MakeExternalScanInfo</name><parameter_list>(<parameter><decl><type><name>ExtTableEntry</name> <modifier>*</modifier></type><name>extEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExternalScanInfo</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExternalScanInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>urilist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ismasteronly</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>islimitinrows</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rejectlimit</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>logerrors</name> <init>= <expr><name>LOG_ERRORS_DISABLE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>scancounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>extEntry</name><operator>-&gt;</operator><name>rejectlimit</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * single row error handling is requested, make sure reject limit and
		 * reject type are valid.
		 *
		 * NOTE: this should never happen unless somebody modified the catalog
		 * manually. We are just being pedantic here.
		 */</comment>
		<expr_stmt><expr><call><name>VerifyRejectLimit</name><argument_list>(<argument><expr><name><name>extEntry</name><operator>-&gt;</operator><name>rejectlimittype</name></name></expr></argument>, <argument><expr><name><name>extEntry</name><operator>-&gt;</operator><name>rejectlimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* assign Uris to segments. */</comment>
	<expr_stmt><expr><name>urilist</name> <operator>=</operator> <call><name>create_external_scan_uri_list</name><argument_list>(<argument><expr><name>extEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ismasteronly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* single row error handling */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>extEntry</name><operator>-&gt;</operator><name>rejectlimit</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>islimitinrows</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>extEntry</name><operator>-&gt;</operator><name>rejectlimittype</name></name> <operator>==</operator> <literal type="char">'r'</literal></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>rejectlimit</name> <operator>=</operator> <name><name>extEntry</name><operator>-&gt;</operator><name>rejectlimit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>logerrors</name> <operator>=</operator> <name><name>extEntry</name><operator>-&gt;</operator><name>logerrors</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>uriList</name></name> <operator>=</operator> <name>urilist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fmtType</name></name> <operator>=</operator> <name><name>extEntry</name><operator>-&gt;</operator><name>fmtcode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>isMasterOnly</name></name> <operator>=</operator> <name>ismasteronly</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rejLimit</name></name> <operator>=</operator> <name>rejectlimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rejLimitInRows</name></name> <operator>=</operator> <name>islimitinrows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>logErrors</name></name> <operator>=</operator> <name>logerrors</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name><name>extEntry</name><operator>-&gt;</operator><name>encoding</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scancounter</name></name> <operator>=</operator> <name>scancounter</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>extOptions</name></name> <operator>=</operator> <name><name>extEntry</name><operator>-&gt;</operator><name>options</name></name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * entry point from ORCA, to create a ForeignScan plan for an external table.
 *
 * Note: the caller is responsible for filling the cost information.
 */</comment>
<function><type><name>ForeignScan</name> <modifier>*</modifier></type>
<name>BuildForeignScanForExternalTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtTableEntry</name> <modifier>*</modifier></type><name>extEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExternalScanInfo</name> <modifier>*</modifier></type><name>externalscan_info</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>extEntry</name> <operator>=</operator> <call><name>GetExtTableEntry</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>externalscan_info</name> <operator>=</operator> <call><name>MakeExternalScanInfo</name><argument_list>(<argument><expr><name>extEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fscan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>qual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>targetlist</name></expr>;</expr_stmt>

	<comment type="block">/* cost will be filled in by create_foreignscan_plan */</comment>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
	<comment type="block">/* fs_server will be filled in by create_foreignscan_plan */</comment>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fs_server</name></name> <operator>=</operator> <call><name>get_foreign_server_oid</name><argument_list>(<argument><expr><name>GP_EXTTABLE_SERVER_NAME</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_exprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>externalscan_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fs_relids</name></name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>scanrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Like in create_foreign_plan(), if rel is a base relation, detect
	 * whether any system columns are requested from the rel.
	 */</comment>
	<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fsSystemCol</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>scanrelid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>attrs_used</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * First, examine all the attributes needed for joins or final output.
		 * Note: we must look at rel's targetlist, not the attr_needed data,
		 * because attr_needed isn't computed for inheritance child rels.
		 */</comment>
		<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetlist</name></expr></argument>, <argument><expr><name>scanrelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now, are any system columns requested from rel? */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>, <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fscan</name><operator>-&gt;</operator><name>fsSystemCol</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>fscan</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>create_external_scan_uri_list</name><parameter_list>(<parameter><decl><type><name>ExtTableEntry</name> <modifier>*</modifier></type><name>ext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>ismasteronly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>modifiedloclist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>db_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>total_primaries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>segdb_file_map</name></decl>;</decl_stmt>

	<comment type="block">/* various processing flags */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>using_execute</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* true if EXECUTE is used */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>using_location</name></decl>;</decl_stmt> <comment type="block">/* true if LOCATION is used */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_candidate</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>filenames</name></decl>;</decl_stmt>

	<comment type="block">/* gpfdist(s) or EXECUTE specific variables */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>total_to_skip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_participants_allowed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_segs_participating</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>skip_map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>should_skip_randomly</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Uri</name>		   <modifier>*</modifier></type><name>uri</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>on_clause</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>ismasteronly</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* is this an EXECUTE table or a LOCATION (URI) table */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ext</name><operator>-&gt;</operator><name>command</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>using_execute</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>using_location</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>using_execute</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>using_location</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* is this an EXECUTE table or a LOCATION (URI) table */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ext</name><operator>-&gt;</operator><name>command</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>gp_external_enable_exec</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_FEATURE_NOT_CONFIGURED</name></expr></argument>)</argument_list></call><operator>,</operator>	<comment type="block">/* any better errcode? */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"using external tables with OS level commands (EXECUTE clause) is disabled"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable set gp_external_enable_exec=on."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* various validations */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ext</name><operator>-&gt;</operator><name>iswritable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot read from a WRITABLE external table"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Create the table as READABLE instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * take a peek at the first URI so we know which protocol we'll deal with
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>using_execute</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>first_uri_str</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>first_uri_str</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>ext</name><operator>-&gt;</operator><name>urilocations</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>uri</name> <operator>=</operator> <call><name>ParseExternalTableUri</name><argument_list>(<argument><expr><name>first_uri_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>uri</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* get the ON clause information, and restrict 'ON COORDINATOR' to custom
	 * protocols only */</comment>
	<expr_stmt><expr><name>on_clause</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>ext</name><operator>-&gt;</operator><name>execlocations</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"COORDINATOR_ONLY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
		<operator>&amp;&amp;</operator> <name>using_location</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>!=</operator> <name>URI_CUSTOM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\'ON COORDINATOR\' is not supported by this protocol yet"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get the total valid primary segdb count */</comment>
	<expr_stmt><expr><name>db_info</name> <operator>=</operator> <call><name>cdbcomponent_getCdbComponents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_primaries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>db_info</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>db_info</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SEGMENT_IS_ACTIVE_PRIMARY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>total_primaries</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * initialize a file-to-segdb mapping. segdb_file_map string array indexes
	 * segindex and the entries are the external file path is assigned to this
	 * segment database. For example if segdb_file_map[2] has "/tmp/emp.1" then
	 * this file is assigned to primary segdb 2. if an entry has NULL then
	 * that segdb isn't assigned any file.
	 */</comment>
	<expr_stmt><expr><name>segdb_file_map</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>total_primaries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we do the actual assignment of work to the segment databases (where
	 * work is either a URI to open or a command to execute). Due to the big
	 * differences between the different protocols we handle each one
	 * separately. Unfortunately this means some code duplication, but keeping
	 * this separation makes the code much more understandable and (even) more
	 * maintainable.
	 *
	 * Outline of the following code blocks (from simplest to most complex):
	 * (only one of these will get executed for a statement)
	 *
	 * 1) segment mapping for tables with LOCATION http:// or file:// .
	 *
	 * These two protocols are very similar in that they enforce a
	 * 1-URI:1-segdb relationship. The only difference between them is that
	 * file:// URI must be assigned to a segdb on a host that is local to that
	 * URI.
	 *
	 * 2) segment mapping for tables with LOCATION gpfdist(s):// or custom
	 * protocol
	 *
	 * This protocol is more complicated - in here we usually duplicate the
	 * user supplied gpfdist(s):// URIs until there is one available to every
	 * segdb. However, in some cases (as determined by gp_external_max_segs
	 * GUC) we don't want to use *all* segdbs but instead figure out how many
	 * and pick them randomly (this is mainly for better performance and
	 * resource mgmt).
	 *
	 * 3) segment mapping for tables with EXECUTE 'cmd' ON.
	 *
	 * In here we don't have URI's. We have a single command string and a
	 * specification of the segdb granularity it should get executed on (the
	 * ON clause). Depending on the ON clause specification we could go many
	 * different ways, for example: assign the command to all segdb, or one
	 * command per host, or assign to 5 random segments, etc...
	 */</comment>

	<comment type="block">/* (1) */</comment>
	<if_stmt><if>if <condition>(<expr><name>using_location</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_FILE</name> <operator>||</operator> <name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_HTTP</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * extract file path and name from URI strings and assign them a
		 * primary segdb
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>c</argument>, <argument>ext-&gt;urilocations</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uri_str</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>uri</name> <operator>=</operator> <call><name>ParseExternalTableUri</name><argument_list>(<argument><expr><name>uri_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>found_candidate</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>found_match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * look through our segment database list and try to find a
			 * database that can handle this uri.
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>db_info</name><operator>-&gt;</operator><name>total_segment_dbs</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found_match</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>db_info</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>segind</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Assign mapping of external file to this segdb only if:
				 * 1) This segdb is a valid primary.
				 * 2) An external file wasn't already assigned to it.
				 * 3) If 'file' protocol, host of segdb and file must be
				 *    the same.
				 *
				 * This logic also guarantees that file that appears first in
				 * the external location list for the same host gets assigned
				 * the segdb with the lowest index for this host.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>SEGMENT_IS_ACTIVE_PRIMARY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_FILE</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>uri</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>uri</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>address</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* a valid primary segdb exist on this host */</comment>
					<expr_stmt><expr><name>found_candidate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>segdb_file_map</name><index>[<expr><name>segind</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* segdb not taken yet. assign this URI to this segdb */</comment>
						<expr_stmt><expr><name><name>segdb_file_map</name><index>[<expr><name>segind</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>uri_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>found_match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * too bad. this segdb already has an external source
					 * assigned
					 */</comment>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * We failed to find a segdb for this URI.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_match</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_FILE</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>found_candidate</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not assign a segment database for \"%s\""</literal></expr></argument>,
										<argument><expr><name>uri_str</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"There are more external files than primary segment databases on host \"%s\""</literal></expr></argument>,
										   <argument><expr><name><name>uri</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not assign a segment database for \"%s\""</literal></expr></argument>,
										<argument><expr><name>uri_str</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"There isn't a valid primary segment database on host \"%s\""</literal></expr></argument>,
										   <argument><expr><name><name>uri</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else	<comment type="block">/* HTTP */</comment>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not assign a segment database for \"%s\""</literal></expr></argument>,
									<argument><expr><name>uri_str</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"There are more URIs than total primary segment databases"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>


	</block_content>}</block></if>
	<comment type="block">/* (2) */</comment>
	<if type="elseif">else if <condition>(<expr><name>using_location</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_GPFDIST</name> <operator>||</operator>
							   <name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_GPFDISTS</name> <operator>||</operator>
							   <name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_CUSTOM</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"COORDINATOR_ONLY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_CUSTOM</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uri_str</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>ext</name><operator>-&gt;</operator><name>urilocations</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>segdb_file_map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>uri_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>ismasteronly</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Re-write the location list for GPFDIST or GPFDISTS before mapping to segments.
			 *
			 * If we happen to be dealing with URI's with the 'gpfdist' (or 'gpfdists') protocol
			 * we do an extra step here.
			 *
			 * (*) We modify the urilocationlist so that every
			 * primary segdb will get a URI (therefore we duplicate the existing
			 * URI's until the list is of size = total_primaries).
			 * Example: 2 URIs, 7 total segdbs.
			 * Original LocationList: URI1-&gt;URI2
			 * Modified LocationList: URI1-&gt;URI2-&gt;URI1-&gt;URI2-&gt;URI1-&gt;URI2-&gt;URI1
			 *
			 * (**) We also make sure that we don't allocate more segdbs than
			 * (# of URIs x gp_external_max_segs).
			 * Example: 2 URIs, 7 total segdbs, gp_external_max_segs = 3
			 * Original LocationList: URI1-&gt;URI2
			 * Modified LocationList: URI1-&gt;URI2-&gt;URI1-&gt;URI2-&gt;URI1-&gt;URI2 (6 total).
			 *
			 * (***) In that case that we need to allocate only a subset of primary
			 * segdbs and not all we then also create a random map of segments to skip.
			 * Using the previous example a we create a map of 7 entries and need to
			 * randomly select 1 segdb to skip (7 - 6 = 1). so it may look like this:
			 * [F F T F F F F] - in which case we know to skip the 3rd segment only.
			 */</comment>

			<comment type="block">/* total num of segs that will participate in the external operation */</comment>
			<expr_stmt><expr><name>num_segs_participating</name> <operator>=</operator> <name>total_primaries</name></expr>;</expr_stmt>

			<comment type="block">/* max num of segs that are allowed to participate in the operation */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_GPFDIST</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_GPFDISTS</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>max_participants_allowed</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>ext</name><operator>-&gt;</operator><name>urilocations</name></name></expr></argument>)</argument_list></call> <operator>*</operator>
					<name>gp_external_max_segs</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * for custom protocol, set max_participants_allowed to
				 * num_segs_participating so that assignment to segments will use
				 * all available segments
				 */</comment>
				<expr_stmt><expr><name>max_participants_allowed</name> <operator>=</operator> <name>num_segs_participating</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>,
				 <argument><expr><literal type="string">"num_segs_participating = %d. max_participants_allowed = %d. number of URIs = %d"</literal></expr></argument>,
				 <argument><expr><name>num_segs_participating</name></expr></argument>, <argument><expr><name>max_participants_allowed</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ext</name><operator>-&gt;</operator><name>urilocations</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* see (**) above */</comment>
			<if_stmt><if>if <condition>(<expr><name>num_segs_participating</name> <operator>&gt;</operator> <name>max_participants_allowed</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>total_to_skip</name> <operator>=</operator> <name>num_segs_participating</name> <operator>-</operator> <name>max_participants_allowed</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>num_segs_participating</name> <operator>=</operator> <name>max_participants_allowed</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>should_skip_randomly</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"External scan %s will utilize %d out "</literal>
					 <literal type="string">"of %d segment databases"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_GPFDIST</name></expr> ?</condition><then> <expr><literal type="string">"from gpfdist(s) server"</literal></expr> </then><else>: <expr><literal type="string">"using custom protocol"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
					 <argument><expr><name>num_segs_participating</name></expr></argument>,
					 <argument><expr><name>total_primaries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ext</name><operator>-&gt;</operator><name>urilocations</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>num_segs_participating</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there are more external files (URLs) than primary segments that can read them"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Found %d URLs and %d primary segments."</literal></expr></argument>,
								   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ext</name><operator>-&gt;</operator><name>urilocations</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>num_segs_participating</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * restart location list and fill in new list until number of
			 * locations equals the number of segments participating in this
			 * action (see (*) above for more details).
			 */</comment>
			<while>while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>
			<block>{<block_content>
				<macro><name>foreach</name><argument_list>(<argument>c</argument>, <argument>ext-&gt;urilocations</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>uri_str</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<comment type="block">/* append to a list of Value nodes, size nelems */</comment>
					<expr_stmt><expr><name>modifiedloclist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>modifiedloclist</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>uri_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>modifiedloclist</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>num_segs_participating</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>modifiedloclist</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>num_segs_participating</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"External scan location list failed building distribution."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></while>

			<comment type="block">/* See (***) above for details */</comment>
			<if_stmt><if>if <condition>(<expr><name>should_skip_randomly</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>skip_map</name> <operator>=</operator> <call><name>makeRandomSegMap</name><argument_list>(<argument><expr><name>total_primaries</name></expr></argument>, <argument><expr><name>total_to_skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * assign each URI from the new location list a primary segdb
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>c</argument>, <argument>modifiedloclist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uri_str</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>uri</name> <operator>=</operator> <call><name>ParseExternalTableUri</name><argument_list>(<argument><expr><name>uri_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>found_match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * look through our segment database list and try to find a
				 * database that can handle this uri.
				 */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>db_info</name><operator>-&gt;</operator><name>total_segment_dbs</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found_match</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>db_info</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>segind</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Assign mapping of external file to this segdb only if:
					 * 1) This segdb is a valid primary.
					 * 2) An external file wasn't already assigned to it.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>SEGMENT_IS_ACTIVE_PRIMARY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * skip this segdb if skip_map for this seg index tells us
						 * to skip it (set to 'true').
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>should_skip_randomly</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segind</name> <operator>&lt;</operator> <name>total_primaries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><name><name>skip_map</name><index>[<expr><name>segind</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
								<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* skip it */</comment>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>segdb_file_map</name><index>[<expr><name>segind</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* segdb not taken yet. assign this URI to this segdb */</comment>
							<expr_stmt><expr><name><name>segdb_file_map</name><index>[<expr><name>segind</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>uri_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>found_match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/*
						 * too bad. this segdb already has an external source
						 * assigned
						 */</comment>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/* We failed to find a segdb for this gpfdist(s) URI */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_match</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* should never happen */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						 <argument><expr><literal type="string">"external tables gpfdist(s) allocation error. "</literal>
						 <literal type="string">"total_primaries: %d, num_segs_participating %d "</literal>
						 <literal type="string">"max_participants_allowed %d, total_to_skip %d"</literal></expr></argument>,
						 <argument><expr><name>total_primaries</name></expr></argument>, <argument><expr><name>num_segs_participating</name></expr></argument>,
						 <argument><expr><name>max_participants_allowed</name></expr></argument>, <argument><expr><name>total_to_skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						 <argument><expr><literal type="string">"internal error in createplan for external tables when trying to assign segments for gpfdist(s)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/* (3) */</comment>
	<if type="elseif">else if <condition>(<expr><name>using_execute</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name><name>ext</name><operator>-&gt;</operator><name>command</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name> <init>= <expr><literal type="string">"execute:"</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prefixed_command</name></decl>;</decl_stmt>

		<comment type="block">/* build the command string for the executor - 'execute:command' */</comment>
		<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prefixed_command</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we handle each one of the ON locations separately:
		 *
		 * 1) all segs
		 * 2) one per host
		 * 3) all segs on host &lt;foo&gt;
		 * 4) seg &lt;n&gt; only
		 * 5) &lt;n&gt; random segs
		 * 6) master only
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"ALL_SEGMENTS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* all segments get a copy of the command to execute */</comment>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>db_info</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>db_info</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>segind</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>SEGMENT_IS_ACTIVE_PRIMARY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>segdb_file_map</name><index>[<expr><name>segind</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>prefixed_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>

		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"PER_HOST"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* 1 seg per host */</comment>

			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>visited_hosts</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>db_info</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>db_info</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>segind</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>SEGMENT_IS_ACTIVE_PRIMARY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>host_taken</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>visited_hosts</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>host_taken</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>

					<comment type="block">/*
					 * if not assigned to a seg on this host before - do it
					 * now and add this hostname to the list so that we don't
					 * use segs on this host again.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>host_taken</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>segdb_file_map</name><index>[<expr><name>segind</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>prefixed_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>visited_hosts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>visited_hosts</name></expr></argument>,
										   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"HOST:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"HOST:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* all segs on the specified host get copy of the command */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>hostname</name> <init>= <expr><name>on_clause</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"HOST:"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>match_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>db_info</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>db_info</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>segind</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>SEGMENT_IS_ACTIVE_PRIMARY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>segdb_file_map</name><index>[<expr><name>segind</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>prefixed_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>match_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match_found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not assign a segment database for command \"%s\")"</literal></expr></argument>,
								<argument><expr><name>command</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"No valid primary segment was found in the requested host name \"%s\"."</literal></expr></argument>,
								<argument><expr><name>hostname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"SEGMENT_ID:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"SEGMENT_ID:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* 1 seg with specified id gets a copy of the command */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>target_segid</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>on_clause</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"SEGMENT_ID:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>match_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>db_info</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>db_info</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>segind</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>SEGMENT_IS_ACTIVE_PRIMARY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>segind</name> <operator>==</operator> <name>target_segid</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>segdb_file_map</name><index>[<expr><name>segind</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>prefixed_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>match_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match_found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not assign a segment database for command \"%s\""</literal></expr></argument>,
								<argument><expr><name>command</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The requested segment id %d is not a valid primary segment or doesn't exist in the database"</literal></expr></argument>,
								   <argument><expr><name>target_segid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"TOTAL_SEGS:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"TOTAL_SEGS:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* total n segments selected randomly */</comment>

			<decl_stmt><decl><type><name>int</name></type>			<name>num_segs_to_use</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>on_clause</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"TOTAL_SEGS:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>num_segs_to_use</name> <operator>&gt;</operator> <name>total_primaries</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table defined with EXECUTE ON %d but there are only %d valid primary segments in the database"</literal></expr></argument>,
								<argument><expr><name>num_segs_to_use</name></expr></argument>, <argument><expr><name>total_primaries</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>total_to_skip</name> <operator>=</operator> <name>total_primaries</name> <operator>-</operator> <name>num_segs_to_use</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>skip_map</name> <operator>=</operator> <call><name>makeRandomSegMap</name><argument_list>(<argument><expr><name>total_primaries</name></expr></argument>, <argument><expr><name>total_to_skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>db_info</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>db_info</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>segind</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>SEGMENT_IS_ACTIVE_PRIMARY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segind</name> <operator>&lt;</operator> <name>total_primaries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>skip_map</name><index>[<expr><name>segind</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* skip it */</comment>

					<expr_stmt><expr><name><name>segdb_file_map</name><index>[<expr><name>segind</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>prefixed_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"COORDINATOR_ONLY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * store the command in first array entry and indicate that it is
			 * meant for the master segment (not seg o).
			 */</comment>
			<expr_stmt><expr><name><name>segdb_file_map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>prefixed_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>ismasteronly</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Internal error in createplan for external tables: got invalid ON clause code %s"</literal></expr></argument>,
				 <argument><expr><name>on_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* should never get here */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Internal error in createplan for external tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * convert array map to a list so it can be serialized as part of the plan
	 */</comment>
	<expr_stmt><expr><name>filenames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>total_primaries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>segdb_file_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>filenames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>filenames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>segdb_file_map</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* no file for this segdb. add a null entry */</comment>
			<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_Null</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>filenames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>filenames</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>filenames</name></expr>;</return>
</block_content>}</block></function>
</unit>
