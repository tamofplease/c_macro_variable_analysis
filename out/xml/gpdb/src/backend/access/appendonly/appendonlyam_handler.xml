<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/appendonly/appendonlyam_handler.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * appendonlyam_handler.c
 *	  appendonly table access method code
 *
 * Portions Copyright (c) 2008, Greenplum Inc
 * Portions Copyright (c) 2020-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/appendonly/appendonlyam_handler.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/aomd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonlywriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_fastsequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_appendonly.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_rusage.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_BTREE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;rd_rel-&gt;relam == BTREE_AM_OID)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reset_state_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TableAmRoutine</name></type> <name>ao_row_methods</name></decl>;</decl_stmt>

<comment type="block">/*
 * Per-relation backend-local DML state for DML or DML-like operations.
 */</comment>
<typedef>typedef <type><struct>struct <name>AppendOnlyDMLState</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyInsertDesc</name></type>	<name>insertDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyDeleteDesc</name></type>	<name>deleteDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyUniqueCheckDesc</name></type> <name>uniqueCheckDesc</name></decl>;</decl_stmt>
}</block></struct></type> <name>AppendOnlyDMLState</name>;</typedef>


<comment type="block">/*
 * A repository for per-relation backend-local DML states. Contains:
 *		a quick look up member for the common case (only 1 relation)
 *		a hash table which keeps per relation information
 *		a memory context that should be long lived enough and is
 *			responsible for reseting the state via its reset cb
 */</comment>
<typedef>typedef <type><struct>struct <name>AppendOnlyDMLStates</name>
<block>{
	<decl_stmt><decl><type><name>AppendOnlyDMLState</name>	   <modifier>*</modifier></type><name>last_used_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>				   <modifier>*</modifier></type><name>state_table</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type>			<name>stateCxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContextCallback</name></type>	<name>cb</name></decl>;</decl_stmt>
}</block></struct></type> <name>AppendOnlyDMLStates</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>AppendOnlyDMLStates</name></type> <name>appendOnlyDMLStates</name></decl>;</decl_stmt>

<comment type="block">/* ------------------------------------------------------------------------
 * DML state related functions
 * ------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Initialize the backend local AppendOnlyDMLStates object for this backend for
 * the current DML or DML-like command (if not already initialized).
 *
 * This function should be called with a current memory context whose life
 * span is enough to last until the end of this command execution.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_appendonly_dml_states</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>hash_ctl</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>appendOnlyDMLStates</name><operator>.</operator><name>state_table</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>stateCxt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>stateCxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(
												<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
												<argument><expr><literal type="string">"AppendOnly DML State Context"</literal></expr></argument>,
												<argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>cb</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>reset_state_cb</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>cb</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextRegisterResetCallback</name><argument_list>(<argument><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>stateCxt</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>appendOnlyDMLStates</name><operator>.</operator><name>cb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyDMLState</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name><name>appendOnlyDMLStates</name><operator>.</operator><name>stateCxt</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>state_table</name></name> <operator>=</operator>
			<call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"AppendOnly DML state"</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
						<argument><expr><name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create and insert a state entry for a relation. The actual descriptors will
 * be created lazily when/if needed.
 *
 * Should be called exactly once per relation.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>init_dml_state</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>relationOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyDMLState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>state_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>AppendOnlyDMLState</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>state_table</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>relationOid</name></expr></argument>,
											   <argument><expr><name>HASH_ENTER</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>insertDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>deleteDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>uniqueCheckDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>last_used_state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Retrieve the state information for a relation.
 * It is required that the state has been created before hand.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>AppendOnlyDMLState</name> <modifier>*</modifier></type>
<name>find_dml_state</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>relationOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyDMLState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>state_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>last_used_state</name></name> <operator>&amp;&amp;</operator>
			<name><name>appendOnlyDMLStates</name><operator>.</operator><name>last_used_state</name><operator>-&gt;</operator><name>relationOid</name></name> <operator>==</operator> <name>relationOid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>last_used_state</name></name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>AppendOnlyDMLState</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>state_table</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>relationOid</name></expr></argument>,
											   <argument><expr><name>HASH_FIND</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>last_used_state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the state information for a relation.
 * It is required that the state has been created before hand.
 *
 * Should be called exactly once per relation.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>remove_dml_state</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>relationOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyDMLState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>state_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>AppendOnlyDMLState</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>state_table</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>relationOid</name></expr></argument>,
											   <argument><expr><name>HASH_REMOVE</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>last_used_state</name></name> <operator>&amp;&amp;</operator>
			<name><name>appendOnlyDMLStates</name><operator>.</operator><name>last_used_state</name><operator>-&gt;</operator><name>relationOid</name></name> <operator>==</operator> <name>relationOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>last_used_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Provides an opportunity to create backend-local state to be consulted during
 * the course of the current DML or DML-like command, for the given relation.
 */</comment>
<function><type><name>void</name></type>
<name>appendonly_dml_init</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Initialize the repository of per-relation states, if not done already for
	 * the current DML or DML-like command.
	 */</comment>
	<expr_stmt><expr><call><name>init_appendonly_dml_states</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* initialize the per-relation state */</comment>
	<expr_stmt><expr><call><name>init_dml_state</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Provides an opportunity to clean up backend-local state set up for the
 * current DML or DML-like command, for the given relation.
 */</comment>
<function><type><name>void</name></type>
<name>appendonly_dml_finish</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyDMLState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>had_delete_desc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationOid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>state_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>AppendOnlyDMLState</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>state_table</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>relationOid</name></expr></argument>,
											  <argument><expr><name>HASH_FIND</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>deleteDesc</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendonly_delete_finish</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>deleteDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>deleteDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Bump up the modcount. If we inserted something (meaning that
		 * this was an UPDATE), we can skip this, as the insertion bumped
		 * up the modcount already.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>insertDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AORelIncrementModCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>had_delete_desc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>insertDesc</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>insertDesc</name><operator>-&gt;</operator><name>aoi_rel</name></name> <operator>==</operator> <name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendonly_insert_finish</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>insertDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>insertDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>uniqueCheckDesc</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* clean up the block directory */</comment>
		<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_End_forUniqueChecks</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>uniqueCheckDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>uniqueCheckDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>uniqueCheckDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this fetch is a part of an update, then we have been reusing the
		 * visimap used by the delete half of the update, which would have
		 * already been cleaned up above. Clean up otherwise.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>had_delete_desc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AppendOnlyVisimap_Finish_forUniquenessChecks</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>uniqueCheckDesc</name><operator>-&gt;</operator><name>visimap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>uniqueCheckDesc</name><operator>-&gt;</operator><name>visimap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>uniqueCheckDesc</name><operator>-&gt;</operator><name>visimap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>uniqueCheckDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>uniqueCheckDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>remove_dml_state</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * There are two cases that we are called from, during context destruction
 * after a successful completion and after a transaction abort. Only in the
 * second case we should not have cleaned up the DML state and the entries in
 * the hash table. We need to reset our global state. The actual clean up is
 * taken care elsewhere.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reset_state_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>state_table</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>last_used_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>stateCxt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Retrieve the insertDescriptor for a relation. Initialize it if its absent.
 * 'num_rows': Number of rows to be inserted. (NUM_FAST_SEQUENCES if we don't
 * know it beforehand). This arg is not used if the descriptor already exists.
 */</comment>
<function><type><specifier>static</specifier> <name>AppendOnlyInsertDesc</name></type>
<name>get_or_create_ao_insert_descriptor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>num_rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyDMLState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>find_dml_state</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>insertDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AppendOnlyInsertDesc</name></type> <name>insertDesc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>stateCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>insertDesc</name> <operator>=</operator> <call><name>appendonly_insert_init</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
											<argument><expr><call><name>ChooseSegnoForWrite</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>num_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * If we have a unique index, insert a placeholder block directory row
		 * to entertain uniqueness checks from concurrent inserts. See
		 * AppendOnlyBlockDirectory_InsertPlaceholder() for details.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>relationHasUniqueIndex</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type> <name>firstRowNum</name> <init>= <expr><name><name>insertDesc</name><operator>-&gt;</operator><name>lastSequence</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BufferedAppend</name> <modifier>*</modifier></type><name>bufferedAppend</name> <init>= <expr><operator>&amp;</operator><name><name>insertDesc</name><operator>-&gt;</operator><name>storageWrite</name><operator>.</operator><name>bufferedAppend</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type> <name>fileOffset</name> <init>= <expr><call><name>BufferedAppendNextBufferPosition</name><argument_list>(<argument><expr><name>bufferedAppend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_InsertPlaceholder</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>insertDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>,
													   <argument><expr><name>firstRowNum</name></expr></argument>,
													   <argument><expr><name>fileOffset</name></expr></argument>,
													   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>insertDesc</name></name> <operator>=</operator> <name>insertDesc</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>insertDesc</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Retrieve the deleteDescriptor for a relation. Initialize it if needed.
 */</comment>
<function><type><specifier>static</specifier> <name>AppendOnlyDeleteDesc</name></type>
<name>get_or_create_delete_descriptor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forUpdate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyDMLState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>find_dml_state</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>deleteDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>stateCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>deleteDesc</name></name> <operator>=</operator> <call><name>appendonly_delete_init</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>deleteDesc</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AppendOnlyUniqueCheckDesc</name></type>
<name>get_or_create_unique_check_desc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyDMLState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>find_dml_state</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>uniqueCheckDesc</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AppendOnlyUniqueCheckDesc</name></type> <name>uniqueCheckDesc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>appendOnlyDMLStates</name><operator>.</operator><name>stateCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>uniqueCheckDesc</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyUniqueCheckDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize the block directory */</comment>
		<expr_stmt><expr><name><name>uniqueCheckDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyBlockDirectory</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_Init_forUniqueChecks</name><argument_list>(<argument><expr><name><name>uniqueCheckDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>,
													  <argument><expr><name>relation</name></expr></argument>,
													  <argument><expr><literal type="number">1</literal></expr></argument>, <comment type="block">/* numColGroups */</comment>
													  <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this is part of an update, we need to reuse the visimap used by
		 * the delete half of the update. This is to avoid spurious conflicts
		 * when the key's previous and new value are identical. Using the
		 * visimap from the delete half ensures that the visimap can recognize
		 * any tuples deleted by us prior to this insert, within this command.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>deleteDesc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>uniqueCheckDesc</name><operator>-&gt;</operator><name>visimap</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>deleteDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Initialize the visimap */</comment>
			<expr_stmt><expr><name><name>uniqueCheckDesc</name><operator>-&gt;</operator><name>visimap</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyVisimap</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AppendOnlyVisimap_Init_forUniqueCheck</name><argument_list>(<argument><expr><name><name>uniqueCheckDesc</name><operator>-&gt;</operator><name>visimap</name></name></expr></argument>,
												  <argument><expr><name>relation</name></expr></argument>,
												  <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>uniqueCheckDesc</name></name> <operator>=</operator> <name>uniqueCheckDesc</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>uniqueCheckDesc</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------
 * Slot related callbacks for appendonly AM
 * ------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Appendonly access method uses virtual tuples
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type>
<name>appendonly_slot_callbacks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MemTuple</name></type>
<name>appendonly_form_memtuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>mt_bind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemTuple</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>oldContext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In case of a non virtal tuple, make certain that the slot's values are
	 * populated, for example during a CTAS.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TTS_IS_VIRTUAL</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>slot_getsomeattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>memtuple_form</name><argument_list>(<argument><expr><name>mt_bind</name></expr></argument>,
						   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
						   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * appendonly_free_memtuple
 */</comment>
<function><type><name>void</name></type>
<name>appendonly_free_memtuple</name><parameter_list>(<parameter><decl><type><name>MemTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------
 * Parallel aware Seq Scan callbacks for ao_row AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>appendonly_parallelscan_estimate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parallel SeqScan not implemented for AO_ROW tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>appendonly_parallelscan_initialize</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ParallelTableScanDesc</name></type> <name>pscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parallel SeqScan not implemented for AO_ROW tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_parallelscan_reinitialize</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ParallelTableScanDesc</name></type> <name>pscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parallel SeqScan not implemented for AO_ROW tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------
 * Seq Scan callbacks for appendonly AM
 *
 * These are in appendonlyam.c
 * ------------------------------------------------------------------------
 */</comment>

<comment type="block">/* ------------------------------------------------------------------------
 * Index Scan Callbacks for appendonly AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>IndexFetchTableData</name> <modifier>*</modifier></type>
<name>appendonly_index_fetch_begin</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexFetchAppendOnlyData</name> <modifier>*</modifier></type><name>aoscan</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexFetchAppendOnlyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>xs_base</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>

	<comment type="block">/* aoscan-&gt;aofetch is initialized lazily on first fetch */</comment>

	<return>return <expr><operator>&amp;</operator><name><name>aoscan</name><operator>-&gt;</operator><name>xs_base</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_index_fetch_reset</name><parameter_list>(<parameter><decl><type><name>IndexFetchTableData</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Unlike Heap, we don't release the resources (fetch descriptor and its
	 * members) here because it is more like a global data structure shared
	 * across scans, rather than an iterator to yield a granularity of data.
	 * 
	 * Additionally, should be aware of that no matter whether allocation or
	 * release on fetch descriptor, it is considerably expensive.
	 */</comment>
	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_index_fetch_end</name><parameter_list>(<parameter><decl><type><name>IndexFetchTableData</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexFetchAppendOnlyData</name> <modifier>*</modifier></type><name>aoscan</name> <init>= <expr><operator>(</operator><name>IndexFetchAppendOnlyData</name> <operator>*</operator><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendonly_fetch_finish</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>aoscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>appendonly_index_fetch_tuple</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>IndexFetchTableData</name></name> <modifier>*</modifier></type><name>scan</name></decl></parameter>,
							 <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
							 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
							 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>call_again</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>all_dead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexFetchAppendOnlyData</name> <modifier>*</modifier></type><name>aoscan</name> <init>= <expr><operator>(</operator><name>IndexFetchAppendOnlyData</name> <operator>*</operator><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Snapshot</name></type>	<name>appendOnlyMetaDataSnapshot</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>appendOnlyMetaDataSnapshot</name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>appendOnlyMetaDataSnapshot</name> <operator>==</operator> <name>SnapshotAny</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * the append-only meta data should never be fetched with
			 * SnapshotAny as bogus results are returned.
			 */</comment>
			<expr_stmt><expr><name>appendOnlyMetaDataSnapshot</name> <operator>=</operator> <call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name> <operator>=</operator>
			<call><name>appendonly_fetch_init</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>xs_base</name><operator>.</operator><name>rel</name></name></expr></argument>,
								  <argument><expr><name>snapshot</name></expr></argument>,
								  <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * There is no reason to expect changes on snapshot between tuple
	 * fetching calls after fech_init is called, treat it as a
	 * programming error in case of occurrence.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>==</operator> <name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendonly_fetch</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name></expr></argument>, <argument><expr><operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <name>tid</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Currently, we don't determine this parameter. By contract, it is to be
	 * set to true iff we can determine that this row is dead to all
	 * transactions. Failure to set this will lead to use of a garbage value
	 * in certain code, such as that for unique index checks.
	 * This is typically used for HOT chains, which we don't support.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>all_dead</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>all_dead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Currently, we don't determine this parameter. By contract, it is to be
	 * set to true iff there is another tuple for the tid, so that we can prompt
	 * the caller to call index_fetch_tuple() again for the same tid.
	 * This is typically used for HOT chains, which we don't support.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>call_again</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>call_again</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a visible tuple exists given the tid and a snapshot. This is
 * currently used to determine uniqueness checks.
 *
 * We determine existence simply by checking if a *visible* block directory
 * entry covers the given tid.
 *
 * There is no need to fetch the tuple (we actually can't reliably do so as
 * we might encounter a placeholder row in the block directory)
 *
 * If no visible block directory entry exists, we are done. If it does, we need
 * to further check the visibility of the tuple itself by consulting the visimap.
 * Now, the visimap check can be skipped if the tuple was found to have been
 * inserted by a concurrent in-progress transaction, in which case we return
 * true and have the xwait machinery kick in.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>appendonly_index_fetch_tuple_exists</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
									<parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
									<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
									<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>all_dead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyUniqueCheckDesc</name></type> 	<name>uniqueCheckDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOTupleId</name> 					<modifier>*</modifier></type><name>aoTupleId</name> <init>= <expr><operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <name>tid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>						<name>visible</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type>			<name>segmentFileNum</name> <init>= <expr><call><name>AOTupleIdGet_segmentFileNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>rowNum</name> <init>= <expr><call><name>AOTupleIdGet_rowNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segmentFileNum</name> <operator>!=</operator> <name>InvalidFileSegNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rowNum</name> <operator>!=</operator> <name>InvalidAORowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Since this can only be called in the context of a unique index check, the
	 * snapshots that are supplied can only be non-MVCC snapshots: SELF and DIRTY.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>==</operator> <name>SNAPSHOT_SELF</name> <operator>||</operator>
		   <name><name>snapshot</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>==</operator> <name>SNAPSHOT_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Currently, we don't determine this parameter. By contract, it is to be
	 * set to true iff we can determine that this row is dead to all
	 * transactions. Failure to set this will lead to use of a garbage value
	 * in certain code, such as that for unique index checks.
	 * This is typically used for HOT chains, which we don't support.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>all_dead</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>all_dead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * FIXME: for when we want CREATE UNIQUE INDEX CONCURRENTLY to work
	 * Unique constraint violation checks with SNAPSHOT_SELF are currently
	 * required to support CREATE UNIQUE INDEX CONCURRENTLY. Currently, the
	 * sole placeholder row inserted at first insert might not be visible to
	 * the snapshot, if it was already updated by its actual first row. So,
	 * we would need to flush a placeholder row at the beginning of each new
	 * in-memory minipage. Currently, CREATE INDEX CONCURRENTLY isn't
	 * supported, so we assume such a check satisfies SNAPSHOT_SELF.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>==</operator> <name>SNAPSHOT_SELF</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>uniqueCheckDesc</name> <operator>=</operator> <call><name>get_or_create_unique_check_desc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First, scan the block directory */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyBlockDirectory_UniqueCheck</name><argument_list>(<argument><expr><name><name>uniqueCheckDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>,
											  <argument><expr><name>aoTupleId</name></expr></argument>,
											  <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the xmin or xmax are set for the dirty snapshot, after the block
	 * directory is scanned with the snapshot, it means that there is a
	 * concurrent in-progress transaction inserting the tuple. So, return true
	 * and have the xwait machinery kick in.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>==</operator> <name>SNAPSHOT_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Now, consult the visimap */</comment>
	<expr_stmt><expr><name>visible</name> <operator>=</operator> <call><name>AppendOnlyVisimap_UniqueCheck</name><argument_list>(<argument><expr><name><name>uniqueCheckDesc</name><operator>-&gt;</operator><name>visimap</name></name></expr></argument>,
											<argument><expr><name>aoTupleId</name></expr></argument>,
											<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we disallow deletes and updates running in parallel with inserts,
	 * there is no way that the dirty snapshot has it's xmin and xmax populated
	 * after the visimap has been scanned with it.
	 *
	 * Note: we disallow it by grabbing an ExclusiveLock on the QD (See
	 * CdbTryOpenTable()). So if we are running in utility mode, there is no
	 * such restriction.
	 */</comment>
	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_UTILITY</name></expr></argument>,
				<argument><expr><operator>(</operator><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * Callbacks for non-modifying operations on individual tuples for
 * appendonly AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>appendonly_fetch_row_version</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
						 <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
						 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This is a generic interface. It is currently used in three distinct
	 * cases, only one of which is currently invoking it for AO tables.
	 * This is DELETE RETURNING. In order to return the slot via the tid for
	 * AO tables one would have to scan the block directory and the visibility
	 * map. A block directory is not guarranteed to exist. Even if it exists, a
	 * state would have to be created and dropped for every tuple look up since
	 * this interface does not allow for the state to be passed around. This is
	 * a very costly operation to be performed per tuple lookup. Furthermore, if
	 * a DELETE operation is currently on the fly, the corresponding visibility
	 * map entries will not have been finalized into a visibility map tuple.
	 *
	 * Error out with feature not supported. Given that this is a generic
	 * interface, we can not really say which feature is that, although we do
	 * know that is DELETE RETURNING.
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"feature not supported on appendoptimized relations"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_get_latest_tid</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>,
						  <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Tid scans are not supported for appendoptimized relation. This function
	 * should not have been called in the first place, but if it is called,
	 * better to error out.
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"feature not supported on appendoptimized relations"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>appendonly_tuple_tid_valid</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Tid scans are not supported for appendoptimized relation. This function
	 * should not have been called in the first place, but if it is called,
	 * better to error out.
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"feature not supported on appendoptimized relations"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>appendonly_tuple_satisfies_snapshot</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
								<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * AO table dose not support unique and tidscan yet.
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
	        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"feature not supported on appendoptimized relations"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>appendonly_compute_xid_horizon_for_tuples</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
										  <parameter><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>tids</name></decl></parameter>,
										  <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// GPDB_12_MERGE_FIXME: vacuum related call back.</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not implemented yet"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------------------
 *  Functions for manipulations of physical tuples for appendonly AM.
 * ----------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_tuple_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyInsertDesc</name></type>    <name>insertDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTuple</name></type>				<name>mtuple</name></decl>;</decl_stmt>

	<comment type="block">/* Fetch the insert desc, which likely already has been created
	 *
	 * Note: since we don't know how many rows will actually be inserted (as we
	 * don't know how many rows are visible), we provide the default number of
	 * rows to bump gp_fastsequence by.
	 */</comment>
	<expr_stmt><expr><name>insertDesc</name> <operator>=</operator> <call><name>get_or_create_ao_insert_descriptor</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NUM_FAST_SEQUENCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mtuple</name> <operator>=</operator> <call><name>appendonly_form_memtuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>insertDesc</name><operator>-&gt;</operator><name>mt_bind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the tuple with table oid */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform the insertion, and copy the resulting ItemPointer */</comment>
	<expr_stmt><expr><call><name>appendonly_insert</name><argument_list>(<argument><expr><name>insertDesc</name></expr></argument>, <argument><expr><name>mtuple</name></expr></argument>, <argument><expr><operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_count_heap_insert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendonly_free_memtuple</name><argument_list>(<argument><expr><name>mtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_tuple_insert_speculative</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
								<parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,
								<parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>specToken</name></decl></parameter>)</parameter_list>
<block>{<block_content>
 	<comment type="block">/* GPDB_12_MERGE_FIXME: not supported. Can this function be left out completely? Or ereport()? */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"speculative insertion not supported on AO tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_tuple_complete_speculative</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
								  <parameter><decl><type><name>uint32</name></type> <name>specToken</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>succeeded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"speculative insertion not supported on AO tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	appendonly_multi_insert	- insert multiple tuples into an ao relation
 *
 * This is like appendonly_tuple_insert(), but inserts multiple tuples in one
 * operation. Typically used by COPY.
 *
 * In the ao_row AM, we already realize the benefits of batched WAL (WAL is
 * generated only when the insert buffer is full). There is also no page locking
 * that we can optimize, as ao_row relations don't use the PG buffer cache. So,
 * this is a thin layer over appendonly_tuple_insert() with one important
 * optimization: We allocate the insert desc with ntuples up front, which can
 * reduce the number of gp_fast_sequence allocations.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_multi_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>slots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntuples</name></decl></parameter>,
						<parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_or_create_ao_insert_descriptor</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ntuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendonly_tuple_insert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>appendonly_tuple_delete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>,
					<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>,
					<parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changingPart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyDeleteDesc</name></type>	<name>deleteDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_Result</name></type>				<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>deleteDesc</name> <operator>=</operator> <call><name>get_or_create_delete_descriptor</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>appendonly_delete</name><argument_list>(<argument><expr><name>deleteDesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_Ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_count_heap_delete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_SelfModified</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The visibility map entry has been set and it was in this command.
		 *
		 * Our caller might want to investigate tmfd to decide on appropriate
		 * action. Set it here to match expectations. The uglyness here is
		 * preferrable to having to inspect the relation's am in the caller.
		 */</comment>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <name>cid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>appendonly_tuple_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>otid</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					<parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>, <parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>,
					<parameter><decl><type><name>LockTupleMode</name> <modifier>*</modifier></type><name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>update_indexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyInsertDesc</name></type>	<name>insertDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyDeleteDesc</name></type>	<name>deleteDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTuple</name></type>				<name>mtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_Result</name></type>				<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: since we don't know how many rows will actually be inserted (as we
	 * don't know how many rows are visible), we provide the default number of
	 * rows to bump gp_fastsequence by.
	 */</comment>
	<expr_stmt><expr><name>insertDesc</name> <operator>=</operator> <call><name>get_or_create_ao_insert_descriptor</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NUM_FAST_SEQUENCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>deleteDesc</name> <operator>=</operator> <call><name>get_or_create_delete_descriptor</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the tuple with table oid */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>mtuple</name> <operator>=</operator> <call><name>appendonly_form_memtuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>insertDesc</name><operator>-&gt;</operator><name>mt_bind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(
								   <argument><expr><literal type="string">"appendonly_update"</literal></expr></argument>,
								   <argument><expr><name>DDLNotSpecified</name></expr></argument>,
								   <argument><expr><literal type="string">""</literal></expr></argument>, <comment type="line">//databaseName</comment>
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>insertDesc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* tableName */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>appendonly_delete</name><argument_list>(<argument><expr><name>deleteDesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <name>otid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>TM_Ok</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendonly_insert</name><argument_list>(<argument><expr><name>insertDesc</name></expr></argument>, <argument><expr><name>mtuple</name></expr></argument>, <argument><expr><operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_count_heap_update</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* No HOT updates with AO tables. */</comment>
	<expr_stmt><expr><operator>*</operator><name>update_indexes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendonly_free_memtuple</name><argument_list>(<argument><expr><name>mtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>appendonly_tuple_lock</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
				  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>,
				  <parameter><decl><type><name>LockWaitPolicy</name></type> <name>wait_policy</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>flags</name></decl></parameter>,
				  <parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
 	<comment type="block">/* GPDB_12_MERGE_FIXME: not supported. Can this function be left out completely? Or ereport()? */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"speculative insertion not supported on AO tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_finish_bulk_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendonly_dml_finish</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* helper routine to call open a rel and call heap_truncate_one_rel() on it */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_truncate_one_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>heap_truncate_one_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------
 * DDL related callbacks for appendonly AM.
 * ------------------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_relation_set_new_filenode</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>RelFileNode</name> <modifier>*</modifier></type><name>newrnode</name></decl></parameter>,
									 <parameter><decl><type><name>char</name></type> <name>persistence</name></decl></parameter>,
									 <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>freezeXid</name></decl></parameter>,
									 <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>minmulti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>srel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Append-optimized tables do not contain transaction information in
	 * tuples.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>freezeXid</name> <operator>=</operator> <operator>*</operator><name>minmulti</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * No special treatment is needed for new AO_ROW/COLUMN relation. Create
	 * the underlying disk file storage for the relation.  No clean up is
	 * needed, RelationCreateStorage() is transactional.
	 *
	 * Segment files will be created when / if needed.
	 */</comment>
	<expr_stmt><expr><name>srel</name> <operator>=</operator> <call><name>RelationCreateStorage</name><argument_list>(<argument><expr><operator>*</operator><name>newrnode</name></expr></argument>, <argument><expr><name>persistence</name></expr></argument>, <argument><expr><name>SMGR_AO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If required, set up an init fork for an unlogged table so that it can
	 * be correctly reinitialized on restart.  An immediate sync is required
	 * even if the page has been logged, because the write did not go through
	 * shared_buffers and therefore a concurrent checkpoint may have moved the
	 * redo pointer past our xlog record.  Recovery may as well remove it
	 * while replaying, for example, XLOG_DBASE_CREATE or XLOG_TBLSPC_CREATE
	 * record. Therefore, logging is necessary even if wal_level=minimal.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>persistence</name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
			   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>smgrcreate</name><argument_list>(<argument><expr><name>srel</name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>log_smgrcreate</name><argument_list>(<argument><expr><name>newrnode</name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>, <argument><expr><name>SMGR_AO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>smgrimmedsync</name><argument_list>(<argument><expr><name>srel</name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>srel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_relation_nontransactional_truncate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>ao_base_relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type>			<name>aoseg_relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aoblkdir_relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aovisimap_relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ao_truncate_one_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also truncate the aux tables */</comment>
	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name>ao_base_relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>aoseg_relid</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>aoblkdir_relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>aovisimap_relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_truncate_one_relid</name><argument_list>(<argument><expr><name>aoseg_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_truncate_one_relid</name><argument_list>(<argument><expr><name>aoblkdir_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_truncate_one_relid</name><argument_list>(<argument><expr><name>aovisimap_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_relation_copy_data</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelFileNode</name> <modifier>*</modifier></type><name>newrnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>dstrel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use the "AO-specific" (non-shared buffers backed storage) SMGR
	 * implementation
	 */</comment>
	<expr_stmt><expr><name>dstrel</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><operator>*</operator><name>newrnode</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>, <argument><expr><name>SMGR_AO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create and copy all forks of the relation, and schedule unlinking of
	 * old physical files.
	 *
	 * NOTE: any conflict in relfilenode value will be caught in
	 * RelationCreateStorage().
	 */</comment>
	<expr_stmt><expr><call><name>RelationCreateStorage</name><argument_list>(<argument><expr><operator>*</operator><name>newrnode</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>, <argument><expr><name>SMGR_AO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_append_only_data</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><operator>*</operator><name>newrnode</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For append-optimized tables, no forks other than the main fork should
	 * exist with the exception of unlogged tables.  For unlogged AO tables,
	 * INIT_FORK must exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><call><name>smgrexists</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * INIT_FORK is empty, creating it is sufficient, no need to copy
		 * contents from source to destination.
		 */</comment>
		<expr_stmt><expr><call><name>smgrcreate</name><argument_list>(<argument><expr><name>dstrel</name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>log_smgrcreate</name><argument_list>(<argument><expr><name>newrnode</name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>, <argument><expr><name>SMGR_AO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* drop old relation, and close new one */</comment>
	<expr_stmt><expr><call><name>RelationDropStorage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>dstrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_vacuum_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
					  <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Implemented but not invoked, we do the AO_ROW different phases vacuuming by
	 * calling ao_vacuum_rel() in vacuum_rel() directly for now.
	 */</comment>
	<expr_stmt><expr><call><name>ao_vacuum_rel</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>bstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_relation_copy_for_cluster</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>OldHeap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>NewHeap</name></decl></parameter>,
								 <parameter><decl><type><name>Relation</name></type> <name>OldIndex</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_sort</name></decl></parameter>,
								 <parameter><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl></parameter>,
								 <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xid_cutoff</name></decl></parameter>,
								 <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>multi_cutoff</name></decl></parameter>,
								 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>num_tuples</name></decl></parameter>,
								 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tups_vacuumed</name></decl></parameter>,
								 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tups_recently_dead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>oldTupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>newTupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>FreezeXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>MultiXactCutoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>tuplesort</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGRUsage</name></type>	<name>ru0</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AOTupleId</name></type>				<name>aoTupleId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyInsertDesc</name></type>	<name>aoInsertDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTupleBinding</name><modifier>*</modifier></type>		<name>mt_bind</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>write_seg_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTuple</name></type>				<name>mtuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name>		   <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type>			<name>aoscandesc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Curently AO storage lacks cost model for IndexScan, thus IndexScan
	 * is not functional. In future, probably, this will be fixed and CLUSTER
	 * command will support this. Though, random IO over AO on TID stream
	 * can be impractical anyway.
	 * Here we are sorting data on on the lines of heap tables, build a tuple
	 * sort state and sort the entire AO table using the index key, rewrite
	 * the table, one tuple at a time, in order as returned by tuple sort state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>OldIndex</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IS_BTREE</name><argument_list>(<argument><expr><name>OldIndex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cluster append-optimized table \"%s\""</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Append-optimized tables can only be clustered against a B-tree index"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Their tuple descriptors should be exactly alike, but here we only need
	 * assume that they have the same number of columns.
	 */</comment>
	<expr_stmt><expr><name>oldTupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newTupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name><name>oldTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Preallocate values/isnull arrays to deform heap tuples after sort */</comment>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the OldHeap has a toast table, get lock on the toast table to keep
	 * it from being vacuumed.  This is needed because autovacuum processes
	 * toast tables independently of their main tables, with no lock on the
	 * latter.  If an autovacuum were to start on the toast table after we
	 * compute our OldestXmin below, it would use a later OldestXmin, and then
	 * possibly remove as DEAD toast tuples belonging to main tuples we think
	 * are only RECENTLY_DEAD.  Then we'd fail while trying to copy those
	 * tuples.
	 *
	 * We don't need to open the toast relation here, just lock it.  The lock
	 * will be held till end of transaction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* use_wal off requires smgr_targblock be initially invalid */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationGetTargetBlock</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute sane values for FreezeXid and CutoffMulti with regular
	 * VACUUM machinery to avoidconfising existing CLUSTER code.
	 */</comment>
	<expr_stmt><expr><call><name>vacuum_set_xid_limits</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>OldestXmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>FreezeXid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>MultiXactCutoff</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * FreezeXid will become the table's new relfrozenxid, and that mustn't go
	 * backwards, so take the max.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>FreezeXid</name></expr></argument>, <argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>FreezeXid</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * MultiXactCutoff, similarly, shouldn't go backwards either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>MultiXactCutoff</name></expr></argument>, <argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>MultiXactCutoff</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relminmxid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* return selected values to caller */</comment>
	<expr_stmt><expr><operator>*</operator><name>xid_cutoff</name> <operator>=</operator> <name>FreezeXid</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>multi_cutoff</name> <operator>=</operator> <name>MultiXactCutoff</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuplesort</name> <operator>=</operator> <call><name>tuplesort_begin_cluster</name><argument_list>(<argument><expr><name>oldTupDesc</name></expr></argument>, <argument><expr><name>OldIndex</name></expr></argument>,
											<argument><expr><name>maintenance_work_mem</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* Log what we're doing */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"clustering \"%s.%s\" using sequential scan and sort"</literal></expr></argument>,
					<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan through old table to convert data into tuples for sorting */</comment>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aoscandesc</name> <operator>=</operator> <call><name>appendonly_beginscan</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mt_bind</name> <operator>=</operator> <call><name>create_memtuple_binding</name><argument_list>(<argument><expr><name>oldTupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>appendonly_getnextslot</name><argument_list>(<argument><expr><name>aoscandesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>slot_values</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>slot_isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>   <name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Extract all the values of the tuple */</comment>
		<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot_values</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot_isnull</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>oldTupDesc</name></expr></argument>, <argument><expr><name>slot_values</name></expr></argument>, <argument><expr><name>slot_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>num_tuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tuplesort_putheaptuple</name><argument_list>(<argument><expr><name>tuplesort</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendonly_endscan</name><argument_list>(<argument><expr><name>aoscandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * omplete the sort, then read out all tuples
	 * from the tuplestore and write them to the new relation.
	 */</comment>

	<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name>tuplesort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>write_seg_no</name> <operator>=</operator> <call><name>ChooseSegnoForWrite</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aoInsertDesc</name> <operator>=</operator> <call><name>appendonly_insert_init</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>, <argument><expr><name>write_seg_no</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <operator>*</operator><name>num_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Insert sorted heap tuples into new storage */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>prev_memtuple_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>null_save_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_nulls</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>tuplesort_getheaptuple</name><argument_list>(<argument><expr><name>tuplesort</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>oldTupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>compute_memtuple_size</name><argument_list>(<argument><expr><name>mt_bind</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>null_save_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>has_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>prev_memtuple_len</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Here we are trying to avoid reallocation of temp mtuple */</comment>
			<if_stmt><if>if <condition>(<expr><name>mtuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>mtuple</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prev_memtuple_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memtuple_form_to</name><argument_list>(<argument><expr><name>mt_bind</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>null_save_len</name></expr></argument>, <argument><expr><name>has_nulls</name></expr></argument>,
					<argument><expr><name>mtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendonly_insert</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>, <argument><expr><name>mtuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name>tuplesort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Finish and deallocate insertion */</comment>
	<expr_stmt><expr><call><name>appendonly_insert_finish</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>appendonly_scan_analyze_next_block</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl></parameter>,
							   <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyScanDesc</name></type> <name>aoscan</name> <init>= <expr><operator>(</operator><name>AppendOnlyScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>targetTupleId</name></name> <operator>=</operator> <name>blockno</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>appendonly_scan_analyze_next_tuple</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl></parameter>,
							   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>liverows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>deadrows</name></decl></parameter>,
							   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyScanDesc</name></type> <name>aoscan</name> <init>= <expr><operator>(</operator><name>AppendOnlyScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* skip several tuples if they are not sampling target */</comment>
	<while>while <condition>(<expr><operator>!</operator><name><name>aoscan</name><operator>-&gt;</operator><name>aos_done_all_segfiles</name></name>
		   <operator>&amp;&amp;</operator> <name><name>aoscan</name><operator>-&gt;</operator><name>targetTupleId</name></name> <operator>&gt;</operator> <name><name>aoscan</name><operator>-&gt;</operator><name>nextTupleId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendonly_getnextslot</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>nextTupleId</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>aoscan</name><operator>-&gt;</operator><name>aos_done_all_segfiles</name></name>
		<operator>&amp;&amp;</operator> <name><name>aoscan</name><operator>-&gt;</operator><name>targetTupleId</name></name> <operator>==</operator> <name><name>aoscan</name><operator>-&gt;</operator><name>nextTupleId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>appendonly_getnextslot</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>nextTupleId</name></name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>liverows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>deadrows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* if return an invisible tuple */</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>appendonly_index_build_range_scan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
							  <parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
							  <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>allow_sync</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>anyvisible</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>progress</name></decl></parameter>,
							  <parameter><decl><type><name>BlockNumber</name></type> <name>start_blockno</name></decl></parameter>,
							  <parameter><decl><type><name>BlockNumber</name></type> <name>numblocks</name></decl></parameter>,
							  <parameter><decl><type><name>IndexBuildCallback</name></type> <name>callback</name></decl></parameter>,
							  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>,
							  <parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyScanDesc</name></type> <name>aoscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_system_catalog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>checking_uniqueness</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>predicate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remember if it's a system catalog */</comment>
	<expr_stmt><expr><name>is_system_catalog</name> <operator>=</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Appendoptimized catalog tables are not supported. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_system_catalog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Appendoptimized tables have no data on master. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* See whether we're verifying uniqueness/exclusion properties */</comment>
	<expr_stmt><expr><name>checking_uniqueness</name> <operator>=</operator> <operator>(</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name> <operator>||</operator>
						   <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * "Any visible" mode is not compatible with uniqueness checks; make sure
	 * only one of those is requested.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>anyvisible</name> <operator>&amp;&amp;</operator> <name>checking_uniqueness</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need an EState for evaluation of index expressions and partial-index
	 * predicates.  Also a slot to hold the current tuple.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/* Set up execution state for predicate, if any. */</comment>
	<expr_stmt><expr><name>predicate</name> <operator>=</operator> <call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Serial index build.
		 *
		 * XXX: We always use SnapshotAny here. An MVCC snapshot and oldest xmin
		 * calculation is necessary to support indexes built CONCURRENTLY.
		 */</comment>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name>SnapshotAny</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_strat</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,	<comment type="block">/* relation */</comment>
									 <argument><expr><name>snapshot</name></expr></argument>,	<comment type="block">/* snapshot */</comment>
									 <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* number of keys */</comment>
									 <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* scan key */</comment>
									 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* buffer access strategy OK */</comment>
									 <argument><expr><name>allow_sync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* syncscan OK? */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Parallel index build.
		 *
		 * Parallel case never registers/unregisters own snapshot.  Snapshot
		 * is taken from parallel heap scan, and is SnapshotAny or an MVCC
		 * snapshot, based on same criteria as serial case.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>allow_sync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_snapshot</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>aoscan</name> <operator>=</operator> <operator>(</operator><name>AppendOnlyScanDesc</name><operator>)</operator> <name>scan</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If block directory is empty, it must also be built along with the index.
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>blkdirrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>blkidxrelid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aos_rd</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>blkdirrelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkidxrelid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Note that block directory is created during creation of the first
	 * index.  If it is found empty, it means the block directory was created
	 * by this create index transaction.  The caller (DefineIndex) must have
	 * acquired sufficiently strong lock on the appendoptimized table such
	 * that index creation as well as insert from concurrent transactions are
	 * blocked.  We can rest assured of exclusive access to the block
	 * directory relation.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>blkdir</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>blkdir</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Allocate blockDirectory in scan descriptor to let the access method
		 * know that it needs to also build the block directory while
		 * scanning.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>blockDirectory</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>blockDirectory</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyBlockDirectory</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>blkdir</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* GPDB_12_MERGE_FIXME */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	<comment type="block">/* Publish number of blocks to scan */</comment>
	if (progress)
	{
		BlockNumber nblocks;

		if (aoscan-&gt;rs_base.rs_parallel != NULL)
		{
			ParallelBlockTableScanDesc pbscan;

			pbscan = (ParallelBlockTableScanDesc) aoscan-&gt;rs_base.rs_parallel;
			nblocks = pbscan-&gt;phs_nblocks;
		}
		else
			nblocks = aoscan-&gt;rs_nblocks;

		pgstat_progress_update_param(PROGRESS_SCAN_BLOCKS_TOTAL,
									 nblocks);
	}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* set our scan endpoints */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_sync</name></expr>)</condition>
	<block>{<block_content>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* syncscan can only be requested on whole relation */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>start_blockno</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numblocks</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan all tuples in the base relation.
	 */</comment>
	<while>while <condition>(<expr><call><name>appendonly_getnextslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoscan</name><operator>-&gt;</operator><name>rs_base</name></name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>tupleIsAlive</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AOTupleId</name> 	<modifier>*</modifier></type><name>aoTupleId</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * GPDB_12_MERGE_FIXME: How to properly do a partial scan? Currently,
		 * we scan the whole table, and throw away tuples that are not in the
		 * range. That's clearly very inefficient.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>start_blockno</name> <operator>||</operator>
			<operator>(</operator><name>numblocks</name> <operator>!=</operator> <name>InvalidBlockNumber</name> <operator>&amp;&amp;</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>numblocks</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

	<comment type="block">/* GPDB_12_MERGE_FIXME */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
		<comment type="block">/* Report scan progress, if asked to. */</comment>
		if (progress)
		{
			BlockNumber blocks_done = appendonly_scan_get_blocks_done(aoscan);

			if (blocks_done != previous_blkno)
			{
				pgstat_progress_update_param(PROGRESS_SCAN_BLOCKS_DONE,
											 blocks_done);
				previous_blkno = blocks_done;
			}
		}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>aoTupleId</name> <operator>=</operator> <operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr>;</expr_stmt>
		<comment type="block">/*
		 * We didn't perform the check to see if the tuple was deleted in
		 * appendonlygettup(), since we passed it SnapshotAny. See
		 * appendonlygettup() for details. We need to do this to avoid spurious
		 * conflicts with deleted tuples for unique index builds.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyVisimap_IsVisible</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoscan</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reltuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* excluded from unique-checking */</comment>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In a partial index, discard tuples that don't satisfy the
		 * predicate.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * For the current heap tuple, extract all the attributes we use in
		 * this index, and note which are null.  This also performs evaluation
		 * of any expressions needed.
		 */</comment>
		<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
					   <argument><expr><name>slot</name></expr></argument>,
					   <argument><expr><name>estate</name></expr></argument>,
					   <argument><expr><name>values</name></expr></argument>,
					   <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * You'd think we should go ahead and build the index tuple here, but
		 * some index AMs want to do further processing on the data first.  So
		 * pass the values[] and isnull[] arrays, instead.
		 */</comment>

		<comment type="block">/* Call the AM's callback routine to process the tuple */</comment>
		<comment type="block">/*
		 * GPDB: the callback is modified to accept ItemPointer as argument
		 * instead of HeapTuple.  That allows the callback to be reused for
		 * appendoptimized tables.
		 */</comment>
		<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>tupleIsAlive</name></expr></argument>,
				 <argument><expr><name>callback_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></while>

	<comment type="block">/* GPDB_12_MERGE_FIXME */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	<comment type="block">/* Report scan progress one last time. */</comment>
	if (progress)
	{
		BlockNumber blks_done;

		if (aoscan-&gt;rs_base.rs_parallel != NULL)
		{
			ParallelBlockTableScanDesc pbscan;

			pbscan = (ParallelBlockTableScanDesc) aoscan-&gt;rs_base.rs_parallel;
			blks_done = pbscan-&gt;phs_nblocks;
		}
		else
			blks_done = aoscan-&gt;rs_nblocks;

		pgstat_progress_update_param(PROGRESS_SCAN_BLOCKS_DONE,
									 blks_done);
	}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* These may have been pointing to the now-gone estate */</comment>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>reltuples</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_index_validate_scan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
						   <parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
						   <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
						   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						   <parameter><decl><type><name>ValidateIndexState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyScanDesc</name></type> <name>aoscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heapTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>predicate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>root_blkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	OffsetNumber root_offsets[MaxHeapTuplesPerPage];
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>in_index</name><index>[<expr><name>MaxHeapTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* state variables for the merge */</comment>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>indexcursor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>decoded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tuplesort_empty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need an EState for evaluation of index expressions and partial-index
	 * predicates.  Also a slot to hold the current tuple.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/* Set up execution state for predicate, if any. */</comment>
	<expr_stmt><expr><name>predicate</name> <operator>=</operator> <call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare for scan of the base relation.  We need just those tuples
	 * satisfying the passed-in reference snapshot.  We must disable syncscan
	 * here, because it's critical that we read from block zero forward to
	 * match the sorted TIDs.
	 */</comment>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_strat</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,	<comment type="block">/* relation */</comment>
								 <argument><expr><name>snapshot</name></expr></argument>,	<comment type="block">/* snapshot */</comment>
								 <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* number of keys */</comment>
								 <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* scan key */</comment>
								 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* buffer access strategy OK */</comment>
								 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* syncscan not OK */</comment>
	<expr_stmt><expr><name>aoscan</name> <operator>=</operator> <operator>(</operator><name>AppendOnlyScanDesc</name><operator>)</operator> <name>scan</name></expr>;</expr_stmt>

	<comment type="block">/* GPDB_12_MERGE_FIXME */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	pgstat_progress_update_param(PROGRESS_SCAN_BLOCKS_TOTAL,
								 aoscan-&gt;rs_nblocks);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Scan all tuples matching the snapshot.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>heapTuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>heapcursor</name> <init>= <expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>rootTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>root_offnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>htups</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* GPDB_12_MERGE_FIXME */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
		if ((previous_blkno == InvalidBlockNumber) ||
			(aoscan-&gt;rs_cblock != previous_blkno))
		{
			pgstat_progress_update_param(PROGRESS_SCAN_BLOCKS_DONE,
										 aoscan-&gt;rs_cblock);
			previous_blkno = aoscan-&gt;rs_cblock;
		}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Convert actual tuple TID to root TID */</comment>
		<expr_stmt><expr><name>rootTuple</name> <operator>=</operator> <operator>*</operator><name>heapcursor</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>root_offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>heapcursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsHeapOnly</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* GPDB_12_MERGE_FIXME: root_offsets unitialized */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
			root_offnum = root_offsets[root_offnum - 1];
			if (!OffsetNumberIsValid(root_offnum))
				ereport(ERROR,
						(errcode(ERRCODE_DATA_CORRUPTED),
						 errmsg_internal("failed to find parent tuple for heap-only tuple at (%u,%u) in table \"%s\"",
										 ItemPointerGetBlockNumber(heapcursor),
										 ItemPointerGetOffsetNumber(heapcursor),
										 RelationGetRelationName(heapRelation))));
			ItemPointerSetOffsetNumber(&amp;rootTuple, root_offnum);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GPDB_12_MERGE_FIXME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * "merge" by skipping through the index tuples until we find or pass
		 * the current root tuple.
		 */</comment>
		<while>while <condition>(<expr><operator>!</operator><name>tuplesort_empty</name> <operator>&amp;&amp;</operator>
			   <operator>(</operator><operator>!</operator><name>indexcursor</name> <operator>||</operator>
				<call><name>ItemPointerCompare</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>ts_val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>ts_isnull</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>indexcursor</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Remember index items seen earlier on the current heap page
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>root_blkno</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>in_index</name><index>[<expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>tuplesort_empty</name> <operator>=</operator> <operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuplesort</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>ts_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts_isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuplesort_empty</name> <operator>||</operator> <operator>!</operator><name>ts_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tuplesort_empty</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>itemptr_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>decoded</name></expr></argument>, <argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>ts_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>indexcursor</name> <operator>=</operator> <operator>&amp;</operator><name>decoded</name></expr>;</expr_stmt>

				<comment type="block">/* If int8 is pass-by-ref, free (encoded) TID Datum memory */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_FLOAT8_BYVAL</name></cpp:ifndef>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>ts_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Be tidy */</comment>
				<expr_stmt><expr><name>indexcursor</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * If the tuplesort has overshot *and* we didn't see a match earlier,
		 * then this tuple is missing from the index, so insert it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tuplesort_empty</name> <operator>||</operator>
			 <call><name>ItemPointerCompare</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>in_index</name><index>[<expr><name>root_offnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Set up for predicate or expression evaluation */</comment>
			<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In a partial index, discard tuples that don't satisfy the
			 * predicate.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * For the current heap tuple, extract all the attributes we use
			 * in this index, and note which are null.  This also performs
			 * evaluation of any expressions needed.
			 */</comment>
			<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
						   <argument><expr><name>slot</name></expr></argument>,
						   <argument><expr><name>estate</name></expr></argument>,
						   <argument><expr><name>values</name></expr></argument>,
						   <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * You'd think we should go ahead and build the index tuple here,
			 * but some index AMs want to do further processing on the data
			 * first. So pass the values[] and isnull[] arrays, instead.
			 */</comment>

			<comment type="block">/*
			 * If the tuple is already committed dead, you might think we
			 * could suppress uniqueness checking, but this is no longer true
			 * in the presence of HOT, because the insert is actually a proxy
			 * for a uniqueness check on the whole HOT-chain.  That is, the
			 * tuple we have here could be dead because it was already
			 * HOT-updated, and if so the updating transaction will not have
			 * thought it should insert index entries.  The index AM will
			 * check the whole HOT-chain and correctly detect a conflict if
			 * there is one.
			 */</comment>

			<expr_stmt><expr><call><name>index_insert</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>,
						 <argument><expr><name>values</name></expr></argument>,
						 <argument><expr><name>isnull</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>,
						 <argument><expr><name>heapRelation</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr> ?</condition><then>
						 <expr><name>UNIQUE_CHECK_YES</name></expr> </then><else>: <expr><name>UNIQUE_CHECK_NO</name></expr></else></ternary></expr></argument>,
						 <argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tups_inserted</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* These may have been pointing to the now-gone estate */</comment>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------
 * Miscellaneous callbacks for the appendonly AM
 * ------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * This pretends that the all the space is taken by the main fork.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>appendonly_relation_size</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_aoseg_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>pg_aoseg_dsc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>aoscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>eof</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>segrelid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>forkNumber</name> <operator>!=</operator> <name>MAIN_FORKNUM</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segrelid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
			<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segrelid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find pg_aoseg aux table for AO table \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pg_aoseg_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>segrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_aoseg_dsc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_aoseg_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aoscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_aoseg_rel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>aoscan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>eof</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_aoseg_eof</name></expr></argument>, <argument><expr><name>pg_aoseg_dsc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>eof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>aoscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_aoseg_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check to see whether the table needs a TOAST table.  It does only if
 * (1) there are any toastable attributes, and (2) the maximum length
 * of a tuple could exceed TOAST_TUPLE_THRESHOLD.  (We don't want to
 * create a toast table for something like "f1 varchar(20)".)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>appendonly_relation_needs_toast_table</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>data_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>maxlength_unknown</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_toastable_attrs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tuple_length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Fixed-length types are never toastable */</comment>
			<expr_stmt><expr><name>data_length</name> <operator>+=</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type>		<name>maxlen</name> <init>= <expr><call><name>type_maximum_size</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
												   <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>maxlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>maxlength_unknown</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>data_length</name> <operator>+=</operator> <name>maxlen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>!=</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>has_toastable_attrs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_toastable_attrs</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* nothing to toast? */</comment>
	<if_stmt><if>if <condition>(<expr><name>maxlength_unknown</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* any unlimited-length attrs? */</comment>
	<expr_stmt><expr><name>tuple_length</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofHeapTupleHeader</name> <operator>+</operator>
							<call><name>BITMAPLEN</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>tuple_length</name> <operator>&gt;</operator> <name>TOAST_TUPLE_THRESHOLD</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------
 * Planner related callbacks for the appendonly AM
 * ------------------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendonly_estimate_rel_size</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>attr_widths</name></decl></parameter>,
						 <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>pages</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>,
						 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>allvisfrac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileSegTotals</name>  <modifier>*</modifier></type><name>fileSegTotals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>		<name>snapshot</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fileSegTotals</name> <operator>=</operator> <call><name>GetSegFilesTotals</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name><name>fileSegTotals</name><operator>-&gt;</operator><name>totaltuples</name></name></expr>;</expr_stmt>

	<comment type="block">/* Quick exit if empty */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tuples</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fileSegTotals</name><operator>-&gt;</operator><name>totalbytesuncompressed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <call><name>RelationGuessNumberOfBlocksFromSize</name><argument_list>(
					<argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><name><name>fileSegTotals</name><operator>-&gt;</operator><name>totalbytesuncompressed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do not bother scanning the visimap aux table.
	 * Investigate if really needed.
	 * 
	 * For Heap table, visibility map may help to estimate
	 * the number of page fetches can be avoided during an
	 * index-only scan. That is not the case for AO/AOCS table
	 * since index-only scan hasn't been used with AO/AOCS.
	 * So leave the comment here for future reference once
	 * we have a clear requirement to do that.
	 */</comment>

	<return>return;</return>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * Executor related callbacks for the appendonly AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>appendonly_scan_bitmap_next_block</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>,
								  <parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmres</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyScanDesc</name></type> <name>aoscan</name> <init>= <expr><operator>(</operator><name>AppendOnlyScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Start scanning from the beginning of the offsets array (or
	 * at first "offset number" if it's a lossy page).
	 * Have to set the init value before return fase. Since in
	 * nodeBitmapHeapscan.c's BitmapHeapNext. After call
	 * `table_scan_bitmap_next_block` and return false, it doesn't
	 * clean the tbmres. And then it'll read tuples from the page
	 * which should be skipped.
	 */</comment>
	<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* If tbmres contains no tuples, continue. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbmres</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Make sure we never cross 15-bit offset number [MPP-24326] */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbmres</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>&lt;=</operator> <name>INT16_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>appendonly_scan_bitmap_next_tuple</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>,
								  <parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmres</name></decl></parameter>,
								  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyScanDesc</name></type>	<name>aoscan</name> <init>= <expr><operator>(</operator><name>AppendOnlyScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type>		<name>pseudoHeapOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> 	<name>pseudoHeapTid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOTupleId</name></type>			<name>aoTid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>numTuples</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name> <operator>=</operator>
			<call><name>appendonly_fetch_init</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
			                      <argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>,
			                      <argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ntuples == -1 indicates a lossy page */</comment>
	<expr_stmt><expr><name>numTuples</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>tbmres</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name>INT16_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name><name>tbmres</name><operator>-&gt;</operator><name>ntuples</name></name></expr></else></ternary></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>aoscan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>&lt;</operator> <name>numTuples</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If it's a lossy pase, iterate through all possible "offset numbers".
		 * Otherwise iterate through the array of "offset numbers".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbmres</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * +1 to convert index to offset, since TID offsets are not zero
			 * based.
			 */</comment>
			<expr_stmt><expr><name>pseudoHeapOffset</name> <operator>=</operator> <name><name>aoscan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>pseudoHeapOffset</name> <operator>=</operator> <name><name>tbmres</name><operator>-&gt;</operator><name>offsets</name><index>[<expr><name><name>aoscan</name><operator>-&gt;</operator><name>rs_cindex</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>rs_cindex</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Okay to fetch the tuple
		 */</comment>
		<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pseudoHeapTid</name></expr></argument>, <argument><expr><name><name>tbmres</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>, <argument><expr><name>pseudoHeapOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tbm_convert_appendonly_tid_out</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pseudoHeapTid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aoTid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><call><name>appendonly_fetch</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aoTid</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* OK to return this tuple */</comment>
			<expr_stmt><expr><call><name>pgstat_count_heap_fetch</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aos_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Done with this block */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>appendonly_scan_sample_next_block</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>SampleScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * GPDB_95_MERGE_FIXME: Add support for AO tables
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid relation type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Sampling is only supported in heap tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>appendonly_scan_sample_next_tuple</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>SampleScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>,
							  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * GPDB_95_MERGE_FIXME: Add support for AO tables
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid relation type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Sampling is only supported in heap tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------
 * Definition of the appendonly table access method.
 *
 * NOTE: While there is a lot of functionality shared with the ao_column access
 * method, is best for the handler methods to remain static in order to honour
 * the contract of the access method interface.
 * ------------------------------------------------------------------------
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TableAmRoutine</name></type> <name>ao_row_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_TableAmRoutine</name></expr>,

	<expr><operator>.</operator><name>slot_callbacks</name> <operator>=</operator> <name>appendonly_slot_callbacks</name></expr>,

	<expr><operator>.</operator><name>scan_begin</name> <operator>=</operator> <name>appendonly_beginscan</name></expr>,
	<expr><operator>.</operator><name>scan_end</name> <operator>=</operator> <name>appendonly_endscan</name></expr>,
	<expr><operator>.</operator><name>scan_rescan</name> <operator>=</operator> <name>appendonly_rescan</name></expr>,
	<expr><operator>.</operator><name>scan_getnextslot</name> <operator>=</operator> <name>appendonly_getnextslot</name></expr>,

	<expr><operator>.</operator><name>parallelscan_estimate</name> <operator>=</operator> <name>appendonly_parallelscan_estimate</name></expr>,
	<expr><operator>.</operator><name>parallelscan_initialize</name> <operator>=</operator> <name>appendonly_parallelscan_initialize</name></expr>,
	<expr><operator>.</operator><name>parallelscan_reinitialize</name> <operator>=</operator> <name>appendonly_parallelscan_reinitialize</name></expr>,

	<expr><operator>.</operator><name>index_fetch_begin</name> <operator>=</operator> <name>appendonly_index_fetch_begin</name></expr>,
	<expr><operator>.</operator><name>index_fetch_reset</name> <operator>=</operator> <name>appendonly_index_fetch_reset</name></expr>,
	<expr><operator>.</operator><name>index_fetch_end</name> <operator>=</operator> <name>appendonly_index_fetch_end</name></expr>,
	<expr><operator>.</operator><name>index_fetch_tuple</name> <operator>=</operator> <name>appendonly_index_fetch_tuple</name></expr>,
	<expr><operator>.</operator><name>index_fetch_tuple_exists</name> <operator>=</operator> <name>appendonly_index_fetch_tuple_exists</name></expr>,

	<expr><operator>.</operator><name>dml_init</name> <operator>=</operator> <name>appendonly_dml_init</name></expr>,
	<expr><operator>.</operator><name>dml_finish</name> <operator>=</operator> <name>appendonly_dml_finish</name></expr>,

	<expr><operator>.</operator><name>tuple_insert</name> <operator>=</operator> <name>appendonly_tuple_insert</name></expr>,
	<expr><operator>.</operator><name>tuple_insert_speculative</name> <operator>=</operator> <name>appendonly_tuple_insert_speculative</name></expr>,
	<expr><operator>.</operator><name>tuple_complete_speculative</name> <operator>=</operator> <name>appendonly_tuple_complete_speculative</name></expr>,
	<expr><operator>.</operator><name>multi_insert</name> <operator>=</operator> <name>appendonly_multi_insert</name></expr>,
	<expr><operator>.</operator><name>tuple_delete</name> <operator>=</operator> <name>appendonly_tuple_delete</name></expr>,
	<expr><operator>.</operator><name>tuple_update</name> <operator>=</operator> <name>appendonly_tuple_update</name></expr>,
	<expr><operator>.</operator><name>tuple_lock</name> <operator>=</operator> <name>appendonly_tuple_lock</name></expr>,
	<expr><operator>.</operator><name>finish_bulk_insert</name> <operator>=</operator> <name>appendonly_finish_bulk_insert</name></expr>,

	<expr><operator>.</operator><name>tuple_fetch_row_version</name> <operator>=</operator> <name>appendonly_fetch_row_version</name></expr>,
	<expr><operator>.</operator><name>tuple_get_latest_tid</name> <operator>=</operator> <name>appendonly_get_latest_tid</name></expr>,
	<expr><operator>.</operator><name>tuple_tid_valid</name> <operator>=</operator> <name>appendonly_tuple_tid_valid</name></expr>,
	<expr><operator>.</operator><name>tuple_satisfies_snapshot</name> <operator>=</operator> <name>appendonly_tuple_satisfies_snapshot</name></expr>,
	<expr><operator>.</operator><name>compute_xid_horizon_for_tuples</name> <operator>=</operator> <name>appendonly_compute_xid_horizon_for_tuples</name></expr>,

	<expr><operator>.</operator><name>relation_set_new_filenode</name> <operator>=</operator> <name>appendonly_relation_set_new_filenode</name></expr>,
	<expr><operator>.</operator><name>relation_nontransactional_truncate</name> <operator>=</operator> <name>appendonly_relation_nontransactional_truncate</name></expr>,
	<expr><operator>.</operator><name>relation_copy_data</name> <operator>=</operator> <name>appendonly_relation_copy_data</name></expr>,
	<expr><operator>.</operator><name>relation_copy_for_cluster</name> <operator>=</operator> <name>appendonly_relation_copy_for_cluster</name></expr>,
	<expr><operator>.</operator><name>relation_vacuum</name> <operator>=</operator> <name>appendonly_vacuum_rel</name></expr>,
	<expr><operator>.</operator><name>scan_analyze_next_block</name> <operator>=</operator> <name>appendonly_scan_analyze_next_block</name></expr>,
	<expr><operator>.</operator><name>scan_analyze_next_tuple</name> <operator>=</operator> <name>appendonly_scan_analyze_next_tuple</name></expr>,
	<expr><operator>.</operator><name>index_build_range_scan</name> <operator>=</operator> <name>appendonly_index_build_range_scan</name></expr>,
	<expr><operator>.</operator><name>index_validate_scan</name> <operator>=</operator> <name>appendonly_index_validate_scan</name></expr>,

	<expr><operator>.</operator><name>relation_size</name> <operator>=</operator> <name>appendonly_relation_size</name></expr>,
	<expr><operator>.</operator><name>relation_needs_toast_table</name> <operator>=</operator> <name>appendonly_relation_needs_toast_table</name></expr>,

	<expr><operator>.</operator><name>relation_estimate_size</name> <operator>=</operator> <name>appendonly_estimate_rel_size</name></expr>,

	<expr><operator>.</operator><name>scan_bitmap_next_block</name> <operator>=</operator> <name>appendonly_scan_bitmap_next_block</name></expr>,
	<expr><operator>.</operator><name>scan_bitmap_next_tuple</name> <operator>=</operator> <name>appendonly_scan_bitmap_next_tuple</name></expr>,
	<expr><operator>.</operator><name>scan_sample_next_block</name> <operator>=</operator> <name>appendonly_scan_sample_next_block</name></expr>,
	<expr><operator>.</operator><name>scan_sample_next_tuple</name> <operator>=</operator> <name>appendonly_scan_sample_next_tuple</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>Datum</name></type>
<name>ao_row_tableam_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ao_row_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
