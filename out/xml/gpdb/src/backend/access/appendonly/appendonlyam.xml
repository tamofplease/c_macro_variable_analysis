<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/appendonly/appendonlyam.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * appendonlyam.c
 *	  append-only relation access method code
 *
 * Portions Copyright (c) 1996-2006, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2008-2009, Greenplum Inc.
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/access/appendonly/appendonlyam.c
 *
 *
 * INTERFACE ROUTINES
 *		appendonly_beginscan		- begin relation scan
 *		appendonly_rescan			- restart a relation scan
 *		appendonly_endscan			- end relation scan
 *		appendonly_getnextslot		- retrieve next tuple in scan
 *		appendonly_insert_init		- initialize an insert operation
 *		appendonly_insert			- insert tuple into a relation
 *		appendonly_insert_finish	- finish an insert operation
 *
 * NOTES
 *	  This file contains the appendonly_ routines which implement
 *	  the access methods used for all append-only relations.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage_xlog.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/aosegfiles.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonlytid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonlywriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/aomd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/valid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_fastsequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_appendonly.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute_encoding.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystorage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystorageformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystoragelayer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>


<typedef>typedef <type><enum>enum <name>AoExecutorBlockKind</name>
<block>{
	<decl><name>AoExecutorBlockKind_None</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>AoExecutorBlockKind_VarBlock</name></decl>,
	<decl><name>AoExecutorBlockKind_SingleRow</name></decl>,
	<decl><name>MaxAoExecutorBlockKind</name></decl>		<comment type="block">/* must always be last */</comment>
}</block></enum></type>			<name>AoExecutorBlockKind</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendOnlyExecutionReadBlock_SetSegmentFileNum</name><parameter_list>(
											   <parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>segmentFileNum</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendOnlyExecutionReadBlock_SetPositionInfo</name><parameter_list>(
											 <parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>,
											 <parameter><decl><type><name>int64</name></type> <name>blockFirstRowNum</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendOnlyExecutorReadBlock_Init</name><parameter_list>(
								 <parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>,
								 <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
								 <parameter><decl><type><name>MemoryContext</name></type> <name>memoryContext</name></decl></parameter>,
								 <parameter><decl><type><name>AppendOnlyStorageRead</name> <modifier>*</modifier></type><name>storageRead</name></decl></parameter>,
								 <parameter><decl><type><name>int32</name></type> <name>usableBlockSize</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendOnlyExecutorReadBlock_Finish</name><parameter_list>(
								   <parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendOnlyExecutorReadBlock_ResetCounts</name><parameter_list>(
										<parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------
 *		initscan - scan code common to appendonly_beginscan and appendonly_rescan
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initscan</name><parameter_list>(<parameter><decl><type><name>AppendOnlyScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * copy the scan key, if appropriate
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_nkeys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_filenamepath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_segfiles_processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_need_new_segfile</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* need to assign a file to be scanned */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_done_all_segfiles</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>bufferDone</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>initedStorageRoutines</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AppendOnlyExecutorReadBlock_ResetCounts</name><argument_list>(
												<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>executorReadBlock</name><operator>.</operator><name>mt_bind</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_count_heap_scan</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open the next file segment to scan and allocate all resources needed for it.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SetNextFileSegForRead</name><parameter_list>(<parameter><decl><type><name>AppendOnlyScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>reln</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>aos_rd</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>eof</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>formatversion</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* some invalid value */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>finished_all_files</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* assume */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fileSegNo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_need_new_segfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* only call me when last segfile
										 * completed */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>aos_done_all_segfiles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* don't call me if I told you to
											 * stop */</comment>


	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>initedStorageRoutines</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGFunction</name> <modifier>*</modifier></type><name>fns</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AppendOnlyStorageRead_Init</name><argument_list>(
								   <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>,
								   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aoScanInitContext</name></name></expr></argument>,
								   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>usableBlockSize</name></name></expr></argument>,
								   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_rd</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>title</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>storageAttributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * There is no guarantee that the current memory context will be
		 * preserved between calls, so switch to a safe memory context for
		 * retrieving compression information.
		 */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldMemoryContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aoScanInitContext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Get the relation specific compression functions */</comment>

		<expr_stmt><expr><name>fns</name> <operator>=</operator> <call><name>get_funcs_for_compression</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>compressType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>storageRead</name><operator>.</operator><name>compression_functions</name></name> <operator>=</operator> <name>fns</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>storageRead</name><operator>.</operator><name>compression_functions</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGFunction</name></type>	<name>cons</name> <init>= <expr><name><name>fns</name><index>[<expr><name>COMPRESSION_CONSTRUCTOR</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CompressionState</name> <modifier>*</modifier></type><name>cs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StorageAttributes</name></type> <name>sa</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>comptype</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>compressType</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>complevel</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>compressLevel</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>blocksize</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>usableBlockSize</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * The relation's tuple descriptor allows the compression
			 * constructor to make decisions about how to compress or
			 * decompress the relation given it's structure.
			 */</comment>
			<expr_stmt><expr><name>cs</name> <operator>=</operator> <call><name>callCompressionConstructor</name><argument_list>(<argument><expr><name>cons</name></expr></argument>,
											<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument> <comment type="block">/* decompress */</comment> )</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>storageRead</name><operator>.</operator><name>compressionState</name></name> <operator>=</operator> <name>cs</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Switch back to caller's memory context. */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AppendOnlyExecutorReadBlock_Init</name><argument_list>(
										 <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>,
										 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_rd</name></name></expr></argument>,
										 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aoScanInitContext</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>,
										 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>usableBlockSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>bufferDone</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* so we read a new buffer right away */</comment>

		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>initedStorageRoutines</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do we have more segment files to read or are we done?
	 */</comment>
	<while>while <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>aos_segfiles_processed</name></name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>aos_total_segfiles</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* still have more segment files to read. get info of the next one */</comment>
		<decl_stmt><decl><type><name>FileSegInfo</name> <modifier>*</modifier></type><name>fsinfo</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>aos_segfile_arr</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>aos_segfiles_processed</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>segno</name> <operator>=</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>segno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>formatversion</name> <operator>=</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>formatversion</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>eof</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>eof</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_segfiles_processed</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the 'eof' is zero or it's just a lingering dropped segment
		 * (which we see as dead, too), skip it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>eof</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>AOSEG_STATE_AWAITING_DROP</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Initialize the block directory for inserts if needed. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_Init_forInsert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>,
														<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>,
														<argument><expr><name>fsinfo</name></expr></argument>,
														<argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* lastSequence */</comment>
														<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_rd</name></name></expr></argument>,
														<argument><expr><name>segno</name></expr></argument>,	<comment type="block">/* segno */</comment>
														<argument><expr><literal type="number">1</literal></expr></argument>,	<comment type="block">/* columnGroupNo */</comment>
														<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>finished_all_files</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>finished_all_files</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* finished reading all segment files */</comment>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_need_new_segfile</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_done_all_segfiles</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MakeAOSegmentFileName</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileSegNo</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_filenamepath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_filenamepath</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name><name>scan</name><operator>-&gt;</operator><name>aos_filenamepath_maxlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>initedStorageRoutines</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyStorageRead_OpenFile</name><argument_list>(
								   <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>,
								   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_filenamepath</name></name></expr></argument>,
								   <argument><expr><name>formatversion</name></expr></argument>,
								   <argument><expr><name>eof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyExecutionReadBlock_SetSegmentFileNum</name><argument_list>(
												   <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>,
												   <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyExecutionReadBlock_SetPositionInfo</name><argument_list>(
												 <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>,
												  <comment type="block">/* blockFirstRowNum */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ready to go! */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_need_new_segfile</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_scan</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-only scan initialize for table '%s', %u/%u/%u, segment file %u, EOF "</literal> <name>INT64_FORMAT</name> <literal type="string">", "</literal>
		   <literal type="string">"(compression = %s, usable blocksize %d)"</literal></expr></argument>,
		   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_rd</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_rd</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
		   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_rd</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
		   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_rd</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
		   <argument><expr><name>segno</name></expr></argument>,
		   <argument><expr><name>eof</name></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name><name>scan</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>compress</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>usableBlockSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errcontext_appendonly_insert_block_user_limit
 *
 * Add an errcontext() line showing the table name but little else because this is a user
 * caused error.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errcontext_appendonly_insert_block_user_limit</name><parameter_list>(<parameter><decl><type><name>AppendOnlyInsertDesc</name></type> <name>aoInsertDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"Append-Only table '%s'"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Open the next file segment for write.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetCurrentFileSegForWrite</name><parameter_list>(<parameter><decl><type><name>AppendOnlyInsertDesc</name></type> <name>aoInsertDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>FileSegInfo</name> <modifier>*</modifier></type><name>fsinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>eof</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>eof_uncompressed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>varblockcount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fileSegNo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>backend</name></name> <operator>=</operator> <name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr>;</expr_stmt>

	<comment type="block">/* Make the 'segment' file name */</comment>
	<expr_stmt><expr><call><name>MakeAOSegmentFileName</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>,
						  <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>fileSegNo</name></expr></argument>,
						  <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>appendFilePathName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>appendFilePathName</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name><name>aoInsertDesc</name><operator>-&gt;</operator><name>appendFilePathNameMaxLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now, get the information for the file segment we are going to append
	 * to.
	 */</comment>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>fsInfo</name></name> <operator>=</operator> <call><name>GetFileSegInfo</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>,
										  <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>,
										  <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Never insert into a segment that is awaiting a drop */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>fsInfo</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>AOSEG_STATE_AWAITING_DROP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot insert into segno (%d) from AO relid %u that is in state AOSEG_STATE_AWAITING_DROP"</literal></expr></argument>,
			 <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fsinfo</name> <operator>=</operator> <name><name>aoInsertDesc</name><operator>-&gt;</operator><name>fsInfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fsinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>eof</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>eof</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>eof_uncompressed</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>eof_uncompressed</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>varblockcount</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>varblockcount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>=</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>total_tupcount</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Segment file #0 is created when the Append-Only table is created.
	 *
	 * Other segment files are created on-demand under transaction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>cur_segno</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eof</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyStorageWrite_TransactionCreateFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>,
													 <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Open the existing file for write.
	 */</comment>
	<expr_stmt><expr><call><name>AppendOnlyStorageWrite_OpenFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>,
									<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>appendFilePathName</name></name></expr></argument>,
									<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>fsInfo</name><operator>-&gt;</operator><name>formatversion</name></name></expr></argument>,
									<argument><expr><name>eof</name></expr></argument>,
									<argument><expr><name>eof_uncompressed</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>,
									<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reset counts */</comment>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>insertCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varblockCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use the current block count from the segfile info so our system log
	 * error messages are accurate.
	 */</comment>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>bufferCount</name></name> <operator>=</operator> <name>varblockcount</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finished scanning this file segment. Close it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CloseScannedFileSeg</name><parameter_list>(<parameter><decl><type><name>AppendOnlyScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AppendOnlyStorageRead_CloseFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_need_new_segfile</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finished writing to this file segment. Update catalog and close file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CloseWritableFileSeg</name><parameter_list>(<parameter><decl><type><name>AppendOnlyInsertDesc</name></type> <name>aoInsertDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>fileLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>fileLen_uncompressed</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AppendOnlyStorageWrite_TransactionFlushAndCloseFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>fileLen</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>fileLen_uncompressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the AO segment info table with our new eof
	 */</comment>
	<expr_stmt><expr><call><name>UpdateFileSegInfo</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>,
					  <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>,
					  <argument><expr><name>fileLen</name></expr></argument>,
					  <argument><expr><name>fileLen_uncompressed</name></expr></argument>,
					  <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>insertCount</name></name></expr></argument>,
					  <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varblockCount</name></name></expr></argument>,
					  <argument><expr><operator>(</operator><ternary><condition><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>skipModCountIncrement</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>,
					  <argument><expr><name>AOSEG_STATE_USECURRENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>fsInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>fsInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_insert</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-only scan closed write file segment #%d for table %s "</literal>
		   <literal type="string">"(file length "</literal> <name>INT64_FORMAT</name> <literal type="string">", insert count "</literal> <name>INT64_FORMAT</name> <literal type="string">", VarBlock count "</literal> <name>INT64_FORMAT</name></expr></argument>,
		   <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>,
		   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>fileLen</name></expr></argument>,
		   <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>insertCount</name></name></expr></argument>,
		   <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varblockCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------------ */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyExecutorReadBlock_GetContents</name><parameter_list>(<parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VarBlockCheckError</name></type> <name>varBlockCheckError</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>isCompressed</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>isLarge</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Small content.
			 */</comment>
			<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataBuffer</name></name> <operator>=</operator>
				<call><name>AppendOnlyStorageRead_GetBuffer</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_scan</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				   <argument><expr><literal type="string">"Append-only scan read small non-compressed block for table '%s' "</literal>
				   <literal type="string">"(length = %d, segment file '%s', block offset in file = "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
				   <argument><expr><call><name>AppendOnlyStorageRead_RelationName</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataLen</name></name></expr></argument>,
				   <argument><expr><call><name>AppendOnlyStorageRead_SegmentFileName</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>headerOffsetInFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Large row.
			 */</comment>

			<comment type="block">/* UNDONE: Error out if NOTOAST isn't ON. */</comment>

			<comment type="block">/* UNDONE: Error out if it is not a single row */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>executorBlockKind</name></name> <operator>==</operator> <name>AoExecutorBlockKind_SingleRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Enough room in our private buffer? UNDONE: Is there a way to
			 * avoid the 2nd copy later doProcessTuple?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>largeContentBufferLen</name></name> <operator>&lt;</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataLen</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldMemoryContext</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Buffer too small.
				 */</comment>
				<expr_stmt><expr><name>oldMemoryContext</name> <operator>=</operator>
					<call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>largeContentBuffer</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Make sure we set the our pointer to NULL here in case
					 * the subsequent allocation fails.  Otherwise cleanup
					 * will get confused.
					 */</comment>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>largeContentBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>largeContentBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>largeContentBuffer</name></name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>largeContentBufferLen</name></name> <operator>=</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataLen</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Deallocation and allocation done.  Go back to caller
				 * memory-context.
				 */</comment>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataBuffer</name></name> <operator>=</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>largeContentBuffer</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AppendOnlyStorageRead_Content</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>,
										  <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataBuffer</name></name></expr></argument>,
										  <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_scan</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				   <argument><expr><literal type="string">"Append-only scan read large row for table '%s' "</literal>
				   <literal type="string">"(length = %d, segment file '%s', "</literal>
				   <literal type="string">"block offset in file = "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
				   <argument><expr><call><name>AppendOnlyStorageRead_RelationName</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataLen</name></name></expr></argument>,
				   <argument><expr><call><name>AppendOnlyStorageRead_SegmentFileName</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>headerOffsetInFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>compressedLen</name> <init>=
		<expr><call><name>AppendOnlyStorageRead_CurrentCompressedLen</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * AppendOnlyStorageWrite does not report compressed for large content
		 * metadata.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>isLarge</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Decompress into our temporary buffer.
		 */</comment>
		<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataBuffer</name></name> <operator>=</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>uncompressedBuffer</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AppendOnlyStorageRead_Content</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>,
									  <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataBuffer</name></name></expr></argument>,
									  <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_scan</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Append-only scan read decompressed block for table '%s' "</literal>
			   <literal type="string">"(compressed length %d, length = %d, segment file '%s', "</literal>
			   <literal type="string">"block offset in file = "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
			   <argument><expr><call><name>AppendOnlyStorageRead_RelationName</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>compressedLen</name></expr></argument>,
			   <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataLen</name></name></expr></argument>,
			   <argument><expr><call><name>AppendOnlyStorageRead_SegmentFileName</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>headerOffsetInFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * The executorBlockKind value is what the executor -- i.e. the upper part
	 * of this appendonlyam module! -- has stored in the Append-Only Storage
	 * header.  We interpret it here.
	 */</comment>

	<switch>switch <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>executorBlockKind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AoExecutorBlockKind_VarBlock</name></expr>:</case>
			<expr_stmt><expr><name>varBlockCheckError</name> <operator>=</operator> <call><name>VarBlockIsValid</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataBuffer</name></name></expr></argument>, <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>varBlockCheckError</name> <operator>!=</operator> <name>VarBlockCheckOk</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"VarBlock is not valid, valid block check error %d, detail '%s'"</literal></expr></argument>,
								<argument><expr><name>varBlockCheckError</name></expr></argument>,
								<argument><expr><call><name>VarBlockGetCheckErrorStr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_appendonly_read_storage_content_header</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errcontext_appendonly_read_storage_block</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Now use the VarBlock module to extract the items out.
			 */</comment>
			<expr_stmt><expr><call><name>VarBlockReaderInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>varBlockReader</name></name></expr></argument>,
							   <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataBuffer</name></name></expr></argument>,
							   <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>readerItemCount</name></name> <operator>=</operator> <call><name>VarBlockReaderItemCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>varBlockReader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>currentItemCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>!=</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>readerItemCount</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"row count %d in append-only storage header does not match VarBlock item count %d"</literal></expr></argument>,
								<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>rowCount</name></name></expr></argument>,
								<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>readerItemCount</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_appendonly_read_storage_content_header</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errcontext_appendonly_read_storage_block</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_scan</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				   <argument><expr><literal type="string">"append-only scan read VarBlock for table '%s' with %d items (block offset in file = "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
				   <argument><expr><call><name>AppendOnlyStorageRead_RelationName</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>readerItemCount</name></name></expr></argument>,
				   <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>headerOffsetInFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AoExecutorBlockKind_SingleRow</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"row count %d in append-only storage header is not 1 for single row"</literal></expr></argument>,
								<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>rowCount</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_appendonly_read_storage_content_header</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errcontext_appendonly_read_storage_block</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>singleRow</name></name> <operator>=</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataBuffer</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>singleRowLen</name></name> <operator>=</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataLen</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_scan</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Append-only scan read single row for table '%s' with length %d (block offset in file = "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
				   <argument><expr><call><name>AppendOnlyStorageRead_RelationName</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>singleRowLen</name></name></expr></argument>,
				   <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>headerOffsetInFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unrecognized append-only executor block kind: %d"</literal></expr></argument>,
				 <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>executorBlockKind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AppendOnlyExecutorReadBlock_GetBlockInfo</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageRead</name> <modifier>*</modifier></type><name>storageRead</name></decl></parameter>,
										 <parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>blockFirstRowNum</name> <init>= <expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyStorageRead_GetBlockInfo</name><argument_list>(<argument><expr><name>storageRead</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>dataLen</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>executorBlockKind</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>rowCount</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>isLarge</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>isCompressed</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the firstRowNum is not stored in the AOBlock,
	 * executorReadBlock-&gt;blockFirstRowNum is set to -1. Since this is
	 * properly updated by calling functions
	 * AppendOnlyExecutionReadBlock_SetPositionInfo and
	 * AppendOnlyExecutionReadBlock_FinishedScanBlock, we restore the last
	 * value when the block does not contain firstRowNum.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name> <operator>=</operator> <name>blockFirstRowNum</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>headerOffsetInFile</name></name> <operator>=</operator>
		<call><name>AppendOnlyStorageRead_CurrentHeaderOffsetInFile</name><argument_list>(<argument><expr><name>storageRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* UNDONE: Check blockFirstRowNum */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyExecutionReadBlock_SetSegmentFileNum</name><parameter_list>(<parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>segmentFileNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>segmentFileNum</name></name> <operator>=</operator> <name>segmentFileNum</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyExecutionReadBlock_SetPositionInfo</name><parameter_list>(<parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>,
											 <parameter><decl><type><name>int64</name></type> <name>blockFirstRowNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name> <operator>=</operator> <name>blockFirstRowNum</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyExecutionReadBlock_FinishedScanBlock</name><parameter_list>(<parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name> <operator>+=</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>rowCount</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the ExecutorReadBlock once.  Assumed to be zeroed out before the call.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyExecutorReadBlock_Init</name><parameter_list>(<parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>,
								 <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
								 <parameter><decl><type><name>MemoryContext</name></type> <name>memoryContext</name></decl></parameter>,
								 <parameter><decl><type><name>AppendOnlyStorageRead</name> <modifier>*</modifier></type><name>storageRead</name></decl></parameter>,
								 <parameter><decl><type><name>int32</name></type> <name>usableBlockSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MemoryContextIsValid</name><argument_list>(<argument><expr><name>memoryContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>memoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>uncompressedBuffer</name></name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>usableBlockSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name> <operator>=</operator> <name>storageRead</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator> <name>memoryContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free the space allocated inside ExexcutorReadBlock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyExecutorReadBlock_Finish</name><parameter_list>(<parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>uncompressedBuffer</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>uncompressedBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>uncompressedBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>numericAtts</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>numericAtts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>numericAtts</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>mt_bind</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>mt_bind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>mt_bind</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyExecutorReadBlock_ResetCounts</name><parameter_list>(<parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>totalRowsScannned</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a tuple in 'formatversion', convert it to a format that is
 * understood by the rest of the system.
 */</comment>
<function><type><specifier>static</specifier> <name>MemTuple</name></type>
<name>upgrade_tuple</name><parameter_list>(<parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>,
			  <parameter><decl><type><name>MemTuple</name></type> <name>mtup</name></decl></parameter>, <parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>pbind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>formatversion</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>shouldFree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>pbind</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>Datum</name> <modifier>*</modifier></type><name>values</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name> <modifier>*</modifier></type><name>isnull</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nallocated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>convert_alignment</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>convert_numerics</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * MPP-7372: If the AO table was created before the fix for this issue, it
	 * may contain tuples with misaligned bindings. Here we check if the
	 * stored memtuple is problematic and then create a clone of the tuple
	 * with properly aligned bindings to be used by the executor.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>formatversion</name> <operator>&lt;</operator> <name>AORelationVersion_Aligned64bit</name> <operator>&amp;&amp;</operator>
		<call><name>memtuple_has_misaligned_attribute</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>, <argument><expr><name>pbind</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>convert_alignment</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG82NumericConversionNeeded</name><argument_list>(<argument><expr><name>formatversion</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * On first call, figure out which columns are numerics, or domains
		 * over numerics.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>numericAtts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>numericAtts</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>typeoid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>typeoid</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>typeoid</name> <operator>==</operator> <name>NUMERICOID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>numericAtts</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>numNumericAtts</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If there were any numeric columns, we need to convert them. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>numNumericAtts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>convert_numerics</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>convert_alignment</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>convert_numerics</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No conversion required. Return the original tuple unmodified. */</comment>
		<expr_stmt><expr><operator>*</operator><name>shouldFree</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>mtup</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Conversion is needed. */</comment>

	<comment type="block">/* enlarge the arrays if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>natts</name> <operator>&gt;</operator> <name>nallocated</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>values</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nallocated</name> <operator>=</operator> <name>natts</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>convert_alignment</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* get attribute values form mis-aligned tuple */</comment>
		<expr_stmt><expr><call><name>memtuple_deform_misaligned</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>, <argument><expr><name>pbind</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Form a new, properly-aligned, tuple */</comment>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>memtuple_form</name><argument_list>(<argument><expr><name>pbind</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * make a modifiable copy
		 */</comment>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>memtuple_copy</name><argument_list>(<argument><expr><name>mtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * NOTE: we do this *after* creating the new tuple, so that we can modify
	 * the new, copied, tuple in-place.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>convert_numerics</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get pointers to the datums within the tuple
		 */</comment>
		<expr_stmt><expr><call><name>memtuple_deform</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>, <argument><expr><name>pbind</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>numNumericAtts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/*
			 * Before PostgreSQL 8.3, the n_weight and n_sign_dscale fields
			 * were the other way 'round. Swap them.
			 */</comment>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>numericdata</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint16</name></type>		<name>tmp</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>numericAtts</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>datum</name> <operator>=</operator> <name><name>values</name><index>[<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>numericAtts</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>numericdata</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>numericdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>numericdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>numericdata</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>numericdata</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>shouldFree</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><name>newtuple</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>AOExecutorReadBlockBindingInit</name><parameter_list>(<parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>,
									   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * MemTupleBinding should be created from the slot's tuple descriptor
	 * and not from the tuple descriptor in the relation.  These could be
	 * different.  One example is alter table rewrite.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>mt_bind</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>mt_bind</name></name> <operator>=</operator> <call><name>create_memtuple_binding</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AppendOnlyExecutorReadBlock_ProcessTuple</name><parameter_list>(<parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>,
										 <parameter><decl><type><name>int64</name></type> <name>rowNum</name></decl></parameter>,
										 <parameter><decl><type><name>MemTuple</name></type> <name>tuple</name></decl></parameter>,
										 <parameter><decl><type><name>int32</name></type> <name>tupleLen</name></decl></parameter>,
										 <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
										 <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
										 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Assume for HeapKeyTestUsingSlot define. */</comment>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>fake_ctid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOTupleId</name>  <modifier>*</modifier></type><name>aoTupleId</name> <init>= <expr><operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>fake_ctid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>formatVersion</name> <init>= <expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AORelationVersion_CheckValid</name><argument_list>(<argument><expr><name>formatVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AOTupleIdInit</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>, <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>segmentFileNum</name></name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>slot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AOExecutorReadBlockBindingInit</name><argument_list>(<argument><expr><name>executorReadBlock</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Is it legal to call this function with NULL slot?  The
	 * HeapKeyTestUsingSlot call below assumes that the slot is not NULL.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>mt_bind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If the tuple is not in the latest format, convert it */</comment>
		<comment type="line">// GPDB_12_MERGE_FIXME: Is pg_upgrade from old versions still a thing? Can we drop this?</comment>
		<if_stmt><if>if <condition>(<expr><name>formatVersion</name> <operator>&lt;</operator> <call><name>AORelationVersion_GetLatest</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>upgrade_tuple</name><argument_list>(<argument><expr><name>executorReadBlock</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>mt_bind</name></name></expr></argument>, <argument><expr><name>formatVersion</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memtuple_deform</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>mt_bind</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name> <operator>=</operator> <name>fake_ctid</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Store the converted memtuple in slot-&gt;data, so that it gets free'd
			 * automatically when it's no longer needed.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TTS_IS_VIRTUAL</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>VirtualTupleTableSlot</name> <modifier>*</modifier></type><name>vslot</name> <init>= <expr><operator>(</operator><name>VirtualTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vslot</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_SHOULDFREE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_flags</name></name> <operator>|=</operator> <name>TTS_FLAG_SHOULDFREE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>vslot</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* skip visibility test, all tuples are visible */</comment>

	<if_stmt><if>if <condition>(<expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HeapKeyTestUsingSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_scan_tuple</name> <operator>&amp;&amp;</operator> <name>valid</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-only scan tuple for table '%s' "</literal>
		   <literal type="string">"(AOTupleId %s, tuple length %d, memtuple length %d, block offset in file "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
		   <argument><expr><call><name>AppendOnlyStorageRead_RelationName</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>AOTupleIdToString</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>tupleLen</name></expr></argument>,
		   <argument><expr><call><name>memtuple_get_size</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>headerOffsetInFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>valid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AppendOnlyExecutorReadBlock_ScanNextTuple</name><parameter_list>(<parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>,
										  <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
										  <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
										  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>executorBlockKind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AoExecutorBlockKind_VarBlock</name></expr>:</case>

			<comment type="block">/*
			 * get the next item (tuple) from the varblock
			 */</comment>
			<while>while <condition>(<expr><name>true</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>itemLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>itemPtr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int64</name></type>		<name>rowNum</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>itemPtr</name> <operator>=</operator> <call><name>VarBlockReaderGetNextItemPtr</name><argument_list>(
													   <argument><expr><operator>&amp;</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>varBlockReader</name></name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>itemLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>itemPtr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* no more items in the varblock, get new buffer */</comment>
					<expr_stmt><expr><call><name>AppendOnlyExecutionReadBlock_FinishedScanBlock</name><argument_list>(
																   <argument><expr><name>executorReadBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>currentItemCount</name></name><operator>++</operator></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>totalRowsScannned</name></name><operator>++</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>itemLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>MemTuple</name><operator>)</operator> <name>itemPtr</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>rowNum</name> <operator>=</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name> <operator>+</operator>
						<name><name>executorReadBlock</name><operator>-&gt;</operator><name>currentItemCount</name></name> <operator>-</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyExecutorReadBlock_ProcessTuple</name><argument_list>(
																 <argument><expr><name>executorReadBlock</name></expr></argument>,
																 <argument><expr><name>rowNum</name></expr></argument>,
																 <argument><expr><name>tuple</name></expr></argument>,
																 <argument><expr><name>itemLen</name></expr></argument>,
																 <argument><expr><name>nkeys</name></expr></argument>,
																 <argument><expr><name>key</name></expr></argument>,
																 <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

			</block_content>}</block></while>

			<comment type="block">/* varblock sanity check */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>readerItemCount</name></name> <operator>!=</operator>
				<name><name>executorReadBlock</name><operator>-&gt;</operator><name>currentItemCount</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Varblock mismatch: Reader count %d, found %d items\n"</literal></expr></argument>,
					 <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>readerItemCount</name></name></expr></argument>,
					 <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>currentItemCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>AoExecutorBlockKind_SingleRow</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int32</name></type>		<name>singleRowLen</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>singleRow</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>AppendOnlyExecutionReadBlock_FinishedScanBlock</name><argument_list>(
																   <argument><expr><name>executorReadBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
					<comment type="block">/* Force fetching new block. */</comment>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>singleRowLen</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>MemTuple</name><operator>)</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>singleRow</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>singleRowLen</name> <operator>=</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>singleRowLen</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Indicated used up for scan.
				 */</comment>
				<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>singleRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>singleRowLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>totalRowsScannned</name></name><operator>++</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyExecutorReadBlock_ProcessTuple</name><argument_list>(
															 <argument><expr><name>executorReadBlock</name></expr></argument>,
															 <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name></expr></argument>,
															 <argument><expr><name>tuple</name></expr></argument>,
															 <argument><expr><name>singleRowLen</name></expr></argument>,
															 <argument><expr><name>nkeys</name></expr></argument>,
															 <argument><expr><name>key</name></expr></argument>,
															 <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unrecognized append-only executor block kind: %d"</literal></expr></argument>,
				 <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>executorBlockKind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>AppendOnlyExecutionReadBlock_FinishedScanBlock</name><argument_list>(
												   <argument><expr><name>executorReadBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
	<comment type="block">/* No match. */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AppendOnlyExecutorReadBlock_FetchTuple</name><parameter_list>(<parameter><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name></decl></parameter>,
									   <parameter><decl><type><name>int64</name></type> <name>rowNum</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
									   <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
									   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>itemNum</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rowNum</name> <operator>&gt;=</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rowNum</name> <operator>&lt;=</operator>
		   <name><name>executorReadBlock</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name> <operator>+</operator>
		   <name><name>executorReadBlock</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get 0-based index to tuple.
	 */</comment>
	<expr_stmt><expr><name>itemNum</name> <operator>=</operator>
		<operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>rowNum</name> <operator>-</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name><operator>)</operator></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>executorBlockKind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AoExecutorBlockKind_VarBlock</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>itemPtr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>itemLen</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>itemPtr</name> <operator>=</operator> <call><name>VarBlockReaderGetItemPtr</name><argument_list>(
												   <argument><expr><operator>&amp;</operator><name><name>executorReadBlock</name><operator>-&gt;</operator><name>varBlockReader</name></name></expr></argument>,
												   <argument><expr><name>itemNum</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>itemLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>MemTuple</name><operator>)</operator> <name>itemPtr</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyExecutorReadBlock_ProcessTuple</name><argument_list>(
															 <argument><expr><name>executorReadBlock</name></expr></argument>,
															 <argument><expr><name>rowNum</name></expr></argument>,
															 <argument><expr><name>tuple</name></expr></argument>,
															 <argument><expr><name>itemLen</name></expr></argument>,
															 <argument><expr><name>nkeys</name></expr></argument>,
															 <argument><expr><name>key</name></expr></argument>,
															 <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>AoExecutorBlockKind_SingleRow</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemNum</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>singleRow</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>singleRowLen</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>MemTuple</name><operator>)</operator> <name><name>executorReadBlock</name><operator>-&gt;</operator><name>singleRow</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyExecutorReadBlock_ProcessTuple</name><argument_list>(
															 <argument><expr><name>executorReadBlock</name></expr></argument>,
															 <argument><expr><name>rowNum</name></expr></argument>,
															 <argument><expr><name>tuple</name></expr></argument>,
															 <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>singleRowLen</name></name></expr></argument>,
															 <argument><expr><name>nkeys</name></expr></argument>,
															 <argument><expr><name>key</name></expr></argument>,
															 <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unrecognized append-only executor block kind: %d"</literal></expr></argument>,
				 <argument><expr><name><name>executorReadBlock</name><operator>-&gt;</operator><name>executorBlockKind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>false</name></expr>;</return>
	<comment type="block">/* No match. */</comment>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------------ */</comment>

<comment type="block">/*
 * You can think of this scan routine as get next "executor" AO block.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>getNextBlock</name><parameter_list>(<parameter><decl><type><name>AppendOnlyScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>aos_need_new_segfile</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Need to open a new segment file.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SetNextFileSegForRead</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyExecutorReadBlock_GetBlockInfo</name><argument_list>(
												  <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_End_forInsert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* done reading the file */</comment>
		<expr_stmt><expr><call><name>CloseScannedFileSeg</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_InsertEntry</name><argument_list>(
											 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>executorReadBlock</name><operator>.</operator><name>blockFirstRowNum</name></name></expr></argument>,
											 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>executorReadBlock</name><operator>.</operator><name>headerOffsetInFile</name></name></expr></argument>,
											 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>executorReadBlock</name><operator>.</operator><name>rowCount</name></name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AppendOnlyExecutorReadBlock_GetContents</name><argument_list>(
											<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		appendonlygettup - fetch next appendonly tuple
 *
 *		Initialize the scan if not already done; then advance to the next
 *		tuple in forward direction; return the next tuple in scan-&gt;aos_ctup,
 *		or set scan-&gt;aos_ctup.t_data = NULL if no more tuples.
 *
 * Note: the reason nkeys/key are passed separately, even though they are
 * kept in the scan descriptor, is that the caller may not want us to check
 * the scankeys.
 * ----------------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>
<name>appendonlygettup</name><argument_list>(<argument><expr><name>AppendOnlyScanDesc</name> <name>scan</name></expr></argument>,
				 <argument><expr><name>ScanDirection</name> <name>dir</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>,
				 <argument><expr><name>int</name> <name>nkeys</name></expr></argument>,
				 <argument><expr><name>ScanKey</name> <name>key</name></expr></argument>,
				 <argument><expr><name>TupleTableSlot</name> <operator>*</operator><name>slot</name></expr></argument>)</argument_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>usableBlockSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>isSnapshotAny</name> <init>= <expr><operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>==</operator> <name>SnapshotAny</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>bufferDone</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Get the next block. We call this function until we successfully
			 * get a block to process, or finished reading all the data (all
			 * 'segment' files) for this relation.
			 */</comment>
			<while>while <condition>(<expr><operator>!</operator><call><name>getNextBlock</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* have we read all this relation's data. done! */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>aos_done_all_segfiles</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>bufferDone</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>AppendOnlyExecutorReadBlock_ScanNextTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>,
														  <argument><expr><name>nkeys</name></expr></argument>,
														  <argument><expr><name>key</name></expr></argument>,
														  <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
		<block>{<block_content>

			<comment type="block">/*
			 * Need to get the Block Directory entry that covers the TID.
			 */</comment>
			<decl_stmt><decl><type><name>AOTupleId</name>  <modifier>*</modifier></type><name>aoTupleId</name> <init>= <expr><operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSnapshotAny</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AppendOnlyVisimap_IsVisible</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The tuple is invisible.
				 * In `analyze`, we can simply return false
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_TYPE_ANALYZE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* The tuple is visible */</comment>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* no more items in the varblock, get new buffer */</comment>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>bufferDone</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cancelLastBuffer</name><parameter_list>(<parameter><decl><type><name>AppendOnlyInsertDesc</name></type> <name>aoInsertDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>nonCompressedData</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AppendOnlyStorageWrite_IsBufferAllocated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AppendOnlyStorageWrite_CancelLastBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>nonCompressedData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>AppendOnlyStorageWrite_IsBufferAllocated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setupNextWriteBlock</name><parameter_list>(<parameter><decl><type><name>AppendOnlyInsertDesc</name></type> <name>aoInsertDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>nonCompressedData</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>AppendOnlyStorageWrite_IsBufferAllocated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the firstRowNum for the block */</comment>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name> <operator>=</operator> <name><name>aoInsertDesc</name><operator>-&gt;</operator><name>lastSequence</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyStorageWrite_SetFirstRowNum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>,
										  <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>nonCompressedData</name></name> <operator>=</operator>
		<call><name>AppendOnlyStorageWrite_GetBuffer</name><argument_list>(
											<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>,
											<argument><expr><name>AoHeaderKind_SmallContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
		* Prepare our VarBlock for items.  Leave room for the Append-Only
		* Storage header.
		*/</comment>
	<expr_stmt><expr><call><name>VarBlockMakerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varBlockMaker</name></name></expr></argument>,
						<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>nonCompressedData</name></name></expr></argument>,
						<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>maxDataLen</name></name></expr></argument>,
						<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>tempSpace</name></name></expr></argument>,
						<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>tempSpaceLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>bufferCount</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>finishWriteBlock</name><parameter_list>(<parameter><decl><type><name>AppendOnlyInsertDesc</name></type> <name>aoInsertDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>executorBlockKind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>itemCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dataLen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>executorBlockKind</name> <operator>=</operator> <name>AoExecutorBlockKind_VarBlock</name></expr>;</expr_stmt>
	<comment type="block">/* Assume. */</comment>

	<expr_stmt><expr><name>itemCount</name> <operator>=</operator> <call><name>VarBlockMakerItemCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varBlockMaker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>itemCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * "Cancel" the last block allocation, if one.
		 */</comment>
		<expr_stmt><expr><call><name>cancelLastBuffer</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>dataLen</name> <operator>=</operator> <call><name>VarBlockMakerFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varBlockMaker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varblockCount</name></name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>itemCount</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dataLen</name> <operator>=</operator> <call><name>VarBlockCollapseToSingleItem</name><argument_list>(
												<comment type="block">/* target */</comment> <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>nonCompressedData</name></name></expr></argument>,
												<comment type="block">/* source */</comment> <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>nonCompressedData</name></name></expr></argument>,
												<comment type="block">/* sourceLen */</comment> <argument><expr><name>dataLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>executorBlockKind</name> <operator>=</operator> <name>AoExecutorBlockKind_SingleRow</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name><operator>.</operator><name>logicalBlockStartOffset</name></name> <operator>=</operator>
		<call><name>BufferedAppendNextBufferPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name><operator>.</operator><name>bufferedAppend</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyStorageWrite_FinishBuffer</name><argument_list>(
										<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>,
										<argument><expr><name>dataLen</name></expr></argument>,
										<argument><expr><name>executorBlockKind</name></expr></argument>,
										<argument><expr><name>itemCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>nonCompressedData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>AppendOnlyStorageWrite_IsBufferAllocated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_insert</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><literal type="string">"Append-only insert finished uncompressed block for table '%s' "</literal>
			<literal type="string">"(length = %d, application specific %d, item count %d, block count "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
			<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>dataLen</name></expr></argument>,
			<argument><expr><name>executorBlockKind</name></expr></argument>,
			<argument><expr><name>itemCount</name></expr></argument>,
			<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>bufferCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Insert an entry to the block directory */</comment>
	<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_InsertEntry</name><argument_list>(
										 <argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>,
										 <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name></expr></argument>,
										 <argument><expr><call><name>AppendOnlyStorageWrite_LogicalBlockStartOffset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>itemCount</name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>nonCompressedData</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>AppendOnlyStorageWrite_IsBufferAllocated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *					 append-only access method interface
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * appendonly_beginrangescan_internal()
 *
 * Begins a scan over a subset of segment info files.
 *
 * Should only be called with valid seginfos for the given relation.
 * Should only be called with an aoentry based on the same snapshot.
 *
 * The ownership of the seginfos and aoentry are transferred to the scan descriptor.
 */</comment>
<function><type><specifier>static</specifier> <name>AppendOnlyScanDesc</name></type>
<name>appendonly_beginrangescan_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
								   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
								   <parameter><decl><type><name>Snapshot</name></type> <name>appendOnlyMetaDataSnapshot</name></decl></parameter>,
								   <parameter><decl><type><name>FileSegInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>seginfo</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>segfile_count</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
								   <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
								   <parameter><decl><type><name>ParallelTableScanDesc</name></type> <name>parallel_scan</name></decl></parameter>,
								   <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyStorageAttributes</name> <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>titleBuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>blocksize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>safefswritesize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>compresslevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>checksum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type> <name>compresstype</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAttributes</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blocksize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>safefswritesize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>compresslevel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>checksum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>compresstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * increment relation ref count while scanning relation
	 *
	 * This is just to make really sure the relcache entry won't go away while
	 * the scan has a pointer to it.  Caller should be holding the rel open
	 * anyway, so this is redundant in all normal scenarios...
	 */</comment>
	<expr_stmt><expr><call><name>RelationIncrementReferenceCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate scan descriptor
	 */</comment>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <operator>(</operator><name>AppendOnlyScanDesc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_nkeys</name></name> <operator>=</operator> <name>nkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>=</operator> <name>parallel_scan</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_filenamepath_maxlen</name></name> <operator>=</operator> <call><name>AOSegmentFilePathNameLen</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_filenamepath</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_filenamepath_maxlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_filenamepath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>usableBlockSize</name></name> <operator>=</operator> <name>blocksize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_rd</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name> <operator>=</operator> <name>appendOnlyMetaDataSnapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_nkeys</name></name> <operator>=</operator> <name>nkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aoScanInitContext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>, <argument><expr><literal type="string">"Scan of Append-Only Row-Oriented relation '%s'"</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>title</name></name> <operator>=</operator> <name><name>titleBuf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>


	<comment type="block">/*
	 * Fill in Append-Only Storage layer attributes.
	 */</comment>
	<expr_stmt><expr><name>attr</name> <operator>=</operator> <operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>storageAttributes</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * These attributes describe the AppendOnly format to be scanned.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compressType</name></name> <operator>=</operator> <literal type="string">"none"</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compressType</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compressLevel</name></name> <operator>=</operator> <name>compresslevel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>checksum</name></name> <operator>=</operator> <name>checksum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>safeFSWriteSize</name></name> <operator>=</operator> <name>safefswritesize</name></expr>;</expr_stmt>

	<comment type="block">/* UNDONE: We are calling the static header length routine here. */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>maxDataLen</name></name> <operator>=</operator>
		<name><name>scan</name><operator>-&gt;</operator><name>usableBlockSize</name></name> <operator>-</operator>
		<call><name>AppendOnlyStorageFormat_RegularHeaderLenNeeded</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * Get information about all the file segments we need to scan
	 */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_segfile_arr</name></name> <operator>=</operator> <name>seginfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_total_segfiles</name></name> <operator>=</operator> <name>segfile_count</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * we do this here instead of in initscan() because appendonly_rescan also
	 * calls initscan() and we don't want to allocate memory again
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nkeys</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_key</name></name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>aos_key</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* pgstat_initstats(relation); */</comment>
	<expr_stmt><expr><call><name>initscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>blockDirectory</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segfile_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>visimaprelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>visimapidxid</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visimaprelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visimapidxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AppendOnlyVisimap_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>,
							   <argument><expr><name>visimaprelid</name></expr></argument>,
							   <argument><expr><name>visimapidxid</name></expr></argument>,
							   <argument><expr><name>AccessShareLock</name></expr></argument>,
							   <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * appendonly_beginrangescan
 *
 * begins range-limited relation scan
 */</comment>
<function><type><name>AppendOnlyScanDesc</name></type>
<name>appendonly_beginrangescan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
						  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						  <parameter><decl><type><name>Snapshot</name></type> <name>appendOnlyMetaDataSnapshot</name></decl></parameter>,
						  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>segfile_no_arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segfile_count</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>keys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Get the pg_appendonly information for this table
	 */</comment>

	<decl_stmt><decl><type><name>FileSegInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>seginfo</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FileSegInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>segfile_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>segfile_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>seginfo</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>GetFileSegInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
									<argument><expr><name><name>segfile_no_arr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><call><name>appendonly_beginrangescan_internal</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
											  <argument><expr><name>snapshot</name></expr></argument>,
											  <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
											  <argument><expr><name>seginfo</name></expr></argument>,
											  <argument><expr><name>segfile_count</name></expr></argument>,
											  <argument><expr><name>nkeys</name></expr></argument>,
											  <argument><expr><name>keys</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		appendonly_beginscan	- begin relation scan
 * ----------------
 */</comment>
<function><type><name>TableScanDesc</name></type>
<name>appendonly_beginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
					 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ScanKeyData</name></name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
					 <parameter><decl><type><name>ParallelTableScanDesc</name></type> <name>pscan</name></decl></parameter>,
					 <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>appendOnlyMetaDataSnapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segfile_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileSegInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>seginfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyScanDesc</name></type> <name>aoscan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>appendOnlyMetaDataSnapshot</name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>appendOnlyMetaDataSnapshot</name> <operator>==</operator> <name>SnapshotAny</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The append-only meta data should never be fetched with
		 * SnapshotAny as bogus results are returned.
		 * We use SnapshotSelf for metadata, as regular MVCC snapshot can hide
		 * newly globally inserted tuples from global index build process.
		 */</comment>
		<expr_stmt><expr><name>appendOnlyMetaDataSnapshot</name> <operator>=</operator> <name>SnapshotSelf</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get the pg_appendonly information for this table
	 */</comment>
	<expr_stmt><expr><name>seginfo</name> <operator>=</operator> <call><name>GetAllFileSegInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
								<argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segfile_count</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aoscan</name> <operator>=</operator> <call><name>appendonly_beginrangescan_internal</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
												<argument><expr><name>snapshot</name></expr></argument>,
												<argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
												<argument><expr><name>seginfo</name></expr></argument>,
												<argument><expr><name>segfile_count</name></expr></argument>,
												<argument><expr><name>nkeys</name></expr></argument>,
												<argument><expr><name>key</name></expr></argument>,
												<argument><expr><name>pscan</name></expr></argument>,
												<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>TableScanDesc</name><operator>)</operator> <name>aoscan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		appendonly_rescan		- restart a relation scan
 *
 *
 * TODO: instead of freeing resources here and reallocating them in initscan
 * over and over see which of them can be refactored into appendonly_beginscan
 * and persist there until endscan is finally reached. For now this will do.
 *
 * GPDB_12_MERGE_FIXME: what to do with the new flags?
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>appendonly_rescan</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>set_params</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_strat</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>allow_sync</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_pagemode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyScanDesc</name></type> <name>aoscan</name> <init>= <expr><operator>(</operator><name>AppendOnlyScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CloseScannedFileSeg</name><argument_list>(<argument><expr><name>aoscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyStorageRead_FinishSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoscan</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>initedStorageRoutines</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyExecutorReadBlock_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoscan</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aos_need_new_segfile</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * reinitialize scan descriptor
	 */</comment>
	<expr_stmt><expr><call><name>initscan</name><argument_list>(<argument><expr><name>aoscan</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		appendonly_endscan	- end relation scan
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>appendonly_endscan</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyScanDesc</name></type> <name>aoscan</name> <init>= <expr><operator>(</operator><name>AppendOnlyScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RelationDecrementReferenceCount</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aos_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aoscan</name><operator>-&gt;</operator><name>aos_key</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aos_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aoscan</name><operator>-&gt;</operator><name>aos_segfile_arr</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>seginfo_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>seginfo_no</name> <operator>&lt;</operator> <name><name>aoscan</name><operator>-&gt;</operator><name>aos_total_segfiles</name></name></expr>;</condition> <incr><expr><name>seginfo_no</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aos_segfile_arr</name><index>[<expr><name>seginfo_no</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aos_segfile_arr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CloseScannedFileSeg</name><argument_list>(<argument><expr><name>aoscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyStorageRead_FinishSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoscan</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>initedStorageRoutines</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyExecutorReadBlock_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoscan</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aoscan</name><operator>-&gt;</operator><name>aos_total_segfiles</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AppendOnlyVisimap_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoscan</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendonly_fetch_finish</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aofetch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aos_filenamepath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>aoscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		appendonly_getnextslot - retrieve next tuple in scan
 * ----------------
 */</comment>
<function><type><name>bool</name></type>
<name>appendonly_getnextslot</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyScanDesc</name></type> <name>aoscan</name> <init>= <expr><operator>(</operator><name>AppendOnlyScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>appendonlygettup</name><argument_list>(<argument><expr><name>aoscan</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_nkeys</name></name></expr></argument>, <argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aos_key</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgstat_count_heap_getnext</name><argument_list>(<argument><expr><name><name>aoscan</name><operator>-&gt;</operator><name>aos_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>slot</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>closeFetchSegmentFile</name><parameter_list>(<parameter><decl><type><name>AppendOnlyFetchDesc</name></type> <name>aoFetchDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyStorageRead_CloseFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>openFetchSegmentFile</name><parameter_list>(<parameter><decl><type><name>AppendOnlyFetchDesc</name></type> <name>aoFetchDesc</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>openSegmentFileNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>FileSegInfo</name> <modifier>*</modifier></type><name>fsInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segmentFileNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>logicalEof</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fileSegNo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>totalSegfiles</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Segment file not visible in catalog information. */</comment>

		<expr_stmt><expr><name>fsInfo</name> <operator>=</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>segmentFileNum</name> <operator>=</operator> <name><name>fsInfo</name><operator>-&gt;</operator><name>segno</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>openSegmentFileNum</name> <operator>==</operator> <name>segmentFileNum</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>fsInfo</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>AOSEG_STATE_AWAITING_DROP</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * File compacted, but not dropped. All information are
				 * declared invisible
				 */</comment>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>logicalEof</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>fsInfo</name><operator>-&gt;</operator><name>eof</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Don't try to open a segment file when its EOF is 0, since the file may
	 * not exist. See MPP-8280.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>logicalEof</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MakeAOSegmentFileName</name><argument_list>(
						  <argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
						  <argument><expr><name>openSegmentFileNum</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>fileSegNo</name></expr></argument>,
						  <argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileName</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator>
		   <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileNameMaxLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* UNDONE: Appropriate to use Try here? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyStorageRead_TryOpenFile</name><argument_list>(
										   <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>,
										   <argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileName</name></name></expr></argument>,
										   <argument><expr><name><name>fsInfo</name><operator>-&gt;</operator><name>formatversion</name></name></expr></argument>,
										   <argument><expr><name>logicalEof</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name>openSegmentFileNum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>logicalEof</name></name> <operator>=</operator> <name>logicalEof</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>fetchNextBlock</name><parameter_list>(<parameter><decl><type><name>AppendOnlyFetchDesc</name></type> <name>aoFetchDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyExecutorReadBlock</name> <modifier>*</modifier></type><name>executorReadBlock</name> <init>=
	<expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Try to read next block.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyExecutorReadBlock_GetBlockInfo</name><argument_list>(
												  <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Hit end of range. */</comment>

	<comment type="block">/*
	 * Unpack information into member variables.
	 */</comment>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>fileOffset</name></name> <operator>=</operator>
		<name><name>executorReadBlock</name><operator>-&gt;</operator><name>headerOffsetInFile</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>overallBlockLen</name></name> <operator>=</operator>
		<call><name>AppendOnlyStorageRead_OverallBlockLen</name><argument_list>(
											  <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>firstRowNum</name></name> <operator>=</operator>
		<name><name>executorReadBlock</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>lastRowNum</name></name> <operator>=</operator>
		<name><name>executorReadBlock</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name> <operator>+</operator>
		<name><name>executorReadBlock</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>gotContents</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the tuple from the block indicated by the block directory entry that
 * covers the tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fetchFromCurrentBlock</name><parameter_list>(<parameter><decl><type><name>AppendOnlyFetchDesc</name></type> <name>aoFetchDesc</name></decl></parameter>,
					  <parameter><decl><type><name>int64</name></type> <name>rowNum</name></decl></parameter>,
					  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>							<name>fetched</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOFetchBlockMetadata</name> 			<modifier>*</modifier></type><name>currentBlock</name> <init>= <expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyExecutorReadBlock</name> 	<modifier>*</modifier></type><name>executorReadBlock</name> <init>= <expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyStorageRead</name>			<modifier>*</modifier></type><name>storageRead</name> <init>= <expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyBlockDirectoryEntry</name> 	<modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>&amp;</operator><name><name>currentBlock</name><operator>-&gt;</operator><name>blockDirectoryEntry</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>currentBlock</name><operator>-&gt;</operator><name>gotContents</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Do decompression if necessary and get contents.
		 */</comment>
		<expr_stmt><expr><call><name>AppendOnlyExecutorReadBlock_GetContents</name><argument_list>(<argument><expr><name>executorReadBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>currentBlock</name><operator>-&gt;</operator><name>gotContents</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>fetched</name> <operator>=</operator> <call><name>AppendOnlyExecutorReadBlock_FetchTuple</name><argument_list>(<argument><expr><name>executorReadBlock</name></expr></argument>,
													 <argument><expr><name>rowNum</name></expr></argument>,
													 <comment type="block">/* nkeys */</comment> <argument><expr><literal type="number">0</literal></expr></argument>,
													 <comment type="block">/* key */</comment> <argument><expr><name>NULL</name></expr></argument>,
													 <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fetched</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyBlockDirectoryEntry_RangeHasRow</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We fell into a hole inside the resolved block directory entry
			 * we obtained from AppendOnlyBlockDirectory_GetEntry().
			 * This should not be happening for versions &gt;= PG12. Scream
			 * appropriately. See AppendOnlyBlockDirectoryEntry for details.
			 */</comment>
			<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name><name>storageRead</name><operator>-&gt;</operator><name>formatVersion</name></name> <operator>&gt;=</operator> <name>AORelationVersion_PG12</name></expr></argument>,
					  <argument><expr><name>ERROR</name></expr></argument>,
					  <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple with row number %ld not found in block directory entry range"</literal></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call><operator>,</operator>
						  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"block directory entry: (fileOffset = %ld, firstRowNum = %ld, "</literal>
									<literal type="string">"afterFileOffset = %ld, lastRowNum = %ld)"</literal></expr></argument>,
									<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>fileOffset</name></name></expr></argument>,
									<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>,
									<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>afterFileOffset</name></name></expr></argument>,
									<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>lastRowNum</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * The resolved block directory entry we obtained from
			 * AppendOnlyBlockDirectory_GetEntry() has range s.t.
			 * firstRowNum &lt; lastRowNum &lt; rowNum
			 * This can happen when rowNum maps to an aborted transaction, and
			 * we find an earlier committed block directory row due to the
			 * &lt;= scan condition in AppendOnlyBlockDirectory_GetEntry().
			 */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>positionFirstBlockOfRange</name><parameter_list>(<parameter><decl><type><name>AppendOnlyFetchDesc</name></type> <name>aoFetchDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AppendOnlyBlockDirectoryEntry_GetBeginRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>blockDirectoryEntry</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanNextFileOffset</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanNextRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>positionLimitToEndOfRange</name><parameter_list>(<parameter><decl><type><name>AppendOnlyFetchDesc</name></type> <name>aoFetchDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AppendOnlyBlockDirectoryEntry_GetEndRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>blockDirectoryEntry</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanAfterFileOffset</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanLastRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>positionSkipCurrentBlock</name><parameter_list>(<parameter><decl><type><name>AppendOnlyFetchDesc</name></type> <name>aoFetchDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanNextFileOffset</name></name> <operator>=</operator>
		<name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>fileOffset</name></name> <operator>+</operator>
		<name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>overallBlockLen</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanNextRowNum</name></name> <operator>=</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>lastRowNum</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Scan through blocks to find row.
 *
 * If row is not represented in any of the blocks covered by the Block Directory, then the row
 * falls into a row gap.  The row must have been aborted or deleted and reclaimed.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>scanToFetchTuple</name><parameter_list>(<parameter><decl><type><name>AppendOnlyFetchDesc</name></type> <name>aoFetchDesc</name></decl></parameter>,
				 <parameter><decl><type><name>int64</name></type> <name>rowNum</name></decl></parameter>,
				 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanNextFileOffset</name></name> <operator>&gt;=</operator>
		<name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanAfterFileOffset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* No more blocks requested for range. */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>logicalEof</name></name> <operator>==</operator>
		<name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanNextFileOffset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* No more blocks in this file. */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>logicalEof</name></name> <operator>&lt;</operator>
		<name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanNextFileOffset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<comment type="block">/* UNDONE:Why does our next scan position go beyond logical EOF ? */</comment>

	<comment type="block">/*
	 * Temporarily restrict our reading to just the range.
	 */</comment>
	<expr_stmt><expr><call><name>AppendOnlyStorageRead_SetTemporaryRange</name><argument_list>(
											<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>,
											<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanNextFileOffset</name></name></expr></argument>,
											<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanAfterFileOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyExecutionReadBlock_SetSegmentFileNum</name><argument_list>(
												   <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>,
												   <argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyExecutionReadBlock_SetPositionInfo</name><argument_list>(
												 <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>,
												 <argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanNextRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>skipBlockCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Fetch block starting at scanNextFileOffset.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fetchNextBlock</name><argument_list>(<argument><expr><name>aoFetchDesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* No more blocks. */</comment>

		<comment type="block">/*
		 * Examine new current block header information.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>rowNum</name> <operator>&lt;</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>firstRowNum</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Since we have read a new block, the temporary range for the
			 * read needs to be adjusted accordingly. Otherwise, the
			 * underlying bufferedRead may stop reading more data because of
			 * the previously-set smaller temporary range.
			 */</comment>
			<decl_stmt><decl><type><name>int64</name></type>		<name>beginFileOffset</name> <init>= <expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>fileOffset</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type>		<name>afterFileOffset</name> <init>= <expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>fileOffset</name></name> <operator>+</operator>
			<name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>overallBlockLen</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>AppendOnlyStorageRead_SetTemporaryRange</name><argument_list>(
													<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>,
													<argument><expr><name>beginFileOffset</name></expr></argument>,
													<argument><expr><name>afterFileOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>false</name></expr>;</return>
			<comment type="block">/* Row fell in gap between blocks. */</comment>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>rowNum</name> <operator>&lt;=</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>lastRowNum</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fetchFromCurrentBlock</name><argument_list>(<argument><expr><name>aoFetchDesc</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Update information to get next block.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>gotContents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* MPP-17061: reach the end of range covered by block directory entry */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>fileOffset</name></name> <operator>+</operator>
			 <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>overallBlockLen</name></name><operator>)</operator> <operator>&gt;=</operator>
			<name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanAfterFileOffset</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>AppendOnlyExecutionReadBlock_FinishedScanBlock</name><argument_list>(
													   <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AppendOnlyStorageRead_SkipCurrentBlock</name><argument_list>(
											   <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>skipBlockCount</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>resetCurrentBlockInfo</name><parameter_list>(<parameter><decl><type><name>AOFetchBlockMetadata</name> <modifier>*</modifier></type> <name>currentBlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>currentBlock</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>currentBlock</name><operator>-&gt;</operator><name>firstRowNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>currentBlock</name><operator>-&gt;</operator><name>lastRowNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>AppendOnlyFetchDesc</name></type>
<name>appendonly_fetch_init</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
					  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
					  <parameter><decl><type><name>Snapshot</name></type> <name>appendOnlyMetaDataSnapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyFetchDesc</name></type>				<name>aoFetchDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyStorageAttributes</name>	   <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGFunction</name>					   <modifier>*</modifier></type><name>fns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>					<name>titleBuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_pg_appendonly</name></type>			<name>aoFormData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>								<name>segno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntry</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aoFormData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * increment relation ref count while scanning relation
	 *
	 * This is just to make really sure the relcache entry won't go away while
	 * the scan has a pointer to it.  Caller should be holding the rel open
	 * anyway, so this is redundant in all normal scenarios...
	 */</comment>
	<expr_stmt><expr><call><name>RelationIncrementReferenceCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate scan descriptor
	 */</comment>
	<expr_stmt><expr><name>aoFetchDesc</name> <operator>=</operator> <operator>(</operator><name>AppendOnlyFetchDesc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyFetchDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name> <operator>=</operator> <name>appendOnlyMetaDataSnapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>initContext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileNameMaxLen</name></name> <operator>=</operator> <call><name>AOSegmentFilePathNameLen</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileName</name></name> <operator>=</operator>
		<operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileNameMaxLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>, <argument><expr><literal type="string">"Fetch of Append-Only Row-Oriented relation '%s'"</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>title</name></name> <operator>=</operator> <name><name>titleBuf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in Append-Only Storage layer attributes.
	 */</comment>
	<expr_stmt><expr><name>attr</name> <operator>=</operator> <operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageAttributes</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * These attributes describe the AppendOnly format to be scanned.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoFormData</name><operator>.</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoFormData</name><operator>.</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compressType</name></name> <operator>=</operator> <literal type="string">"none"</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compressType</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoFormData</name><operator>.</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compressLevel</name></name> <operator>=</operator> <name><name>aoFormData</name><operator>.</operator><name>compresslevel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>checksum</name></name> <operator>=</operator> <name><name>aoFormData</name><operator>.</operator><name>checksum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>safeFSWriteSize</name></name> <operator>=</operator> <name><name>aoFormData</name><operator>.</operator><name>safefswritesize</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>usableBlockSize</name></name> <operator>=</operator> <name><name>aoFormData</name><operator>.</operator><name>blocksize</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get information about all the file segments we need to scan
	 */</comment>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name></name> <operator>=</operator>
		<call><name>GetAllFileSegInfo</name><argument_list>(
						  <argument><expr><name>relation</name></expr></argument>,
						  <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>totalSegfiles</name></name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * Initialize lastSequence only for segments which we got above is sufficient,
	 * rather than all AOTupleId_MultiplierSegmentFileNum ones that introducing
	 * too many unnecessary calls in most cases.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>lastSequence</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>lastSequence</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>totalSegfiles</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* always initailize segment 0 */</comment>
		<expr_stmt><expr><name>segno</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>segno</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* set corresponding bit for target segment */</comment>
		<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>lastSequence</name><index>[<expr><name>segno</name></expr>]</index></name> <operator>=</operator> <call><name>ReadLastSequence</name><argument_list>(<argument><expr><name><name>aoFormData</name><operator>.</operator><name>segrelid</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>AppendOnlyStorageRead_Init</name><argument_list>(
							   <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>,
							   <argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>initContext</name></name></expr></argument>,
							   <argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>usableBlockSize</name></name></expr></argument>,
							   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>title</name></name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageAttributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><name>fns</name> <operator>=</operator> <call><name>get_funcs_for_compression</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoFormData</name><operator>.</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name><operator>.</operator><name>compression_functions</name></name> <operator>=</operator> <name>fns</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fns</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGFunction</name></type>	<name>cons</name> <init>= <expr><name><name>fns</name><index>[<expr><name>COMPRESSION_CONSTRUCTOR</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CompressionState</name> <modifier>*</modifier></type><name>cs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StorageAttributes</name></type> <name>sa</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>comptype</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoFormData</name><operator>.</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>complevel</name></name> <operator>=</operator> <name><name>aoFormData</name><operator>.</operator><name>compresslevel</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>blocksize</name></name> <operator>=</operator> <name><name>aoFormData</name><operator>.</operator><name>blocksize</name></name></expr>;</expr_stmt>


		<expr_stmt><expr><name>cs</name> <operator>=</operator> <call><name>callCompressionConstructor</name><argument_list>(<argument><expr><name>cons</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument> <comment type="block">/* decompress */</comment> )</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name><operator>.</operator><name>compressionState</name></name> <operator>=</operator> <name>cs</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AppendOnlyExecutorReadBlock_Init</name><argument_list>(
									 <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>,
									 <argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
									 <argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>initContext</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>,
									 <argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>usableBlockSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_Init_forSearch</name><argument_list>(
											<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>,
											<argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
											<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name></name></expr></argument>,
											<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>totalSegfiles</name></name></expr></argument>,
											<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
											<argument><expr><literal type="number">1</literal></expr></argument>,
											<argument><expr><name>false</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>,
						   <argument><expr><name><name>aoFormData</name><operator>.</operator><name>visimaprelid</name></name></expr></argument>,
						   <argument><expr><name><name>aoFormData</name><operator>.</operator><name>visimapidxid</name></name></expr></argument>,
						   <argument><expr><name>AccessShareLock</name></expr></argument>,
						   <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>aoFetchDesc</name></expr>;</return>

</block_content>}</block></function>

<comment type="block">/*
 * appendonly_fetch -- fetch the tuple for a given tid.
 *
 * If the 'slot' is not NULL, the fetched tuple will be assigned to the slot.
 *
 * Return true if such a tuple is found. Otherwise, return false.
 */</comment>
<function><type><name>bool</name></type>
<name>appendonly_fetch</name><parameter_list>(<parameter><decl><type><name>AppendOnlyFetchDesc</name></type> <name>aoFetchDesc</name></decl></parameter>,
				 <parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>,
				 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>segmentFileNum</name> <init>= <expr><call><name>AOTupleIdGet_segmentFileNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>rowNum</name> <init>= <expr><call><name>AOTupleIdGet_rowNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isSnapshotAny</name> <init>= <expr><operator>(</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>==</operator> <name>SnapshotAny</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segmentFileNum</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>lastSequence</name><index>[<expr><name>segmentFileNum</name></expr>]</index></name> <operator>==</operator> <name>InvalidAORowNum</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Row No. %ld in segment file No. %d is out of scanning scope for target relfilenode %u."</literal></expr></argument>,
				 		<argument><expr><name>rowNum</name></expr></argument>, <argument><expr><name>segmentFileNum</name></expr></argument>, <argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * This is an improvement for brin. BRIN index stores ranges of TIDs in
	 * terms of block numbers and not specific TIDs, so it's possible that the
	 * fetch function is called with a non-existent TID. The function
	 * appendonly_fetch will access the block directory table first and cache
	 * some MinipageEntrys. If we try to access the non-existent tid, a cache
	 * miss will occur. And we need to search the btree on block directory
	 * table. This is a vary slow operation. So a fast return path was added
	 * here. If the rowNum is bigger than lastsequence, skip it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rowNum</name> <operator>&gt;</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>lastSequence</name><index>[<expr><name>segmentFileNum</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>	<comment type="block">/* row has been deleted or updated. */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do we have a current block?  If it has the requested tuple, that would
	 * be a great performance optimization.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>valid</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name> <operator>&amp;&amp;</operator>
			<name>segmentFileNum</name> <operator>==</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>num</name></name> <operator>&amp;&amp;</operator>
			<name>segmentFileNum</name> <operator>==</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>blockDirectory</name><operator>.</operator><name>currentSegmentFileNum</name></name> <operator>&amp;&amp;</operator>
			<name>segmentFileNum</name> <operator>==</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>executorReadBlock</name><operator>.</operator><name>segmentFileNum</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>rowNum</name> <operator>&gt;=</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>firstRowNum</name></name> <operator>&amp;&amp;</operator>
				<name>rowNum</name> <operator>&lt;=</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>lastRowNum</name></name> <operator>&amp;&amp;</operator>
				<call><name>AppendOnlyBlockDirectoryEntry_RangeHasRow</name><argument_list>(
														  <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>blockDirectoryEntry</name></name></expr></argument>,
														  <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSnapshotAny</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AppendOnlyVisimap_IsVisible</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<return>return <expr><name>false</name></expr>;</return>	<comment type="block">/* row has been deleted or updated. */</comment>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>fetchFromCurrentBlock</name><argument_list>(<argument><expr><name>aoFetchDesc</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Otherwise, if the current Block Directory entry covers the
			 * request tuples, lets use its information as another performance
			 * optimization.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyBlockDirectoryEntry_RangeHasRow</name><argument_list>(
														  <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>blockDirectoryEntry</name></name></expr></argument>,
														  <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The tuple is covered by the current Block Directory entry,
				 * but is it before or after our current block?
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>rowNum</name> <operator>&lt;</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>firstRowNum</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * XXX This could happen when an insert is cancelled. In
					 * that case, we fetched the next block that has a higher
					 * firstRowNum when we try to find the first cancelled
					 * row. So for the second or any cancelled row, we enter
					 * here, and re-read the previous block. This seems
					 * inefficient.
					 *
					 * We may be able to fix this by adding an entry to the
					 * block directory for those cancelled inserts.
					 */</comment>

					<comment type="block">/*
					 * Set scan range to prior blocks.
					 */</comment>
					<expr_stmt><expr><call><name>positionFirstBlockOfRange</name><argument_list>(<argument><expr><name>aoFetchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Set limit to before current block. */</comment>
					<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanAfterFileOffset</name></name> <operator>=</operator>
						<name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>fileOffset</name></name></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>scanLastRowNum</name></name> <operator>=</operator>
						<name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>firstRowNum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Set scan range to following blocks.
					 */</comment>
					<expr_stmt><expr><call><name>positionSkipCurrentBlock</name><argument_list>(<argument><expr><name>aoFetchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>positionLimitToEndOfRange</name><argument_list>(<argument><expr><name>aoFetchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSnapshotAny</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AppendOnlyVisimap_IsVisible</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<return>return <expr><name>false</name></expr>;</return>	<comment type="block">/* row has been deleted or updated. */</comment>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>scanToFetchTuple</name><argument_list>(<argument><expr><name>aoFetchDesc</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
				<comment type="block">/* Segment file not in aoseg table.. */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Open or switch open, if necessary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name> <operator>&amp;&amp;</operator>
		<name>segmentFileNum</name> <operator>!=</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>num</name></name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<comment type="block">/*
		 * Currently, we only support Index Scan on bitmap index and Bitmap Index Scan
		 * on AO tables, so normally the below warning should not happen.
		 * See get_index_paths in indxpath.c.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>segmentFileNum</name> <operator>&lt;</operator> <name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>num</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"append-only fetch requires scan prior segment file: segmentFileNum %d, rowNum "</literal> <name>INT64_FORMAT</name> <literal type="string">", currentSegmentFileNum %d"</literal></expr></argument>,
							<argument><expr><name>segmentFileNum</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>,
							<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>num</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>closeFetchSegmentFile</name><argument_list>(<argument><expr><name>aoFetchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentSegmentFile</name><operator>.</operator><name>isOpen</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>openFetchSegmentFile</name><argument_list>(
								  <argument><expr><name>aoFetchDesc</name></expr></argument>,
								  <argument><expr><name>segmentFileNum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
			<comment type="block">/* Segment file not in aoseg table.. */</comment>
			<comment type="block">/* Must be aborted or deleted and reclaimed. */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Reset currentBlock info */</comment>
		<expr_stmt><expr><call><name>resetCurrentBlockInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Need to get the Block Directory entry that covers the TID.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyBlockDirectory_GetEntry</name><argument_list>(
										   <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>,
										   <argument><expr><name>aoTupleId</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>currentBlock</name><operator>.</operator><name>blockDirectoryEntry</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* Row not represented in Block Directory. */</comment>
		<comment type="block">/* Must be aborted or deleted and reclaimed. */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSnapshotAny</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AppendOnlyVisimap_IsVisible</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* row has been deleted or updated. */</comment>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * Set scan range covered by new Block Directory entry.
	 */</comment>
	<expr_stmt><expr><call><name>positionFirstBlockOfRange</name><argument_list>(<argument><expr><name>aoFetchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>positionLimitToEndOfRange</name><argument_list>(<argument><expr><name>aoFetchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>scanToFetchTuple</name><argument_list>(<argument><expr><name>aoFetchDesc</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
	<comment type="block">/* Segment file not in aoseg table.. */</comment>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>appendonly_fetch_finish</name><parameter_list>(<parameter><decl><type><name>AppendOnlyFetchDesc</name></type> <name>aoFetchDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RelationDecrementReferenceCount</name><argument_list>(<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyStorageRead_CloseFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyStorageRead_FinishSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>storageRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyExecutorReadBlock_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>executorReadBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_End_forSearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FreeAllSegFileInfo</name><argument_list>(<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name></name></expr></argument>, <argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>totalSegfiles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>segmentFileName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aoFetchDesc</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * appendonly_delete_init
 *
 * before using appendonly_delete() to delete tuples from append-only segment
 * files, we need to call this function to initialize the delete desc
 * data structured.
 */</comment>
<function><type><name>AppendOnlyDeleteDesc</name></type>
<name>appendonly_delete_init</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>visimaprelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>visimapidxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visimaprelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visimapidxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>AppendOnlyDeleteDesc</name></type> <name>aoDeleteDesc</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyDeleteDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>aod_rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>,
						   <argument><expr><name>visimaprelid</name></expr></argument>,
						   <argument><expr><name>visimapidxid</name></expr></argument>,
						   <argument><expr><name>RowExclusiveLock</name></expr></argument>,
						   <argument><expr><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimapDelete_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>visiMapDelete</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>aoDeleteDesc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>appendonly_delete_finish</name><parameter_list>(<parameter><decl><type><name>AppendOnlyDeleteDesc</name></type> <name>aoDeleteDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aoDeleteDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimapDelete_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>visiMapDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>aoDeleteDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TM_Result</name></type>
<name>appendonly_delete</name><parameter_list>(<parameter><decl><type><name>AppendOnlyDeleteDesc</name></type> <name>aoDeleteDesc</name></decl></parameter>,
				  <parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aoDeleteDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_delete</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-only delete tuple from table '%s' (AOTupleId %s)"</literal></expr></argument>,
		   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>aod_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>AOTupleIdToString</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(
								   <argument><expr><literal type="string">"appendonly_delete"</literal></expr></argument>,
								   <argument><expr><name>DDLNotSpecified</name></expr></argument>,
								   <argument><expr><literal type="string">""</literal></expr></argument>, <comment type="line">//databaseName</comment>
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>aod_rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* tableName */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>AppendOnlyVisimapDelete_Hide</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoDeleteDesc</name><operator>-&gt;</operator><name>visiMapDelete</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * appendonly_insert_init
 *
 * 'segno' must be a segment that has been previously locked for this
 * transaction, by calling LockSegnoForWrite() or ChooseSegnoForWrite().
 *
 * before using appendonly_insert() to insert tuples we need to call
 * this function to initialize our varblock and bufferedAppend structures
 * and memory for appending data into the relation file.
 *
 * 'num_rows': Size of gp_fast_sequence allocation for this insert iteration.
 * If a valid number of rows value is provided, in cases where we have a sense
 * of how many rows we will be inserting (such as multi-insert), we use that to
 * perform the allocation. Otherwise, if 0 is supplied, the default
 * NUM_FAST_SEQUENCES is used. Using a larger range for gp_fast_sequence helps
 * reduce trips to gp_fast_sequence, enhancing performance, especially for
 * concurrent loads.
 *
 * see appendonly_insert() for more specifics about inserting tuples into
 * append only tables.
 */</comment>
<function><type><name>AppendOnlyInsertDesc</name></type>
<name>appendonly_insert_init</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>num_rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyInsertDesc</name></type> <name>aoInsertDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxtupsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>firstSequence</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGFunction</name> <modifier>*</modifier></type><name>fns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>desiredOverflowBytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<function_decl><type><name>size_t</name></type>		(<modifier>*</modifier><name>desiredCompressionSize</name>) <parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>input</name></decl></parameter>)</parameter_list>;</function_decl>

	<decl_stmt><decl><type><name>AppendOnlyStorageAttributes</name> <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>titleBuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>segrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>blocksize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>safefswritesize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>compresslevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>checksum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type> <name>compresstype</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAttributes</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blocksize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>safefswritesize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>compresslevel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>checksum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>compresstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the pg_appendonly information for this table
	 */</comment>

	<comment type="block">/*
	 * allocate and initialize the insert descriptor
	 */</comment>
	<expr_stmt><expr><name>aoInsertDesc</name> <operator>=</operator> <operator>(</operator><name>AppendOnlyInsertDesc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyInsertDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We want to see an up-to-date view of the metadata. The target segment's
	 * pg_aoseg row is already locked for us.
	 */</comment>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>mt_bind</name></name> <operator>=</operator> <call><name>create_memtuple_binding</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>appendFile</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>appendFilePathNameMaxLen</name></name> <operator>=</operator> <call><name>AOSegmentFilePathNameLen</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>appendFilePathName</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>appendFilePathNameMaxLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>appendFilePathName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>bufferCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>blockFirstRowNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>insertCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varblockCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segno</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>cur_segno</name></name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adding a NOTOAST table attribute in 3.3.3 would require a catalog
	 * change, so in the interim we will test this with a GUC.
	 *
	 * This GUC must have the same value on write and read.
	 */</comment>
<comment type="block">/* 	aoInsertDesc-&gt;useNoToast = aoentry-&gt;notoast; */</comment>

	<comment type="block">/*
	 * Although variable length blocks of AO should be able to accommodate variable length
	 * datums, we still need to keep TOAST for AO_ROW to benefit to performance when query
	 * in-line data.
	 */</comment>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>useNoToast</name></name> <operator>=</operator> <operator>!</operator><operator>(</operator><call><name><name>rel</name><operator>-&gt;</operator><name>rd_tableam</name><operator>-&gt;</operator><name>relation_needs_toast_table</name></name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>usableBlockSize</name></name> <operator>=</operator> <name>blocksize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>attr</name> <operator>=</operator> <operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageAttributes</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * These attributes describe the AppendOnly format to be scanned.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compressType</name></name> <operator>=</operator> <literal type="string">"none"</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compressType</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>compressLevel</name></name> <operator>=</operator> <name>compresslevel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>checksum</name></name> <operator>=</operator> <name>checksum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>safeFSWriteSize</name></name> <operator>=</operator> <name>safefswritesize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>fns</name> <operator>=</operator> <call><name>get_funcs_for_compression</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CompressionState</name> <modifier>*</modifier></type><name>cs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CompressionState</name> <modifier>*</modifier></type><name>verifyCs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fns</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGFunction</name></type>	<name>cons</name> <init>= <expr><name><name>fns</name><index>[<expr><name>COMPRESSION_CONSTRUCTOR</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StorageAttributes</name></type> <name>sa</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>comptype</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>complevel</name></name> <operator>=</operator> <name>compresslevel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>blocksize</name></name> <operator>=</operator> <name>blocksize</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>cs</name> <operator>=</operator> <call><name>callCompressionConstructor</name><argument_list>(<argument><expr><name>cons</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument> <comment type="block">/* compress */</comment> )</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>gp_appendonly_verify_write_block</name> <operator>==</operator> <name>true</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>verifyCs</name> <operator>=</operator> <call><name>callCompressionConstructor</name><argument_list>(<argument><expr><name>cons</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>,
												  <argument><expr><name>false</name></expr></argument> <comment type="block">/* decompress */</comment> )</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>desiredCompressionSize</name> <operator>=</operator> <name><name>cs</name><operator>-&gt;</operator><name>desired_sz</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>desiredCompressionSize</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Call the compression's desired size function to find out what
			 * additional space it requires for our block size.
			 */</comment>
			<expr_stmt><expr><name>desiredOverflowBytes</name> <operator>=</operator>
				<operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>desiredCompressionSize</name><operator>)</operator> <operator>(</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>usableBlockSize</name></name><operator>)</operator>
				<operator>-</operator> <name><name>aoInsertDesc</name><operator>-&gt;</operator><name>usableBlockSize</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>desiredOverflowBytes</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>overflowSize</name></name> <operator>=</operator> <name>desiredOverflowBytes</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>titleBuf</name></expr></argument>, <argument><expr><literal type="string">"Write of Append-Only Row-Oriented relation '%s'"</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>title</name></name> <operator>=</operator> <name><name>titleBuf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyStorageWrite_Init</name><argument_list>(
								<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>,
								<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>usableBlockSize</name></name></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>title</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageAttributes</name></name></expr></argument>,
								<argument><expr><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name><operator>.</operator><name>compression_functions</name></name> <operator>=</operator> <name>fns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name><operator>.</operator><name>compressionState</name></name> <operator>=</operator> <name>cs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name><operator>.</operator><name>verifyWriteCompressionState</name></name> <operator>=</operator> <name>verifyCs</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_insert</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-only insert initialize for table '%s' segment file %u "</literal>
		   <literal type="string">"(compression = %s, compression type %s, compression level %d)"</literal></expr></argument>,
		   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name><name>attr</name><operator>-&gt;</operator><name>compress</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>compressLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Temporarily set the firstRowNum for the block so that we can calculate
	 * the correct header length.
	 */</comment>
	<expr_stmt><expr><call><name>AppendOnlyStorageWrite_SetFirstRowNum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>,
										  <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>completeHeaderLen</name></name> <operator>=</operator>
		<call><name>AppendOnlyStorageWrite_CompleteHeaderLen</name><argument_list>(
												 <argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>,
												 <argument><expr><name>AoHeaderKind_SmallContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>maxDataLen</name></name> <operator>=</operator>
		<name><name>aoInsertDesc</name><operator>-&gt;</operator><name>usableBlockSize</name></name> <operator>-</operator>
		<name><name>aoInsertDesc</name><operator>-&gt;</operator><name>completeHeaderLen</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>tempSpaceLen</name></name> <operator>=</operator> <name><name>aoInsertDesc</name><operator>-&gt;</operator><name>usableBlockSize</name></name> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt> <comment type="block">/* TODO - come up with a
																	 * more efficient
																	 * calculation */</comment>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>tempSpace</name></name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>tempSpaceLen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxtupsize</name> <operator>=</operator> <name><name>aoInsertDesc</name><operator>-&gt;</operator><name>maxDataLen</name></name> <operator>-</operator> <name>VARBLOCK_HEADER_LEN</name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>toast_tuple_threshold</name></name> <operator>=</operator> <name>maxtupsize</name> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt>	<comment type="block">/* see tuptoaster.h for
															 * more information */</comment>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>toast_tuple_target</name></name> <operator>=</operator> <name>maxtupsize</name> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt>

	<comment type="block">/* open our current relation file segment for write */</comment>
	<expr_stmt><expr><call><name>SetCurrentFileSegForWrite</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>tempSpaceLen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Obtain the next list of fast sequences for this relation.
	 *
	 * Even in the case of no indexes, we need to update the fast sequences,
	 * since the table may contain indexes at some point of time.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>fsInfo</name><operator>-&gt;</operator><name>segno</name></name> <operator>==</operator> <name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>segrelid</name></expr></argument>,
			<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>firstSequence</name> <operator>=</operator> <call><name>GetFastSequences</name><argument_list>(<argument><expr><name>segrelid</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>num_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>numSequences</name></name> <operator>=</operator> <name>num_rows</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>firstSequence</name> <operator>&gt;</operator> <name><name>aoInsertDesc</name><operator>-&gt;</operator><name>rowCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>lastSequence</name></name> <operator>=</operator> <name>firstSequence</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setupNextWriteBlock</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the block directory. */</comment>
	<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_Init_forInsert</name><argument_list>(
											<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name><operator>)</operator></expr></argument>,
<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>, <comment type="line">//CONCERN:Safe to assume all block directory entries for segment are "covered" by same exclusive lock.</comment>
											<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>fsInfo</name></name></expr></argument>, <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>lastSequence</name></name></expr></argument>,
											<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>aoInsertDesc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	appendonly_insert		- insert tuple into a varblock
 *
 * Note the following major differences from heap_insert
 *
 * - wal is always bypassed here.
 * - transaction information is of no interest.
 * - tuples inserted into varblocks, not via the postgresql buf/page manager.
 * - no need to pin buffers.
 *
  * The header fields of *tup are updated to match the stored tuple;
  *
  * Unlike heap_insert(), this function doesn't scribble on the input tuple.
  */</comment>
<function><type><name>void</name></type>
<name>appendonly_insert</name><parameter_list>(<parameter><decl><type><name>AppendOnlyInsertDesc</name></type> <name>aoInsertDesc</name></decl></parameter>,
				  <parameter><decl><type><name>MemTuple</name></type> <name>instup</name></decl></parameter>,
				  <parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name> <init>= <expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>itemLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>itemPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTuple</name></type>	<name>tup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_toast</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isLargeContent</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>usableBlockSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aoInsertDesc</name><operator>-&gt;</operator><name>tempSpaceLen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>toast_tuple_threshold</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aoInsertDesc</name><operator>-&gt;</operator><name>toast_tuple_target</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(
								   <argument><expr><literal type="string">"appendonly_insert"</literal></expr></argument>,
								   <argument><expr><name>DDLNotSpecified</name></expr></argument>,
								   <argument><expr><literal type="string">""</literal></expr></argument>, <comment type="line">//databaseName</comment>
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* tableName */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>useNoToast</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>need_toast</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>need_toast</name> <operator>=</operator> <operator>(</operator><call><name>MemTupleHasExternal</name><argument_list>(<argument><expr><name>instup</name></expr></argument>, <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>mt_bind</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
					  <call><name>memtuple_get_size</name><argument_list>(<argument><expr><name>instup</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>aoInsertDesc</name><operator>-&gt;</operator><name>toast_tuple_threshold</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If the new tuple is too big for storage or contains already toasted
	 * out-of-line attributes from some other relation, invoke the toaster.
	 *
	 * Note: below this point, tup is the data we actually intend to store
	 * into the relation; instup is the caller's original untoasted data.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>need_toast</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>toast_insert_or_update_memtup</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>instup</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>mt_bind</name></name></expr></argument>,
											<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>toast_tuple_target</name></name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>,	<comment type="block">/* errtbl is never AO */</comment>
											<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <name>instup</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * get space to insert our next item (tuple)
	 */</comment>
	<expr_stmt><expr><name>itemLen</name> <operator>=</operator> <call><name>memtuple_get_size</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>isLargeContent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are at the limit for append-only storage header's row count,
	 * force this VarBlock to finish.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VarBlockMakerItemCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varBlockMaker</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>AOSmallContentHeader_MaxRowCount</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>itemPtr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>itemPtr</name> <operator>=</operator> <call><name>VarBlockMakerGetNextItemPtr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varBlockMaker</name></name></expr></argument>, <argument><expr><name>itemLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If no more room to place items in the current varblock finish it and
	 * start inserting into the next one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>itemPtr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>VarBlockMakerItemCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varBlockMaker</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Case #1.  The entire tuple cannot fit within a VarBlock.  It is
			 * too large.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>useNoToast</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Indicate we need to write the large tuple as a large
				 * content multiple-block set.
				 */</comment>
				<expr_stmt><expr><name>isLargeContent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Use a different errcontext when user input (tuple contents)
				 * cause the error.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"item too long (check #1): length %d, maxBufferLen %d"</literal></expr></argument>,
								<argument><expr><name>itemLen</name></expr></argument>, <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varBlockMaker</name><operator>.</operator><name>maxBufferLen</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errcontext_appendonly_insert_block_user_limit</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Write out the current VarBlock to make room.
			 */</comment>
			<expr_stmt><expr><call><name>finishWriteBlock</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>nonCompressedData</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>AppendOnlyStorageWrite_IsBufferAllocated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Setup a new VarBlock.
			 */</comment>
			<expr_stmt><expr><call><name>setupNextWriteBlock</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>itemPtr</name> <operator>=</operator> <call><name>VarBlockMakerGetNextItemPtr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varBlockMaker</name></name></expr></argument>, <argument><expr><name>itemLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>itemPtr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Case #2.  The entire tuple cannot fit within a VarBlock. It
				 * is too large.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>useNoToast</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Indicate we need to write the large tuple as a large
					 * content multiple-block set.
					 */</comment>
					<expr_stmt><expr><name>isLargeContent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Use a different errcontext when user input (tuple
					 * contents) cause the error.
					 */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"item too long (check #2): length %d, maxBufferLen %d"</literal></expr></argument>,
									<argument><expr><name>itemLen</name></expr></argument>, <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>varBlockMaker</name><operator>.</operator><name>maxBufferLen</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errcontext_appendonly_insert_block_user_limit</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isLargeContent</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have room in the current VarBlock for the new tuple.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>itemLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>itemPtr</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>itemLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Write the large tuple as a large content multiple-block set.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemPtr</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>need_toast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>instup</name> <operator>==</operator> <name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * "Cancel" the last block allocation, if one.
		 */</comment>
		<expr_stmt><expr><call><name>cancelLastBuffer</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>nonCompressedData</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>AppendOnlyStorageWrite_IsBufferAllocated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Write large content.
		 */</comment>
		<expr_stmt><expr><call><name>AppendOnlyStorageWrite_Content</name><argument_list>(
									   <argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>,
									   <argument><expr><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <name>tup</name></expr></argument>,
									   <argument><expr><name>itemLen</name></expr></argument>,
									   <argument><expr><name>AoExecutorBlockKind_SingleRow</name></expr></argument>,
									    <comment type="block">/* rowCount */</comment> <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>nonCompressedData</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>AppendOnlyStorageWrite_IsBufferAllocated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>setupNextWriteBlock</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>insertCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>lastSequence</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>numSequences</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>numSequences</name></name><operator>)</operator><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>numSequences</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AOTupleIdInit</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>, <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>, <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>lastSequence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the allocated fast sequence numbers are used up, we request for a
	 * next list of fast sequence numbers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>numSequences</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>firstSequence</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>segrelid</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name>segrelid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>firstSequence</name> <operator>=</operator>
			<call><name>GetFastSequences</name><argument_list>(<argument><expr><name>segrelid</name></expr></argument>,
							 <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>cur_segno</name></name></expr></argument>,
							 <argument><expr><name>NUM_FAST_SEQUENCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>firstSequence</name> <operator>==</operator> <name><name>aoInsertDesc</name><operator>-&gt;</operator><name>lastSequence</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>numSequences</name></name> <operator>=</operator> <name>NUM_FAST_SEQUENCES</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_insert_tuple</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-only insert tuple for table '%s' "</literal>
		   <literal type="string">"(AOTupleId %s, memtuple length %d, isLargeRow %s, block count "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
		   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>aoi_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>AOTupleIdToString</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>itemLen</name></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name>isLargeContent</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		   <argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>bufferCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tup</name> <operator>!=</operator> <name>instup</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * appendonly_insert_finish
 *
 * when done inserting all the data via appendonly_insert() we need to call
 * this function to flush all remaining data in the buffer into the file.
 */</comment>
<function><type><name>void</name></type>
<name>appendonly_insert_finish</name><parameter_list>(<parameter><decl><type><name>AppendOnlyInsertDesc</name></type> <name>aoInsertDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Finish up that last varblock.
	 */</comment>
	<expr_stmt><expr><call><name>finishWriteBlock</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CloseWritableFileSeg</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_End_forInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>blockDirectory</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyStorageWrite_FinishSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>storageWrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroy_memtuple_binding</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>mt_bind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>aoInsertDesc</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>aoInsertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
