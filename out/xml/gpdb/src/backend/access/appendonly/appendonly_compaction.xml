<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/appendonly/appendonly_compaction.c"><comment type="block">/*------------------------------------------------------------------------------
 *
 * Code dealing with the compaction of append-only tables.
 *
 * Compaction is the part of updatable append-only tables that
 * is responsible to freeing the space occupied by tuples that have
 * been deleted or updated.
 *
 * The general process is that first all visible tuples of a segment
 * file (or a set of segment files) are moved to a different segment file.
 * Afterwards in a different transaction that requires AccessExclusiveLocks
 * the compacted segment files are dropped and the eof/tupcount/varblock
 * information in pg_aoseg_&lt;oid&gt; are reset to 0.
 *
 * Copyright (c) 2013-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/access/appendonly/appendonly_compaction.c
 *
 *------------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/aocs_compaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/aomd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/aosegfiles.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonly_compaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonlywriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_fastsequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_appendonly.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Drops a segment file.
 *
 * Actually, we just truncate the segfile to 0 bytes, to reclaim the space.
 * Before GPDB 6, we used to remove the file, but with WAL replication, we
 * no longer have a convenient function to remove a single segment of a
 * relation. An empty file is as almost as good as a non-existent file. If
 * the relation is dropped later, the code in mdunlink() will remove all
 * segments, including any empty ones we've left behind.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyCompaction_DropSegmentFile</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aorel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>filenamepath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fileSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsAoRows</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_appendonly_print_compaction</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Drop segment file: segno %d"</literal></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Open and truncate the relation segfile */</comment>
	<expr_stmt><expr><call><name>MakeAOSegmentFileName</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileSegNo</name></expr></argument>, <argument><expr><name>filenamepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenAOSegmentFile</name><argument_list>(<argument><expr><name>filenamepath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TruncateAOSegmentFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>fileSegNo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseAOSegmentFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The file we were about to drop/truncate didn't exist. That shouldn't
		 * happen, but the end result is what we wanted. Assert so that we will
		 * find out if this happens, after all, in testing. In production, we'd
		 * rather keep running.
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not truncate segfile %s, because it does not exist"</literal></expr></argument>, <argument><expr><name>filenamepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calculates the ratio of hidden tuples as a double between 0 and 100
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>AppendOnlyCompaction_GetHideRatio</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>hiddenTupcount</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>totalTupcount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>hideRatio</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>hiddenTupcount</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>totalTupcount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>hideRatio</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>hiddenTupcount</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>totalTupcount</name><operator>)</operator> <operator>*</operator> <literal type="number">100.0</literal></expr>;</expr_stmt>
	<return>return <expr><name>hideRatio</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true iff the given segment file should be compacted.
 */</comment>
<function><type><name>bool</name></type>
<name>AppendOnlyCompaction_ShouldCompact</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aoRelation</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>,
								   <parameter><decl><type><name>int64</name></type> <name>segmentTotalTupcount</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>isFull</name></decl></parameter>,
								   <parameter><decl><type><name>Snapshot</name></type>	<name>appendOnlyMetaDataSnapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyVisimap</name></type> <name>visiMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>hiddenTupcount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>hideRatio</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>visimaprelid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>visimapidxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>aoRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>aoRelation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>visimaprelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visimapidxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_appendonly_compaction</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"append-only compaction skipped on relation %s, segment file num %d"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>aoRelation</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>segno</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Compaction is disabled."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Disable compaction by global guc. */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>visiMap</name></expr></argument>,
						   <argument><expr><name>visimaprelid</name></expr></argument>,
						   <argument><expr><name>visimapidxid</name></expr></argument>,
						   <argument><expr><name>ShareLock</name></expr></argument>,
						   <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hiddenTupcount</name> <operator>=</operator> <call><name>AppendOnlyVisimap_GetSegmentFileHiddenTupleCount</name><argument_list>(
																	  <argument><expr><operator>&amp;</operator><name>visiMap</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isFull</name> <operator>&amp;&amp;</operator> <name>hiddenTupcount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * if it is a full vacuum and there is any obsolete data, do a
		 * compaction
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>hideRatio</name> <operator>=</operator> <call><name>AppendOnlyCompaction_GetHideRatio</name><argument_list>(<argument><expr><name>hiddenTupcount</name></expr></argument>, <argument><expr><name>segmentTotalTupcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hideRatio</name> <operator>&lt;=</operator> <name>gp_appendonly_compaction_threshold</name> <operator>||</operator> <name>gp_appendonly_compaction_threshold</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>hiddenTupcount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
						  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only compaction skipped on relation %s, segment file num %d, "</literal>
								  <literal type="string">"hidden tupcount "</literal> <name>INT64_FORMAT</name> <literal type="string">", total tupcount "</literal> <name>INT64_FORMAT</name> <literal type="string">", "</literal>
								  <literal type="string">"hide ratio %lf%%, threshold %d%%"</literal></expr></argument>,
								  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>aoRelation</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>segno</name></expr></argument>,
								  <argument><expr><name>hiddenTupcount</name></expr></argument>, <argument><expr><name>segmentTotalTupcount</name></expr></argument>,
								  <argument><expr><name>hideRatio</name></expr></argument>, <argument><expr><name>gp_appendonly_compaction_threshold</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only compaction skipped on relation %s, segment file num %d"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>aoRelation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>segno</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Ratio of obsolete tuples below threshold (%lf%% vs %d%%)"</literal></expr></argument>,
								   <argument><expr><name>hideRatio</name></expr></argument>, <argument><expr><name>gp_appendonly_compaction_threshold</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
						  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only compaction skipped on relation %s, segment file num %d, "</literal>
								  <literal type="string">"hidden tupcount "</literal> <name>INT64_FORMAT</name> <literal type="string">", total tupcount "</literal> <name>INT64_FORMAT</name> <literal type="string">", "</literal>
								  <literal type="string">"hide ratio %lf%%, threshold %d%%"</literal></expr></argument>,
								  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>aoRelation</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>segno</name></expr></argument>,
								  <argument><expr><name>hiddenTupcount</name></expr></argument>, <argument><expr><name>segmentTotalTupcount</name></expr></argument>,
								  <argument><expr><name>hideRatio</name></expr></argument>, <argument><expr><name>gp_appendonly_compaction_threshold</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Schedule compaction: "</literal>
			   <literal type="string">"segno %d, "</literal>
			   <literal type="string">"hidden tupcount "</literal> <name>INT64_FORMAT</name> <literal type="string">", total tupcount "</literal> <name>INT64_FORMAT</name> <literal type="string">", "</literal>
			   <literal type="string">"hide ratio %lf%%, threshold %d%%"</literal></expr></argument>,
			   <argument><expr><name>segno</name></expr></argument>,
			   <argument><expr><name>hiddenTupcount</name></expr></argument>, <argument><expr><name>segmentTotalTupcount</name></expr></argument>,
			   <argument><expr><name>hideRatio</name></expr></argument>, <argument><expr><name>gp_appendonly_compaction_threshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>AppendOnlyVisimap_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>visiMap</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AppendOnlySegmentFileTruncateToEOF()
 *
 * Assumes that the segment file lock is already held.
 *
 * For the segment file is truncates to the eof.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlySegmentFileTruncateToEOF</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aorel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>segeof</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fileSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>filenamepath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsAoRows</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open and truncate the relation segfile to its eof */</comment>
	<expr_stmt><expr><call><name>MakeAOSegmentFileName</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileSegNo</name></expr></argument>, <argument><expr><name>filenamepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Opening AO relation \"%s.%s\", relation id %u, relfilenode %u (physical segment file #%d, logical EOF "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
		   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>relname</name></expr></argument>,
		   <argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
		   <argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
		   <argument><expr><name>segno</name></expr></argument>,
		   <argument><expr><name>segeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenAOSegmentFile</name><argument_list>(<argument><expr><name>filenamepath</name></expr></argument>, <argument><expr><name>segeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TruncateAOSegmentFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>fileSegNo</name></expr></argument>, <argument><expr><name>segeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseAOSegmentFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Successfully truncated AO ROW relation \"%s.%s\", relation id %u, relfilenode %u (physical segment file #%d, logical EOF "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
			   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>relname</name></expr></argument>,
			   <argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
			   <argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
			   <argument><expr><name>segno</name></expr></argument>,
			   <argument><expr><name>segeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_compaction</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"No gp_relation_node entry for AO ROW relation \"%s.%s\", relation id %u, relfilenode %u (physical segment file #%d, logical EOF "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
			   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>relname</name></expr></argument>,
			   <argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
			   <argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
			   <argument><expr><name>segno</name></expr></argument>,
			   <argument><expr><name>segeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyMoveTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					<parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>mt_bind</name></decl></parameter>,
					<parameter><decl><type><name>AppendOnlyInsertDesc</name></type> <name>insertDesc</name></decl></parameter>,
					<parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
					<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOTupleId</name>  <modifier>*</modifier></type><name>oldAoTupleId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOTupleId</name></type>	<name>newAoTupleId</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mt_bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldAoTupleId</name> <operator>=</operator> <operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr>;</expr_stmt>
	<comment type="block">/* Extract all the values of the tuple */</comment>
	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>appendonly_form_memtuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>mt_bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendonly_insert</name><argument_list>(<argument><expr><name>insertDesc</name></expr></argument>,
					  <argument><expr><name>tuple</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>newAoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>ItemPointerData</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>newAoTupleId</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* insert index' tuples if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_NumIndices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecInsertIndexTuples</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
							  <argument><expr><name>estate</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <comment type="block">/* noDupError */</comment>
							  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* specConflict */</comment>
							  <argument><expr><name>NIL</name></expr></argument> <comment type="block">/* arbiterIndexes */</comment>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendonly_free_memtuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_appendonly_print_compaction</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Compaction: Moved tuple (%d,"</literal> <name>INT64_FORMAT</name> <literal type="string">") -&gt; (%d,"</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
						<argument><expr><call><name>AOTupleIdGet_segmentFileNum</name><argument_list>(<argument><expr><name>oldAoTupleId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AOTupleIdGet_rowNum</name><argument_list>(<argument><expr><name>oldAoTupleId</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>AOTupleIdGet_segmentFileNum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newAoTupleId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>AOTupleIdGet_rowNum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newAoTupleId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>AppendOnlyThrowAwayTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>mt_bind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numAttrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOTupleId</name>  <modifier>*</modifier></type><name>aoTupleId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>toast_values</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>toast_isnull</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aoTupleId</name> <operator>=</operator> <operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr>;</expr_stmt>
	<comment type="block">/* Extract all the values of the tuple */</comment>
	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>appendonly_form_memtuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>mt_bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>numAttrs</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numAttrs</name> <operator>&lt;=</operator> <name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memtuple_deform</name><argument_list>(<argument><expr><operator>(</operator><name>MemTuple</name><operator>)</operator> <name>tuple</name></expr></argument>, <argument><expr><name>mt_bind</name></expr></argument>, <argument><expr><name>toast_values</name></expr></argument>, <argument><expr><name>toast_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* loop through all attributes, delete external stored values */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name> <init>= <expr><name><name>toast_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>toast_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_ONDISK</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>toast_delete_datum</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendonly_free_memtuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>Debug_appendonly_print_compaction</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Compaction: Throw away tuple (%d,"</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
						<argument><expr><call><name>AOTupleIdGet_segmentFileNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>AOTupleIdGet_rowNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Assumes that the segment file lock is already held.
 * Assumes that the segment file should be compacted.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlySegmentFileFullCompaction</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aorel</name></decl></parameter>,
									<parameter><decl><type><name>AppendOnlyInsertDesc</name></type> <name>insertDesc</name></decl></parameter>,
									<parameter><decl><type><name>FileSegInfo</name> <modifier>*</modifier></type><name>fsinfo</name></decl></parameter>,
									<parameter><decl><type><name>Snapshot</name></type>	<name>appendOnlyMetaDataSnapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyVisimap</name></type> <name>visiMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyScanDesc</name></type> <name>scanDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemTupleBinding</name> <modifier>*</modifier></type><name>mt_bind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>compact_segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>movedTupleCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOTupleId</name>  <modifier>*</modifier></type><name>aoTupleId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>tupleCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>tuplePerPage</name> <init>= <expr><name>INT_MAX</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>visimaprelid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>visimapidxid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>blkdirrelid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsAoRows</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>insertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>compact_segno</name> <operator>=</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>segno</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fsinfo</name><operator>-&gt;</operator><name>varblockcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuplePerPage</name> <operator>=</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>total_tupcount</name></name> <operator>/</operator> <name><name>fsinfo</name><operator>-&gt;</operator><name>varblockcount</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkdirrelid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>visimaprelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visimapidxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>visiMap</name></expr></argument>,
						   <argument><expr><name>visimaprelid</name></expr></argument>,
						   <argument><expr><name>visimapidxid</name></expr></argument>,
						   <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>,
						   <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_appendonly_print_compaction</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Compact AO segno %d, relation %s, insert segno %d"</literal></expr></argument>,
			 <argument><expr><name>compact_segno</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name><name>insertDesc</name><operator>-&gt;</operator><name>storageWrite</name><operator>.</operator><name>segmentFileNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Todo: We need to limit the scan to one file and we need to avoid to
	 * lock the file again.
	 *
	 * We use SnapshotAny to get visible and invisible tuples.
	 */</comment>
	<expr_stmt><expr><name>scanDesc</name> <operator>=</operator> <call><name>appendonly_beginrangescan</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>,
										 <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>compact_segno</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mt_bind</name> <operator>=</operator> <call><name>create_memtuple_binding</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need a ResultRelInfo and an EState so we can use the regular
	 * executor's index-entry-making machinery.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RangeTableIndex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* dummy */</comment>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name> <operator>=</operator> <name>aorel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_TrigDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* we don't fire triggers */</comment>
	<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't want uniqueness checks to be performed while "insert"ing tuples
	 * to a destination segfile during AppendOnlyMoveTuple(). This is to ensure
	 * that we can avoid spurious conflicts between the moved tuple and the
	 * original tuple.
	 */</comment>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>gp_bypass_unique_check</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Go through all visible tuples and move them to a new segfile.
	 */</comment>
	<while>while <condition>(<expr><call><name>appendonly_getnextslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanDesc</name><operator>-&gt;</operator><name>rs_base</name></name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check interrupts as this may take time. */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>aoTupleId</name> <operator>=</operator> <operator>(</operator><name>AOTupleId</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyVisimap_IsVisible</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanDesc</name><operator>-&gt;</operator><name>visibilityMap</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AppendOnlyMoveTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,
								<argument><expr><name>mt_bind</name></expr></argument>,
								<argument><expr><name>insertDesc</name></expr></argument>,
								<argument><expr><name>resultRelInfo</name></expr></argument>,
								<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>movedTupleCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Tuple is invisible and needs to be dropped */</comment>
			<expr_stmt><expr><call><name>AppendOnlyThrowAwayTuple</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>mt_bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Check for vacuum delay point after approximately a var block
		 */</comment>
		<expr_stmt><expr><name>tupleCount</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>VacuumCostActive</name> <operator>&amp;&amp;</operator> <name>tupleCount</name> <operator>%</operator> <name>tuplePerPage</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MarkFileSegInfoAwaitingDrop</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>compact_segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_DeleteSegmentFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>visiMap</name></expr></argument>, <argument><expr><name>compact_segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete all mini pages of the segment files if block directory exists */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyBlockDirectory_DeleteSegmentFile</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>,
												   <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
												   <argument><expr><name>compact_segno</name></expr></argument>,
												   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_appendonly_print_compaction</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Finished compaction: AO segfile %d, relation %s, moved tuple count "</literal> <name>INT64_FORMAT</name></expr></argument>,
			 <argument><expr><name>compact_segno</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>movedTupleCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>visiMap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroy_memtuple_binding</name><argument_list>(<argument><expr><name>mt_bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendonly_endscan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanDesc</name><operator>-&gt;</operator><name>rs_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Collect AWAITING_DROP segments.
 * 
 * Acquire AccessShareLock with cutoff_xid to scan and collect dead
 * segments.
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>AppendOptimizedCollectDeadSegments</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aorel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_aoseg_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>pg_aoseg_dsc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>aoscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>appendOnlyMetaDataSnapshot</name> <init>= <expr><call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>cutoff_xid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>segrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>	<modifier>*</modifier></type><name>dead_segs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>segrelid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>pg_aoseg_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>segrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_aoseg_dsc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_aoseg_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aoscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_aoseg_rel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>aoscan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>visible_to_all</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>segno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationIsAoRows</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
											  <argument><expr><name>Anum_pg_aoseg_segno</name></expr></argument>,
											  <argument><expr><name>pg_aoseg_dsc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
											  <argument><expr><name>Anum_pg_aoseg_state</name></expr></argument>,
											  <argument><expr><name>pg_aoseg_dsc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
											  <argument><expr><name>Anum_pg_aocs_segno</name></expr></argument>,
											  <argument><expr><name>pg_aoseg_dsc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
											  <argument><expr><name>Anum_pg_aocs_state</name></expr></argument>,
											  <argument><expr><name>pg_aoseg_dsc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>AOSEG_STATE_AWAITING_DROP</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Cutoff XID Screening
		 * 
		 * It's in awaiting-drop state, but does everyone see it that way?
		 *
		 * Compare the tuple's xmin with the oldest-xmin horizon. We don't bother
		 * checking the xmax; we never update or lock awaiting-drop tuples, so it
		 * should not be set. Even if the tuple was update, presumably an AO
		 * segment that's in awaiting-drop state won't be resurrected, so even if
		 * someone updates or locks the tuple, it's still safe to drop.
		 * 
		 * We don't need to acquire AccessExclusiveLock any longer because we only
		 * scan pg_aoseg to collect dead segments but no truncaste happens here.
		 * Considering the following two cases:
		 * 
		 * a) When there was a reader accessing a segment file which was changed to
		 * AWAITING_DROP in later VACUUM compaction, the reader's xid should be earlier
		 * than this tuple's xmin hence would set visible_to_all to false. Then the
		 * AWAITING_DROP segment file wouldn't be dropped in this VACUUM cleanup and
		 * the earlier reader could still be able to access old tuples.
		 * 
		 * b) Continue above, so there was a segment file in AWAITING_DROP state, the
		 * subsequent transactions can't see that hence it wouldn't be touched until
		 * next VACUUM is arrived. Therefore no later transaction's xid could be earlier
		 * than this dead segment tuple's xmin hence it would be true on visible_to_all.
		 * Then the corresponding dead segment file could be dropped later at that time.
		 */</comment>
		<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>xmin</name> <operator>==</operator> <name>FrozenTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>visible_to_all</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>cutoff_xid</name> <operator>==</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cutoff_xid</name> <operator>=</operator> <call><name>GetOldestXmin</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PROCARRAY_FLAGS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>visible_to_all</name> <operator>=</operator> <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>cutoff_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>visible_to_all</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* collect dead segnos for dropping */</comment>
		<expr_stmt><expr><name>dead_segs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>dead_segs</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>aoscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_aoseg_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dead_segs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Drop AWAITING_DROP segments.
 * 
 * Callers should guarantee that the segfile is no longer needed by any
 * running transaction. It is not necessary to hold a lock on the segfile
 * row, though.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>AppendOptimizedDropDeadSegment</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aorel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsAoRows</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyCompaction_DropSegmentFile</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ClearFileSegInfo</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>AOCSCompaction_DropSegmentFile</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ClearAOCSFileSegInfo</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>AppendOptimizedDropDeadSegments</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aorel</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>segnos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>segno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * drop segments in batch with concurrent-safety
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>segno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>segno</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>segnos</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AppendOptimizedDropDeadSegment</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	
	<expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Truncates each segment file in the AO relation to its EOF.
 * If we cannot get a lock on the segment file (because e.g. a concurrent insert)
 * the segment file is skipped.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOptimizedTruncateToEOF</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aorel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_aoseg_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>pg_aoseg_dsc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>aoscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>appendOnlyMetaDataSnapshot</name> <init>= <expr><call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>segrelid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The algorithm below for choosing a target segment is not concurrent-safe.
	 * Grab a lock to serialize.
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>aorel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>segrelid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_aoseg_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>segrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_aoseg_dsc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_aoseg_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aoscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_aoseg_rel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>aoscan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>segno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationIsAoRows</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
											  <argument><expr><name>Anum_pg_aoseg_segno</name></expr></argument>,
											  <argument><expr><name>pg_aoseg_dsc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
											  <argument><expr><name>Anum_pg_aocs_segno</name></expr></argument>,
											  <argument><expr><name>pg_aoseg_dsc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Is anyone writing to this segfile? Readers are OK, because they won't
		 * try to read beyond the EOF as stated in the pg_aoseg entry
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_aoseg_tuple_could_be_updated</name><argument_list>(<argument><expr><name>pg_aoseg_rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationIsAoRows</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64</name></type>		<name>segeof</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>segeof</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
											   <argument><expr><name>Anum_pg_aoseg_eof</name></expr></argument>,
											   <argument><expr><name>pg_aoseg_dsc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AppendOnlySegmentFileTruncateToEOF</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>segeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name> <init>= <expr><call><name>fastgetattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
										<argument><expr><name>Anum_pg_aocs_vpinfo</name></expr></argument>,
										<argument><expr><name>pg_aoseg_dsc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AOCSVPInfo</name> <modifier>*</modifier></type><name>vpinfo</name> <init>= <expr><operator>(</operator><name>AOCSVPInfo</name> <operator>*</operator><operator>)</operator> <call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>AOCSSegmentFileTruncateToEOF</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>vpinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>vpinfo</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>vpinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>aoscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_aoseg_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Performs a compaction of an append-only relation.
 *
 * The compaction segment file should be marked as in-use/in-compaction in
 * the appendonlywriter.c code.
 *
 * On exit, *insert_segno will be set to the the segment that was used as the
 * insertion target. The segfiles listed in 'avoid_segnos' will not be used
 * for insertion.
 *
 * The caller is required to hold either an AccessExclusiveLock (vacuum full)
 * or a ShareLock on the relation.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyCompact</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aorel</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>compaction_segno</name></decl></parameter>,
				  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>insert_segno</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>isFull</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>avoid_segnos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyInsertDesc</name></type> <name>insertDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileSegInfo</name> <modifier>*</modifier></type><name>fsinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>appendOnlyMetaDataSnapshot</name> <init>= <expr><call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsAoRows</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch under the write lock to get latest committed eof. */</comment>
	<expr_stmt><expr><name>fsinfo</name> <operator>=</operator> <call><name>GetFileSegInfo</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>, <argument><expr><name>compaction_segno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyCompaction_ShouldCompact</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>,
										   <argument><expr><name><name>fsinfo</name><operator>-&gt;</operator><name>segno</name></name></expr></argument>, <argument><expr><name><name>fsinfo</name><operator>-&gt;</operator><name>total_tupcount</name></name></expr></argument>, <argument><expr><name>isFull</name></expr></argument>,
										   <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>insert_segno</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* get the insertion segment on first call. */</comment>
			<expr_stmt><expr><operator>*</operator><name>insert_segno</name> <operator>=</operator> <call><name>ChooseSegnoForCompactionWrite</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>avoid_segnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>insert_segno</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note: since we don't know how many rows will actually be inserted,
			 * we provide the default number of rows to bump gp_fastsequence by.
			 */</comment>
			<expr_stmt><expr><name>insertDesc</name> <operator>=</operator> <call><name>appendonly_insert_init</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>, <argument><expr><operator>*</operator><name>insert_segno</name></expr></argument>, <argument><expr><name>NUM_FAST_SEQUENCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AppendOnlySegmentFileFullCompaction</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>,
												<argument><expr><name>insertDesc</name></expr></argument>,
												<argument><expr><name>fsinfo</name></expr></argument>,
												<argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>insertDesc</name><operator>-&gt;</operator><name>skipModCountIncrement</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendonly_insert_finish</name><argument_list>(<argument><expr><name>insertDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Could not find a target segment. Give up */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find a free segment file to use for compacting segfile %d of relation %s"</literal></expr></argument>,
							<argument><expr><name>compaction_segno</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>aorel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fsinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
