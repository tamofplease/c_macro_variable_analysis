<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/appendonly/aomd.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * aomd.c
 *	  This code manages append only relations that reside on magnetic disk.
 *	  It serves the same general purpose as smgr/md.c however we introduce
 *    AO specific file access functions mainly because would like to bypass 
 *	  md.c's and bgwriter's fsyncing. AO relations also use a non constant
 *	  block number to file segment mapping unlike heap relations.
 *
 *	  As of now we still let md.c create and unlink AO relations for us. This
 *	  may need to change if inconsistencies arise.
 *
 * Portions Copyright (c) 2008, Greenplum Inc.
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	    src/backend/access/appendonly/aomd.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/aomd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonlytid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonlywriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_appendonly.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystorage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/relpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEGNO_SUFFIX_LENGTH</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mdunlink_ao_base_relfile</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>mdunlink_ao_perFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>copy_append_only_data_perFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>truncate_ao_perFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>int</name></type>
<name>AOSegmentFilePathNameLen</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>basepath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>len</name></decl>;</decl_stmt>
		
	<comment type="block">/* Get base path for this relation file */</comment>
	<expr_stmt><expr><name>basepath</name> <operator>=</operator> <call><name>relpathbackend</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The basepath will be the RelFileNode number.  Optional part is dot "." plus 
	 * 6 digit segment file number.
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>basepath</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>	<comment type="line">// Generous.</comment>
	
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>basepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Formats an Append Only relation file segment file name.
 *
 * The filepathname parameter assume sufficient space.
 */</comment>
<function><type><name>void</name></type>
<name>FormatAOSegmentFileName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>basepath</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>,
						<parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>fileSegNo</name></decl></parameter>,
						<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filepathname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>pseudoSegNo</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segno</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segno</name> <operator>&lt;=</operator> <name>AOTupleId_MaxSegmentFileNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>col</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Row oriented Append-Only.
		 */</comment>
		<expr_stmt><expr><name>pseudoSegNo</name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt>		
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Column oriented Append-only.
		 */</comment>
		<expr_stmt><expr><name>pseudoSegNo</name> <operator>=</operator> <operator>(</operator><name>col</name><operator>*</operator><name>AOTupleId_MultiplierSegmentFileNum</name><operator>)</operator> <operator>+</operator> <name>segno</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	
	<expr_stmt><expr><operator>*</operator><name>fileSegNo</name> <operator>=</operator> <name>pseudoSegNo</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pseudoSegNo</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>filepathname</name></expr></argument>, <argument><expr><literal type="string">"%s.%u"</literal></expr></argument>, <argument><expr><name>basepath</name></expr></argument>, <argument><expr><name>pseudoSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>filepathname</name></expr></argument>, <argument><expr><name>basepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make an Append Only relation file segment file name.
 *
 * The filepathname parameter assume sufficient space.
 */</comment>
<function><type><name>void</name></type>
<name>MakeAOSegmentFileName</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>,
					  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>fileSegNo</name></decl></parameter>,
					  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filepathname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>basepath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>   <name>fileSegNoLocal</name></decl>;</decl_stmt>
	
	<comment type="block">/* Get base path for this relation file */</comment>
	<expr_stmt><expr><name>basepath</name> <operator>=</operator> <call><name>relpathbackend</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FormatAOSegmentFileName</name><argument_list>(<argument><expr><name>basepath</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileSegNoLocal</name></expr></argument>, <argument><expr><name>filepathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><operator>*</operator><name>fileSegNo</name> <operator>=</operator> <name>fileSegNoLocal</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>basepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Open an Append Only relation file segment
 *
 * The fd module's PathNameOpenFile() is used to open the file, so the
 * the File* routines can be used to read, write, close, etc, the file.
 */</comment>
<function><type><name>File</name></type>
<name>OpenAOSegmentFile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filepathname</name></decl></parameter>, <parameter><decl><type><name>int64</name></type>	<name>logicalEof</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fileFlags</name> <init>= <expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>filepathname</name></expr></argument>, <argument><expr><name>fileFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>logicalEof</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open Append-Only segment file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>filepathname</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"logicalEof for open operation: %ld"</literal></expr></argument>, <argument><expr><name>logicalEof</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Close an Append Only relation file segment
 */</comment>
<function><type><name>void</name></type>
<name>CloseAOSegmentFile</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Truncate all bytes from offset to end of file.
 */</comment>
<function><type><name>void</name></type>
<name>TruncateAOSegmentFile</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>segFileNum</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fd</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call the 'fd' module with a 64-bit length since AO segment files
	 * can be multi-gigabyte to the terabytes...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FileTruncate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_TRUNCATE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": failed to truncate data after eof: %m"</literal></expr></argument>,
					    <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xlog_ao_truncate</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>segFileNum</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>file_truncate_hook</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>backend</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>file_truncate_hook</name>)<argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<struct>struct <name>mdunlink_ao_callback_ctx</name>
<block>{
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt> <comment type="block">/* used to register forget request */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segpathSuffixPosition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isRedo</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>truncate_ao_callback_ctx</name>
<block>{
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segpathSuffixPosition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><name>void</name></type>
<name>mdunlink_ao</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNumber</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>relpath</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Unlogged AO tables have INIT_FORK, in addition to MAIN_FORK.  It is
	 * created once, regardless of the number of segment files (or the number
	 * of columns for column-oriented tables).  Sync requests for INIT_FORKs
	 * are not remembered, so they need not be forgotten.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>forkNumber</name> <operator>==</operator> <name>INIT_FORKNUM</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpath</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forkNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/* This storage manager is not concerned with forks other than MAIN_FORK */</comment>
	<if type="elseif">else if <condition>(<expr><name>forkNumber</name> <operator>==</operator> <name>MAIN_FORKNUM</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>pathSize</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segPath</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>pathSize</name> <operator>+</operator> <name>SEGNO_SUFFIX_LENGTH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segPathSuffixPosition</name> <init>= <expr><name>segPath</name> <operator>+</operator> <name>pathSize</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>mdunlink_ao_callback_ctx</name></name></type> <name>unlinkFiles</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>unlinkFiles</name><operator>.</operator><name>isRedo</name></name> <operator>=</operator> <name>isRedo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unlinkFiles</name><operator>.</operator><name>rnode</name></name> <operator>=</operator> <name><name>rnode</name><operator>.</operator><name>node</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>segPath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>unlinkFiles</name><operator>.</operator><name>segPath</name></name> <operator>=</operator> <name>segPath</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unlinkFiles</name><operator>.</operator><name>segpathSuffixPosition</name></name> <operator>=</operator> <name>segPathSuffixPosition</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>mdunlink_ao_base_relfile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unlinkFiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ao_foreach_extent_file</name><argument_list>(<argument><expr><name>mdunlink_ao_perFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unlinkFiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>segPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete or truncate segfile 0.  Note: There is no &lt;relfilenode&gt;.0 file.  The
 * segfile 0 is the same as base relfilenode for row-oriented AO.  For
 * column-oriented AO, the segno 0 for the first column corresponds to base
 * relfilenode.  See also: ao_foreach_extent_file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mdunlink_ao_base_relfile</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileTag</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>mdunlink_ao_callback_ctx</name></name> <modifier>*</modifier></type><name>unlinkFiles</name> <init>=
		<expr><operator>(</operator>struct <name>mdunlink_ao_callback_ctx</name> <operator>*</operator><operator>)</operator><name>ctx</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>baserel</name> <init>= <expr><name><name>unlinkFiles</name><operator>-&gt;</operator><name>segPath</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name><name>unlinkFiles</name><operator>-&gt;</operator><name>segpathSuffixPosition</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>unlinkFiles</name><operator>-&gt;</operator><name>isRedo</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First, forget any pending sync requests for the first segment */</comment>
		<expr_stmt><expr><call><name>INIT_FILETAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>unlinkFiles</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>SYNC_HANDLER_AO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RegisterSyncRequest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>SYNC_FORGET_REQUEST</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ENOENT is expected after the end of the extensions */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>baserel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>


		<comment type="block">/* Register request to unlink first segment later */</comment>
		<expr_stmt><expr><call><name>INIT_FILETAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>unlinkFiles</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>SYNC_HANDLER_AO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RegisterSyncRequest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>SYNC_UNLINK_REQUEST</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* retryOnError */</comment> )</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ftruncate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>save_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not truncate file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>baserel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>mdunlink_ao_perFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FileTag</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>mdunlink_ao_callback_ctx</name></name> <modifier>*</modifier></type><name>unlinkFiles</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segPath</name> <init>= <expr><name><name>unlinkFiles</name><operator>-&gt;</operator><name>segPath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segPathSuffixPosition</name> <init>= <expr><name><name>unlinkFiles</name><operator>-&gt;</operator><name>segpathSuffixPosition</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>segno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>segPathSuffixPosition</name></expr></argument>, <argument><expr><literal type="string">".%u"</literal></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First, forget any pending sync requests for the first segment */</comment>
	<expr_stmt><expr><call><name>INIT_FILETAG</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>unlinkFiles</name><operator>-&gt;</operator><name>rnode</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>,
				 <argument><expr><name>SYNC_HANDLER_AO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RegisterSyncRequest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>SYNC_FORGET_REQUEST</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Next unlink the file */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>segPath</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ENOENT is expected after the end of the extensions */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>segPath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_file</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>srcsegpath</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dstsegpath</name></decl></parameter>,
		  <parameter><decl><type><name>RelFileNode</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segfilenum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_wal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>File</name></type>		<name>srcFile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>File</name></type>		<name>dstFile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>buffer</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>dstflags</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>srcFile</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>srcsegpath</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>srcFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file %s: %m"</literal></expr></argument>, <argument><expr><name>srcsegpath</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dstflags</name> <operator>=</operator> <name>O_WRONLY</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>PG_BINARY</name></expr>;</expr_stmt>
	<comment type="block">/*
	 * .0 relfilenode is expected to exist before calling this
	 * function. Caller calls RelationCreateStorage() which creates the base
	 * file for the relation. Hence use different flag for the same.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>segfilenum</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dstflags</name> <operator>|=</operator> <name>O_CREAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dstFile</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>dstsegpath</name></expr></argument>, <argument><expr><name>dstflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dstFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create destination file %s: %m"</literal></expr></argument>, <argument><expr><name>dstsegpath</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>FileDiskSize</name><argument_list>(<argument><expr><name>srcFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to end of file %s: %m"</literal></expr></argument>, <argument><expr><name>srcsegpath</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while<condition>(<expr><name>left</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>FileRead</name><argument_list>(<argument><expr><name>srcFile</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read %d bytes from file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>len</name></expr></argument>, <argument><expr><name>srcsegpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>FileWrite</name><argument_list>(<argument><expr><name>dstFile</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_WRITE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write %d bytes to file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>len</name></expr></argument>, <argument><expr><name>dstsegpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>use_wal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>xlog_ao_insert</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>segfilenum</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>left</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><call><name>FileSync</name><argument_list>(<argument><expr><name>dstFile</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_IMMEDIATE_SYNC</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>dstsegpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>srcFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name>dstFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>copy_append_only_data_callback_ctx</name> <block>{
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>srcPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dstPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>dst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>useWal</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Like copy_relation_data(), but for AO tables.
 *
 */</comment>
<function><type><name>void</name></type>
<name>copy_append_only_data</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name></type> <name>dst</name></decl></parameter>,
        <parameter><decl><type><name>BackendId</name></type> <name>backendid</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>srcPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dstPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>useWal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>copy_append_only_data_callback_ctx</name></name></type> <name>copyFiles</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * We need to log the copied data in WAL iff WAL archiving/streaming is
	 * enabled AND it's a permanent relation.
	 */</comment>
	<expr_stmt><expr><name>useWal</name> <operator>=</operator> <call><name>XLogIsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>relpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>srcPath</name> <operator>=</operator> <call><name>relpathbackend</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>backendid</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dstPath</name> <operator>=</operator> <call><name>relpathbackend</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>backendid</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>copy_file</name><argument_list>(<argument><expr><name>srcPath</name></expr></argument>, <argument><expr><name>dstPath</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>useWal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>copyFiles</name><operator>.</operator><name>srcPath</name></name> <operator>=</operator> <name>srcPath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyFiles</name><operator>.</operator><name>dstPath</name></name> <operator>=</operator> <name>dstPath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyFiles</name><operator>.</operator><name>dst</name></name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyFiles</name><operator>.</operator><name>useWal</name></name> <operator>=</operator> <name>useWal</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ao_foreach_extent_file</name><argument_list>(<argument><expr><name>copy_append_only_data_perFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copyFiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>file_extend_hook</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>backend</name></name> <operator>=</operator> <name>backendid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>file_extend_hook</name>)<argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>copy_append_only_data_perFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>copy_append_only_data_callback_ctx</name></name> <modifier>*</modifier></type><name>copyFiles</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name><name>srcSegPath</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>dstSegPath</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>srcSegPath</name></expr></argument>, <argument><expr><literal type="string">"%s.%u"</literal></expr></argument>, <argument><expr><name><name>copyFiles</name><operator>-&gt;</operator><name>srcPath</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>srcSegPath</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ENOENT is expected after the end of the extensions */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"access failed for file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>srcSegPath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>dstSegPath</name></expr></argument>, <argument><expr><literal type="string">"%s.%u"</literal></expr></argument>, <argument><expr><name><name>copyFiles</name><operator>-&gt;</operator><name>dstPath</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>copy_file</name><argument_list>(<argument><expr><name>srcSegPath</name></expr></argument>, <argument><expr><name>dstSegPath</name></expr></argument>, <argument><expr><name><name>copyFiles</name><operator>-&gt;</operator><name>dst</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name><name>copyFiles</name><operator>-&gt;</operator><name>useWal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ao_truncate_one_rel
 *
 * This routine deletes all data within the specified ao relation.
 */</comment>
<function><type><name>void</name></type>
<name>ao_truncate_one_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>basepath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segPathSuffixPosition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>truncate_ao_callback_ctx</name></name></type> <name>truncateFiles</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>pathSize</name></decl>;</decl_stmt>

	<comment type="block">/* Get base path for this relation file */</comment>
	<expr_stmt><expr><name>basepath</name> <operator>=</operator> <call><name>relpathbackend</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pathSize</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>basepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>segPath</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>pathSize</name> <operator>+</operator> <name>SEGNO_SUFFIX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>segPathSuffixPosition</name> <operator>=</operator> <name>segPath</name> <operator>+</operator> <name>pathSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>segPath</name></expr></argument>, <argument><expr><name>basepath</name></expr></argument>, <argument><expr><name>pathSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>truncateFiles</name><operator>.</operator><name>segPath</name></name> <operator>=</operator> <name>segPath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>truncateFiles</name><operator>.</operator><name>segpathSuffixPosition</name></name> <operator>=</operator> <name>segPathSuffixPosition</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>truncateFiles</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Truncate the actual file.
	 *
	 * Segfile 0 first, ao_foreach_extent_file() doesn't invoke the
	 * callback for it.
	 */</comment>
	<expr_stmt><expr><call><name>truncate_ao_perFile</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>truncateFiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ao_foreach_extent_file</name><argument_list>(<argument><expr><name>truncate_ao_perFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>truncateFiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>segPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>basepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Truncate a specific segment file of ao relation.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>truncate_ao_perFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>File</name></type>		<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>aorel</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>truncate_ao_callback_ctx</name></name> <modifier>*</modifier></type><name>truncateFiles</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segPath</name> <init>= <expr><name><name>truncateFiles</name><operator>-&gt;</operator><name>segPath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>segPathSuffixPosition</name> <init>= <expr><name><name>truncateFiles</name><operator>-&gt;</operator><name>segpathSuffixPosition</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>aorel</name> <operator>=</operator> <name><name>truncateFiles</name><operator>-&gt;</operator><name>rel</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>segPathSuffixPosition</name></expr></argument>, <argument><expr><literal type="string">".%u"</literal></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>segPathSuffixPosition</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenAOSegmentFile</name><argument_list>(<argument><expr><name>segPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TruncateAOSegmentFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>aorel</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseAOSegmentFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* 
		 * we traverse possible segment files of AO/AOCS tables and call
		 * truncate_ao_perFile to truncate them. It is ok that some files do not exist
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
