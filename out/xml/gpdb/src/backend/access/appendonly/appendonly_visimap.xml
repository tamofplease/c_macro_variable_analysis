<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/appendonly/appendonly_visimap.c"><comment type="block">/*------------------------------------------------------------------------------
 *
 * AppendOnlyVisimap
 *   maintain a visibility bitmap.
 *
 * Copyright (c) 2013-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/access/appendonly/appendonly_visimap.c
 *
 *------------------------------------------------------------------------------
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonly_visimap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonly_visimap_entry.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonly_visimap_store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonlytid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyblockdirectory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Key structure for the visimap deletion hash table.
 */</comment>
<typedef>typedef <type><struct>struct <name>AppendOnlyVisiMapDeleteKey</name>
<block>{
	<comment type="block">/*
	 * Segno of the dirty visimap entry.
	 *
	 * MPP-23546: Changed the type of segno from int to uint64.  With uint
	 * (4-bytes), additional 4-bytes were being used for padding. The padding
	 * bits may differ for two keys causing two otherwise equal objects to be
	 * treated as unequal by hash functions. Keeping type to uint64 does not
	 * change the value of sizeof(AppendOnlyVisiMapDeleteKey) but eliminates
	 * padding.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>segno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First row num of the dirty visimap entry.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>firstRowNum</name></decl>;</decl_stmt>
}</block></struct></type> <name>AppendOnlyVisiMapDeleteKey</name>;</typedef>

<comment type="block">/*
 * Key/Value structure for the visimap deletion hash table.
 */</comment>
<typedef>typedef <type><struct>struct <name>AppendOnlyVisiMapDeleteData</name>
<block>{
	<comment type="block">/*
	 * Key of the visimap entry
	 */</comment>
	<decl_stmt><decl><type><name>AppendOnlyVisiMapDeleteKey</name></type> <name>key</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Location of the latest dirty version of the visimap bitmap in the
	 * BufFile.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> 		<name>workFileno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>workFileOffset</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Tuple id of the visimap entry if the visimap entry existed before.
	 */</comment>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tupleTid</name></decl>;</decl_stmt>
}</block></struct></type> <name>AppendOnlyVisiMapDeleteData</name>;</typedef>



<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendOnlyVisimap_Store</name><parameter_list>(
						<parameter><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendOnlyVisimap_Find</name><parameter_list>(
					   <parameter><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl></parameter>,
					   <parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>tupleId</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Finishes the visimap operations.
 * No other function should be called with the given
 * visibility map after this function has been called.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyVisimap_Finish</name><parameter_list>(
						 <parameter><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl></parameter>,
						 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyVisimapEntry_HasChanged</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyVisimap_Store</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimapStore_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapStore</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyVisimapEntry_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>visiMap</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initializes the visimap data structure.
 *
 * It assumes a zero-allocated visibility map.
 * Should not be called twice.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyVisimap_Init</name><parameter_list>(
					   <parameter><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>visimapRelid</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>visimapIdxid</name></decl></parameter>,
					   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
					   <parameter><decl><type><name>Snapshot</name></type> <name>appendOnlyMetaDataSnapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>visimapRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>visimapIdxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>visiMap</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(
												   <argument><expr><name>CurrentMemoryContext</name></expr></argument>,
												   <argument><expr><literal type="string">"VisiMapContext"</literal></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(
									   <argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimapEntry_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>,
								<argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimapStore_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapStore</name></name></expr></argument>,
								<argument><expr><name>visimapRelid</name></expr></argument>,
								<argument><expr><name>visimapIdxid</name></expr></argument>,
								<argument><expr><name>lockmode</name></expr></argument>,
								<argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>,
								<argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Moves the visibility map entry so that the given
 * AO tuple id is covered by it.
 * If necessary a new map entry is initialized.
 *
 * Assumes that all previous changed information have been
 * stored.
 * Should not be called when the append-only table has no relation
 * Assumes that the visibility has been initialized and not finished.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyVisimap_Find</name><parameter_list>(
					   <parameter><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl></parameter>,
					   <parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_visimap</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-only visi map: Find entry for "</literal>
		   <literal type="string">"(tupleId) = %s"</literal></expr></argument>,
		   <argument><expr><call><name>AOTupleIdToString</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyVisimapStore_Find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapStore</name></name></expr></argument>,
									 <argument><expr><call><name>AOTupleIdGet_segmentFileNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>AppendOnlyVisimapEntry_GetFirstRowNum</name><argument_list>(
																		   <argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There is no entry that covers the given tuple id.
		 */</comment>
		<expr_stmt><expr><call><name>AppendOnlyVisimapEntry_New</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if a tuple is visible according to the visibility map.
 * A positive result is a necessary but not sufficient condition for
 * a tuple to be visible to the user.
 *
 * Assumes that the visibility has been initialized and not finished.
 */</comment>
<function><type><name>bool</name></type>
<name>AppendOnlyVisimap_IsVisible</name><parameter_list>(
							<parameter><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl></parameter>,
							<parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_visimap</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-only visi map: Visibility check: "</literal>
		   <literal type="string">"(tupleId) = %s"</literal></expr></argument>,
		   <argument><expr><call><name>AOTupleIdToString</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyVisimapEntry_CoversTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>,
											<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if necessary persist the current entry before moving. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyVisimapEntry_HasChanged</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AppendOnlyVisimap_Store</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>AppendOnlyVisimap_Find</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* visimap entry is now positioned to cover the aoTupleId */</comment>
	<return>return <expr><call><name>AppendOnlyVisimapEntry_IsVisible</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>,
											<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Stores the current visibility map entry information
 * in the relation either as update or delete.
 *
 * Should not be called if AppendOnlyVisimap_Find has not been
 * called earlier.
 * It may be called when the visibility map entry has not changed. However
 * that is usually wasteful.
 *
 * Assumes that the visibility has been initialized and not finished.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyVisimap_Store</name><parameter_list>(
						<parameter><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AppendOnlyVisimapEntry_IsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimapStore_Store</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapStore</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * Deletes all visibility information for the given segment file.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyVisimap_DeleteSegmentFile</name><parameter_list>(
									<parameter><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_visimap</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Delete visimap for segment file %d"</literal></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimapStore_DeleteSegmentFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapStore</name></name></expr></argument>,
											 <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the number of hidden tuples in the relation.
 */</comment>
<function><type><name>int64</name></type>
<name>AppendOnlyVisimap_GetRelationHiddenTupleCount</name><parameter_list>(
											  <parameter><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>AppendOnlyVisimapStore_GetRelationHiddenTupleCount</name><argument_list>(
															  <argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapStore</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the number of hidden tuples in a given segment file.
 */</comment>
<function><type><name>int64</name></type>
<name>AppendOnlyVisimap_GetSegmentFileHiddenTupleCount</name><parameter_list>(
												 <parameter><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl></parameter>,
												 <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>AppendOnlyVisimapStore_GetSegmentFileHiddenTupleCount</name><argument_list>(
																 <argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapStore</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Starts a new scan for invisible tuple ids.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyVisimapScan_Init</name><parameter_list>(
						   <parameter><decl><type><name>AppendOnlyVisimapScan</name> <modifier>*</modifier></type><name>visiMapScan</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>visimapRelid</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>visimapIdxid</name></decl></parameter>,
						   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
						   <parameter><decl><type><name>Snapshot</name></type> <name>appendonlyMetadataSnapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMapScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>visimapRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>visimapIdxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMapScan</name><operator>-&gt;</operator><name>visimap</name></name></expr></argument>, <argument><expr><name>visimapRelid</name></expr></argument>, <argument><expr><name>visimapIdxid</name></expr></argument>,
						   <argument><expr><name>lockmode</name></expr></argument>,
						   <argument><expr><name>appendonlyMetadataSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>visiMapScan</name><operator>-&gt;</operator><name>indexScan</name></name> <operator>=</operator> <call><name>AppendOnlyVisimapStore_BeginScan</name><argument_list>(
															  <argument><expr><operator>&amp;</operator><name><name>visiMapScan</name><operator>-&gt;</operator><name>visimap</name><operator>.</operator><name>visimapStore</name></name></expr></argument>,
															  <argument><expr><literal type="number">0</literal></expr></argument>,
															  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>visiMapScan</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the next tuple id in the visimap scan that is invisible.
 *
 * If there was a previous successful call to this function during this can,
 * the tupleId parameter should contain the value of the last call.
 * The contents of tupleId is undefined if false is returned.
 */</comment>
<function><type><name>bool</name></type>
<name>AppendOnlyVisimapScan_GetNextInvisible</name><parameter_list>(
									   <parameter><decl><type><name>AppendOnlyVisimapScan</name> <modifier>*</modifier></type><name>visiMapScan</name></decl></parameter>,
									   <parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>tupleId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMapScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>visiMapScan</name><operator>-&gt;</operator><name>isFinished</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>visiMapScan</name><operator>-&gt;</operator><name>isFinished</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyVisimapEntry_IsValid</name><argument_list>(
											<argument><expr><operator>&amp;</operator><name><name>visiMapScan</name><operator>-&gt;</operator><name>visimap</name><operator>.</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyVisimapStore_GetNext</name><argument_list>(
												<argument><expr><operator>&amp;</operator><name><name>visiMapScan</name><operator>-&gt;</operator><name>visimap</name><operator>.</operator><name>visimapStore</name></name></expr></argument>,
												<argument><expr><name><name>visiMapScan</name><operator>-&gt;</operator><name>indexScan</name></name></expr></argument>,
												<argument><expr><name>ForwardScanDirection</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name><name>visiMapScan</name><operator>-&gt;</operator><name>visimap</name><operator>.</operator><name>visimapEntry</name></name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>visiMapScan</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>AOTupleIdSetInvalid</name><argument_list>(<argument><expr><name>tupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyVisimapEntry_GetNextInvisible</name><argument_list>(
													 <argument><expr><operator>&amp;</operator><name><name>visiMapScan</name><operator>-&gt;</operator><name>visimap</name><operator>.</operator><name>visimapEntry</name></name></expr></argument>,
													 <argument><expr><name>tupleId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * no more invisible tuples in this visimap entry. Try next one
			 */</comment>
			<expr_stmt><expr><call><name>AppendOnlyVisimapEntry_Reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMapScan</name><operator>-&gt;</operator><name>visimap</name><operator>.</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Found a tuple. The tuple is is already in the out parameter. */</comment>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

	</block_content>}</block></while>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Finishes a visimap scan.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyVisimapScan_Finish</name><parameter_list>(<parameter><decl><type><name>AppendOnlyVisimapScan</name> <modifier>*</modifier></type><name>visiMapScan</name></decl></parameter>,
							 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AppendOnlyVisimapStore_EndScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMapScan</name><operator>-&gt;</operator><name>visimap</name><operator>.</operator><name>visimapStore</name></name></expr></argument>,
								   <argument><expr><name><name>visiMapScan</name><operator>-&gt;</operator><name>indexScan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyVisimap_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMapScan</name><operator>-&gt;</operator><name>visimap</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Hash function for the visimap deletion hash table.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>hash_delete_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keysize</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyVisiMapDeleteKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>,
								   <argument><expr><name>keysize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Hash function for comparing two keys of type
 * AppendOnlyVisiMapDeleteKey.  Equality of keys is of interest and
 * not ordering between them (greater/less).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>hash_compare_keys</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keysize</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyVisiMapDeleteKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>AppendOnlyVisiMapDeleteKey</name> <modifier>*</modifier></type><name>k1</name> <init>= <expr><operator>(</operator><name>AppendOnlyVisiMapDeleteKey</name> <operator>*</operator><operator>)</operator> <name>key1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyVisiMapDeleteKey</name> <modifier>*</modifier></type><name>k2</name> <init>= <expr><operator>(</operator><name>AppendOnlyVisiMapDeleteKey</name> <operator>*</operator><operator>)</operator> <name>key2</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>k1</name><operator>-&gt;</operator><name>segno</name></name> <operator>==</operator> <name><name>k2</name><operator>-&gt;</operator><name>segno</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>k1</name><operator>-&gt;</operator><name>firstRowNum</name></name> <operator>==</operator> <name><name>k2</name><operator>-&gt;</operator><name>firstRowNum</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Inits the visimap delete helper structure.
 *
 * This prepares the hash table and opens the temporary file.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyVisimapDelete_Init</name><parameter_list>(
							 <parameter><decl><type><name>AppendOnlyVisimapDelete</name> <modifier>*</modifier></type><name>visiMapDelete</name></decl></parameter>,
							 <parameter><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMapDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>visiMap</name></name> <operator>=</operator> <name>visiMap</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyVisiMapDeleteKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyVisiMapDeleteData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>hash_delete_key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>hash_compare_keys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name><name>visiMap</name><operator>-&gt;</operator><name>memoryContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>dirtyEntryCache</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"VisimapEntryCache"</literal></expr></argument>,
												 <argument><expr><literal type="number">4</literal></expr></argument>, <comment type="block">/* start small and extend */</comment>
												 <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
												 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name> <operator>=</operator> <call><name>BufFileCreateTemp</name><argument_list>(<argument><expr><literal type="string">"visimap_delete"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* interXact */</comment>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Rebuild the visimap entry based on the data contents and
 * a few other pieces of information.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyVisimapDelete_RebuildEntry</name><parameter_list>(<parameter><decl><type><name>AppendOnlyVisimapEntry</name> <modifier>*</modifier></type><name>visimapEntry</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>dataSize</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>visimapEntry</name><operator>-&gt;</operator><name>segmentFileNum</name></name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>visimapEntry</name><operator>-&gt;</operator><name>firstRowNum</name></name> <operator>=</operator> <name>firstRowNum</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>dataSize</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>visimapEntry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>-</operator>
		<call><name>offsetof</name><argument_list>(<argument><expr><name>AppendOnlyVisimapData</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>visimapEntry</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyVisiMapEnty_ReadData</name><argument_list>(<argument><expr><name>visimapEntry</name></expr></argument>, <argument><expr><name>dataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We only stash away a visimap entry when it is dirty. Thus, we mark the
	 * visimap entry again as dirty during unstash
	 */</comment>
	<expr_stmt><expr><name><name>visimapEntry</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visimapEntry</name><operator>-&gt;</operator><name>tupleTid</name></name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unstashes a dirty visimap from the spill file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyVisimapDelete_Unstash</name><parameter_list>(
								<parameter><decl><type><name>AppendOnlyVisimapDelete</name> <modifier>*</modifier></type><name>visiMapDelete</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>, <parameter><decl><type><name>AppendOnlyVisiMapDeleteData</name> <modifier>*</modifier></type><name>deleteData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>len</name></decl>,
				<decl><type ref="prev"/><name>dataLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyVisiMapDeleteKey</name></type> <name>key</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMapDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>visiMap</name> <operator>=</operator> <name><name>visiMapDelete</name><operator>-&gt;</operator><name>visiMap</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_visimap</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-only visi map delete: Unstash dirty visimap entry %d/"</literal> <name>INT64_FORMAT</name>
		   <literal type="string">", (fileno %d, offset "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
		   <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>firstRowNum</name></expr></argument>, <argument><expr><name><name>deleteData</name><operator>-&gt;</operator><name>workFileno</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator><name><name>deleteData</name><operator>-&gt;</operator><name>workFileOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>, <argument><expr><name><name>deleteData</name><operator>-&gt;</operator><name>workFileno</name></name></expr></argument>,
					<argument><expr><name><name>deleteData</name><operator>-&gt;</operator><name>workFileOffset</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to seek visimap delete buf file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"location (fileno %d, offset "</literal> <name>INT64_FORMAT</name> <literal type="string">") visimap entry: %d/"</literal> <name>INT64_FORMAT</name></expr></argument>,
						   <argument><expr><name><name>deleteData</name><operator>-&gt;</operator><name>workFileno</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator><name><name>deleteData</name><operator>-&gt;</operator><name>workFileOffset</name></name></expr></argument>,
						   <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>firstRowNum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to read visimap delete buf file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"location (fileno %d, offset "</literal> <name>INT64_FORMAT</name> <literal type="string">") visimap entry: %d/"</literal> <name>INT64_FORMAT</name></expr></argument>,
						   <argument><expr><name><name>deleteData</name><operator>-&gt;</operator><name>workFileno</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator><name><name>deleteData</name><operator>-&gt;</operator><name>workFileOffset</name></name></expr></argument>,
						   <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>firstRowNum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>segno</name></name> <operator>==</operator> <name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>firstRowNum</name></name> <operator>==</operator> <name>firstRowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>, <argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to read visimap delete buf file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>dataLen</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now read the remaining part of the entry */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>,
					  <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>data</name></name><operator>)</operator> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>dataLen</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>dataLen</name> <operator>-</operator> <literal type="number">4</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to read visimap delete buf file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"location (fileno %d, offset "</literal> <name>INT64_FORMAT</name> <literal type="string">") visimap entry: %d/"</literal>
							<name>INT64_FORMAT</name> <literal type="string">", len "</literal> <name>INT64_FORMAT</name></expr></argument>,
							<argument><expr><name><name>deleteData</name><operator>-&gt;</operator><name>workFileno</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator><name><name>deleteData</name><operator>-&gt;</operator><name>workFileOffset</name></name></expr></argument>,
							<argument><expr><name>segno</name></expr></argument>, <argument><expr><name>firstRowNum</name></expr></argument>, <argument><expr><name>dataLen</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimapDelete_RebuildEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>,
										 <argument><expr><name>segno</name></expr></argument>,
										 <argument><expr><name>firstRowNum</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>deleteData</name><operator>-&gt;</operator><name>tupleTid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Moves the visibility map entry so that the given
 * AO tuple id is covered by it.
 * If necessary a new map entry is initialized.
 * Uses the visimap dirty cache.
 *
 * Assumes that all previous changed information have been
 * stored.
 * Should not be called when the append-only table has no relation
 * Assumes that the visibility has been initialized and not finished.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyVisimapDelete_Find</name><parameter_list>(
							 <parameter><decl><type><name>AppendOnlyVisimapDelete</name> <modifier>*</modifier></type><name>visiMapDelete</name></decl></parameter>,
							 <parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>firstRowNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyVisiMapDeleteData</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyVisiMapDeleteKey</name></type> <name>key</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMapDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>visiMap</name> <operator>=</operator> <name><name>visiMapDelete</name><operator>-&gt;</operator><name>visiMap</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>firstRowNum</name> <operator>=</operator> <call><name>AppendOnlyVisimapEntry_GetFirstRowNum</name><argument_list>(
														<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>segno</name></name> <operator>=</operator> <call><name>AOTupleIdGet_segmentFileNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>firstRowNum</name></name> <operator>=</operator> <name>firstRowNum</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_visimap</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-only visi map delete: Search dirty visimap entry "</literal>
		   <name>INT64_FORMAT</name> <literal type="string">"/"</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>segno</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>dirtyEntryCache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
					<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_visimap</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Append-only visi map delete: Found dirty visimap entry "</literal>
			   <name>INT64_FORMAT</name> <literal type="string">"/"</literal> <name>INT64_FORMAT</name></expr></argument>,
			   <argument><expr><name><name>r</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>segno</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>firstRowNum</name></name> <operator>==</operator> <name><name>key</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>segno</name></name> <operator>==</operator> <name><name>key</name><operator>.</operator><name>segno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AppendOnlyVisimapDelete_Unstash</name><argument_list>(<argument><expr><name>visiMapDelete</name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>segno</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyVisimapStore_Find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapStore</name></name></expr></argument>,
										 <argument><expr><call><name>AOTupleIdGet_segmentFileNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>AppendOnlyVisimapEntry_GetFirstRowNum</name><argument_list>(
																			   <argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * There is no entry that covers the given tuple id.
			 */</comment>
			<expr_stmt><expr><call><name>AppendOnlyVisimapEntry_New</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This function stashes away a dirty visimap entry.
 * It stores the compression bitmap in the spill file and
 * sets the meta information in the hash table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyVisimapDelete_Stash</name><parameter_list>(
							  <parameter><decl><type><name>AppendOnlyVisimapDelete</name> <modifier>*</modifier></type><name>visiMapDelete</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyVisiMapDeleteData</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyVisiMapDeleteKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>fileno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMapDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>visiMap</name> <operator>=</operator> <name><name>visiMapDelete</name><operator>-&gt;</operator><name>visiMap</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>segno</name></name> <operator>=</operator> <name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>segmentFileNum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>firstRowNum</name></name> <operator>=</operator> <name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>firstRowNum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>dirtyEntryCache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
					<argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>workFileOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>workFileno</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>tupleTid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>firstRowNum</name></name> <operator>==</operator> <name><name>key</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>segno</name></name> <operator>==</operator> <name><name>key</name><operator>.</operator><name>segno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyVisimapEntry_WriteData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the BufFile was seeked to an internal position for reading a
	 * previously stashed visimap entry before we were called, we must seek
	 * till the end of it before writing new visimap entries.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to seek to end of visimap buf file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>BufFileTell</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_visimap</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-only visi map delete: Stash dirty visimap entry %d/"</literal> <name>INT64_FORMAT</name></expr></argument>,
		   <argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>segmentFileNum</name></name></expr></argument>, <argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to write visimap delete spill key information: "</literal>
			 <literal type="string">"segno "</literal> <name>INT64_FORMAT</name> <literal type="string">", first row "</literal> <name>INT64_FORMAT</name> <literal type="string">", offset "</literal>
			 <name>INT64_FORMAT</name> <literal type="string">", length %lu"</literal></expr></argument>,
			 <argument><expr><name><name>key</name><operator>.</operator><name>segno</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator><name>offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>, <argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>size</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to write visimap delete spill key information: "</literal>
			 <literal type="string">"segno "</literal> <name>INT64_FORMAT</name> <literal type="string">", first row "</literal> <name>INT64_FORMAT</name> <literal type="string">", offset "</literal>
			 <name>INT64_FORMAT</name> <literal type="string">", length %d"</literal></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>segno</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>int64</name><operator>)</operator><operator>(</operator><name>offset</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>tupleTid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>tupleTid</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>workFileOffset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>workFileno</name></name> <operator>=</operator> <name>fileno</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>dirty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Hides a given tuple id.
 * If the tuple is not in the current visimap range, the current
 * visimap entry is stashed away and the correct one is loaded or
 * read from the spill file.
 *
 * Then, the bit of the tuple is set.
 *
 * Should only be called when in-order delete of tuples can
 * be guranteed. This means that the tuples are deleted in increasing order.
 * A special case there this function can be used is when only
 * a single tuple is deleted.
 * In all other cases, AppendOnlyVisimapDelete_Hide needs to be used.
 */</comment>
<function><type><name>TM_Result</name></type>
<name>AppendOnlyVisimapDelete_Hide</name><parameter_list>(<parameter><decl><type><name>AppendOnlyVisimapDelete</name> <modifier>*</modifier></type><name>visiMapDelete</name></decl></parameter>, <parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMapDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_visimap</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-only visi map delete: Hide tuple "</literal>
		   <literal type="string">"(tupleId) = %s"</literal></expr></argument>,
		   <argument><expr><call><name>AOTupleIdToString</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>visiMap</name> <operator>=</operator> <name><name>visiMapDelete</name><operator>-&gt;</operator><name>visiMap</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyVisimapEntry_CoversTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>,
											<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if necessary persist the current entry before moving. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyVisimapEntry_HasChanged</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AppendOnlyVisimapDelete_Stash</name><argument_list>(<argument><expr><name>visiMapDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>AppendOnlyVisimapDelete_Find</name><argument_list>(<argument><expr><name>visiMapDelete</name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>AppendOnlyVisimapEntry_HideTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyVisimapDelete_WriteBackStashedEntries</name><parameter_list>(<parameter><decl><type><name>AppendOnlyVisimapDelete</name> <modifier>*</modifier></type><name>visiMapDelete</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyVisiMapDeleteData</name> <modifier>*</modifier></type><name>deleteData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>len</name></decl>,
				<decl><type ref="prev"/><name>dataLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>currentOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>currentFileno</name></decl>;</decl_stmt>
	
	<decl_stmt><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyVisiMapDeleteKey</name></type> <name>key</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>visiMap</name> <operator>=</operator> <name><name>visiMapDelete</name><operator>-&gt;</operator><name>visiMap</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>dirtyEntryCache</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to seek to visimap delete spill beginning"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get next entry */</comment>
	<expr_stmt><expr><call><name>BufFileTell</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>currentFileno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>currentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>len</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_visimap</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Append-only visi map delete: Got next dirty visimap: "</literal>
			   <name>INT64_FORMAT</name> <literal type="string">"/"</literal> <name>INT64_FORMAT</name> <literal type="string">", offset "</literal> <name>INT64_FORMAT</name></expr></argument>,
			   <argument><expr><name><name>key</name><operator>.</operator><name>segno</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator><name>currentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* VARSIZE is only using the first four byte */</comment>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>, <argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to read visimap delete spill data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>dataLen</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dataLen</name> <operator>&lt;=</operator> <name>APPENDONLY_VISIMAP_DATA_BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now read the remaining part of the entry */</comment>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>,
						  <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>data</name></name><operator>)</operator> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>dataLen</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <operator>(</operator><name>dataLen</name> <operator>-</operator> <literal type="number">4</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to read visimap delete spill data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now we search the hash entry and check if we here have the most
		 * recent version of the visimap entry
		 */</comment>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>deleteData</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>dirtyEntryCache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
								 <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Found a stashed visimap entry without corresponding meta data: "</literal>
				 <literal type="string">"offset "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator><name>currentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>deleteData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>deleteData</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>firstRowNum</name></name> <operator>==</operator> <name><name>key</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>deleteData</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>segno</name></name> <operator>==</operator> <name><name>key</name><operator>.</operator><name>segno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>currentFileno</name> <operator>!=</operator> <name><name>deleteData</name><operator>-&gt;</operator><name>workFileno</name></name> <operator>||</operator>
			<name>currentOffset</name> <operator>!=</operator> <name><name>deleteData</name><operator>-&gt;</operator><name>workFileOffset</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_visimap</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				   <argument><expr><literal type="string">"Append-only visi map delete: Found out-dated stashed dirty visimap: "</literal>
				   <literal type="string">"current (fileno %d, offset "</literal> <name>INT64_FORMAT</name> <literal type="string">") expected (fileno %d, offset "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
				   <argument><expr><name>currentFileno</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator><name>currentOffset</name></expr></argument>,
				   <argument><expr><name><name>deleteData</name><operator>-&gt;</operator><name>workFileno</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator><name><name>deleteData</name><operator>-&gt;</operator><name>workFileOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Until this point on the data field of the visimap entry has
			 * valid information. After this the visimap entry is fully
			 * rebuild.
			 */</comment>
			<expr_stmt><expr><call><name>AppendOnlyVisimapDelete_RebuildEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>,
												 <argument><expr><name><name>deleteData</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>segno</name></name></expr></argument>,
												 <argument><expr><name><name>deleteData</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name><name>deleteData</name><operator>-&gt;</operator><name>tupleTid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AppendOnlyVisimap_Store</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>visiMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>BufFileTell</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>currentFileno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>currentOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to read visimap delete spill data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Finishes the delete operation.
 * All the dirty visimap entries are read from the spill file and
 * stored in the visimap heap table.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyVisimapDelete_Finish</name><parameter_list>(
							   <parameter><decl><type><name>AppendOnlyVisimapDelete</name> <modifier>*</modifier></type><name>visiMapDelete</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyVisiMapDeleteData</name> <modifier>*</modifier></type><name>deleteData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendOnlyVisiMapDeleteKey</name></type> <name>key</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>visiMap</name> <operator>=</operator> <name><name>visiMapDelete</name><operator>-&gt;</operator><name>visiMap</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_visimap</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Write-back all dirty visimap entries"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Write back the current change because it is be definition the newest.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AppendOnlyVisimapEntry_HasChanged</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyVisimap_Store</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>visiMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make the hash map entry invalid so that we do not overwrite the
		 * entry later
		 */</comment>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>segno</name></name> <operator>=</operator> <name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>segmentFileNum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>firstRowNum</name></name> <operator>=</operator> <name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name><operator>.</operator><name>firstRowNum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>deleteData</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>dirtyEntryCache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
								 <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>deleteData</name><operator>-&gt;</operator><name>workFileOffset</name></name> <operator>=</operator> <name>INT64_MAX</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>deleteData</name><operator>-&gt;</operator><name>workFileno</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>deleteData</name><operator>-&gt;</operator><name>tupleTid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimapDelete_WriteBackStashedEntries</name><argument_list>(<argument><expr><name>visiMapDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>dirtyEntryCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>visiMapDelete</name><operator>-&gt;</operator><name>workfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AppendOnlyVisimap_Init_forUniqueCheck
 *
 * Initializes the visimap to determine if tuples were deleted as a part of
 * uniqueness checks.
 *
 * Note: we defer setting up the appendOnlyMetaDataSnapshot for the visibility
 * map to the index_fetch_tuple_exists() table AM call. This is because
 * snapshots used for unique index lookups are special and don't follow the
 * usual allocation or registration mechanism. They may be stack-allocated and a
 * new snapshot object may be passed to every unique index check (this happens
 * when SNAPSHOT_DIRTY is passed). While technically, we could set up the
 * metadata snapshot in advance for SNAPSHOT_SELF, the alternative is fine.
 */</comment>
<function><type><name>void</name></type> <name>AppendOnlyVisimap_Init_forUniqueCheck</name><parameter_list>(
	<parameter><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl></parameter>,
	<parameter><decl><type><name>Relation</name></type> <name>aoRel</name></decl></parameter>,
	<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>visimaprelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>visimapidxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>==</operator> <name>SNAPSHOT_DIRTY</name> <operator>||</operator>
			   <name><name>snapshot</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>==</operator> <name>SNAPSHOT_SELF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>aoRel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
							  <argument><expr><name>InvalidSnapshot</name></expr></argument>, <comment type="block">/* catalog snapshot is enough */</comment>
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visimaprelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>visimapidxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>visimaprelid</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>visimapidxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Could not find block directory for relation: %u"</literal></expr></argument>, <argument><expr><name><name>aoRel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_visimap</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only visimap init for unique checks"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"(aoRel = %u, visimaprel = %u, visimapidxrel = %u)"</literal></expr></argument>,
							<argument><expr><name><name>aoRel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>visimaprelid</name></expr></argument>, <argument><expr><name>visimapidxid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimap_Init</name><argument_list>(<argument><expr><name>visiMap</name></expr></argument>,
						   <argument><expr><name>visimaprelid</name></expr></argument>,
						   <argument><expr><name>visimapidxid</name></expr></argument>,
						   <argument><expr><name>AccessShareLock</name></expr></argument>,
						   <argument><expr><name>InvalidSnapshot</name></expr></argument> <comment type="block">/* appendOnlyMetaDataSnapshot */</comment>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>AppendOnlyVisimap_Finish_forUniquenessChecks</name><parameter_list>(
	<parameter><decl><type><name>AppendOnlyVisimap</name> <modifier>*</modifier></type><name>visiMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendOnlyVisimapStore</name> <modifier>*</modifier></type><name>visimapStore</name> <init>= <expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapStore</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * The snapshot was either reset to NULL in between calls or already cleaned
	 * up (if this was part of an update command)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>visimapStore</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>==</operator> <name>InvalidSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_visimap</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only visimap finish for unique checks"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"(visimaprel = %u, visimapidxrel = %u)"</literal></expr></argument>,
							<argument><expr><name><name>visimapStore</name><operator>-&gt;</operator><name>visimapRelation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
							<argument><expr><name><name>visimapStore</name><operator>-&gt;</operator><name>visimapRelation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendOnlyVisimapStore_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapStore</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOnlyVisimapEntry_Finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>visiMap</name><operator>-&gt;</operator><name>visimapEntry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>visiMap</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>visiMap</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
