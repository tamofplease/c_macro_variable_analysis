<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/appendonly/appendonlyblockdirectory.c"><comment type="block">/*-----------------------------------------------------------------------------
 *
 * appendonlyblockdirectory.c
 *    maintain the block directory to blocks in append-only relation files.
 *
 * Portions Copyright (c) 2009, Greenplum Inc.
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/access/appendonly/appendonlyblockdirectory.c
 *
 *-----------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyblockdirectory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/aoblkdir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_appendonly.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyam.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>int</name></type>			<name>gp_blockdirectory_entry_min_range</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_blockdirectory_minipage_size</name> <init>= <expr><name>NUM_MINIPAGE_ENTRIES</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_last_minipage</name><parameter_list>(
				   <parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
				   <parameter><decl><type><name>int64</name></type> <name>lastSequence</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_scankeys</name><parameter_list>(
			  <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>scanKeys</name></decl></parameter>,
			  <parameter><decl><type><name>StrategyNumber</name> <modifier>*</modifier></type><name>strategyNumbers</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>find_minipage_entry</name><parameter_list>(
					<parameter><decl><type><name>Minipage</name> <modifier>*</modifier></type><name>minipage</name></decl></parameter>,
					<parameter><decl><type><name>uint32</name></type> <name>numEntries</name></decl></parameter>,
					<parameter><decl><type><name>int64</name></type> <name>rowNum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>extract_minipage</name><parameter_list>(
				 <parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
				 <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
				 <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_minipage</name><parameter_list>(<parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>,
			   <parameter><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipageInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>insert_new_entry</name><parameter_list>(<parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>,
				 <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>,
				 <parameter><decl><type><name>int64</name></type> <name>fileOffset</name></decl></parameter>,
				 <parameter><decl><type><name>int64</name></type> <name>rowCount</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>addColAction</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clear_minipage</name><parameter_list>(<parameter><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipagePerColumnGroup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>blkdir_entry_exists</name><parameter_list>(<parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
								<parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>
<name>AppendOnlyBlockDirectoryEntry_GetBeginRange</name><parameter_list>(
											<parameter><decl><type><name>AppendOnlyBlockDirectoryEntry</name> <modifier>*</modifier></type><name>directoryEntry</name></decl></parameter>,
											<parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>fileOffset</name></decl></parameter>,
											<parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>firstRowNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>fileOffset</name> <operator>=</operator> <name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>fileOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>firstRowNum</name> <operator>=</operator> <name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>firstRowNum</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>AppendOnlyBlockDirectoryEntry_GetEndRange</name><parameter_list>(
										  <parameter><decl><type><name>AppendOnlyBlockDirectoryEntry</name> <modifier>*</modifier></type><name>directoryEntry</name></decl></parameter>,
										  <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>afterFileOffset</name></decl></parameter>,
										  <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>lastRowNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>afterFileOffset</name> <operator>=</operator> <name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>afterFileOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>lastRowNum</name> <operator>=</operator> <name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>lastRowNum</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>AppendOnlyBlockDirectoryEntry_RangeHasRow</name><parameter_list>(
										  <parameter><decl><type><name>AppendOnlyBlockDirectoryEntry</name> <modifier>*</modifier></type><name>directoryEntry</name></decl></parameter>,
										  <parameter><decl><type><name>int64</name></type> <name>checkRowNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>checkRowNum</name> <operator>&gt;=</operator> <name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>firstRowNum</name></name> <operator>&amp;&amp;</operator>
			<name>checkRowNum</name> <operator>&lt;=</operator> <name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>lastRowNum</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * init_internal
 *
 * Initialize the block directory structure.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_internal</name><parameter_list>(<parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numScanKeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>heapTupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>idxTupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>groupNo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator>
		<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
							  <argument><expr><literal type="string">"BlockDirectoryContext"</literal></expr></argument>,
							  <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
							  <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
							  <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>heapTupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>values</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>heapTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>nulls</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>heapTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>numScanKeys</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>numScanKeys</name> <operator>=</operator> <name><name>blockDirectory</name><operator>-&gt;</operator><name>numScanKeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>scanKeys</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numScanKeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>strategyNumbers</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numScanKeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>StrategyNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>strategyNumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>strategyNumbers</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>strategyNumbers</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>BTLessEqualStrategyNumber</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>idxTupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_scankeys</name><argument_list>(<argument><expr><name>idxTupleDesc</name></expr></argument>, <argument><expr><name>numScanKeys</name></expr></argument>,
				  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>scanKeys</name></name></expr></argument>,
				  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>strategyNumbers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the last minipage */</comment>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>minipages</name></name> <operator>=</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MinipagePerColumnGroup</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>groupNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>groupNo</name> <operator>&lt;</operator> <name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name></expr>;</condition> <incr><expr><name>groupNo</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>proj</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>proj</name><index>[<expr><name>groupNo</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Ignore columns that are not projected. */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipageInfo</name> <init>=
		<expr><operator>&amp;</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>minipages</name><index>[<expr><name>groupNo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name></name> <operator>=</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><call><name>minipage_size</name><argument_list>(<argument><expr><name>NUM_MINIPAGE_ENTRIES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>minipageInfo</name><operator>-&gt;</operator><name>tupleTid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AppendOnlyBlockDirectory_Init_forSearch
 *
 * Initialize the block directory to handle the lookup.
 *
 * If the block directory relation for this appendonly relation
 * does not exist before calling this function, set blkdirRel
 * and blkdirIdx to NULL, and return.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyBlockDirectory_Init_forSearch</name><parameter_list>(
										<parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
										<parameter><decl><type><name>Snapshot</name></type> <name>appendOnlyMetaDataSnapshot</name></decl></parameter>,
										<parameter><decl><type><name>FileSegInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>segmentFileInfo</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>totalSegfiles</name></decl></parameter>,
										<parameter><decl><type><name>Relation</name></type> <name>aoRel</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>numColumnGroups</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>isAOCol</name></decl></parameter>,
										<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>proj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>blkdirrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>blkdiridxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>aoRel</name></name> <operator>=</operator> <name>aoRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>aoRel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkdirrelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkdiridxid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory init for search: "</literal>
					  <literal type="string">"(totalSegfiles, numColumnGroups, isAOCol)="</literal>
					  <literal type="string">"(%d, %d, %d)"</literal></expr></argument>,
					  <argument><expr><name>totalSegfiles</name></expr></argument>, <argument><expr><name>numColumnGroups</name></expr></argument>, <argument><expr><name>isAOCol</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>segmentFileInfo</name></name> <operator>=</operator> <name>segmentFileInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>totalSegfiles</name></name> <operator>=</operator> <name>totalSegfiles</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>aoRel</name></name> <operator>=</operator> <name>aoRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name> <operator>=</operator> <name>appendOnlyMetaDataSnapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name> <operator>=</operator> <name>numColumnGroups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name> <operator>=</operator> <name>isAOCol</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>proj</name></name> <operator>=</operator> <name>proj</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name> <operator>=</operator>
		<call><name>heap_open</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name> <operator>=</operator>
		<call><name>index_open</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_internal</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AppendOnlyBlockDirectory_Init_forUniqueChecks
 *
 * Initializes the block directory to handle lookups for uniqueness checks.
 *
 * Note: These lookups will be purely restricted to the block directory relation
 * itself and will not involve the physical AO relation.
 *
 * Note: we defer setting up the appendOnlyMetaDataSnapshot for the block
 * directory to the index_fetch_tuple_exists() table AM call. This is because
 * snapshots used for unique index lookups are special and don't follow the
 * usual allocation or registration mechanism. They may be stack-allocated and a
 * new snapshot object may be passed to every unique index check (this happens
 * when SNAPSHOT_DIRTY is passed). While technically, we could set up the
 * metadata snapshot in advance for SNAPSHOT_SELF, the alternative is fine.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyBlockDirectory_Init_forUniqueChecks</name><parameter_list>(
											  <parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
											  <parameter><decl><type><name>Relation</name></type> <name>aoRel</name></decl></parameter>,
											  <parameter><decl><type><name>int</name></type> <name>numColumnGroups</name></decl></parameter>,
											  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>blkdirrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>blkdiridxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>aoRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>==</operator> <name>SNAPSHOT_DIRTY</name> <operator>||</operator>
			<name><name>snapshot</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>==</operator> <name>SNAPSHOT_SELF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>aoRel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
							  <argument><expr><name>InvalidSnapshot</name></expr></argument>, <comment type="block">/* catalog snapshot is enough */</comment>
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkdirrelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkdiridxid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Could not find block directory for relation: %u"</literal></expr></argument>, <argument><expr><name><name>aoRel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory init for unique checks"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			   <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"(aoRel = %u, blkdirrel = %u, blkdiridxrel = %u, numColumnGroups = %d)"</literal></expr></argument>,
						 <argument><expr><name><name>aoRel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>blkdirrelid</name></expr></argument>, <argument><expr><name>blkdiridxid</name></expr></argument>, <argument><expr><name>numColumnGroups</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>aoRel</name></name> <operator>=</operator> <name>aoRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name> <operator>=</operator> <call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>aoRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Segfile setup is not necessary as physical AO tuples will not be accessed */</comment>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>segmentFileInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>totalSegfiles</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Metadata snapshot assignment is deferred to lookup-time */</comment>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name> <operator>=</operator> <name>InvalidSnapshot</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name> <operator>=</operator> <name>numColumnGroups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>proj</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_internal</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AppendOnlyBlockDirectory_Init_forInsert
 *
 * Initialize the block directory to handle the inserts.
 *
 * If the block directory relation for this appendonly relation
 * does not exist before calling this function, set blkdirRel
 * and blkdirIdx to NULL, and return.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyBlockDirectory_Init_forInsert</name><parameter_list>(
										<parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
										<parameter><decl><type><name>Snapshot</name></type> <name>appendOnlyMetaDataSnapshot</name></decl></parameter>,
										<parameter><decl><type><name>FileSegInfo</name> <modifier>*</modifier></type><name>segmentFileInfo</name></decl></parameter>,
										<parameter><decl><type><name>int64</name></type> <name>lastSequence</name></decl></parameter>,
										<parameter><decl><type><name>Relation</name></type> <name>aoRel</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>numColumnGroups</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>isAOCol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>groupNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>blkdirrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>blkdiridxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>aoRel</name></name> <operator>=</operator> <name>aoRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name> <operator>=</operator> <name>appendOnlyMetaDataSnapshot</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>aoRel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkdirrelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkdiridxid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>segmentFileInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>totalSegfiles</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileInfo</name></name> <operator>=</operator> <name>segmentFileInfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name> <operator>=</operator> <name>numColumnGroups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name> <operator>=</operator> <name>isAOCol</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>proj</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name> <operator>=</operator>
		<call><name>heap_open</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name> <operator>=</operator>
		<call><name>index_open</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>indinfo</name></name> <operator>=</operator> <call><name>CatalogOpenIndexes</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_internal</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory init for insert: "</literal>
					  <literal type="string">"(segno, numColumnGroups, isAOCol, lastSequence)="</literal>
					  <literal type="string">"(%d, %d, %d, "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
					  <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>numColumnGroups</name></expr></argument>, <argument><expr><name>isAOCol</name></expr></argument>, <argument><expr><name>lastSequence</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Load the last minipages from the block directory relation.
	 */</comment>
	<for>for <control>(<init><expr><name>groupNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>groupNo</name> <operator>&lt;</operator> <name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name></expr>;</condition> <incr><expr><name>groupNo</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>load_last_minipage</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>, <argument><expr><name>lastSequence</name></expr></argument>, <argument><expr><name>groupNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Open block directory relation, initialize scan keys and minipages
 * for ALTER TABLE ADD COLUMN operation.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyBlockDirectory_Init_addCol</name><parameter_list>(
									 <parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
									 <parameter><decl><type><name>Snapshot</name></type> <name>appendOnlyMetaDataSnapshot</name></decl></parameter>,
									 <parameter><decl><type><name>FileSegInfo</name> <modifier>*</modifier></type><name>segmentFileInfo</name></decl></parameter>,
									 <parameter><decl><type><name>Relation</name></type> <name>aoRel</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>numColumnGroups</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name></type> <name>isAOCol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>blkdirrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>blkdiridxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>aoRel</name></name> <operator>=</operator> <name>aoRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name> <operator>=</operator> <name>appendOnlyMetaDataSnapshot</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>aoRel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkdirrelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkdiridxid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>segmentFileInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>totalSegfiles</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileInfo</name></name> <operator>=</operator> <name>segmentFileInfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name> <operator>=</operator> <name>numColumnGroups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name> <operator>=</operator> <name>isAOCol</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>proj</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * TODO: refactor the *_addCol* interface so that opening of
	 * blockdirectory relation and index, init_internal and corresponding
	 * cleanup in *_End_addCol() is called only once during the add-column
	 * operation.  Currently, this is being called for every appendonly
	 * segment.
	 */</comment>
	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name> <operator>=</operator>
		<call><name>heap_open</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name> <operator>=</operator>
		<call><name>index_open</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>indinfo</name></name> <operator>=</operator> <call><name>CatalogOpenIndexes</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_internal</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>set_directoryentry_range</name><parameter_list>(
						 <parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>entry_no</name></decl></parameter>,
						 <parameter><decl><type><name>AppendOnlyBlockDirectoryEntry</name> <modifier>*</modifier></type><name>directoryEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipageInfo</name> <init>=
	<expr><operator>&amp;</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>minipages</name><index>[<expr><name>columnGroupNo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileSegInfo</name> <modifier>*</modifier></type><name>fsInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier></type><name>aocsFsInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinipageEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinipageEntry</name> <modifier>*</modifier></type><name>next_entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>entry_no</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>uint32</name><operator>)</operator> <name>entry_no</name><operator>)</operator> <operator>&lt;</operator> <name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fsInfo</name> <operator>=</operator> <name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileInfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fsInfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aocsFsInfo</name> <operator>=</operator> <operator>(</operator><name>AOCSFileSegInfo</name> <operator>*</operator><operator>)</operator> <name>fsInfo</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name><operator>-&gt;</operator><name>entry</name><index>[<expr><name>entry_no</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>uint32</name><operator>)</operator> <name>entry_no</name><operator>)</operator> <operator>&lt;</operator> <name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>next_entry</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name><operator>-&gt;</operator><name>entry</name><index>[<expr><name>entry_no</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>fileOffset</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>fileOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>firstRowNum</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>firstRowNum</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>next_entry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>afterFileOffset</name></name> <operator>=</operator> <name><name>next_entry</name><operator>-&gt;</operator><name>fileOffset</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>afterFileOffset</name></name> <operator>=</operator> <name><name>fsInfo</name><operator>-&gt;</operator><name>eof</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>

		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>afterFileOffset</name></name> <operator>=</operator>
				<name><name>aocsFsInfo</name><operator>-&gt;</operator><name>vpinfo</name><operator>.</operator><name>entry</name><index>[<expr><name>columnGroupNo</name></expr>]</index></name><operator>.</operator><name>eof</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>lastRowNum</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>firstRowNum</name></name> <operator>+</operator> <name><name>entry</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>next_entry</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>gp_blockdirectory_entry_min_range</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>lastRowNum</name></name> <operator>=</operator> <operator>(</operator><operator>~</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">63</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>	<comment type="block">/* set to the maximal
																	 * value */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When crashes during inserts, or cancellation during inserts, the block
	 * directory may contain out-of-date entries. We check for the end of file
	 * here. If the requested directory entry is after the end of file, return
	 * false.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name> <operator>&amp;&amp;</operator>
		 <name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>fileOffset</name></name> <operator>&gt;</operator> <name><name>fsInfo</name><operator>-&gt;</operator><name>eof</name></name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name> <operator>&amp;&amp;</operator>
		 <name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>fileOffset</name></name> <operator>&gt;</operator>
		 <name><name>aocsFsInfo</name><operator>-&gt;</operator><name>vpinfo</name><operator>.</operator><name>entry</name><index>[<expr><name>columnGroupNo</name></expr>]</index></name><operator>.</operator><name>eof</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name> <operator>&amp;&amp;</operator>
		 <name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>afterFileOffset</name></name> <operator>&gt;</operator> <name><name>fsInfo</name><operator>-&gt;</operator><name>eof</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>afterFileOffset</name></name> <operator>=</operator> <name><name>fsInfo</name><operator>-&gt;</operator><name>eof</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name> <operator>&amp;&amp;</operator>
		<name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>afterFileOffset</name></name> <operator>&gt;</operator>
		<name><name>aocsFsInfo</name><operator>-&gt;</operator><name>vpinfo</name><operator>.</operator><name>entry</name><index>[<expr><name>columnGroupNo</name></expr>]</index></name><operator>.</operator><name>eof</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>afterFileOffset</name></name> <operator>=</operator>
			<name><name>aocsFsInfo</name><operator>-&gt;</operator><name>vpinfo</name><operator>.</operator><name>entry</name><index>[<expr><name>columnGroupNo</name></expr>]</index></name><operator>.</operator><name>eof</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory find entry: "</literal>
					  <literal type="string">"(columnGroupNo, firstRowNum, fileOffset, lastRowNum, afterFileOffset) = "</literal>
					  <literal type="string">"(%d, "</literal> <name>INT64_FORMAT</name> <literal type="string">", "</literal> <name>INT64_FORMAT</name> <literal type="string">", "</literal> <name>INT64_FORMAT</name> <literal type="string">", "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
					  <argument><expr><name>columnGroupNo</name></expr></argument>, <argument><expr><name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>,
					  <argument><expr><name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>fileOffset</name></name></expr></argument>, <argument><expr><name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>lastRowNum</name></name></expr></argument>,
					  <argument><expr><name><name>directoryEntry</name><operator>-&gt;</operator><name>range</name><operator>.</operator><name>afterFileOffset</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AppendOnlyBlockDirectory_GetEntry
 *
 * Find a directory entry for the given AOTupleId in the block directory.
 * If such an entry is found, return true. Otherwise, return false.
 *
 * The range for directoryEntry is assigned accordingly in this function.
 *
 * The block directory for the appendonly table should exist before calling
 * this function.
 */</comment>
<function><type><name>bool</name></type>
<name>AppendOnlyBlockDirectory_GetEntry</name><parameter_list>(
								  <parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
								  <parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>,
								  <parameter><decl><type><name>AppendOnlyBlockDirectoryEntry</name> <modifier>*</modifier></type><name>directoryEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>segmentFileNum</name> <init>= <expr><call><name>AOTupleIdGet_segmentFileNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>rowNum</name> <init>= <expr><call><name>AOTupleIdGet_rowNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>blkdirRel</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>blkdirIdx</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numScanKeys</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>numScanKeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>scanKeys</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>scanKeys</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>heapTupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FileSegInfo</name> <modifier>*</modifier></type><name>fsInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>idxScanDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipageInfo</name> <init>=
	<expr><operator>&amp;</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>minipages</name><index>[<expr><name>columnGroupNo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>entry_no</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tmpGroupNo</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>blkdirRel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>blkdirIdx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>aoRel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block directory for append-only relation '%s' does not exist"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>aoRel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory get entry: "</literal>
					  <literal type="string">"(columnGroupNo, segmentFileNum, rowNum) = "</literal>
					  <literal type="string">"(%d, %d, "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
					  <argument><expr><name>columnGroupNo</name></expr></argument>, <argument><expr><name>segmentFileNum</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the segment file number is the same as
	 * blockDirectory-&gt;currentSegmentFileNum, the in-memory minipage may
	 * contain such an entry. We search the in-memory minipage first. If such
	 * an entry can not be found, we search for the appropriate minipage by
	 * using the block directory btree index.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>segmentFileNum</name> <operator>==</operator> <name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name> <operator>&amp;&amp;</operator>
		<name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileInfo</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>MinipageEntry</name> <modifier>*</modifier></type><name>firstentry</name> <init>=
		<expr><operator>&amp;</operator><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name><operator>-&gt;</operator><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>rowNum</name> <operator>&gt;=</operator> <name><name>firstentry</name><operator>-&gt;</operator><name>firstRowNum</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Check if the existing minipage contains the requested rowNum.
			 * If so, just get it.
			 */</comment>
			<expr_stmt><expr><name>entry_no</name> <operator>=</operator> <call><name>find_minipage_entry</name><argument_list>(<argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name></name></expr></argument>,
										   <argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name></expr></argument>,
										   <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>entry_no</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>set_directoryentry_range</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>,
												<argument><expr><name>columnGroupNo</name></expr></argument>,
												<argument><expr><name>entry_no</name></expr></argument>,
												<argument><expr><name>directoryEntry</name></expr></argument>)</argument_list></call></expr>;</return>

			</block_content>}</block></if>

			<comment type="block">/*
			 * The given rowNum may point to a tuple that does not exist in
			 * the AO table any more, either because of cancellation of an
			 * insert, or due to crashes during an insert. If this is the
			 * case, rowNum is smaller than the highest entry in the in-memory
			 * minipage entry.
			 */</comment>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>MinipageEntry</name> <modifier>*</modifier></type><name>entry</name> <init>=
				<expr><operator>&amp;</operator><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name><operator>-&gt;</operator><name>entry</name><index>[<expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>rowNum</name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>firstRowNum</name></name> <operator>+</operator> <name><name>entry</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>blockDirectory</name><operator>-&gt;</operator><name>totalSegfiles</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>fsInfo</name> <operator>=</operator> <name><name>blockDirectory</name><operator>-&gt;</operator><name>segmentFileInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name> <operator>&amp;&amp;</operator> <name>segmentFileNum</name> <operator>==</operator> <name><name>fsInfo</name><operator>-&gt;</operator><name>segno</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name> <operator>&amp;&amp;</operator> <name>segmentFileNum</name> <operator>==</operator>
				 <operator>(</operator><operator>(</operator><name>AOCSFileSegInfo</name> <operator>*</operator><operator>)</operator> <name>fsInfo</name><operator>)</operator><operator>-&gt;</operator><name>segno</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fsInfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Search the btree index to find the minipage that contains the rowNum.
	 * We find the minipages for all column groups, since currently we will
	 * need to access all columns at the same time.
	 */</comment>
	<expr_stmt><expr><name>heapTupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>blkdirRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numScanKeys</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>tmpGroupNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tmpGroupNo</name> <operator>&lt;</operator> <name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name></expr>;</condition> <incr><expr><name>tmpGroupNo</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>proj</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>proj</name><index>[<expr><name>tmpGroupNo</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Ignore columns that are not projected. */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/*
		 * Set up the scan keys values. The keys have already been set up in
		 * init_internal() with the following strategy:
		 * (=segmentFileNum, =columnGroupNo, &lt;=rowNum)
		 * See init_internal().
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scanKeys</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scanKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>segmentFileNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scanKeys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>tmpGroupNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scanKeys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>rowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>idxScanDesc</name> <operator>=</operator> <call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>blkdirRel</name></expr></argument>, <argument><expr><name>blkdirIdx</name></expr></argument>,
												 <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>,
												 <argument><expr><name>numScanKeys</name></expr></argument>, <argument><expr><name>scanKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>idxScanDesc</name></expr></argument>, <argument><expr><name>BackwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * MPP-17061: we need to update currentSegmentFileNum &amp;
			 * currentSegmentFileInfo at the same time when we load the
			 * minipage for the block directory entry we found, otherwise we
			 * would risk having inconsistency between
			 * currentSegmentFileNum/currentSegmentFileInfo and minipage
			 * contents, which would cause wrong block header offset being
			 * returned in following block directory entry look up.
			 */</comment>
			<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name> <operator>=</operator> <name>segmentFileNum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileInfo</name></name> <operator>=</operator> <name>fsInfo</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>extract_minipage</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>,
							 <argument><expr><name>tuple</name></expr></argument>,
							 <argument><expr><name>heapTupleDesc</name></expr></argument>,
							 <argument><expr><name>tmpGroupNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* MPP-17061: index look up failed, row is invisible */</comment>
			<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>idxScanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>idxScanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<block>{<block_content>
		<decl_stmt><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipageInfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>minipageInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>minipages</name><index>[<expr><name>columnGroupNo</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Perform a binary search over the minipage to find the entry about
		 * the AO block.
		 */</comment>
		<expr_stmt><expr><name>entry_no</name> <operator>=</operator> <call><name>find_minipage_entry</name><argument_list>(<argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name></name></expr></argument>,
									   <argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name></expr></argument>,
									   <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If there are no entries, return false. */</comment>
		<if_stmt><if>if <condition>(<expr><name>entry_no</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>entry_no</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Since the last few blocks may not be logged in the block
			 * directory, we always use the last entry.
			 *
			 * FIXME: If we didn't find a suitable entry, why even use the last
			 * entry? Currently, as it stands we would most likely return
			 * true from this function. This will lead to us having to do a
			 * fetch of the tuple from the physical file in the layer above (see
			 * scanToFetchTuple()), where we would ultimately find the tuple
			 * missing. Would it be correct to set the directory entry here to
			 * be the last one (for caching purposes) and return false, in order
			 * to avoid this physical file read?
			 */</comment>
			<expr_stmt><expr><name>entry_no</name> <operator>=</operator> <name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><call><name>set_directoryentry_range</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>,
										<argument><expr><name>columnGroupNo</name></expr></argument>,
										<argument><expr><name>entry_no</name></expr></argument>,
										<argument><expr><name>directoryEntry</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AppendOnlyBlockDirectory_CoversTuple
 *
 * Check if there exists a visible block directory entry that represents a range
 * in which this tid resides.
 *
 * Currently used by index fetches to perform unique constraint validation. A
 * sysscan of the block directory relation is performed to determine the result.
 * (see blkdir_entry_exists())
 *
 * Performing a sysscan also has the distinct advantage of setting the xmin/xmax
 * of the snapshot used to scan, which is a requirement when SNAPSHOT_DIRTY is
 * used. See _bt_check_unique() and SNAPSHOT_DIRTY for details.
 *
 * Note about AOCO tables:
 * For AOCO tables, there are multiple block directory entries for each tid.
 * However, it is currently sufficient to check the block directory entry for
 * just one of these columns. We do so for the 1st non-dropped column. Note that
 * if we write a placeholder row for the 1st non-dropped column i, there is a
 * guarantee that if there is a conflict on the placeholder row, the covering
 * block directory entry will be based on the same column i (as columnar DDL
 * changes need exclusive locks and placeholder rows can't be seen after tx end)
 * (We could just have checked the covers condition for column 0, as block
 * directory entries are inserted even for dropped columns. But, this may change
 * one day, and we want our code to be future-proof)
 */</comment>
<function><type><name>bool</name></type>
<name>AppendOnlyBlockDirectory_CoversTuple</name><parameter_list>(
									 <parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
									 <parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>aoRel</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>aoRel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>firstNonDroppedColumn</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>aoRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationIsAoRows</name><argument_list>(<argument><expr><name>aoRel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>blkdir_entry_exists</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>, <argument><expr><name>aoTupleId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>aoRel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>aoRel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attisdropped</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>firstNonDroppedColumn</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>firstNonDroppedColumn</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>blkdir_entry_exists</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>,
								   <argument><expr><name>aoTupleId</name></expr></argument>,
								   <argument><expr><name>firstNonDroppedColumn</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Does a visible block directory entry exist for a given aotid and column no?
 * Currently used to satisfy unique constraint checks.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>blkdir_entry_exists</name><parameter_list>(<parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
					<parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTupleId</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>segmentFileNum</name> <init>= <expr><call><name>AOTupleIdGet_segmentFileNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>rowNum</name> <init>= <expr><call><name>AOTupleIdGet_rowNum</name><argument_list>(<argument><expr><name>aoTupleId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>blkdirRel</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>blkdirIdx</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>scanKeys</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>scanKeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>idxScanDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>      <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>blkdirTupleDesc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>blkdirRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory covers tuple check: "</literal>
					  <literal type="string">"(columnGroupNo, segmentFileNum, rowNum) = "</literal>
					  <literal type="string">"(%d, %d, "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
				  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>segmentFileNum</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blkdirTupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>blkdirRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up the scan keys values. The keys have already been set up in
	 * init_internal() with the following strategy:
	 * (=segmentFileNum, =columnGroupNo, &lt;=rowNum)
	 * See init_internal().
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scanKeys</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>numScanKeys</name></name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>segmentFileNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanKeys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>columnGroupNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanKeys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>rowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>idxScanDesc</name> <operator>=</operator> <call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>blkdirRel</name></expr></argument>, <argument><expr><name>blkdirIdx</name></expr></argument>,
											 <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>,
											 <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>numScanKeys</name></name></expr></argument>,
											 <argument><expr><name>scanKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 *
	 * Loop until:
	 *
	 * (1) No rows are returned from the sysscan, as there is no visible row
	 * satisfying the criteria. This is what happens when there is no uniqueness
	 * conflict, when we call this in the context of a uniqueness check.
	 *
	 * (2) We find a row such that: rowNum  [firstRowNum, firstRowNum + rowCount)
	 *   (a) The row is a regular block directory row covering the rowNum.
	 *   (b) The row is a placeholder block directory row, inserted by
	 *       AppendOnlyBlockDirectory_InsertPlaceholder(), which will always
	 *       cover the rowNum by virtue of it's rowCount = AOTupleId_MaxRowNum.
	 */</comment>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>idxScanDesc</name></expr></argument>, <argument><expr><name>BackwardScanDirection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Once we have found a matching row, we must also ensure that we check
		 * for a block directory entry, in this row's minipage, that has a range
		 * that covers the rowNum.
		 *
		 * This is necessary for aborted transactions where the index entry
		 * might still be live. In such a case, since our search criteria lacks
		 * a lastRowNum, we will match rows where:
		 * firstRowNum &lt; lastRowNum &lt; rowNum
		 * Such rows will obviously not cover the rowNum, thus making inspection
		 * of the row's minipage a necessity.
		 */</comment>
		<decl_stmt><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipageInfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>entry_no</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockNumber</name> <init>= <expr><call><name>ItemPointerGetBlockNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offsetNumber</name> <init>= <expr><call><name>ItemPointerGetOffsetNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"For segno = %d, rownum = %ld, tid returned: (%u,%u) "</literal>
			   <literal type="string">"tuple (xmin, xmax) = (%lu, %lu), snaptype = %d"</literal></expr></argument>,
			   <argument><expr><name>segmentFileNum</name></expr></argument>, <argument><expr><name>rowNum</name></expr></argument>, <argument><expr><name>blockNumber</name></expr></argument>, <argument><expr><name>offsetNumber</name></expr></argument>,
			   <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name><operator>-&gt;</operator><name>snapshot_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set this so that we don't blow up in the assert in extract_minipage */</comment>
		<expr_stmt><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name> <operator>=</operator> <name>segmentFileNum</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>extract_minipage</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>,
						 <argument><expr><name>tuple</name></expr></argument>,
						 <argument><expr><name>blkdirTupleDesc</name></expr></argument>,
						 <argument><expr><name>columnGroupNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>minipageInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>minipages</name><index>[<expr><name>columnGroupNo</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>entry_no</name> <operator>=</operator> <call><name>find_minipage_entry</name><argument_list>(<argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name></name></expr></argument>,
									   <argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name></expr></argument>,
									   <argument><expr><name>rowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>entry_no</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>idxScanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AppendOnlyBlockDirectory_InsertEntry
 *
 * Insert an entry to the block directory. This entry is appended to the
 * in-memory minipage. If the minipage is full, it is written to the block
 * directory relation on disk. After that, the new entry is added to the
 * new in-memory minipage.
 *
 * To reduce the size of a block directory, this function ignores new entries
 * when the range between the offset value of the latest existing entry and
 * the offset of the new entry is smaller than gp_blockdirectory_entry_min_range
 * (if it is set). Otherwise, the latest existing entry is updated with new
 * rowCount value, and the given new entry is appended to the in-memory minipage.
 *
 * If the block directory for the appendonly relation does not exist,
 * this function simply returns.
 *
 * If rowCount is 0, simple return false.
 */</comment>
<function><type><name>bool</name></type>
<name>AppendOnlyBlockDirectory_InsertEntry</name><parameter_list>(
									 <parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>,
									 <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>,
									 <parameter><decl><type><name>int64</name></type> <name>fileOffset</name></decl></parameter>,
									 <parameter><decl><type><name>int64</name></type> <name>rowCount</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name></type> <name>addColAction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>insert_new_entry</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>, <argument><expr><name>columnGroupNo</name></expr></argument>, <argument><expr><name>firstRowNum</name></expr></argument>,
							<argument><expr><name>fileOffset</name></expr></argument>, <argument><expr><name>rowCount</name></expr></argument>, <argument><expr><name>addColAction</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper method used to insert a new minipage entry in the block
 * directory relation.  Refer to AppendOnlyBlockDirectory_InsertEntry()
 * for more details.
 *
 * 1. Checks if the current minipage is full. If yes, it writes the current
 * minipage to the block directory relation and empty the in-memory area. This
 * could mean a new block directory tuple is inserted OR an old tuple is updated.
 *
 * 2. "Inserts" the new entry in the current in-mem minipage -&gt; just sets the
 * in-memory area with the supplied function args.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>insert_new_entry</name><parameter_list>(
				 <parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>,
				 <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>,
				 <parameter><decl><type><name>int64</name></type> <name>fileOffset</name></decl></parameter>,
				 <parameter><decl><type><name>int64</name></type> <name>rowCount</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>addColAction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinipageEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipageInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>minipageIndex</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rowCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>addColAction</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * columnGroupNo is attribute number of the new column for
		 * addColAction. We need to map it to the right index in the minipage
		 * array.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>numExistingCols</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>aoRel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator>
		<name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>numExistingCols</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>numExistingCols</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>columnGroupNo</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>minipageIndex</name> <operator>=</operator> <name>columnGroupNo</name> <operator>-</operator> <name>numExistingCols</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>minipageIndex</name> <operator>=</operator> <name>columnGroupNo</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>minipageInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>minipages</name><index>[<expr><name>minipageIndex</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>&lt;=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>NUM_MINIPAGE_ENTRIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before we insert the new entry into the current minipage, we should
	 * check if the current minipage is full. If so, we write out the current
	 * minipage to the block directory relation and clear out the last minipage
	 * in-mem, making the current in-mem minipage empty and ready to hold the
	 * new entry (and beyond).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsMinipageFull</name><argument_list>(<argument><expr><name>minipageInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_minipage</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>, <argument><expr><name>columnGroupNo</name></expr></argument>, <argument><expr><name>minipageInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>clear_minipage</name><argument_list>(<argument><expr><name>minipageInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"insert_new_entry_curr_minipage_full"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now insert the new entry */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>&lt;</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>gp_blockdirectory_minipage_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name><operator>-&gt;</operator><name>entry</name><index>[<expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>firstRowNum</name></name> <operator>=</operator> <name>firstRowNum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>fileOffset</name></name> <operator>=</operator> <name>fileOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>=</operator> <name>rowCount</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory insert entry: "</literal>
					  <literal type="string">"(firstRowNum, columnGroupNo, fileOffset, rowCount) = ("</literal> <name>INT64_FORMAT</name>
					  <literal type="string">", %d, "</literal> <name>INT64_FORMAT</name> <literal type="string">", "</literal> <name>INT64_FORMAT</name> <literal type="string">") at index %d"</literal></expr></argument>,
					  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>firstRowNum</name></name></expr></argument>, <argument><expr><name>columnGroupNo</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>fileOffset</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>rowCount</name></name></expr></argument>,
					  <argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AppendOnlyBlockDirectory_DeleteSegmentFile
 *
 * Deletes all block directory entries for given segment file of an
 * append-only relation.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyBlockDirectory_DeleteSegmentFile</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>aoRel</name></decl></parameter>,
										   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
										   <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>,
										   <parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>blkdirrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>blkdiridxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name><name>aoRel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkdirrelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkdiridxid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type>	<name>blkdirRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>blkdirIdx</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scanKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>indexScan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanKey</name></expr></argument>,
				<argument><expr><literal type="number">1</literal></expr></argument>,				<comment type="block">/* segno */</comment>
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexScan</name> <operator>=</operator> <call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>blkdirRel</name></expr></argument>,
										   <argument><expr><name>blkdirIdx</name></expr></argument>,
										   <argument><expr><name>snapshot</name></expr></argument>,
										   <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* nkeys */</comment>,
										   <argument><expr><operator>&amp;</operator><name>scanKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>indexScan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>blkdirRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>indexScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>blkdirIdx</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>blkdirRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * init_scankeys
 *
 * Initialize the scan keys.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_scankeys</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>scanKeys</name></decl></parameter>,
			  <parameter><decl><type><name>StrategyNumber</name> <modifier>*</modifier></type><name>strategyNumbers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyNo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nkeys</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>keyNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyNo</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>keyNo</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>atttypid</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>keyNo</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKey</name></type>		<name>scanKey</name> <init>= <expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>scanKeys</name><operator>)</operator> <operator>+</operator>
										 <name>keyNo</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RegProcedure</name></type> <name>opfuncid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategyNumber</name> <init>= <expr><name><name>strategyNumbers</name><index>[<expr><name>keyNo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>strategyNumber</name> <operator>&lt;=</operator> <name>BTMaxStrategyNumber</name> <operator>&amp;&amp;</operator>
			   <name>strategyNumber</name> <operator>!=</operator> <name>InvalidStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>strategyNumber</name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_opr</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eq_opr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opfuncid</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>eq_opr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><name>scanKey</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* sk_flag */</comment>
								   <argument><expr><name>keyNo</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,	<comment type="block">/* attribute number to scan */</comment>
								   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,	<comment type="block">/* strategy */</comment>
								   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* strategy subtype */</comment>
								   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* collation */</comment>
								   <argument><expr><name>opfuncid</name></expr></argument>,	<comment type="block">/* reg proc to use */</comment>
								   <argument><expr><literal type="number">0</literal></expr></argument>	<comment type="block">/* constant */</comment>
				)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>gtOid</name></decl>,
						<decl><type ref="prev"/><name>leOid</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gtOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>leOid</name> <operator>=</operator> <call><name>get_negator</name><argument_list>(<argument><expr><name>gtOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opfuncid</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>leOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><name>scanKey</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* sk_flag */</comment>
								   <argument><expr><name>keyNo</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,	<comment type="block">/* attribute number to scan */</comment>
								   <argument><expr><name>strategyNumber</name></expr></argument>,	<comment type="block">/* strategy */</comment>
								   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* strategy subtype */</comment>
								   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* collation */</comment>
								   <argument><expr><name>opfuncid</name></expr></argument>,	<comment type="block">/* reg proc to use */</comment>
								   <argument><expr><literal type="number">0</literal></expr></argument>	<comment type="block">/* constant */</comment>
				)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * extract_minipage
 *
 * Extract the minipage info from the given tuple. The tupleTid
 * is also set here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>extract_minipage</name><parameter_list>(<parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
				 <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
				 <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>values</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>nulls</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipageInfo</name> <init>= <expr><operator>&amp;</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>minipages</name><index>[<expr><name>columnGroupNo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name> <operator>==</operator>
		   <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Anum_pg_aoblkdir_segno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy out the minipage
	 */</comment>
	<expr_stmt><expr><call><name>copy_out_minipage</name><argument_list>(<argument><expr><name>minipageInfo</name></expr></argument>,
					  <argument><expr><name><name>values</name><index>[<expr><name>Anum_pg_aoblkdir_minipage</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
					  <argument><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_aoblkdir_minipage</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>minipageInfo</name><operator>-&gt;</operator><name>tupleTid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * load_last_minipage
 *
 * Search through the block directory btree to find the last row that
 * contains the last minipage.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_last_minipage</name><parameter_list>(<parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
				   <parameter><decl><type><name>int64</name></type> <name>lastSequence</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>blkdirRel</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>blkdirIdx</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>heapTupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>idxScanDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numScanKeys</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>numScanKeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>scanKeys</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>scanKeys</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>StrategyNumber</name> <modifier>*</modifier></type><name>strategyNumbers</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>strategyNumbers</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_ASSERT_CHECKING */</comment>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>aoRel</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>heapTupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>blkdirRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numScanKeys</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileInfo</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Setup the scan keys for the scan. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scanKeys</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>strategyNumbers</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lastSequence</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lastSequence</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>scanKeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanKeys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>columnGroupNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scanKeys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>sk_argument</name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>lastSequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Search the btree to find the entry in the block directory that contains
	 * the last minipage.
	 */</comment>
	<expr_stmt><expr><name>idxScanDesc</name> <operator>=</operator> <call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>blkdirRel</name></expr></argument>, <argument><expr><name>blkdirIdx</name></expr></argument>,
											 <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name></expr></argument>,
											 <argument><expr><name>numScanKeys</name></expr></argument>, <argument><expr><name>scanKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>idxScanDesc</name></expr></argument>, <argument><expr><name>BackwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>extract_minipage</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>,
						 <argument><expr><name>tuple</name></expr></argument>,
						 <argument><expr><name>heapTupleDesc</name></expr></argument>,
						 <argument><expr><name>columnGroupNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>idxScanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory load last minipage: "</literal>
					  <literal type="string">"(columnGroupNo, lastSequence, nEntries) = (%d, "</literal> <name>INT64_FORMAT</name> <literal type="string">", %u)"</literal></expr></argument>,
					  <argument><expr><name>columnGroupNo</name></expr></argument>, <argument><expr><name>lastSequence</name></expr></argument>,
					  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>minipages</name><index>[<expr><name>columnGroupNo</name></expr>]</index></name><operator>.</operator><name>numMinipageEntries</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * find_minipage_entry
 *
 * Find the minipage entry that covers the given rowNum.
 * If such an entry does not exists, -1 is returned. Otherwise
 * the index to such an entry in the minipage array is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_minipage_entry</name><parameter_list>(<parameter><decl><type><name>Minipage</name> <modifier>*</modifier></type><name>minipage</name></decl></parameter>,
					<parameter><decl><type><name>uint32</name></type> <name>numEntries</name></decl></parameter>,
					<parameter><decl><type><name>int64</name></type> <name>rowNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>start_no</name></decl>,
				<decl><type ref="prev"/><name>end_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>entry_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinipageEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>start_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_no</name> <operator>=</operator> <name>numEntries</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>start_no</name> <operator>&lt;=</operator> <name>end_no</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>entry_no</name> <operator>=</operator> <name>start_no</name> <operator>+</operator> <operator>(</operator><name>end_no</name> <operator>-</operator> <name>start_no</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>entry_no</name> <operator>&gt;=</operator> <name>start_no</name> <operator>&amp;&amp;</operator> <name>entry_no</name> <operator>&lt;=</operator> <name>end_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>minipage</name><operator>-&gt;</operator><name>entry</name><index>[<expr><name>entry_no</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>firstRowNum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>firstRowNum</name></name> <operator>&lt;=</operator> <name>rowNum</name> <operator>&amp;&amp;</operator>
			<name><name>entry</name><operator>-&gt;</operator><name>firstRowNum</name></name> <operator>+</operator> <name><name>entry</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>&gt;</operator> <name>rowNum</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>firstRowNum</name></name> <operator>&gt;</operator> <name>rowNum</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>end_no</name> <operator>=</operator> <name>entry_no</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>start_no</name> <operator>=</operator> <name>entry_no</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>start_no</name> <operator>&lt;=</operator> <name>end_no</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>entry_no</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * write_minipage
 *
 * Write the in-memory minipage to the block directory relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_minipage</name><parameter_list>(<parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>, <parameter><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipageInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>values</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>nulls</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>blkdirRel</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogIndexState</name></type> <name>indinfo</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>indinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>heapTupleDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>blkdirRel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blkdirRel</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aoblkdir_segno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_aoblkdir_segno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aoblkdir_columngroupno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>columnGroupNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_aoblkdir_columngroupno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aoblkdir_firstrownum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name><operator>-&gt;</operator><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>firstRowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_aoblkdir_firstrownum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name></name></expr></argument>,
				<argument><expr><call><name>minipage_size</name><argument_list>(<argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name><operator>-&gt;</operator><name>nEntry</name></name> <operator>=</operator> <name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_aoblkdir_minipage</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_aoblkdir_minipage</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heaptuple_form_to</name><argument_list>(<argument><expr><name>heapTupleDesc</name></expr></argument>,
							  <argument><expr><name>values</name></expr></argument>,
							  <argument><expr><name>nulls</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Write out the minipage to the block directory relation. If this
	 * minipage is already in the relation, we update the row. Otherwise, a
	 * new row is inserted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>minipageInfo</name><operator>-&gt;</operator><name>tupleTid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory update a minipage: "</literal>
						  <literal type="string">"(segno, columnGroupNo, nEntries, firstRowNum) = "</literal>
						  <literal type="string">"(%d, %d, %u, "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
						  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name></expr></argument>,
						  <argument><expr><name>columnGroupNo</name></expr></argument>, <argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name></expr></argument>,
						  <argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name><operator>-&gt;</operator><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>firstRowNum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdateWithInfo</name><argument_list>(<argument><expr><name>blkdirRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>minipageInfo</name><operator>-&gt;</operator><name>tupleTid</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><name>indinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory insert a minipage: "</literal>
						  <literal type="string">"(segno, columnGroupNo, nEntries, firstRowNum) = "</literal>
						  <literal type="string">"(%d, %d, %u, "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
						  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name></expr></argument>,
						  <argument><expr><name>columnGroupNo</name></expr></argument>, <argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name></expr></argument>,
						  <argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>minipage</name><operator>-&gt;</operator><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>firstRowNum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleInsertWithInfo</name><argument_list>(<argument><expr><name>blkdirRel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>indinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* memorize updated/inserted tuple header info */</comment>
	<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>minipageInfo</name><operator>-&gt;</operator><name>tupleTid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_minipage</name><parameter_list>(<parameter><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipagePerColumnGroup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>minipagePerColumnGroup</name><operator>-&gt;</operator><name>minipage</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><name><name>minipagePerColumnGroup</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MinipageEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>minipagePerColumnGroup</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>minipagePerColumnGroup</name><operator>-&gt;</operator><name>tupleTid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AppendOnlyBlockDirectory_InsertPlaceholder
 *
 * We perform uniqueness checks by looking up block directory rows that cover
 * the rowNum indicated by the aotid obtained from the index. See
 * AppendOnlyBlockDirectory_CoversTuple() for details.
 *
 * However, there are multiple time windows in which there are no covering block
 * directory entries in the table for already inserted data rows. Such time
 * windows start from when a data row is inserted and lasts till the block
 * directory row covering it is written to the block directory table (see
 * write_minipage()). Block directory rows are written only when:
 * 	(i) the current in-memory minipage is full
 * 	(ii) at end of command.
 *
 * So we insert a placeholder entry in the current block directory row and
 * persist the row before the first insert to cover rows in the range:
 * [firstRowNum, lastRowNum], starting at firstOffset in the relfile
 * corresponding to columnGroupNo.
 *
 * firstRowNum is the rowNum assigned to the 1st insert of the insert command.
 * lastRowNum is the last rowNum that will be entered by the insert command,
 * which is something unknown to us. So, to cover all such windows during the
 * insert command's execution, we insert an entry with a placeholder
 * rowcount = AOTupleId_MaxRowNum into the current minipage and write it to the
 * relation (by reusing the machinery in write_minipage()). Such a row whose
 * last entry is a placeholder entry is called a placeholder row. This entry
 * will cover up to lastRowNum, whatever its value may be, for all such time
 * windows during the insert command.
 *
 * Safety:
 * (1) The placeholder upper bound is not a concern as this row will be consulted
 * ONLY by SNAPSHOT_DIRTY (for uniqueness checks) and will be ignored by regular
 * MVCC processing (for index scans). Eventually, it will be rendered invisible
 * as it will be updated by a subsequent write_minipage() or by virtue of abort.
 *
 * (2) There is no way a placeholder row will detect spurious conflicts due to
 * its loose upper bound, in the same segment file, to which it maps. This is
 * because there can be no other rows inserted into a segment file other than
 * the insert operation that is currently in progress on the file.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyBlockDirectory_InsertPlaceholder</name><parameter_list>(<parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>,
									  <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>,
									  <parameter><decl><type><name>int64</name></type> <name>fileOffset</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>columnGroupNo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipagePerColumnGroup</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>firstRowNum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fileOffset</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>columnGroupNo</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>columnGroupNo</name> <operator>&lt;</operator> <name><name>blockDirectory</name><operator>-&gt;</operator><name>aoRel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>minipagePerColumnGroup</name> <operator>=</operator> <operator>&amp;</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>minipages</name><index>[<expr><name>columnGroupNo</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* insert placeholder entry with a max row count */</comment>
	<expr_stmt><expr><call><name>insert_new_entry</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>, <argument><expr><name>columnGroupNo</name></expr></argument>, <argument><expr><name>firstRowNum</name></expr></argument>, <argument><expr><name>fileOffset</name></expr></argument>,
					 <argument><expr><name>AOTupleId_MaxRowNum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* insert placeholder row containing placeholder entry */</comment>
	<expr_stmt><expr><call><name>write_minipage</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>, <argument><expr><name>columnGroupNo</name></expr></argument>, <argument><expr><name>minipagePerColumnGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Delete the placeholder entry as it has no business being in memory.
	 * Removing it from the current minipage will make rest of the processing
	 * for the current command behave as if it never existed. The absence of
	 * this entry will help effectively "update" it once it's replacement entry
	 * is created in memory, in a subsequent call to insert_new_entry(),
	 * followed by a write_minipage() which will make this "update" persistent.
	 */</comment>
	<expr_stmt><expr><name><name>minipagePerColumnGroup</name><operator>-&gt;</operator><name>numMinipageEntries</name></name><operator>--</operator></expr>;</expr_stmt>
	<comment type="block">/*
	 * Increment the command counter, as we will be updating this temp row later
	 * on in write_minipage().
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>AppendOnlyBlockDirectory_End_forInsert</name><parameter_list>(
									   <parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>groupNo</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>groupNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>groupNo</name> <operator>&lt;</operator> <name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name></expr>;</condition> <incr><expr><name>groupNo</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipageInfo</name> <init>=
		<expr><operator>&amp;</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>minipages</name><index>[<expr><name>groupNo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_minipage</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>, <argument><expr><name>groupNo</name></expr></argument>, <argument><expr><name>minipageInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
					  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory end of insert write minipage: "</literal>
							  <literal type="string">"(columnGroupNo, nEntries) = (%d, %u)"</literal></expr></argument>,
							  <argument><expr><name>groupNo</name></expr></argument>, <argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory end for insert: "</literal>
					  <literal type="string">"(segno, numColumnGroups, isAOCol)="</literal>
					  <literal type="string">"(%d, %d, %d)"</literal></expr></argument>,
					  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name></expr></argument>,
					  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name></expr></argument>,
					  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogCloseIndexes</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>indinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>AppendOnlyBlockDirectory_End_forSearch</name><parameter_list>(
									   <parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory end for search: "</literal>
					  <literal type="string">"(totalSegfiles, numColumnGroups, isAOCol)="</literal>
					  <literal type="string">"(%d, %d, %d)"</literal></expr></argument>,
					  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>totalSegfiles</name></name></expr></argument>,
					  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name></expr></argument>,
					  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>AppendOnlyBlockDirectory_End_addCol</name><parameter_list>(
									<parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>groupNo</name></decl>;</decl_stmt>

	<comment type="block">/* newly added columns have attribute number beginning with this */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>colno</name> <init>= <expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>aoRel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator>
	<name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>groupNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>groupNo</name> <operator>&lt;</operator> <name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name></expr>;</condition> <incr><expr><name>groupNo</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MinipagePerColumnGroup</name> <modifier>*</modifier></type><name>minipageInfo</name> <init>=
		<expr><operator>&amp;</operator><name><name>blockDirectory</name><operator>-&gt;</operator><name>minipages</name><index>[<expr><name>groupNo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_minipage</name><argument_list>(<argument><expr><name>blockDirectory</name></expr></argument>, <argument><expr><name>groupNo</name> <operator>+</operator> <name>colno</name></expr></argument>, <argument><expr><name>minipageInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
					  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory end of insert write"</literal>
							  <literal type="string">" minipage: (columnGroupNo, nEntries) = (%d, %u)"</literal></expr></argument>,
							  <argument><expr><name>groupNo</name></expr></argument>, <argument><expr><name><name>minipageInfo</name><operator>-&gt;</operator><name>numMinipageEntries</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory end for insert: "</literal>
					  <literal type="string">"(segno, numColumnGroups, isAOCol)="</literal>
					  <literal type="string">"(%d, %d, %d)"</literal></expr></argument>,
					  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>currentSegmentFileNum</name></name></expr></argument>,
					  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>numColumnGroups</name></name></expr></argument>,
					  <argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>isAOCol</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We already hold transaction-scope exclusive lock on the AOCS relation.
	 * Let's defer release of locks on block directory as well until the end
	 * of alter-table transaction.
	 */</comment>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogCloseIndexes</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>indinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>AppendOnlyBlockDirectory_End_forUniqueChecks</name><parameter_list>(<parameter><decl><type><name>AppendOnlyBlockDirectory</name> <modifier>*</modifier></type><name>blockDirectory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This must have been reset after each uniqueness check */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>appendOnlyMetaDataSnapshot</name></name> <operator>==</operator> <name>InvalidSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereportif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_blockdirectory</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			  <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only block directory end for unique checks"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"(aoRel = %u, blkdirrel = %u, blkdiridxrel = %u)"</literal></expr></argument>,
							<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>aoRel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
							<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>,
							<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirIdx</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>blkdirRel</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>blockDirectory</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
