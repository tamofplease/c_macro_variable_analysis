<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/heap/heapam.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * heapam.c
 *	  heap access method code
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/heap/heapam.c
 *
 *
 * INTERFACE ROUTINES
 *		heap_beginscan	- begin relation scan
 *		heap_rescan		- restart a relation scan
 *		heap_endscan	- end relation scan
 *		heap_getnext	- retrieve next tuple in scan
 *		heap_fetch		- retrieve tuple with given tid
 *		heap_insert		- insert tuple into a relation
 *		heap_multi_insert - insert multiple tuples into a relation
 *		heap_delete		- delete a tuple from a relation
 *		heap_update		- replace a tuple in a relation with another tuple
 *		heap_sync		- sync heap, for when no WAL has been written
 *
 * NOTES
 *	  This file contains the heap_ routines which implement
 *	  the POSTGRES heap access method used for all POSTGRES
 *	  relations.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bufmask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hio.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/valid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/freespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/gpexpand.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/spccache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/oid_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>TM_Result</name></type> <name>heap_update_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>otid</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>newtup</name></decl></parameter>,
									  <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>,
									  <parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>, <parameter><decl><type><name>LockTupleMode</name> <modifier>*</modifier></type><name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>simple</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>heap_prepare_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>,
									 <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isFrozen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>log_heap_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>oldbuf</name></decl></parameter>,
								  <parameter><decl><type><name>Buffer</name></type> <name>newbuf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>oldtup</name></decl></parameter>,
								  <parameter><decl><type><name>HeapTuple</name></type> <name>newtup</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>old_key_tup</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>all_visible_cleared</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>new_all_visible_cleared</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>HeapDetermineModifiedColumns</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
											   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>interesting_cols</name></decl></parameter>,
											   <parameter><decl><type><name>HeapTuple</name></type> <name>oldtup</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>newtup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>heap_acquire_tuplock</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
								 <parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>LockWaitPolicy</name></type> <name>wait_policy</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>have_tuple_lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_new_xmax_infomask</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xmax</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>old_infomask</name></decl></parameter>,
									  <parameter><decl><type><name>uint16</name></type> <name>old_infomask2</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>add_to_xmax</name></decl></parameter>,
									  <parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_update</name></decl></parameter>,
									  <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>result_xmax</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>result_infomask</name></decl></parameter>,
									  <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>result_infomask2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TM_Result</name></type> <name>heap_lock_updated_tuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
										 <parameter><decl><type><name>ItemPointer</name></type> <name>ctid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
										 <parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GetMultiXactIdHintBits</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>new_infomask</name></decl></parameter>,
								   <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>new_infomask2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>MultiXactIdGetUpdateXid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xmax</name></decl></parameter>,
											 <parameter><decl><type><name>uint16</name></type> <name>t_infomask</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DoesMultiXactIdConflict</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>infomask</name></decl></parameter>,
									<parameter><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>current_is_member</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MultiXactIdWait</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>MultiXactStatus</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>infomask</name></decl></parameter>,
							<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>ctid</name></decl></parameter>, <parameter><decl><type><name>XLTW_Oper</name></type> <name>oper</name></decl></parameter>,
							<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ConditionalMultiXactIdWait</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>MultiXactStatus</name></type> <name>status</name></decl></parameter>,
									   <parameter><decl><type><name>uint16</name></type> <name>infomask</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>log_heap_new_cid</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>ExtractReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>key_modified</name></decl></parameter>,
										<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>copy</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Each tuple lock mode has a corresponding heavyweight lock, and one or two
 * corresponding MultiXactStatuses (one to merely lock tuples, another one to
 * update them).  This table (and the macros below) helps us determine the
 * heavyweight lock mode and MultiXactStatus values to use for any particular
 * tuple lock strength.
 *
 * Don't look at lockstatus/updstatus directly!  Use get_mxact_status_for_lock
 * instead.
 */</comment>
<struct><specifier>static</specifier> <specifier>const</specifier> struct
<block>{
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>hwlock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lockstatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>updstatus</name></decl>;</decl_stmt>
}</block>

			<decl><name><name>tupleLockExtraInfo</name><index>[<expr><name>MaxLockTupleMode</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>=
<expr><block>{
	<expr><block>{							<comment type="block">/* LockTupleKeyShare */</comment>
		<expr><name>AccessShareLock</name></expr>,
		<expr><name>MultiXactStatusForKeyShare</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>						<comment type="block">/* KeyShare does not allow updating tuples */</comment>
	}</block></expr>,
	<expr><block>{							<comment type="block">/* LockTupleShare */</comment>
		<expr><name>RowShareLock</name></expr>,
		<expr><name>MultiXactStatusForShare</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>						<comment type="block">/* Share does not allow updating tuples */</comment>
	}</block></expr>,
	<expr><block>{							<comment type="block">/* LockTupleNoKeyExclusive */</comment>
		<expr><name>ExclusiveLock</name></expr>,
		<expr><name>MultiXactStatusForNoKeyUpdate</name></expr>,
		<expr><name>MultiXactStatusNoKeyUpdate</name></expr>
	}</block></expr>,
	<expr><block>{							<comment type="block">/* LockTupleExclusive */</comment>
		<expr><name>AccessExclusiveLock</name></expr>,
		<expr><name>MultiXactStatusForUpdate</name></expr>,
		<expr><name>MultiXactStatusUpdate</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</struct>

<comment type="block">/* Get the LOCKMODE for a given MultiXactStatus */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCKMODE_from_mxstatus</name><parameter_list>(<parameter><type><name>status</name></type></parameter>)</parameter_list></cpp:macro> \
			<cpp:value>(tupleLockExtraInfo[TUPLOCK_from_mxstatus((status))].hwlock)</cpp:value></cpp:define>

<comment type="block">/*
 * Acquire heavyweight locks on tuples, using a LockTupleMode strength value.
 * This is more readable than having every caller translate it to lock.h's
 * LOCKMODE.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LockTupleTuplock</name><parameter_list>(<parameter><type><name>rel</name></type></parameter>, <parameter><type><name>tup</name></type></parameter>, <parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>LockTuple((rel), (tup), tupleLockExtraInfo[mode].hwlock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UnlockTupleTuplock</name><parameter_list>(<parameter><type><name>rel</name></type></parameter>, <parameter><type><name>tup</name></type></parameter>, <parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>UnlockTuple((rel), (tup), tupleLockExtraInfo[mode].hwlock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ConditionalLockTupleTuplock</name><parameter_list>(<parameter><type><name>rel</name></type></parameter>, <parameter><type><name>tup</name></type></parameter>, <parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>ConditionalLockTuple((rel), (tup), tupleLockExtraInfo[mode].hwlock)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
<comment type="block">/*
 * heap_compute_xid_horizon_for_tuples and xid_horizon_prefetch_buffer use
 * this structure to coordinate prefetching activity.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>cur_hblkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>next_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>tids</name></decl>;</decl_stmt>
}</block></struct></type> <name>XidHorizonPrefetchState</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * This table maps tuple lock strength values for each particular
 * MultiXactStatus value.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>MultiXactStatusLock</name><index>[<expr><name>MaxMultiXactStatus</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>=
<expr><block>{
	<expr><name>LockTupleKeyShare</name></expr>,			<comment type="block">/* ForKeyShare */</comment>
	<expr><name>LockTupleShare</name></expr>,				<comment type="block">/* ForShare */</comment>
	<expr><name>LockTupleNoKeyExclusive</name></expr>,	<comment type="block">/* ForNoKeyUpdate */</comment>
	<expr><name>LockTupleExclusive</name></expr>,			<comment type="block">/* ForUpdate */</comment>
	<expr><name>LockTupleNoKeyExclusive</name></expr>,	<comment type="block">/* NoKeyUpdate */</comment>
	<expr><name>LockTupleExclusive</name></expr>			<comment type="block">/* Update */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Get the LockTupleMode for a given MultiXactStatus */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TUPLOCK_from_mxstatus</name><parameter_list>(<parameter><type><name>status</name></type></parameter>)</parameter_list></cpp:macro> \
			<cpp:value>(MultiXactStatusLock[(status)])</cpp:value></cpp:define>

<comment type="block">/* ----------------------------------------------------------------
 *						 heap support routines
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *		initscan - scan code common to heap_beginscan and heap_rescan
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initscan</name><parameter_list>(<parameter><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keep_startblock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelBlockTableScanDesc</name></type> <name>bpscan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>allow_strat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>allow_sync</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Determine the number of blocks we have to scan.
	 *
	 * It is sufficient to do this once at scan start, since any tuples added
	 * while the scan is in progress will be invisible to my snapshot anyway.
	 * (That is not true when using a non-MVCC snapshot.  However, we couldn't
	 * guarantee to return tuples added after scan start anyway, since they
	 * might go into pages we already scanned.  To guarantee consistent
	 * results for a non-MVCC snapshot, the caller must hold some higher-level
	 * lock that ensures the interesting tuple(s) won't change.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bpscan</name> <operator>=</operator> <operator>(</operator><name>ParallelBlockTableScanDesc</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name> <operator>=</operator> <name><name>bpscan</name><operator>-&gt;</operator><name>phs_nblocks</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If the table is large relative to NBuffers, use a bulk-read access
	 * strategy and enable synchronized scanning (see syncscan.c).  Although
	 * the thresholds for these features could be different, we make them the
	 * same so that there are only two behaviors to tune rather than four.
	 * (However, some callers need to be able to disable one or both of these
	 * behaviors, independently of the size of the table; also there is a GUC
	 * variable that can disable synchronized scanning.)
	 *
	 * Note that table_block_parallelscan_initialize has a very similar test;
	 * if you change this, consider changing that one, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationUsesLocalBuffers</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name> <operator>&gt;</operator> <name>NBuffers</name> <operator>/</operator> <literal type="number">4</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>allow_strat</name> <operator>=</operator> <operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_ALLOW_STRAT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>allow_sync</name> <operator>=</operator> <operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_ALLOW_SYNC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>allow_strat</name> <operator>=</operator> <name>allow_sync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>allow_strat</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* During a rescan, keep the previous strategy object. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_strategy</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_strategy</name></name> <operator>=</operator> <call><name>GetAccessStrategy</name><argument_list>(<argument><expr><name>BAS_BULKREAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_strategy</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FreeAccessStrategy</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_strategy</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* For parallel scan, believe whatever ParallelTableScanDesc says. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name><operator>-&gt;</operator><name>phs_syncscan</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>|=</operator> <name>SO_ALLOW_SYNC</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SO_ALLOW_SYNC</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>keep_startblock</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When rescanning, we want to keep the previous startblock setting,
		 * so that rewinding a cursor doesn't generate surprising results.
		 * Reset the active syncscan setting, though.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>allow_sync</name> <operator>&amp;&amp;</operator> <name>synchronize_seqscans</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>|=</operator> <name>SO_ALLOW_SYNC</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SO_ALLOW_SYNC</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>allow_sync</name> <operator>&amp;&amp;</operator> <name>synchronize_seqscans</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>|=</operator> <name>SO_ALLOW_SYNC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_startblock</name></name> <operator>=</operator> <call><name>ss_get_location</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SO_ALLOW_SYNC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_startblock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name><operator>.</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>

	<comment type="block">/* page-at-a-time fields are always invalid when not rs_inited */</comment>

	<comment type="block">/*
	 * copy the scan key, if appropriate
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_nkeys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Currently, we only have a stats counter for sequential heap scans (but
	 * e.g for bitmap scans the underlying bitmap index scans will be counted,
	 * and for sample scans we update stats for tuple fetches).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_TYPE_SEQSCAN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_count_heap_scan</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * heap_setscanlimits - restrict range of a heapscan
 *
 * startBlk is the page to start at
 * numBlks is number of pages to scan (InvalidBlockNumber means "all")
 */</comment>
<function><type><name>void</name></type>
<name>heap_setscanlimits</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>startBlk</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>numBlks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>sscan</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* else too late to change */</comment>
	<comment type="block">/* else rs_startblock is significant */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_ALLOW_SYNC</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check startBlk is valid (but allow case of zero blocks...) */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>startBlk</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>startBlk</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_startblock</name></name> <operator>=</operator> <name>startBlk</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>=</operator> <name>numBlks</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * heapgetpage - subroutine for heapgettup()
 *
 * This routine reads and pins the specified page of the relation.
 * In page-at-a-time mode it performs additional work, namely determining
 * which tuples on the page are visible.
 */</comment>
<function><type><name>void</name></type>
<name>heapgetpage</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>sscan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lines</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>lineoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lpp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_visible</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>t_xmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>t_cid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>page</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* release previous scan buffer, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Be sure to check for interrupts at least once per page.  Checks at
	 * higher code levels won't be able to stop a seqscan that encounters many
	 * pages' worth of consecutive dead tuples.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* read page using selected strategy */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
									   <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_ALLOW_PAGEMODE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prune and repair fragmentation for the whole page, if possible.
	 */</comment>
	<expr_stmt><expr><call><name>heap_page_prune_opt</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must hold share lock on the buffer content while examining tuple
	 * visibility.  Afterwards, however, the tuples we have found to be
	 * visible are guaranteed good as long as we hold the buffer pin.
	 */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lines</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ntup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>t_xmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>t_cid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the all-visible flag indicates that all tuples on the page are
	 * visible to everyone, we can skip the per-tuple visibility tests.
	 *
	 * Note: In hot standby, a tuple that's already visible to all
	 * transactions in the master might still be invisible to a read-only
	 * transaction in the standby. We partly handle this problem by tracking
	 * the minimum xmin of visible tuples as the cut-off XID while marking a
	 * page all-visible on master and WAL log that along with the visibility
	 * map SET operation. In hot standby, we wait for (or abort) all
	 * transactions that can potentially may not see one or more tuples on the
	 * page. That's how index-only scans work fine in hot standby. A crucial
	 * difference between index-only scans and heap scans is that the
	 * index-only scan completely relies on the visibility map where as heap
	 * scan looks at the page-level PD_ALL_VISIBLE flag. We are not sure if
	 * the page-level flag can be trusted in the same way, because it might
	 * get propagated somehow without being explicitly WAL-logged, e.g. via a
	 * full page write. Until we can prove that beyond doubt, let's check each
	 * tuple for visibility the hard way.
	 */</comment>
	<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>snapshot</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>lineoff</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr><operator>,</operator> <expr><name>lpp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>lineoff</name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>lineoff</name> <operator>&lt;=</operator> <name>lines</name></expr>;</condition>
		 <incr><expr><name>lineoff</name><operator>++</operator></expr><operator>,</operator> <expr><name>lpp</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>loctup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>theader</name> <init>= <expr><operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>dp</name></expr></argument>, <argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>loctup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>loctup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>dp</name></expr></argument>, <argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>loctup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>loctup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>lineoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>all_visible</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>valid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * GPDB: We have a one-item cache for the common case that a
				 * lot of tuples have the same visibility info. Don't use the
				 * cache, if the tuple was ever deleted, though (i.e. if xmax
				 * is valid, and not just for tuple-locking). We could cache
				 * the xmax too, but the visibility rules get more complicated
				 * with locked-only tuples and multi-XIDs, so it seems better
				 * to just give up early.
				 */</comment>
				<decl_stmt><decl><type><name>bool</name></type>		<name>use_cache</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>theader</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name><name>theader</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>use_cache</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>use_cache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>use_cache</name> <operator>&amp;&amp;</operator>
					<name>t_xmin</name> <operator>==</operator> <call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name>theader</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name>t_cid</name> <operator>==</operator> <call><name>HeapTupleHeaderGetRawCommandId</name><argument_list>(<argument><expr><name>theader</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>valid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>HeapTupleSatisfiesVisibility</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>loctup</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>valid</name> <operator>&amp;&amp;</operator> <name>use_cache</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>t_xmin</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>loctup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>t_cid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawCommandId</name><argument_list>(<argument><expr><name><name>loctup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>CheckForSerializableConflictOut</name><argument_list>(<argument><expr><name>valid</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>loctup</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_vistuples</name><index>[<expr><name>ntup</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>lineoff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ntup</name> <operator>&lt;=</operator> <name>MaxHeapTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_ntuples</name></name> <operator>=</operator> <name>ntup</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		heapgettup - fetch next heap tuple
 *
 *		Initialize the scan if not already done; then advance to the next
 *		tuple as indicated by "dir"; return the next tuple in scan-&gt;rs_ctup,
 *		or set scan-&gt;rs_ctup.t_data = NULL if no more tuples.
 *
 * dir == NoMovementScanDirection means "re-fetch the tuple indicated
 * by scan-&gt;rs_ctup".
 *
 * Note: the reason nkeys/key are passed separately, even though they are
 * kept in the scan descriptor, is that the caller may not want us to check
 * the scankeys.
 *
 * Note: when we fall off the end of the scan in either direction, we
 * reset rs_inited.  This means that a further request with the same
 * scan direction will restart the scan, which is a bit odd, but a
 * request with the opposite scan direction will start a fresh scan
 * in the proper direction.  The latter is required behavior for cursors,
 * while the former case is generally undefined behavior in Postgres
 * so we don't care too much.
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapgettup</name><parameter_list>(<parameter><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl></parameter>,
		   <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
		   <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>backward</name> <init>= <expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>finished</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lines</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>lineoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>linesleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lpp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * calculate next starting lineoff, given scan direction
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * return null immediately if relation is empty
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ParallelBlockTableScanDesc</name></type> <name>pbscan</name> <init>=
				<expr><operator>(</operator><name>ParallelBlockTableScanDesc</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>table_block_parallelscan_startblock_init</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
														 <argument><expr><name>pbscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>table_block_parallelscan_nextpage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
														 <argument><expr><name>pbscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Other processes might have already finished the scan. */</comment>
				<if_stmt><if>if <condition>(<expr><name>page</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_startblock</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* first page */</comment>
			<expr_stmt><expr><call><name>heapgetpage</name><argument_list>(<argument><expr><operator>(</operator><name>TableScanDesc</name><operator>)</operator> <name>scan</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lineoff</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>	<comment type="block">/* first offnum */</comment>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* continue from previously returned page/tuple */</comment>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr>;</expr_stmt> <comment type="block">/* current page */</comment>
			<expr_stmt><expr><name>lineoff</name> <operator>=</operator>			<comment type="block">/* next offnum */</comment>
				<call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lines</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* page and lineoff now reference the physically next tid */</comment>

		<expr_stmt><expr><name>linesleft</name> <operator>=</operator> <name>lines</name> <operator>-</operator> <name>lineoff</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>backward</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* backward parallel scan not supported */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * return null immediately if relation is empty
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Disable reporting to syncscan logic in a backwards scan; it's
			 * not very likely anyone else is doing the same thing at the same
			 * time, and much more likely that we'll just bollix things for
			 * forward scanners.
			 */</comment>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SO_ALLOW_SYNC</name></expr>;</expr_stmt>
			<comment type="block">/* start from last page of the scan */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_startblock</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_startblock</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>heapgetpage</name><argument_list>(<argument><expr><operator>(</operator><name>TableScanDesc</name><operator>)</operator> <name>scan</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* continue from previously returned page/tuple */</comment>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr>;</expr_stmt> <comment type="block">/* current page */</comment>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lines</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lineoff</name> <operator>=</operator> <name>lines</name></expr>;</expr_stmt>	<comment type="block">/* final offnum */</comment>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>lineoff</name> <operator>=</operator>			<comment type="block">/* previous offnum */</comment>
				<call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* page and lineoff now reference the physically previous tid */</comment>

		<expr_stmt><expr><name>linesleft</name> <operator>=</operator> <name>lineoff</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * ``no movement'' scan direction: refetch prior tuple
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>page</name> <operator>!=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heapgetpage</name><argument_list>(<argument><expr><operator>(</operator><name>TableScanDesc</name><operator>)</operator> <name>scan</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Since the tuple was previously fetched, needn't lock page here */</comment>
		<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lineoff</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lpp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>lineoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>dp</name></expr></argument>, <argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * advance the scan until we find a qualifying tuple or run out of stuff
	 * to scan
	 */</comment>
	<expr_stmt><expr><name>lpp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>lineoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>linesleft</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>dp</name></expr></argument>, <argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>lineoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * if current tuple qualifies, return it.
				 */</comment>
				<expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>HeapTupleSatisfiesVisibility</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
													 <argument><expr><name>tuple</name></expr></argument>,
													 <argument><expr><name>snapshot</name></expr></argument>,
													 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CheckForSerializableConflictOut</name><argument_list>(<argument><expr><name>valid</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
												<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>,
												<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>valid</name> <operator>&amp;&amp;</operator> <name>key</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>HeapKeyTest</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * otherwise move to the next item on the page
			 */</comment>
			<expr_stmt><expr><operator>--</operator><name>linesleft</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>backward</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>--</operator><name>lpp</name></expr>;</expr_stmt>			<comment type="block">/* move back in this page's ItemId array */</comment>
				<expr_stmt><expr><operator>--</operator><name>lineoff</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>++</operator><name>lpp</name></expr>;</expr_stmt>			<comment type="block">/* move forward in this page's ItemId array */</comment>
				<expr_stmt><expr><operator>++</operator><name>lineoff</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * if we get here, it means we've exhausted the items on this page and
		 * it's time to move to the next.
		 */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * advance to next/prior page and detect end of scan
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>backward</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>finished</name> <operator>=</operator> <operator>(</operator><name>page</name> <operator>==</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_startblock</name></name><operator>)</operator> <operator>||</operator>
				<operator>(</operator><ternary><condition><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr> ?</condition><then> <expr><operator>--</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>page</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>page</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParallelBlockTableScanDesc</name></type> <name>pbscan</name> <init>=
			<expr><operator>(</operator><name>ParallelBlockTableScanDesc</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>table_block_parallelscan_nextpage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
													 <argument><expr><name>pbscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>finished</name> <operator>=</operator> <operator>(</operator><name>page</name> <operator>==</operator> <name>InvalidBlockNumber</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>page</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>page</name> <operator>&gt;=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>finished</name> <operator>=</operator> <operator>(</operator><name>page</name> <operator>==</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_startblock</name></name><operator>)</operator> <operator>||</operator>
				<operator>(</operator><ternary><condition><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr> ?</condition><then> <expr><operator>--</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * Report our new scan position for synchronization purposes. We
			 * don't do that when moving backwards, however. That would just
			 * mess up any other forward-moving scanners.
			 *
			 * Note: we do this before checking for end of scan so that the
			 * final state of the position hint is back at the start of the
			 * rel.  That's not strictly necessary, but otherwise when you run
			 * the same query multiple times the starting position would shift
			 * a little bit backwards on every invocation, which is confusing.
			 * We don't guarantee any specific ordering in general, though.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_ALLOW_SYNC</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ss_report_location</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * return NULL if we've exhausted all the pages
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>finished</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>heapgetpage</name><argument_list>(<argument><expr><operator>(</operator><name>TableScanDesc</name><operator>)</operator> <name>scan</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lines</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>linesleft</name> <operator>=</operator> <name>lines</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>backward</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lineoff</name> <operator>=</operator> <name>lines</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lpp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>lineoff</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lpp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		heapgettup_pagemode - fetch next heap tuple in page-at-a-time mode
 *
 *		Same API as heapgettup, but used in page-at-a-time mode
 *
 * The internal logic is much the same as heapgettup's too, but there are some
 * differences: we do not take the buffer content lock (that only needs to
 * happen inside heapgetpage), and we iterate through just the tuples listed
 * in rs_vistuples[] rather than all tuples on the page.  Notice that
 * lineindex is 0-based, where the corresponding loop variable lineoff in
 * heapgettup is 1-based.
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapgettup_pagemode</name><parameter_list>(<parameter><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl></parameter>,
					<parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
					<parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>backward</name> <init>= <expr><call><name>ScanDirectionIsBackward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>finished</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lines</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lineindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>lineoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>linesleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lpp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * calculate next starting lineindex, given scan direction
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * return null immediately if relation is empty
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ParallelBlockTableScanDesc</name></type> <name>pbscan</name> <init>=
				<expr><operator>(</operator><name>ParallelBlockTableScanDesc</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>table_block_parallelscan_startblock_init</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
														 <argument><expr><name>pbscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>table_block_parallelscan_nextpage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
														 <argument><expr><name>pbscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Other processes might have already finished the scan. */</comment>
				<if_stmt><if>if <condition>(<expr><name>page</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_startblock</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* first page */</comment>
			<expr_stmt><expr><call><name>heapgetpage</name><argument_list>(<argument><expr><operator>(</operator><name>TableScanDesc</name><operator>)</operator> <name>scan</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lineindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* continue from previously returned page/tuple */</comment>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr>;</expr_stmt> <comment type="block">/* current page */</comment>
			<expr_stmt><expr><name>lineindex</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lines</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_ntuples</name></name></expr>;</expr_stmt>
		<comment type="block">/* page and lineindex now reference the next visible tid */</comment>

		<expr_stmt><expr><name>linesleft</name> <operator>=</operator> <name>lines</name> <operator>-</operator> <name>lineindex</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>backward</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* backward parallel scan not supported */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * return null immediately if relation is empty
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Disable reporting to syncscan logic in a backwards scan; it's
			 * not very likely anyone else is doing the same thing at the same
			 * time, and much more likely that we'll just bollix things for
			 * forward scanners.
			 */</comment>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SO_ALLOW_SYNC</name></expr>;</expr_stmt>
			<comment type="block">/* start from last page of the scan */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_startblock</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_startblock</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>heapgetpage</name><argument_list>(<argument><expr><operator>(</operator><name>TableScanDesc</name><operator>)</operator> <name>scan</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* continue from previously returned page/tuple */</comment>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr>;</expr_stmt> <comment type="block">/* current page */</comment>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lines</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_ntuples</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lineindex</name> <operator>=</operator> <name>lines</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>lineindex</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* page and lineindex now reference the previous visible tid */</comment>

		<expr_stmt><expr><name>linesleft</name> <operator>=</operator> <name>lineindex</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * ``no movement'' scan direction: refetch prior tuple
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>page</name> <operator>!=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heapgetpage</name><argument_list>(<argument><expr><operator>(</operator><name>TableScanDesc</name><operator>)</operator> <name>scan</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Since the tuple was previously fetched, needn't lock page here */</comment>
		<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lineoff</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lpp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>lineoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>dp</name></expr></argument>, <argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check that rs_cindex is in sync */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_ntuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lineoff</name> <operator>==</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_vistuples</name><index>[<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cindex</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * advance the scan until we find a qualifying tuple or run out of stuff
	 * to scan
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>linesleft</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lineoff</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_vistuples</name><index>[<expr><name>lineindex</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lpp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>lineoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>dp</name></expr></argument>, <argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lpp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>lineoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * if current tuple qualifies, return it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>HeapKeyTest</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>=</operator> <name>lineindex</name></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>=</operator> <name>lineindex</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * otherwise move to the next item on the page
			 */</comment>
			<expr_stmt><expr><operator>--</operator><name>linesleft</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>backward</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>--</operator><name>lineindex</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name>lineindex</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * if we get here, it means we've exhausted the items on this page and
		 * it's time to move to the next.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>backward</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>finished</name> <operator>=</operator> <operator>(</operator><name>page</name> <operator>==</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_startblock</name></name><operator>)</operator> <operator>||</operator>
				<operator>(</operator><ternary><condition><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr> ?</condition><then> <expr><operator>--</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>page</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>page</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParallelBlockTableScanDesc</name></type> <name>pbscan</name> <init>=
			<expr><operator>(</operator><name>ParallelBlockTableScanDesc</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>table_block_parallelscan_nextpage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
													 <argument><expr><name>pbscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>finished</name> <operator>=</operator> <operator>(</operator><name>page</name> <operator>==</operator> <name>InvalidBlockNumber</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>page</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>page</name> <operator>&gt;=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>finished</name> <operator>=</operator> <operator>(</operator><name>page</name> <operator>==</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_startblock</name></name><operator>)</operator> <operator>||</operator>
				<operator>(</operator><ternary><condition><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr> ?</condition><then> <expr><operator>--</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_numblocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * Report our new scan position for synchronization purposes. We
			 * don't do that when moving backwards, however. That would just
			 * mess up any other forward-moving scanners.
			 *
			 * Note: we do this before checking for end of scan so that the
			 * final state of the position hint is back at the start of the
			 * rel.  That's not strictly necessary, but otherwise when you run
			 * the same query multiple times the starting position would shift
			 * a little bit backwards on every invocation, which is confusing.
			 * We don't guarantee any specific ordering in general, though.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_ALLOW_SYNC</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ss_report_location</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * return NULL if we've exhausted all the pages
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>finished</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_inited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>heapgetpage</name><argument_list>(<argument><expr><operator>(</operator><name>TableScanDesc</name><operator>)</operator> <name>scan</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lines</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_ntuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>linesleft</name> <operator>=</operator> <name>lines</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>backward</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lineindex</name> <operator>=</operator> <name>lines</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>lineindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DISABLE_COMPLEX_MACRO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * This is formatted so oddly so that the correspondence to the macro
 * definition in access/htup_details.h is maintained.
 */</comment>
<function><type><name>Datum</name></type>
<name>fastgetattr</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
			<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator>
			<ternary><condition><expr><operator>(</operator><name>attnum</name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then>
			<expr><operator>(</operator>
			 <operator>(</operator><operator>*</operator><operator>(</operator><name>isnull</name><operator>)</operator> <operator>=</operator> <name>false</name><operator>)</operator><operator>,</operator>
			 <ternary><condition><expr><call><name>HeapTupleNoNulls</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
			 <expr><operator>(</operator>
			  <ternary><condition><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><operator>(</operator><name>tupleDesc</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>attnum</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then>
			  <expr><operator>(</operator>
			   <call><name>fetchatt</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><operator>(</operator><name>tupleDesc</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>attnum</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>tup</name><operator>)</operator><operator>-&gt;</operator><name>t_data</name> <operator>+</operator> <operator>(</operator><name>tup</name><operator>)</operator><operator>-&gt;</operator><name><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>+</operator>
						<call><name>TupleDescAttr</name><argument_list>(<argument><expr><operator>(</operator><name>tupleDesc</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>attnum</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcacheoff</name></expr></argument>)</argument_list></call>
			   <operator>)</operator></expr>
			  </then><else>:
			  <expr><call><name>nocachegetattr</name><argument_list>(<argument><expr><operator>(</operator><name>tup</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>attnum</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>tupleDesc</name><operator>)</operator></expr></argument>)</argument_list></call></expr></else></ternary>
			  <operator>)</operator></expr>
			 </then><else>:
			 <expr><operator>(</operator>
			  <ternary><condition><expr><call><name>att_isnull</name><argument_list>(<argument><expr><operator>(</operator><name>attnum</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>tup</name><operator>)</operator><operator>-&gt;</operator><name><name>t_data</name><operator>-&gt;</operator><name>t_bits</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
			  <expr><operator>(</operator>
			   <operator>(</operator><operator>*</operator><operator>(</operator><name>isnull</name><operator>)</operator> <operator>=</operator> <name>true</name><operator>)</operator><operator>,</operator>
			   <operator>(</operator><name>Datum</name><operator>)</operator> <name>NULL</name>
			   <operator>)</operator></expr>
			  </then><else>:
			  <expr><operator>(</operator>
			   <call><name>nocachegetattr</name><argument_list>(<argument><expr><operator>(</operator><name>tup</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>attnum</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>tupleDesc</name><operator>)</operator></expr></argument>)</argument_list></call>
			   <operator>)</operator></expr></else></ternary>
			  <operator>)</operator></expr></else></ternary>
			 <operator>)</operator></expr>
			</then><else>:
			<expr><operator>(</operator>
			 <operator>(</operator><name>Datum</name><operator>)</operator> <name>NULL</name>
			 <operator>)</operator></expr></else></ternary>
		<operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* defined(DISABLE_COMPLEX_MACRO) */</comment>


<comment type="block">/* ----------------------------------------------------------------
 *					 heap access method interface
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>TableScanDesc</name></type>
<name>heap_beginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
			   <parameter><decl><type><name>ParallelTableScanDesc</name></type> <name>parallel_scan</name></decl></parameter>,
			   <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * increment relation ref count while scanning relation
	 *
	 * This is just to make really sure the relcache entry won't go away while
	 * the scan has a pointer to it.  Caller should be holding the rel open
	 * anyway, so this is redundant in all normal scenarios...
	 */</comment>
	<expr_stmt><expr><call><name>RelationIncrementReferenceCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate and initialize scan descriptor
	 */</comment>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_nkeys</name></name> <operator>=</operator> <name>nkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>=</operator> <name>parallel_scan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_strategy</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* set in initscan */</comment>

	<comment type="block">/*
	 * Disable page-at-a-time mode if it's not a MVCC-safe snapshot.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>snapshot</name> <operator>&amp;&amp;</operator> <call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SO_ALLOW_PAGEMODE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For seqscan and sample scans in a serializable transaction, acquire a
	 * predicate lock on the entire relation. This is required not only to
	 * lock all the matching tuples, but also to conflict with new insertions
	 * into the table. In an indexscan, we take page locks on the index pages
	 * covering the range specified in the scan qual, but in a heap scan there
	 * is nothing more fine-grained to lock. A bitmap scan is a different
	 * story, there we have already scanned the index and locked the index
	 * pages covering the predicate. But in that case we still have to lock
	 * any matching heap tuples. For sample scan we could optimize the locking
	 * to be at least page-level granularity, but we'd need to add per-tuple
	 * locking for that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SO_TYPE_SEQSCAN</name> <operator>|</operator> <name>SO_TYPE_SAMPLESCAN</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ensure a missing snapshot is noticed reliably, even if the
		 * isolation mode means predicate locking isn't performed (and
		 * therefore the snapshot isn't used here).
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PredicateLockRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we only need to set this up once */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we do this here instead of in initscan() because heap_rescan also calls
	 * initscan() and we don't want to allocate memory again
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nkeys</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_key</name></name> <operator>=</operator> <operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_key</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>initscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>TableScanDesc</name><operator>)</operator> <name>scan</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>heap_rescan</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>set_params</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>allow_strat</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_sync</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_pagemode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>sscan</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_params</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>allow_strat</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>|=</operator> <name>SO_ALLOW_STRAT</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SO_ALLOW_STRAT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>allow_sync</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>|=</operator> <name>SO_ALLOW_SYNC</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SO_ALLOW_SYNC</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>allow_pagemode</name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name> <operator>&amp;&amp;</operator>
			<call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>|=</operator> <name>SO_ALLOW_PAGEMODE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SO_ALLOW_PAGEMODE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * unpin scan buffers
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * reinitialize scan descriptor
	 */</comment>
	<expr_stmt><expr><call><name>initscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>heap_endscan</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>sscan</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Note: no locking manipulations needed */</comment>

	<comment type="block">/*
	 * unpin scan buffers
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * decrement relation reference count and free scan descriptor storage
	 */</comment>
	<expr_stmt><expr><call><name>RelationDecrementReferenceCount</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_key</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_strategy</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeAccessStrategy</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_TEMP_SNAPSHOT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HEAPDEBUGALL</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAPDEBUG_1</name></cpp:macro> \
	<cpp:value>elog(DEBUG2, "heap_getnext([%s,nkeys=%d],dir=%d) called", \
		 RelationGetRelationName(scan-&gt;rs_rd), scan-&gt;rs_nkeys, (int) direction)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAPDEBUG_2</name></cpp:macro> \
	<cpp:value>elog(DEBUG2, "heap_getnext returning EOS")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAPDEBUG_3</name></cpp:macro> \
	<cpp:value>elog(DEBUG2, "heap_getnext returning tuple")</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAPDEBUG_1</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAPDEBUG_2</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAPDEBUG_3</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* !defined(HEAPDEBUGALL) */</comment>


<function><type><name>HeapTuple</name></type>
<name>heap_getnext</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>sscan</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is still widely used directly, without going through table AM, so
	 * add a safety check.  It's possible we should, at a later point,
	 * downgrade this to an assert. The reason for checking the AM routine,
	 * rather than the AM oid, is that this allows to write regression tests
	 * that create another AM reusing the heap handler.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>sscan</name><operator>-&gt;</operator><name>rs_rd</name><operator>-&gt;</operator><name>rd_tableam</name></name> <operator>!=</operator> <call><name>GetHeapamTableAmRoutine</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"only heap AM is supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Note: no locking manipulations needed */</comment>

	<expr_stmt><expr><name>HEAPDEBUG_1</name></expr>;</expr_stmt>				<comment type="block">/* heap_getnext( info ) */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_ALLOW_PAGEMODE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heapgettup_pagemode</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>,
							<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_nkeys</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heapgettup</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>,
				   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_nkeys</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name><operator>.</operator><name>t_data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>HEAPDEBUG_2</name></expr>;</expr_stmt>			<comment type="block">/* heap_getnext returning EOS */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if we get here it means we have a new current scan tuple, so point to
	 * the proper return buffer and return the tuple.
	 */</comment>
	<expr_stmt><expr><name>HEAPDEBUG_3</name></expr>;</expr_stmt>				<comment type="block">/* heap_getnext returning tuple */</comment>

	<expr_stmt><expr><call><name>pgstat_count_heap_getnext</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HEAPAMSLOTDEBUGALL</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAPAMSLOTDEBUG_1</name></cpp:macro> \
	<cpp:value>elog(DEBUG2, "heapam_getnextslot([%s,nkeys=%d],dir=%d) called", \
		 RelationGetRelationName(scan-&gt;rs_base.rs_rd), scan-&gt;rs_base.rs_nkeys, (int) direction)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAPAMSLOTDEBUG_2</name></cpp:macro> \
	<cpp:value>elog(DEBUG2, "heapam_getnextslot returning EOS")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAPAMSLOTDEBUG_3</name></cpp:macro> \
	<cpp:value>elog(DEBUG2, "heapam_getnextslot returning tuple")</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAPAMSLOTDEBUG_1</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAPAMSLOTDEBUG_2</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAPAMSLOTDEBUG_3</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>bool</name></type>
<name>heap_getnextslot</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>sscan</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Note: no locking manipulations needed */</comment>

	<expr_stmt><expr><name>HEAPAMSLOTDEBUG_1</name></expr>;</expr_stmt>			<comment type="block">/* heap_getnextslot( info ) */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>sscan</name><operator>-&gt;</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_ALLOW_PAGEMODE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heapgettup_pagemode</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name><name>sscan</name><operator>-&gt;</operator><name>rs_nkeys</name></name></expr></argument>, <argument><expr><name><name>sscan</name><operator>-&gt;</operator><name>rs_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heapgettup</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name><name>sscan</name><operator>-&gt;</operator><name>rs_nkeys</name></name></expr></argument>, <argument><expr><name><name>sscan</name><operator>-&gt;</operator><name>rs_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name><operator>.</operator><name>t_data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>HEAPAMSLOTDEBUG_2</name></expr>;</expr_stmt>		<comment type="block">/* heap_getnextslot returning EOS */</comment>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if we get here it means we have a new current scan tuple, so point to
	 * the proper return buffer and return the tuple.
	 */</comment>
	<expr_stmt><expr><name>HEAPAMSLOTDEBUG_3</name></expr>;</expr_stmt>			<comment type="block">/* heap_getnextslot returning tuple */</comment>

	<expr_stmt><expr><call><name>pgstat_count_heap_getnext</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecStoreBufferHeapTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_ctup</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
							 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	heap_fetch		- retrieve tuple with given tid
 *
 * On entry, tuple-&gt;t_self is the TID to fetch.  We pin the buffer holding
 * the tuple, fill in the remaining fields of *tuple, and check the tuple
 * against the specified snapshot.
 *
 * If successful (tuple found and passes snapshot time qual), then *userbuf
 * is set to the buffer holding the tuple and true is returned.  The caller
 * must unpin the buffer when done with the tuple.
 *
 * If the tuple is not found (ie, item number references a deleted slot),
 * then tuple-&gt;t_data is set to NULL and false is returned.
 *
 * If the tuple is found but fails the time qual check, then false is returned
 * but tuple-&gt;t_data is left pointing to the tuple.
 *
 * heap_fetch does not follow HOT chains: only the exact TID requested will
 * be fetched.
 *
 * It is somewhat inconsistent that we ereport() on invalid block number but
 * return false on invalid item number.  There are a couple of reasons though.
 * One is that the caller can relatively easily check the block number for
 * validity, but cannot check the item number without reading the page
 * himself.  Another is that when we are following a t_ctid link, we can be
 * reasonably confident that the page number is valid (since VACUUM shouldn't
 * truncate off the destination page without having killed the referencing
 * tuple first), but the item number might well not be good.
 */</comment>
<function><type><name>bool</name></type>
<name>heap_fetch</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
		   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
		   <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
		   <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>userbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>tid</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Fetch and pin the appropriate page of the relation.
	 */</comment>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need share lock on buffer to examine tuple commit status.
	 */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We'd better check for out-of-range offnum in case of VACUUM since the
	 * TID was obtained.
	 */</comment>
	<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>offnum</name> <argument_list type="generic">&lt; <argument><expr><name>FirstOffsetNumber</name> <operator>||</operator> <name>offnum</name></expr></argument> &gt;</argument_list></name> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>userbuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * get the item line pointer corresponding to the requested tid
	 */</comment>
	<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must check for deleted tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>userbuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * fill in *tuple fields
	 */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * check tuple visibility, then release lock
	 */</comment>
	<expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>HeapTupleSatisfiesVisibility</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PredicateLockTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CheckForSerializableConflictOut</name><argument_list>(<argument><expr><name>valid</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * All checks passed, so return the tuple as valid. Caller is now
		 * responsible for releasing the buffer.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>userbuf</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Tuple failed time qual */</comment>
	<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>userbuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	heap_hot_search_buffer	- search HOT chain for tuple satisfying snapshot
 *
 * On entry, *tid is the TID of a tuple (either a simple tuple, or the root
 * of a HOT chain), and buffer is the buffer holding this tuple.  We search
 * for the first chain member satisfying the given snapshot.  If one is
 * found, we update *tid to reference that tuple's offset number, and
 * return true.  If no match, return false without modifying *tid.
 *
 * heapTuple is a caller-supplied buffer.  When a match is found, we return
 * the tuple here, in addition to updating *tid.  If no match is found, the
 * contents of this buffer on return are undefined.
 *
 * If all_dead is not NULL, we check non-visible tuples to see if they are
 * globally dead; *all_dead is set true if all members of the HOT chain
 * are vacuumable, false if not.
 *
 * Unlike heap_fetch, the caller must already have pin and (at least) share
 * lock on the buffer; it is still pinned/locked at exit.  Also unlike
 * heap_fetch, we do not report any pgstats count; caller may do so if wanted.
 */</comment>
<function><type><name>bool</name></type>
<name>heap_hot_search_buffer</name><parameter_list>(<parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
					   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>all_dead</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>first_call</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>dp</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>prev_xmax</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>at_chain_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skip</name></decl>;</decl_stmt>

	<comment type="block">/* If this is not the first call, previous call returned a (live!) tuple */</comment>
	<if_stmt><if>if <condition>(<expr><name>all_dead</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>all_dead</name> <operator>=</operator> <name>first_call</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>RecentGlobalXmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>at_chain_start</name> <operator>=</operator> <name>first_call</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>skip</name> <operator>=</operator> <operator>!</operator><name>first_call</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>

	<comment type="block">/* Scan through possible multiple members of HOT-chain */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>

		<comment type="block">/* check for bogus TID */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>offnum</name> <argument_list type="generic">&lt; <argument><expr><name>FirstOffsetNumber</name> <operator>||</operator> <name>offnum</name></expr></argument> &gt;</argument_list></name> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check for unused, dead, or redirected items */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We should only see a redirect at start of chain */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsRedirected</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>at_chain_start</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Follow the redirect */</comment>
				<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemIdGetRedirect</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>at_chain_start</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* else must be end of chain */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Shouldn't see a HEAP_ONLY tuple at chain start.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>at_chain_start</name> <operator>&amp;&amp;</operator> <call><name>HeapTupleIsHeapOnly</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The xmin should match the previous xmax value, else chain is
		 * broken.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>prev_xmax</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>prev_xmax</name></expr></argument>,
								 <argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * When first_call is true (and thus, skip is initially false) we'll
		 * return the first tuple we find.  But on later passes, heapTuple
		 * will initially be pointing to the tuple we returned last time.
		 * Returning it again would be incorrect (and would loop forever), so
		 * we skip it and return the next match we find.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For the benefit of logical decoding, have t_self point at the
			 * element of the HOT chain we're currently investigating instead
			 * of the root tuple of the HOT chain. This is important because
			 * the *Satisfies routine for historical mvcc snapshots needs the
			 * correct tid to decide about the visibility in some cases.
			 */</comment>
			<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If it's visible per the snapshot, we must return it */</comment>
			<expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>HeapTupleSatisfiesVisibility</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckForSerializableConflictOut</name><argument_list>(<argument><expr><name>valid</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>,
											<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* reset to original, non-redirected, tid */</comment>
			<expr_stmt><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PredicateLockTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>all_dead</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>all_dead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>skip</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we can't see it, maybe no one else can either.  At caller
		 * request, check whether all chain members are dead to all
		 * transactions.
		 *
		 * Note: if you change the criterion here for what is "dead", fix the
		 * planner's get_actual_variable_range() function to match.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>all_dead</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>all_dead</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>HeapTupleIsSurelyDead</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>RecentGlobalXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>all_dead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check to see if HOT chain continues past this tuple; if so fetch
		 * the next offnum and loop around.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsHotUpdated</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
				   <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>at_chain_start</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>prev_xmax</name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>				<comment type="block">/* end of chain */</comment>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	heap_get_latest_tid -  get the latest tid of a specified tuple
 *
 * Actually, this gets the latest version that is visible according to the
 * scan's snapshot.  Create a scan using SnapshotDirty to get the very latest,
 * possibly uncommitted version.
 *
 * *tid is both an input and an output parameter: it is updated to
 * show the latest version of the row.  Note that it will not be changed
 * if no version of the row passes the snapshot test.
 */</comment>
<function><type><name>void</name></type>
<name>heap_get_latest_tid</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>,
					<parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name> <init>= <expr><name><name>sscan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name> <init>= <expr><name><name>sscan</name><operator>-&gt;</operator><name>rs_snapshot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>ctid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>priorXmax</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * table_get_latest_tid verified that the passed in tid is valid.  Assume
	 * that t_ctid links are valid however - there shouldn't be invalid ones
	 * in the table.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop to chase down t_ctid links.  At top of loop, ctid is the tuple we
	 * need to examine, and *tid is the TID we will return if ctid turns out
	 * to be bogus.
	 *
	 * Note that we will loop until we reach the end of the t_ctid chain.
	 * Depending on the snapshot passed, there might be at most one visible
	 * version of the row, but we don't try to optimize for that.
	 */</comment>
	<expr_stmt><expr><name>ctid</name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>priorXmax</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>	<comment type="block">/* cannot check first XMIN */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Read, pin, and lock the page.
		 */</comment>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for bogus item number.  This is not treated as an error
		 * condition because it can happen while following a t_ctid link. We
		 * just assume that the prior tid is OK and return it unchanged.
		 */</comment>
		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>offnum</name> <argument_list type="generic">&lt; <argument><expr><name>FirstOffsetNumber</name> <operator>||</operator> <name>offnum</name></expr></argument> &gt;</argument_list></name> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* OK to access the tuple */</comment>
		<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name>ctid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * After following a t_ctid link, we might arrive at an unrelated
		 * tuple.  Check for XMIN match.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>priorXmax</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>priorXmax</name></expr></argument>, <argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check tuple visibility; if visible, set it as the new result
		 * candidate.
		 */</comment>
		<expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>HeapTupleSatisfiesVisibility</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CheckForSerializableConflictOut</name><argument_list>(<argument><expr><name>valid</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>tid</name> <operator>=</operator> <name>ctid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If there's a valid t_ctid link, follow it, else we're done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name><operator>)</operator> <operator>||</operator>
			<call><name>HeapTupleHeaderIsOnlyLocked</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>HeapTupleHeaderIndicatesMovedPartitions</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tp</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>ctid</name> <operator>=</operator> <name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>priorXmax</name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>							<comment type="block">/* end of loop */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateXmaxHintBits - update tuple hint bits after xmax transaction ends
 *
 * This is called after we have waited for the XMAX transaction to terminate.
 * If the transaction aborted, we guarantee the XMAX_INVALID hint bit will
 * be set on exit.  If the transaction committed, we set the XMAX_COMMITTED
 * hint bit if possible --- but beware that that may not yet be possible,
 * if the transaction committed asynchronously.
 *
 * Note that if the transaction was a locker only, we set HEAP_XMAX_INVALID
 * even if it commits.
 *
 * Hence callers should look only at XMAX_INVALID.
 *
 * Note this is not allowed for tuples whose xmax is a multixact.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateXmaxHintBits</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <operator>(</operator><name>HEAP_XMAX_COMMITTED</name> <operator>|</operator> <name>HEAP_XMAX_INVALID</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>HeapTupleSetHintBits</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>HEAP_XMAX_COMMITTED</name></expr></argument>,
								 <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>HeapTupleSetHintBits</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>HEAP_XMAX_INVALID</name></expr></argument>,
								 <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetBulkInsertState - prepare status object for a bulk insert
 */</comment>
<function><type><name>BulkInsertState</name></type>
<name>GetBulkInsertState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>bistate</name> <operator>=</operator> <operator>(</operator><name>BulkInsertState</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BulkInsertStateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bistate</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <call><name>GetAccessStrategy</name><argument_list>(<argument><expr><name>BAS_BULKWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<return>return <expr><name>bistate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FreeBulkInsertState - clean up after finishing a bulk insert
 */</comment>
<function><type><name>void</name></type>
<name>FreeBulkInsertState</name><parameter_list>(<parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>FreeAccessStrategy</name><argument_list>(<argument><expr><name><name>bistate</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReleaseBulkInsertStatePin - release a buffer currently held in bistate
 */</comment>
<function><type><name>void</name></type>
<name>ReleaseBulkInsertStatePin</name><parameter_list>(<parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>bistate</name><operator>-&gt;</operator><name>current_buf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	heap_insert		- insert tuple into a heap
 *
 * The new tuple is stamped with current transaction ID and the specified
 * command ID.
 *
 * See table_tuple_insert for comments about most of the input flags, except
 * that this routine directly takes a tuple rather than a slot.
 *
 * There's corresponding HEAP_INSERT_ options to all the TABLE_INSERT_
 * options, and there additionally is HEAP_INSERT_SPECULATIVE which is used to
 * implement table_tuple_insert_speculative().
 *
 * On return the header fields of *tup are updated to match the stored tuple;
 * in particular tup-&gt;t_self receives the actual TID where the tuple was
 * stored.  But note that any toasting of fields within the tuple data is NOT
 * reflected into *tup.
 */</comment>
<function><type><name>void</name></type>
<name>heap_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isFrozen</name> <init>= <expr><operator>(</operator><name>xid</name> <operator>==</operator> <name>FrozenTransactionId</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heaptup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_visible_cleared</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needwal</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>needwal</name> <operator>=</operator> <operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>HEAP_INSERT_SKIP_WAL</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gp_expand_protect_catalog_changes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(<argument><expr><literal type="string">"heap_insert"</literal></expr></argument>, <argument><expr><name>DDLNotSpecified</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Fill in tuple header fields and toast the tuple if necessary.
	 *
	 * Note: below this point, heaptup is the data we actually intend to store
	 * into the relation; tup is the caller's original untoasted data.
	 */</comment>
	<expr_stmt><expr><name>heaptup</name> <operator>=</operator> <call><name>heap_prepare_insert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>isFrozen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find buffer to insert this tuple into.  If the page is all visible,
	 * this will also pin the requisite visibility map page.
	 */</comment>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>RelationGetBufferForTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>heaptup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>,
									   <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We're about to do the actual insert -- but check for conflict first, to
	 * avoid possibly having to roll back work we've just done.
	 *
	 * This is safe without a recheck as long as there is no possibility of
	 * another process scanning the page between this check and the insert
	 * being visible to the scan (i.e., an exclusive buffer content lock is
	 * continuously held from this point until the tuple insert is visible).
	 *
	 * For a heap insert, we only need to check for table-level SSI locks. Our
	 * new tuple can't possibly conflict with existing tuple locks, and heap
	 * page locks are only consolidated versions of tuple locks; they do not
	 * lock "gaps" as index page locks do.  So we don't need to specify a
	 * buffer when making the call, which makes for a faster check.
	 */</comment>
	<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NO EREPORT(ERROR) from here till changes are logged */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RelationPutHeapTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>heaptup</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>HEAP_INSERT_SPECULATIVE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>all_visible_cleared</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
							<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>heaptup</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * XXX Should we set PageSetPrunable on this page ?
	 *
	 * The inserting transaction may eventually abort thus making this tuple
	 * DEAD and hence available for pruning. Though we don't want to optimize
	 * for aborts, if no other tuple in this page is UPDATEd/DELETEd, the
	 * aborted tuple will never be pruned until next vacuum is triggered.
	 *
	 * If you do add PageSetPrunable here, add it in heap_xlog_insert too.
	 */</comment>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><name>needwal</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_heap_insert</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_heap_header</name></type> <name>xlhdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><name>XLOG_HEAP_INSERT</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>bufflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this is a catalog, we need to transmit combocids to properly
		 * decode, so log that as well.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationIsAccessibleInLogicalDecoding</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>log_heap_new_cid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>heaptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If this is the single and first tuple on page, we can reinit the
		 * page instead of restoring the whole thing.  Set flag, and hide
		 * buffer references from XLogInsert.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>heaptup</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator>
			<call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FirstOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>info</name> <operator>|=</operator> <name>XLOG_HEAP_INIT_PAGE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bufflags</name> <operator>|=</operator> <name>REGBUF_WILL_INIT</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heaptup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>all_visible_cleared</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>HEAP_INSERT_SPECULATIVE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_INSERT_IS_SPECULATIVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heaptup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For logical decoding, we need the tuple even if we're doing a full
		 * page write, so make sure it's included even if we take a full-page
		 * image. (XXX We could alternatively store a pointer into the FPW).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>HEAP_INSERT_NO_LOGICAL</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_INSERT_CONTAINS_NEW_TUPLE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bufflags</name> <operator>|=</operator> <name>REGBUF_KEEP_DATA</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xlhdr</name><operator>.</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>heaptup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlhdr</name><operator>.</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>heaptup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlhdr</name><operator>.</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>heaptup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * note we mark xlhdr as belonging to buffer; if XLogInsert decides to
		 * write the whole page to the xlog, we don't need to store
		 * xl_heap_header in the xlog.
		 */</comment>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name> <operator>|</operator> <name>bufflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlhdr</name></expr></argument>, <argument><expr><name>SizeOfHeapHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* PG73FORMAT: write bitmap [+ padding] [+ oid] + data */</comment>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>heaptup</name><operator>-&gt;</operator><name>t_data</name></name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr></argument>,
							<argument><expr><name><name>heaptup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* filtering by origin on a row level is much more efficient */</comment>
		<expr_stmt><expr><call><name>XLogSetRecordFlags</name><argument_list>(<argument><expr><name>XLOG_INCLUDE_ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isFrozen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP_ID</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert_OverrideXid</name><argument_list>(<argument><expr><name>RM_HEAP_ID</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>FrozenTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>vmbuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If tuple is cachable, mark it for invalidation from the caches in case
	 * we abort.  Note it is OK to do this after releasing the buffer, because
	 * the heaptup data structure is all in local memory, not in the shared
	 * buffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CacheInvalidateHeapTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>heaptup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Note: speculative insertions are counted too, even if aborted later */</comment>
	<expr_stmt><expr><call><name>pgstat_count_heap_insert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If heaptup is a private copy, release it.  Don't forget to copy t_self
	 * back to the caller's image, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>heaptup</name> <operator>!=</operator> <name>tup</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>heaptup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>heaptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>needwal</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>wait_to_avoid_large_repl_lag</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for heap_insert(). Prepares a tuple for insertion. This sets the
 * tuple header fields and toasts the tuple if necessary.  Returns a toasted
 * version of the tuple if it was toasted, or the original tuple if not. Note
 * that in any case, the header fields are also set in the original tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>heap_prepare_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
					<parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isFrozen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Parallel operations are required to be strictly read-only in a parallel
	 * worker.  Parallel inserts are not safe even in the leader in the
	 * general case, because group locking means that heavyweight locks for
	 * relation extension or GIN page locks will not conflict between members
	 * of a lock group, but we don't prohibit that case here because there are
	 * useful special cases that we can safely allow, such as CREATE TABLE AS.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert tuples in a parallel worker"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XACT_MASK</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isFrozen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>HEAP_XMIN_COMMITTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP2_XACT_MASK</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>HEAP_XMAX_INVALID</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>HEAP_INSERT_FROZEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetXminFrozen</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>HeapTupleHeaderSetCmin</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>cid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* for cleanliness */</comment>
	<expr_stmt><expr><name><name>tup</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the new tuple is too big for storage or contains already toasted
	 * out-of-line attributes from some other relation, invoke the toaster.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* toast table entries should never be recursively toasted */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>tup</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>&gt;</operator> <name>TOAST_TUPLE_THRESHOLD</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>toast_insert_or_update</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>TOAST_TUPLE_TARGET</name></expr></argument>, <argument><expr><name>isFrozen</name></expr></argument>,
									  <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>tup</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	heap_multi_insert	- insert multiple tuple into a heap
 *
 * This is like heap_insert(), but inserts multiple tuples in one operation.
 * That's faster than calling heap_insert() in a loop, because when multiple
 * tuples can be inserted on a single page, we can write just a single WAL
 * record covering all of them, and only need to lock/unlock the page once.
 *
 * Note: this leaks memory into the current memory context. You can create a
 * temporary context before calling this, if that's a problem.
 */</comment>
<function><type><name>void</name></type>
<name>heap_multi_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>slots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntuples</name></decl></parameter>,
				  <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>isFrozen</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name>  <modifier>*</modifier></type><name>heaptuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndone</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>scratch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needwal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>saveFreeSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_tuple_data</name> <init>= <expr><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_cids</name> <init>= <expr><call><name>RelationIsAccessibleInLogicalDecoding</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* currently not needed (thus unsupported) for heap_multi_insert() */</comment>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>HEAP_INSERT_NO_LOGICAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>needwal</name> <operator>=</operator> <operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>HEAP_INSERT_SKIP_WAL</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>saveFreeSpace</name> <operator>=</operator> <call><name>RelationGetTargetPageFreeSpace</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
												   <argument><expr><name>HEAP_DEFAULT_FILLFACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Toast and set header data in all the slots */</comment>
	<expr_stmt><expr><name>heaptuples</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ntuples</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tts_tableOid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tts_tableOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>heaptuples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>heap_prepare_insert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>,
											<argument><expr><name>options</name></expr></argument>, <argument><expr><name>isFrozen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We're about to do the actual inserts -- but check for conflict first,
	 * to minimize the possibility of having to roll back work we've just
	 * done.
	 *
	 * A check here does not definitively prevent a serialization anomaly;
	 * that check MUST be done at least past the point of acquiring an
	 * exclusive buffer content lock on every buffer that will be affected,
	 * and MAY be done after all inserts are reflected in the buffers and
	 * those locks are released; otherwise there race condition.  Since
	 * multiple buffers can be locked and unlocked in the loop below, and it
	 * would not be feasible to identify and lock all of those buffers before
	 * the loop, we must do a final check at the end.
	 *
	 * The check here could be omitted with no loss of correctness; it is
	 * present strictly as an optimization.
	 *
	 * For heap inserts, we only need to check for table-level SSI locks. Our
	 * new tuples can't possibly conflict with existing tuple locks, and heap
	 * page locks are only consolidated versions of tuple locks; they do not
	 * lock "gaps" as index page locks do.  So we don't need to specify a
	 * buffer when making the call, which makes for a faster check.
	 */</comment>
	<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ndone</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>ndone</name> <operator>&lt;</operator> <name>ntuples</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>all_visible_cleared</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nthispage</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find buffer where at least the next tuple will fit.  If the page is
		 * all-visible, this will also pin the requisite visibility map page.
		 */</comment>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>RelationGetBufferForTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>heaptuples</name><index>[<expr><name>ndone</name></expr>]</index></name><operator>-&gt;</operator><name>t_len</name></expr></argument>,
										   <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* NO EREPORT(ERROR) from here till changes are logged */</comment>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * RelationGetBufferForTuple has ensured that the first tuple fits.
		 * Put that on the page, and then as many other tuples as fit.
		 */</comment>
		<expr_stmt><expr><call><name>RelationPutHeapTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>heaptuples</name><index>[<expr><name>ndone</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>nthispage</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>ndone</name> <operator>+</operator> <name>nthispage</name> <operator>&lt;</operator> <name>ntuples</name></expr>;</condition> <incr><expr><name>nthispage</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heaptup</name> <init>= <expr><name><name>heaptuples</name><index>[<expr><name>ndone</name> <operator>+</operator> <name>nthispage</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>heaptup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>saveFreeSpace</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>RelationPutHeapTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>heaptup</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We don't use heap_multi_insert for catalog tuples yet, but
			 * better be prepared...
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>needwal</name> <operator>&amp;&amp;</operator> <name>need_cids</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>log_heap_new_cid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>heaptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>all_visible_cleared</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
								<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * XXX Should we set PageSetPrunable on this page ? See heap_insert()
		 */</comment>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* XLOG stuff */</comment>
		<if_stmt><if>if <condition>(<expr><name>needwal</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>xl_heap_multi_insert</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><name>XLOG_HEAP2_MULTI_INSERT</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tupledata</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>totaldatalen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>scratchptr</name> <init>= <expr><name><name>scratch</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>init</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>bufflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If the page was previously empty, we can reinit the page
			 * instead of restoring the whole thing.
			 */</comment>
			<expr_stmt><expr><name>init</name> <operator>=</operator> <operator>(</operator><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>heaptuples</name><index>[<expr><name>ndone</name></expr>]</index></name><operator>-&gt;</operator><name>t_self</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator>
					<call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FirstOffsetNumber</name> <operator>+</operator> <name>nthispage</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

			<comment type="block">/* allocate xl_heap_multi_insert struct from the scratch area */</comment>
			<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_heap_multi_insert</name> <operator>*</operator><operator>)</operator> <name>scratchptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>scratchptr</name> <operator>+=</operator> <name>SizeOfHeapMultiInsert</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Allocate offsets array. Unless we're reinitializing the page,
			 * in that case the tuples are stored in order starting at
			 * FirstOffsetNumber and we don't need to store the offsets
			 * explicitly.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>init</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>scratchptr</name> <operator>+=</operator> <name>nthispage</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* the rest of the scratch space is used for tuple data */</comment>
			<expr_stmt><expr><name>tupledata</name> <operator>=</operator> <name>scratchptr</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <ternary><condition><expr><name>all_visible_cleared</name></expr> ?</condition><then> <expr><name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <name>nthispage</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Write out an xl_multi_insert_tuple and the tuple data itself
			 * for each tuple.
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nthispage</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heaptup</name> <init>= <expr><name><name>heaptuples</name><index>[<expr><name>ndone</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>xl_multi_insert_tuple</name> <modifier>*</modifier></type><name>tuphdr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>datalen</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>init</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heaptup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* xl_multi_insert_tuple needs two-byte alignment. */</comment>
				<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <operator>(</operator><name>xl_multi_insert_tuple</name> <operator>*</operator><operator>)</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>scratchptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>scratchptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuphdr</name><operator>)</operator> <operator>+</operator> <name>SizeOfMultiInsertTuple</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>heaptup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>heaptup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>heaptup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>

				<comment type="block">/* write bitmap [+ padding] [+ oid] + data */</comment>
				<expr_stmt><expr><name>datalen</name> <operator>=</operator> <name><name>heaptup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scratchptr</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>heaptup</name><operator>-&gt;</operator><name>t_data</name></name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr></argument>,
					   <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>datalen</name></name> <operator>=</operator> <name>datalen</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>scratchptr</name> <operator>+=</operator> <name>datalen</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name>totaldatalen</name> <operator>=</operator> <name>scratchptr</name> <operator>-</operator> <name>tupledata</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>scratchptr</name> <operator>-</operator> <name><name>scratch</name><operator>.</operator><name>data</name></name><operator>)</operator> <operator>&lt;</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>need_tuple_data</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_INSERT_CONTAINS_NEW_TUPLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Signal that this is the last xl_heap_multi_insert record
			 * emitted by this call to heap_multi_insert(). Needed for logical
			 * decoding so it knows when to cleanup temporary data.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ndone</name> <operator>+</operator> <name>nthispage</name> <operator>==</operator> <name>ntuples</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_INSERT_LAST_IN_MULTI</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>init</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>info</name> <operator>|=</operator> <name>XLOG_HEAP_INIT_PAGE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>bufflags</name> <operator>|=</operator> <name>REGBUF_WILL_INIT</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If we're doing logical decoding, include the new tuple data
			 * even if we take a full-page image of the page.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>need_tuple_data</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>bufflags</name> <operator>|=</operator> <name>REGBUF_KEEP_DATA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>xlrec</name></expr></argument>, <argument><expr><name>tupledata</name> <operator>-</operator> <name><name>scratch</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name> <operator>|</operator> <name>bufflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tupledata</name></expr></argument>, <argument><expr><name>totaldatalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* filtering by origin on a row level is much more efficient */</comment>
			<expr_stmt><expr><call><name>XLogSetRecordFlags</name><argument_list>(<argument><expr><name>XLOG_INCLUDE_ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP2_ID</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>vmbuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>ndone</name> <operator>+=</operator> <name>nthispage</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * We're done with the actual inserts.  Check for conflicts again, to
	 * ensure that all rw-conflicts in to these inserts are detected.  Without
	 * this final check, a sequential scan of the heap may have locked the
	 * table after the "before" check, missing one opportunity to detect the
	 * conflict, and then scanned the table before the new tuples were there,
	 * missing the other chance to detect the conflict.
	 *
	 * For heap inserts, we only need to check for table-level SSI locks. Our
	 * new tuples can't possibly conflict with existing tuple locks, and heap
	 * page locks are only consolidated versions of tuple locks; they do not
	 * lock "gaps" as index page locks do.  So we don't need to specify a
	 * buffer when making the call.
	 */</comment>
	<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If tuples are cachable, mark them for invalidation from the caches in
	 * case we abort.  Note it is OK to do this after releasing the buffer,
	 * because the heaptuples data structure is all in local memory, not in
	 * the shared buffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCatalogRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CacheInvalidateHeapTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>heaptuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* copy t_self fields back to the caller's slots */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tts_tid</name> <operator>=</operator> <name><name>heaptuples</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>t_self</name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>pgstat_count_heap_insert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ntuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>needwal</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>wait_to_avoid_large_repl_lag</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	simple_heap_insert - insert a tuple
 *
 * Currently, this routine differs from heap_insert only in supplying
 * a default command ID and not allowing access to the speedup options.
 *
 * This should be used rather than using heap_insert directly in most places
 * where we are modifying system catalogs.
 */</comment>
<function><type><name>void</name></type>
<name>simple_heap_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	frozen_heap_insert - insert a tuple and freeze it (always visible).
 *
 * Currently, this routine differs from heap_insert in supplying
 * a default command ID and a frozen transaction id. Also, the committed
 * bit of the tuple is set. This function is currently used for data that
 * goes into error tables and need to stay there even if transaction
 * aborts.
 */</comment>
<function><type><name>void</name></type>
<name>frozen_heap_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>heap_insert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FrozenTransactionId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given infomask/infomask2, compute the bits that must be saved in the
 * "infobits" field of xl_heap_delete, xl_heap_update, xl_heap_lock,
 * xl_heap_lock_updated WAL records.
 *
 * See fix_infomask_from_infobits.
 */</comment>
<function><type><specifier>static</specifier> <name>uint8</name></type>
<name>compute_infobits</name><parameter_list>(<parameter><decl><type><name>uint16</name></type> <name>infomask</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>infomask2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return
		<expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>XLHL_XMAX_IS_MULTI</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><operator>(</operator><name>infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_LOCK_ONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>XLHL_XMAX_LOCK_ONLY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><operator>(</operator><name>infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_EXCL_LOCK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>XLHL_XMAX_EXCL_LOCK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
	<comment type="block">/* note we ignore HEAP_XMAX_SHR_LOCK here */</comment>
		<operator>(</operator><ternary><condition><expr><operator>(</operator><name>infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_KEYSHR_LOCK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>XLHL_XMAX_KEYSHR_LOCK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><operator>(</operator><name>infomask2</name> <operator>&amp;</operator> <name>HEAP_KEYS_UPDATED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then>
		 <expr><name>XLHL_KEYS_UPDATED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given two versions of the same t_infomask for a tuple, compare them and
 * return whether the relevant status for a tuple Xmax has changed.  This is
 * used after a buffer lock has been released and reacquired: we want to ensure
 * that the tuple state continues to be the same it was when we previously
 * examined it.
 *
 * Note the Xmax field itself must be compared separately.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>xmax_infomask_changed</name><parameter_list>(<parameter><decl><type><name>uint16</name></type> <name>new_infomask</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>old_infomask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint16</name></type> <name>interesting</name> <init>=
	<expr><name>HEAP_XMAX_IS_MULTI</name> <operator>|</operator> <name>HEAP_XMAX_LOCK_ONLY</name> <operator>|</operator> <name>HEAP_LOCK_MASK</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>new_infomask</name> <operator>&amp;</operator> <name>interesting</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>old_infomask</name> <operator>&amp;</operator> <name>interesting</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	heap_delete - delete a tuple
 *
 * See table_tuple_delete() for an explanation of the parameters, except that
 * this routine directly takes a tuple rather than a slot.
 *
 * In the failure cases, the routine fills *tmfd with the tuple's t_ctid,
 * t_xmax (resolving a possible MultiXact, if necessary), and t_cmax (the last
 * only for TM_SelfModified, since we cannot obtain cmax from a combocid
 * generated by another transaction).
 */</comment>
<function><type><name>TM_Result</name></type>
<name>heap_delete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
			<parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>,
			<parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changingPart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TM_Result</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>block</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>new_xmax</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>new_infomask</name></decl>,
				<decl><type ref="prev"/><name>new_infomask2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_tuple_lock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>iscombo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_visible_cleared</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>old_key_tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* replica identity of the tuple */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>old_key_copied</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>gp_expand_protect_catalog_changes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Forbid this during a parallel operation, lest it allocate a combocid.
	 * Other workers might need that combocid for visibility checks, and we
	 * have no provision for broadcasting it to them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot delete tuples during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before locking the buffer, pin the visibility map page if it appears to
	 * be necessary.  Since we haven't got the lock yet, someone else might be
	 * in the middle of changing this, so we'll need to recheck after we have
	 * the lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we didn't pin the visibility map page and the page has become all
	 * visible while we were busy locking the buffer, we'll have to unlock and
	 * re-lock, to avoid holding the buffer lock across an I/O.  That's a bit
	 * unfortunate, but hopefully shouldn't happen often.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>vmbuffer</name> <operator>==</operator> <name>InvalidBuffer</name> <operator>&amp;&amp;</operator> <call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>

<label><name>l1</name>:</label>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleSatisfiesUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_Invisible</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attempted to delete invisible tuple"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_BeingModified</name> <operator>&amp;&amp;</operator> <name>wait</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xwait</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint16</name></type>		<name>infomask</name></decl>;</decl_stmt>

		<comment type="block">/* must copy state data before unlocking buffer */</comment>
		<expr_stmt><expr><name>xwait</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>infomask</name> <operator>=</operator> <name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sleep until concurrent transaction ends -- except when there's a
		 * single locker and it's our own transaction.  Note we don't care
		 * which lock mode the locker has, because we need the strongest one.
		 *
		 * Before sleeping, we need to acquire tuple lock to establish our
		 * priority for the tuple (see heap_lock_tuple).  LockTuple will
		 * release us when we are next-in-line for the tuple.
		 *
		 * If we are forced to "start over" below, we keep the tuple lock;
		 * this arranges that we stay at the head of the line while rechecking
		 * tuple state.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>current_is_member</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>DoesMultiXactIdConflict</name><argument_list>(<argument><expr><operator>(</operator><name>MultiXactId</name><operator>)</operator> <name>xwait</name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>,
										<argument><expr><name>LockTupleExclusive</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_is_member</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Acquire the lock, if necessary (but skip it when we're
				 * requesting a lock and already have one; avoids deadlock).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>current_is_member</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>heap_acquire_tuplock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tp</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><name>LockTupleExclusive</name></expr></argument>,
										 <argument><expr><name>LockWaitBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>have_tuple_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* wait for multixact */</comment>
				<expr_stmt><expr><call><name>MultiXactIdWait</name><argument_list>(<argument><expr><operator>(</operator><name>MultiXactId</name><operator>)</operator> <name>xwait</name></expr></argument>, <argument><expr><name>MultiXactStatusUpdate</name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>,
								<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tp</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><name>XLTW_Delete</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If xwait had just locked the tuple then some other xact
				 * could update this tuple before we get to this point.  Check
				 * for xmax change, and start over if so.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>xmax_infomask_changed</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>l1</name>;</goto></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * You might think the multixact is necessarily done here, but not
			 * so: it could have surviving members, namely our own xact or
			 * other subxacts of this backend.  It is legal for us to delete
			 * the tuple in either case, however (the latter case is
			 * essentially a situation of upgrading our former shared lock to
			 * exclusive).  We don't bother changing the on-disk hint bits
			 * since we are about to overwrite the xmax altogether.
			 */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Wait for regular transaction to end; but first, acquire tuple
			 * lock.
			 */</comment>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_acquire_tuplock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tp</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><name>LockTupleExclusive</name></expr></argument>,
								 <argument><expr><name>LockWaitBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>have_tuple_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tp</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><name>XLTW_Delete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * xwait is done, but if xwait had just locked the tuple then some
			 * other xact could update this tuple before we get to this point.
			 * Check for xmax change, and start over if so.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>xmax_infomask_changed</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>l1</name>;</goto></block_content></block></if></if_stmt>

			<comment type="block">/* Otherwise check if it committed or aborted */</comment>
			<expr_stmt><expr><call><name>UpdateXmaxHintBits</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We may overwrite if previous xmax aborted, or if it committed but
		 * only locked the tuple without updating it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name><operator>)</operator> <operator>||</operator>
			<call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>HeapTupleHeaderIsOnlyLocked</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tp</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				 <call><name>HeapTupleHeaderIndicatesMovedPartitions</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Updated</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Deleted</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>crosscheck</name> <operator>!=</operator> <name>InvalidSnapshot</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>==</operator> <name>TM_Ok</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Perform additional check for transaction-snapshot mode RI updates */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleSatisfiesVisibility</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>, <argument><expr><name>crosscheck</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Updated</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>TM_Ok</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>==</operator> <name>TM_SelfModified</name> <operator>||</operator>
			   <name>result</name> <operator>==</operator> <name>TM_Updated</name> <operator>||</operator>
			   <name>result</name> <operator>==</operator> <name>TM_Deleted</name> <operator>||</operator>
			   <name>result</name> <operator>==</operator> <name>TM_BeingModified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>!=</operator> <name>TM_Updated</name> <operator>||</operator>
			   <operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tp</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>ctid</name></name> <operator>=</operator> <name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_SelfModified</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetCmax</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <name>InvalidCommandId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>have_tuple_lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockTupleTuplock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tp</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><name>LockTupleExclusive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>vmbuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We're about to do the actual delete -- check for conflict first, to
	 * avoid possibly having to roll back work we've just done.
	 *
	 * This is safe without a recheck as long as there is no possibility of
	 * another process scanning the page between this check and the delete
	 * being visible to the scan (i.e., an exclusive buffer content lock is
	 * continuously held from this point until the tuple delete is visible).
	 */</comment>
	<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* replace cid with a combo cid if necessary */</comment>
	<expr_stmt><expr><call><name>HeapTupleHeaderAdjustCmax</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iscombo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute replica identity tuple before entering the critical section so
	 * we don't PANIC upon a memory allocation failure.
	 */</comment>
	<expr_stmt><expr><name>old_key_tuple</name> <operator>=</operator> <call><name>ExtractReplicaIdentity</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_key_copied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is the first possibly-multixact-able operation in the current
	 * transaction, set my per-backend OldestMemberMXactId setting. We can be
	 * certain that the transaction will never become a member of any older
	 * MultiXactIds than that.  (We have to do this even if we end up just
	 * using our own TransactionId below, since some other backend could
	 * incorporate our XID into a MultiXact immediately afterwards.)
	 */</comment>
	<expr_stmt><expr><call><name>MultiXactIdSetOldestMember</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>compute_new_xmax_infomask</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>, <argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>,
							  <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>LockTupleExclusive</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>new_xmax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this transaction commits, the tuple will become DEAD sooner or
	 * later.  Set flag that this page is a candidate for pruning once our xid
	 * falls below the OldestXmin horizon.  If the transaction finally aborts,
	 * the subsequent page pruning will be a no-op and the hint will be
	 * cleared.
	 */</comment>
	<expr_stmt><expr><call><name>PageSetPrunable</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>all_visible_cleared</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* store transaction information of xact deleting the tuple */</comment>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XMAX_BITS</name> <operator>|</operator> <name>HEAP_MOVED</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>new_infomask</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>|=</operator> <name>new_infomask2</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderClearHotUpdated</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>new_xmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetCmax</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>iscombo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Make sure there is no forward chain link in t_ctid */</comment>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name><name>tp</name><operator>.</operator><name>t_self</name></name></expr>;</expr_stmt>

	<comment type="block">/* Signal that this is actually a move into another partition */</comment>
	<if_stmt><if>if <condition>(<expr><name>changingPart</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetMovedPartitions</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XLOG stuff
	 *
	 * NB: heap_abort_speculative() uses the same xlog record and replay
	 * routines.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_heap_delete</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_heap_header</name></type> <name>xlhdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<comment type="block">/* For logical decode we need combocids to properly decode the catalog */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationIsAccessibleInLogicalDecoding</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>log_heap_new_cid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>all_visible_cleared</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_DELETE_ALL_VISIBLE_CLEARED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>changingPart</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_DELETE_IS_PARTITION_MOVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>infobits_set</name></name> <operator>=</operator> <call><name>compute_infobits</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
											  <argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tp</name><operator>.</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>xmax</name></name> <operator>=</operator> <name>new_xmax</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>old_key_tuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_FULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_DELETE_CONTAINS_OLD_TUPLE</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_DELETE_CONTAINS_OLD_KEY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Log replica identity of the deleted tuple if there is one
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>old_key_tuple</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>xlhdr</name><operator>.</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>old_key_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlhdr</name><operator>.</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>old_key_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlhdr</name><operator>.</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>old_key_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlhdr</name></expr></argument>, <argument><expr><name>SizeOfHeapHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>old_key_tuple</name><operator>-&gt;</operator><name>t_data</name></name>
							 <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr></argument>,
							 <argument><expr><name><name>old_key_tuple</name><operator>-&gt;</operator><name>t_len</name></name>
							 <operator>-</operator> <name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* filtering by origin on a row level is much more efficient */</comment>
		<expr_stmt><expr><call><name>XLogSetRecordFlags</name><argument_list>(<argument><expr><name>XLOG_INCLUDE_ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>vmbuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the tuple has toasted out-of-line attributes, we need to delete
	 * those items too.  We have to do this before releasing the buffer
	 * because we need to look at the contents of the tuple, but it's OK to
	 * release the content lock on the buffer first.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* toast table entries should never be recursively toasted */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>toast_delete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Mark tuple for invalidation from system caches at next command
	 * boundary. We have to do this before releasing the buffer because we
	 * need to look at the contents of the tuple.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateHeapTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now we can release the buffer */</comment>
	<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release the lmgr tuple lock, if we had it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_tuple_lock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockTupleTuplock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tp</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><name>LockTupleExclusive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_count_heap_delete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>old_key_tuple</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>old_key_copied</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>old_key_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>TM_Ok</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	simple_heap_delete - delete a tuple
 *
 * This routine may be used to delete a tuple when concurrent updates of
 * the target tuple are not expected (for example, because we have a lock
 * on the relation associated with the tuple).  Any failure is reported
 * via ereport().
 */</comment>
<function><type><name>void</name></type>
<name>simple_heap_delete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TM_Result</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_FailureData</name></type> <name>tmfd</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_delete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>,
						 <argument><expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument> <comment type="block">/* wait for commit */</comment> ,
						 <argument><expr><operator>&amp;</operator><name>tmfd</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* changingPart */</comment> )</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TM_SelfModified</name></expr>:</case>
			<comment type="block">/* Tuple was already updated in current command? */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tuple already updated by self"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TM_Ok</name></expr>:</case>
			<comment type="block">/* done successfully */</comment>
			<break>break;</break>

		<case>case <expr><name>TM_Updated</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tuple concurrently updated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TM_Deleted</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tuple concurrently deleted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized heap_delete status: %u"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 *	heap_update - replace a tuple
 *
 * See table_tuple_update() for an explanation of the parameters, except that
 * this routine directly takes a tuple rather than a slot.
 *
 * In the failure cases, the routine fills *tmfd with the tuple's t_ctid,
 * t_xmax (resolving a possible MultiXact, if necessary), and t_cmax (the last
 * only for TM_SelfModified, since we cannot obtain cmax from a combocid
 * generated by another transaction).
 */</comment>
<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>heap_update_internal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>otid</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>newtup</name></decl></parameter>,
			<parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>,
			<parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>, <parameter><decl><type><name>LockTupleMode</name> <modifier>*</modifier></type><name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>simple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TM_Result</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>hot_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>key_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>id_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>interesting_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>modified_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>oldtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heaptup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>old_key_tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>old_key_copied</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>block</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactStatus</name></type> <name>mxact_status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>,
				<decl><type ref="prev"/><name>newbuf</name></decl>,
				<decl><type ref="prev"/><name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>,
				<decl><type ref="prev"/><name>vmbuffer_new</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_toast</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>newtupsize</name></decl>,
				<decl><type ref="prev"/><name>pagefree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_tuple_lock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>iscombo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_hot_update</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hot_attrs_checked</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>key_intact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_visible_cleared</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_visible_cleared_new</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>checked_lockers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>locker_remains</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmax_new_tuple</name></decl>,
				<decl><type ref="prev"/><name>xmax_old_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>infomask_old_tuple</name></decl>,
				<decl><type ref="prev"/><name>infomask2_old_tuple</name></decl>,
				<decl><type ref="prev"/><name>infomask_new_tuple</name></decl>,
				<decl><type ref="prev"/><name>infomask2_new_tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>otid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>gp_expand_protect_catalog_changes</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Forbid this during a parallel operation, lest it allocate a combocid.
	 * Other workers might need that combocid for visibility checks, and we
	 * have no provision for broadcasting it to them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot update tuples during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fetch the list of attributes to be checked for various operations.
	 *
	 * For HOT considerations, this is wasted effort if we fail to update or
	 * have to put the new tuple on a different page.  But we must compute the
	 * list before obtaining buffer lock --- in the worst case, if we are
	 * doing an update on one of the relevant system catalogs, we could
	 * deadlock if we try to fetch the list later.  In any case, the relcache
	 * caches the data so this is usually pretty cheap.
	 *
	 * We also need columns used by the replica identity and columns that are
	 * considered the "key" of rows in the table.
	 *
	 * Note that we get copies of each bitmap, so we need not worry about
	 * relcache flush happening midway through.
	 */</comment>
	<expr_stmt><expr><name>hot_attrs</name> <operator>=</operator> <call><name>RelationGetIndexAttrBitmap</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>INDEX_ATTR_BITMAP_ALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>key_attrs</name> <operator>=</operator> <call><name>RelationGetIndexAttrBitmap</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>INDEX_ATTR_BITMAP_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>id_attrs</name> <operator>=</operator> <call><name>RelationGetIndexAttrBitmap</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
										  <argument><expr><name>INDEX_ATTR_BITMAP_IDENTITY_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>otid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>interesting_attrs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the page is already full, there is hardly any chance of doing a HOT
	 * update on this page. It might be wasteful effort to look for index
	 * column updates only to later reject HOT updates for lack of space in
	 * the same page. So we be conservative and only fetch hot_attrs if the
	 * page is not already full. Since we are already holding a pin on the
	 * buffer, there is no chance that the buffer can get cleaned up
	 * concurrently and even if that was possible, in the worst case we lose a
	 * chance to do a HOT update.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsFull</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>interesting_attrs</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>interesting_attrs</name></expr></argument>, <argument><expr><name>hot_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hot_attrs_checked</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>interesting_attrs</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>interesting_attrs</name></expr></argument>, <argument><expr><name>key_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>interesting_attrs</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>interesting_attrs</name></expr></argument>, <argument><expr><name>id_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before locking the buffer, pin the visibility map page if it appears to
	 * be necessary.  Since we haven't got the lock yet, someone else might be
	 * in the middle of changing this, so we'll need to recheck after we have
	 * the lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>otid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in enough data in oldtup for HeapDetermineModifiedColumns to work
	 * properly.
	 */</comment>
	<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>otid</name></expr>;</expr_stmt>

	<comment type="block">/* the new tuple is ready, except for this: */</comment>
	<expr_stmt><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Determine columns modified by the update. */</comment>
	<expr_stmt><expr><name>modified_attrs</name> <operator>=</operator> <call><name>HeapDetermineModifiedColumns</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>interesting_attrs</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're not updating any "key" column, we can grab a weaker lock type.
	 * This allows for more concurrency when we are running simultaneously
	 * with foreign key checks.
	 *
	 * Note that if a column gets detoasted while executing the update, but
	 * the value ends up being the same, this test will fail and we will use
	 * the stronger lock.  This is acceptable; the important case to optimize
	 * is updates that don't manipulate key columns, not those that
	 * serendipitiously arrive at the same key values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>modified_attrs</name></expr></argument>, <argument><expr><name>key_attrs</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>lockmode</name> <operator>=</operator> <name>LockTupleNoKeyExclusive</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mxact_status</name> <operator>=</operator> <name>MultiXactStatusNoKeyUpdate</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>key_intact</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this is the first possibly-multixact-able operation in the
		 * current transaction, set my per-backend OldestMemberMXactId
		 * setting. We can be certain that the transaction will never become a
		 * member of any older MultiXactIds than that.  (We have to do this
		 * even if we end up just using our own TransactionId below, since
		 * some other backend could incorporate our XID into a MultiXact
		 * immediately afterwards.)
		 */</comment>
		<expr_stmt><expr><call><name>MultiXactIdSetOldestMember</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>lockmode</name> <operator>=</operator> <name>LockTupleExclusive</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mxact_status</name> <operator>=</operator> <name>MultiXactStatusUpdate</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>key_intact</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Note: beyond this point, use oldtup not otid to refer to old tuple.
	 * otid may very well point at newtup-&gt;t_self, which we will overwrite
	 * with the new tuple's location, so there's great risk of confusion if we
	 * use otid anymore.
	 */</comment>

<label><name>l2</name>:</label>
	<expr_stmt><expr><name>checked_lockers</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>locker_remains</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleSatisfiesUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* see below about the "no wait" case */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>!=</operator> <name>TM_BeingModified</name> <operator>||</operator> <name>wait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_Invisible</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attempted to update invisible tuple"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_BeingModified</name> <operator>&amp;&amp;</operator> <name>wait</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xwait</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint16</name></type>		<name>infomask</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>can_continue</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * XXX note that we don't consider the "no wait" case here.  This
		 * isn't a problem currently because no caller uses that case, but it
		 * should be fixed if such a caller is introduced.  It wasn't a
		 * problem previously because this code would always wait, but now
		 * that some tuple locks do not conflict with one of the lock modes we
		 * use, it is possible that this case is interesting to handle
		 * specially.
		 *
		 * This may cause failures with third-party code that calls
		 * heap_update directly.
		 */</comment>

		<comment type="block">/* must copy state data before unlocking buffer */</comment>
		<expr_stmt><expr><name>xwait</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>infomask</name> <operator>=</operator> <name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we have to do something about the existing locker.  If it's a
		 * multi, sleep on it; we might be awakened before it is completely
		 * gone (or even not sleep at all in some cases); we need to preserve
		 * it as locker, unless it is gone completely.
		 *
		 * If it's not a multi, we need to check for sleeping conditions
		 * before actually going to sleep.  If the update doesn't conflict
		 * with the locks, we just continue without sleeping (but making sure
		 * it is preserved).
		 *
		 * Before sleeping, we need to acquire tuple lock to establish our
		 * priority for the tuple (see heap_lock_tuple).  LockTuple will
		 * release us when we are next-in-line for the tuple.  Note we must
		 * not acquire the tuple lock until we're sure we're going to sleep;
		 * otherwise we're open for race conditions with other transactions
		 * holding the tuple lock which sleep on us.
		 *
		 * If we are forced to "start over" below, we keep the tuple lock;
		 * this arranges that we stay at the head of the line while rechecking
		 * tuple state.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>update_xact</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>remain</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>current_is_member</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>DoesMultiXactIdConflict</name><argument_list>(<argument><expr><operator>(</operator><name>MultiXactId</name><operator>)</operator> <name>xwait</name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>,
										<argument><expr><operator>*</operator><name>lockmode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_is_member</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Acquire the lock, if necessary (but skip it when we're
				 * requesting a lock and already have one; avoids deadlock).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>current_is_member</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>heap_acquire_tuplock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldtup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>*</operator><name>lockmode</name></expr></argument>,
										 <argument><expr><name>LockWaitBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>have_tuple_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* wait for multixact */</comment>
				<expr_stmt><expr><call><name>MultiXactIdWait</name><argument_list>(<argument><expr><operator>(</operator><name>MultiXactId</name><operator>)</operator> <name>xwait</name></expr></argument>, <argument><expr><name>mxact_status</name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>,
								<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>XLTW_Update</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>remain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>checked_lockers</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>locker_remains</name> <operator>=</operator> <name>remain</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If xwait had just locked the tuple then some other xact
				 * could update this tuple before we get to this point.  Check
				 * for xmax change, and start over if so.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>xmax_infomask_changed</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
										  <argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>l2</name>;</goto></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Note that the multixact may not be done by now.  It could have
			 * surviving members; our own xact or other subxacts of this
			 * backend, and also any other concurrent transaction that locked
			 * the tuple with KeyShare if we only got TupleLockUpdate.  If
			 * this is the case, we have to be careful to mark the updated
			 * tuple with the surviving members in Xmax.
			 *
			 * Note that there could have been another update in the
			 * MultiXact. In that case, we need to check whether it committed
			 * or aborted. If it aborted we are safe to update it again;
			 * otherwise there is an update conflict, and we have to return
			 * TableTuple{Deleted, Updated} below.
			 *
			 * In the LockTupleExclusive case, we still need to preserve the
			 * surviving members: those would include the tuple locks we had
			 * before this one, which are important to keep in case this
			 * subxact aborts.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>update_xact</name> <operator>=</operator> <call><name>HeapTupleGetUpdateXid</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>update_xact</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * There was no UPDATE in the MultiXact; or it aborted. No
			 * TransactionIdIsInProgress() call needed here, since we called
			 * MultiXactIdWait() above.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>update_xact</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>TransactionIdDidAbort</name><argument_list>(<argument><expr><name>update_xact</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>can_continue</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The only locker is ourselves; we can avoid grabbing the tuple
			 * lock here, but must preserve our locking information.
			 */</comment>
			<expr_stmt><expr><name>checked_lockers</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>locker_remains</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>can_continue</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>HEAP_XMAX_IS_KEYSHR_LOCKED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>key_intact</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If it's just a key-share locker, and we're not changing the key
			 * columns, we don't need to wait for it to end; but we need to
			 * preserve it as locker.
			 */</comment>
			<expr_stmt><expr><name>checked_lockers</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>locker_remains</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>can_continue</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Wait for regular transaction to end; but first, acquire tuple
			 * lock.
			 */</comment>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_acquire_tuplock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldtup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>*</operator><name>lockmode</name></expr></argument>,
								 <argument><expr><name>LockWaitBlock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>have_tuple_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>.</operator><name>t_self</name></name></expr></argument>,
							  <argument><expr><name>XLTW_Update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>checked_lockers</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * xwait is done, but if xwait had just locked the tuple then some
			 * other xact could update this tuple before we get to this point.
			 * Check for xmax change, and start over if so.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>xmax_infomask_changed</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>,
									 <argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>l2</name>;</goto></block_content></block></if></if_stmt>

			<comment type="block">/* Otherwise check if it committed or aborted */</comment>
			<expr_stmt><expr><call><name>UpdateXmaxHintBits</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>can_continue</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>can_continue</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				 <call><name>HeapTupleHeaderIndicatesMovedPartitions</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Updated</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Deleted</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>crosscheck</name> <operator>!=</operator> <name>InvalidSnapshot</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>==</operator> <name>TM_Ok</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Perform additional check for transaction-snapshot mode RI updates */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleSatisfiesVisibility</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>, <argument><expr><name>crosscheck</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Updated</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>TM_Ok</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>==</operator> <name>TM_SelfModified</name> <operator>||</operator>
			   <name>result</name> <operator>==</operator> <name>TM_Updated</name> <operator>||</operator>
			   <name>result</name> <operator>==</operator> <name>TM_Deleted</name> <operator>||</operator>
			   <name>result</name> <operator>==</operator> <name>TM_BeingModified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>!=</operator> <name>TM_Updated</name> <operator>||</operator>
			   <operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>ctid</name></name> <operator>=</operator> <name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_SelfModified</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetCmax</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <name>InvalidCommandId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>have_tuple_lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockTupleTuplock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldtup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>*</operator><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>vmbuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>hot_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>key_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>id_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>modified_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>interesting_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we didn't pin the visibility map page and the page has become all
	 * visible while we were busy locking the buffer, or during some
	 * subsequent window during which we had it unlocked, we'll have to unlock
	 * and re-lock, to avoid holding the buffer lock across an I/O.  That's a
	 * bit unfortunate, especially since we'll now have to recheck whether the
	 * tuple has been locked or updated under us, but hopefully it won't
	 * happen very often.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>vmbuffer</name> <operator>==</operator> <name>InvalidBuffer</name> <operator>&amp;&amp;</operator> <call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>l2</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fill in transaction status data */</comment>

	<comment type="block">/*
	 * If the tuple we're updating is locked, we need to preserve the locking
	 * info in the old tuple's Xmax.  Prepare a new Xmax value for this.
	 */</comment>
	<expr_stmt><expr><call><name>compute_new_xmax_infomask</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
							  <argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>,
							  <argument><expr><name>xid</name></expr></argument>, <argument><expr><operator>*</operator><name>lockmode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>xmax_old_tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>infomask_old_tuple</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>infomask2_old_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And also prepare an Xmax value for the new copy of the tuple.  If there
	 * was no xmax previously, or there was one but all lockers are now gone,
	 * then use InvalidXid; otherwise, get the xmax from the old tuple.  (In
	 * rare cases that might also be InvalidXid and yet not have the
	 * HEAP_XMAX_INVALID bit set; that's fine.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name><operator>)</operator> <operator>||</operator>
		<call><name>HEAP_LOCKED_UPGRADED</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name>checked_lockers</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>locker_remains</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xmax_new_tuple</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>xmax_new_tuple</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xmax_new_tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>infomask_new_tuple</name> <operator>=</operator> <name>HEAP_XMAX_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>infomask2_new_tuple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If we found a valid Xmax for the new tuple, then the infomask bits
		 * to use on the new tuple depend on what was there on the old one.
		 * Note that since we're doing an update, the only possibility is that
		 * the lockers had FOR KEY SHARE lock.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GetMultiXactIdHintBits</name><argument_list>(<argument><expr><name>xmax_new_tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>infomask_new_tuple</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>infomask2_new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>infomask_new_tuple</name> <operator>=</operator> <name>HEAP_XMAX_KEYSHR_LOCK</name> <operator>|</operator> <name>HEAP_XMAX_LOCK_ONLY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>infomask2_new_tuple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Prepare the new tuple with the appropriate initial values of Xmin and
	 * Xmax, as well as initial infomask bits as computed above.
	 */</comment>
	<expr_stmt><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XACT_MASK</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP2_XACT_MASK</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetCmin</name><argument_list>(<argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>cid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>HEAP_UPDATED</name> <operator>|</operator> <name>infomask_new_tuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>|=</operator> <name>infomask2_new_tuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>xmax_new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace cid with a combo cid if necessary.  Note that we already put
	 * the plain cid into the new tuple.
	 */</comment>
	<expr_stmt><expr><call><name>HeapTupleHeaderAdjustCmax</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iscombo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the toaster needs to be activated, OR if the new tuple will not fit
	 * on the same page as the old, then we need to release the content lock
	 * (but not the pin!) on the old tuple's buffer while we are off doing
	 * TOAST and/or table-file-extension work.  We must mark the old tuple to
	 * show that it's locked, else other processes may try to update it
	 * themselves.
	 *
	 * We need to invoke the toaster if there are already any out-of-line
	 * toasted values present, or if the new tuple is over-threshold.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* toast table entries should never be recursively toasted */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>need_toast</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>need_toast</name> <operator>=</operator> <operator>(</operator><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>)</argument_list></call> <operator>||</operator>
					  <call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call> <operator>||</operator>
					  <name><name>newtup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>&gt;</operator> <name>TOAST_TUPLE_THRESHOLD</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>pagefree</name> <operator>=</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newtupsize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_toast</name> <operator>||</operator> <name>newtupsize</name> <operator>&gt;</operator> <name>pagefree</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmax_lock_old_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint16</name></type>		<name>infomask_lock_old_tuple</name></decl>,
					<decl><type ref="prev"/><name>infomask2_lock_old_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>cleared_all_frozen</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * To prevent concurrent sessions from updating the tuple, we have to
		 * temporarily mark it locked, while we release the page-level lock.
		 *
		 * To satisfy the rule that any xid potentially appearing in a buffer
		 * written out to disk, we unfortunately have to WAL log this
		 * temporary modification.  We can reuse xl_heap_lock for this
		 * purpose.  If we crash/error before following through with the
		 * actual update, xmax will be of an aborted transaction, allowing
		 * other sessions to proceed.
		 */</comment>

		<comment type="block">/*
		 * Compute xmax / infomask appropriate for locking the tuple. This has
		 * to be done separately from the combo that's going to be used for
		 * updating, because the potentially created multixact would otherwise
		 * be wrong.
		 */</comment>
		<expr_stmt><expr><call><name>compute_new_xmax_infomask</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
								  <argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>,
								  <argument><expr><name>xid</name></expr></argument>, <argument><expr><operator>*</operator><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>xmax_lock_old_tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>infomask_lock_old_tuple</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>infomask2_lock_old_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>infomask_lock_old_tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Clear obsolete visibility flags ... */</comment>
		<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XMAX_BITS</name> <operator>|</operator> <name>HEAP_MOVED</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleClearHotUpdated</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ... and store info about transaction updating this tuple */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xmax_lock_old_tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>xmax_lock_old_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>infomask_lock_old_tuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>|=</operator> <name>infomask2_lock_old_tuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetCmax</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>iscombo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* temporarily make it look not-updated, but locked */</comment>
		<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name><name>oldtup</name><operator>.</operator><name>t_self</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Clear all-frozen bit on visibility map if needed. We could
		 * immediately reset ALL_VISIBLE, but given that the WAL logging
		 * overhead would be unchanged, that doesn't seem necessarily
		 * worthwhile.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>,
								<argument><expr><name>VISIBILITYMAP_ALL_FROZEN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cleared_all_frozen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_heap_lock</name></type> <name>xlrec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>.</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>locking_xid</name></name> <operator>=</operator> <name>xmax_lock_old_tuple</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>infobits_set</name></name> <operator>=</operator> <call><name>compute_infobits</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
												  <argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>=</operator>
				<ternary><condition><expr><name>cleared_all_frozen</name></expr> ?</condition><then> <expr><name>XLH_LOCK_ALL_FROZEN_CLEARED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Let the toaster do its thing, if needed.
		 *
		 * Note: below this point, heaptup is the data we actually intend to
		 * store into the relation; newtup is the caller's original untoasted
		 * data.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>need_toast</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Note we always use WAL and FSM during updates */</comment>
			<expr_stmt><expr><name>heaptup</name> <operator>=</operator> <call><name>toast_insert_or_update</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>,
											 <argument><expr><name>TOAST_TUPLE_TARGET</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newtupsize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>heaptup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>heaptup</name> <operator>=</operator> <name>newtup</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Now, do we need a new page for the tuple, or not?  This is a bit
		 * tricky since someone else could have added tuples to the page while
		 * we weren't looking.  We have to recheck the available space after
		 * reacquiring the buffer lock.  But don't bother to do that if the
		 * former amount of free space is still not enough; it's unlikely
		 * there's more free now than before.
		 *
		 * What's more, if we need to get a new page, we will need to acquire
		 * buffer locks on both old and new pages.  To avoid deadlock against
		 * some other backend trying to get the same two locks in the other
		 * order, we must be consistent about the order we get the locks in.
		 * We use the rule "lock the lower-numbered page of the relation
		 * first".  To implement this, we must do RelationGetBufferForTuple
		 * while not holding the lock on the old page, and we must rely on it
		 * to get the locks on both pages in the correct order.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>newtupsize</name> <operator>&gt;</operator> <name>pagefree</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Assume there's no chance to put heaptup on same page. */</comment>
			<expr_stmt><expr><name>newbuf</name> <operator>=</operator> <call><name>RelationGetBufferForTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>heaptup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>,
											   <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>vmbuffer_new</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Re-acquire the lock on the old tuple's page. */</comment>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Re-check using the up-to-date free space */</comment>
			<expr_stmt><expr><name>pagefree</name> <operator>=</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newtupsize</name> <operator>&gt;</operator> <name>pagefree</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Rats, it doesn't fit anymore.  We must now unlock and
				 * relock to avoid deadlock.  Fortunately, this path should
				 * seldom be taken.
				 */</comment>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>newbuf</name> <operator>=</operator> <call><name>RelationGetBufferForTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>heaptup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>,
												   <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>vmbuffer_new</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* OK, it fits here, so we're done. */</comment>
				<expr_stmt><expr><name>newbuf</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No TOAST work needed, and it'll fit on same page */</comment>
		<expr_stmt><expr><name>newbuf</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>heaptup</name> <operator>=</operator> <name>newtup</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We're about to do the actual update -- check for conflict first, to
	 * avoid possibly having to roll back work we've just done.
	 *
	 * This is safe without a recheck as long as there is no possibility of
	 * another process scanning the pages between this check and the update
	 * being visible to the scan (i.e., exclusive buffer content lock(s) are
	 * continuously held from this point until the tuple update is visible).
	 *
	 * For the new tuple the only check needed is at the relation level, but
	 * since both tuples are in the same relation and the check for oldtup
	 * will include checking the relation level, there is no benefit to a
	 * separate check for the new tuple.
	 */</comment>
	<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * At this point newbuf and buffer are both pinned and locked, and newbuf
	 * has enough space for the new tuple.  If they are the same buffer, only
	 * one pin is held.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>newbuf</name> <operator>==</operator> <name>buffer</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Since the new tuple is going into the same page, we might be able
		 * to do a HOT update.  Check if any of the index columns have been
		 * changed. If the page was already full, we may have skipped checking
		 * for index columns, and also can't do a HOT update.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hot_attrs_checked</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>modified_attrs</name></expr></argument>, <argument><expr><name>hot_attrs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>use_hot_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Set a hint that the old page could use prune/defrag */</comment>
		<expr_stmt><expr><call><name>PageSetFull</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Compute replica identity tuple before entering the critical section so
	 * we don't PANIC upon a memory allocation failure.
	 * ExtractReplicaIdentity() will return NULL if nothing needs to be
	 * logged.
	 */</comment>
	<expr_stmt><expr><name>old_key_tuple</name> <operator>=</operator> <call><name>ExtractReplicaIdentity</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>,
										   <argument><expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>modified_attrs</name></expr></argument>, <argument><expr><name>id_attrs</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>old_key_copied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NO EREPORT(ERROR) from here till changes are logged */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this transaction commits, the old tuple will become DEAD sooner or
	 * later.  Set flag that this page is a candidate for pruning once our xid
	 * falls below the OldestXmin horizon.  If the transaction finally aborts,
	 * the subsequent page pruning will be a no-op and the hint will be
	 * cleared.
	 *
	 * XXX Should we set hint on newbuf as well?  If the transaction aborts,
	 * there would be a prunable tuple in the newbuf; but for now we choose
	 * not to optimize for aborts.  Note that heap_xlog_update must be kept in
	 * sync if this decision changes.
	 */</comment>
	<expr_stmt><expr><call><name>PageSetPrunable</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_hot_update</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Mark the old tuple as HOT-updated */</comment>
		<expr_stmt><expr><call><name>HeapTupleSetHotUpdated</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* And mark the new tuple as heap-only */</comment>
		<expr_stmt><expr><call><name>HeapTupleSetHeapOnly</name><argument_list>(<argument><expr><name>heaptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Mark the caller's copy too, in case different from heaptup */</comment>
		<expr_stmt><expr><call><name>HeapTupleSetHeapOnly</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Make sure tuples are correctly marked as not-HOT */</comment>
		<expr_stmt><expr><call><name>HeapTupleClearHotUpdated</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleClearHeapOnly</name><argument_list>(<argument><expr><name>heaptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleClearHeapOnly</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>RelationPutHeapTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>newbuf</name></expr></argument>, <argument><expr><name>heaptup</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* insert new tuple */</comment>


	<comment type="block">/* Clear obsolete visibility flags, possibly set by ourselves above... */</comment>
	<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XMAX_BITS</name> <operator>|</operator> <name>HEAP_MOVED</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
	<comment type="block">/* ... and store info about transaction updating this tuple */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xmax_old_tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>xmax_old_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>infomask_old_tuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>|=</operator> <name>infomask2_old_tuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetCmax</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>iscombo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* record address of new tuple in t_ctid of old one */</comment>
	<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name><name>heaptup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>

	<comment type="block">/* clear PD_ALL_VISIBLE flags, reset all visibilitymap bits */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>all_visible_cleared</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>newbuf</name> <operator>!=</operator> <name>buffer</name> <operator>&amp;&amp;</operator> <call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>all_visible_cleared_new</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>vmbuffer_new</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newbuf</name> <operator>!=</operator> <name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * For logical decoding we need combocids to properly decode the
		 * catalog.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationIsAccessibleInLogicalDecoding</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>log_heap_new_cid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>log_heap_new_cid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>heaptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>log_heap_update</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>,
								 <argument><expr><name>newbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>, <argument><expr><name>heaptup</name></expr></argument>,
								 <argument><expr><name>old_key_tuple</name></expr></argument>,
								 <argument><expr><name>all_visible_cleared</name></expr></argument>,
								 <argument><expr><name>all_visible_cleared_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newbuf</name> <operator>!=</operator> <name>buffer</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>newbuf</name> <operator>!=</operator> <name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark old tuple for invalidation from system caches at next command
	 * boundary, and mark the new tuple for invalidation in case we abort. We
	 * have to do this before releasing the buffer because oldtup is in the
	 * buffer.  (heaptup is all in local memory, but it's necessary to process
	 * both tuple versions in one call to inval.c so we can avoid redundant
	 * sinval messages.)
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateHeapTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>, <argument><expr><name>heaptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now we can release the buffer(s) */</comment>
	<if_stmt><if>if <condition>(<expr><name>newbuf</name> <operator>!=</operator> <name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>vmbuffer_new</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Release the lmgr tuple lock, if we had it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_tuple_lock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockTupleTuplock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldtup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>*</operator><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_count_heap_update</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If heaptup is a private copy, release it.  Don't forget to copy t_self
	 * back to the caller's image, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>heaptup</name> <operator>!=</operator> <name>newtup</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>heaptup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>heaptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>old_key_tuple</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>old_key_copied</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>old_key_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>hot_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>key_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>id_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>modified_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>interesting_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>TM_Ok</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TM_Result</name></type>
<name>heap_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>otid</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>newtup</name></decl></parameter>,
			<parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>,
			<parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>, <parameter><decl><type><name>LockTupleMode</name> <modifier>*</modifier></type><name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>heap_update_internal</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>otid</name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>,
								<argument><expr><name>cid</name></expr></argument>, <argument><expr><name>crosscheck</name></expr></argument>, <argument><expr><name>wait</name></expr></argument>,
								<argument><expr><name>tmfd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
								<comment type="block">/* simple */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if the specified attribute's value is same in both given tuples.
 * Subroutine for HeapDetermineModifiedColumns.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heap_tuple_attr_equals</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attrnum</name></decl></parameter>,
					   <parameter><decl><type><name>HeapTuple</name></type> <name>tup1</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value1</name></decl>,
				<decl><type ref="prev"/><name>value2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull1</name></decl>,
				<decl><type ref="prev"/><name>isnull2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it's a whole-tuple reference, say "not equal".  It's not really
	 * worth supporting this case, since it could only succeed after a no-op
	 * update, which is hardly a case worth optimizing for.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>attrnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Likewise, automatically say "not equal" for any system attribute other
	 * than tableOID; we cannot expect these to be consistent in a HOT chain,
	 * or even to be set correctly yet in the new tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>attrnum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>attrnum</name> <operator>!=</operator> <name>TableOidAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Extract the corresponding values.  XXX this is pretty inefficient if
	 * there are many indexed columns.  Should HeapDetermineModifiedColumns do
	 * a single heap_deform_tuple call on each tuple, instead?	But that
	 * doesn't work for system columns ...
	 */</comment>
	<expr_stmt><expr><name>value1</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tup1</name></expr></argument>, <argument><expr><name>attrnum</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>value2</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tup2</name></expr></argument>, <argument><expr><name>attrnum</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If one value is NULL and other is not, then they are certainly not
	 * equal
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isnull1</name> <operator>!=</operator> <name>isnull2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If both are NULL, they can be considered equal.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isnull1</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We do simple binary comparison of the two datums.  This may be overly
	 * strict because there can be multiple binary representations for the
	 * same logical value.  But we should be OK as long as there are no false
	 * positives.  Using a type-specific equality operator is messy because
	 * there could be multiple notions of equality in different operator
	 * classes; furthermore, we cannot safely invoke user-defined functions
	 * while holding exclusive buffer lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>attrnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* The only allowed system columns are OIDs, so do this */</comment>
		<return>return <expr><operator>(</operator><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>value1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>value2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attrnum</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attrnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>datumIsEqual</name><argument_list>(<argument><expr><name>value1</name></expr></argument>, <argument><expr><name>value2</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check which columns are being updated.
 *
 * Given an updated tuple, determine (and return into the output bitmapset),
 * from those listed as interesting, the set of columns that changed.
 *
 * The input bitmapset is destructively modified; that is OK since this is
 * invoked at most once in heap_update.
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>HeapDetermineModifiedColumns</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>interesting_cols</name></decl></parameter>,
							 <parameter><decl><type><name>HeapTuple</name></type> <name>oldtup</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>newtup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>modified</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>attnum</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>interesting_cols</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>attnum</name> <operator>+=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>heap_tuple_attr_equals</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>oldtup</name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>modified</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>modified</name></expr></argument>,
									  <argument><expr><name>attnum</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>modified</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	simple_heap_update - replace a tuple
 *
 * This routine may be used to update a tuple when concurrent updates of
 * the target tuple are not expected (for example, because we have a lock
 * on the relation associated with the tuple).  Any failure is reported
 * via ereport().
 */</comment>
<function><type><name>void</name></type>
<name>simple_heap_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>otid</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TM_Result</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_FailureData</name></type> <name>tmfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_update_internal</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>otid</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>,
						 <argument><expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument> <comment type="block">/* wait for commit */</comment> ,
						 <argument><expr><operator>&amp;</operator><name>tmfd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lockmode</name></expr></argument>,
						 <comment type="block">/* simple */</comment> <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TM_SelfModified</name></expr>:</case>
			<comment type="block">/* Tuple was already updated in current command? */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tuple already updated by self"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TM_Ok</name></expr>:</case>
			<comment type="block">/* done successfully */</comment>
			<break>break;</break>

		<case>case <expr><name>TM_Updated</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tuple concurrently updated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TM_Deleted</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tuple concurrently deleted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized heap_update status: %u"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * Return the MultiXactStatus corresponding to the given tuple lock mode.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiXactStatus</name></type>
<name>get_mxact_status_for_lock</name><parameter_list>(<parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_update</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>retval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_update</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name><name>tupleLockExtraInfo</name><index>[<expr><name>mode</name></expr>]</index></name><operator>.</operator><name>updstatus</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name><name>tupleLockExtraInfo</name><index>[<expr><name>mode</name></expr>]</index></name><operator>.</operator><name>lockstatus</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid lock tuple mode %d/%s"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>is_update</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>MultiXactStatus</name><operator>)</operator> <name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	heap_lock_tuple - lock a tuple in shared or exclusive mode
 *
 * Note that this acquires a buffer pin, which the caller must release.
 *
 * Input parameters:
 *	relation: relation containing tuple (caller must hold suitable lock)
 *	tid: TID of tuple to lock
 *	cid: current command ID (used for visibility test, and stored into
 *		tuple's cmax if lock is successful)
 *	mode: indicates if shared or exclusive tuple lock is desired
 *	wait_policy: what to do if tuple lock is not available
 *	follow_updates: if true, follow the update chain to also lock descendant
 *		tuples.
 *
 * Output parameters:
 *	*tuple: all fields filled in
 *	*buffer: set to buffer holding tuple (pinned but not locked at exit)
 *	*tmfd: filled in failure cases (see below)
 *
 * Function results are the same as the ones for table_tuple_lock().
 *
 * In the failure cases other than TM_Invisible, the routine fills
 * *tmfd with the tuple's t_ctid, t_xmax (resolving a possible MultiXact,
 * if necessary), and t_cmax (the last only for TM_SelfModified,
 * since we cannot obtain cmax from a combocid generated by another
 * transaction).
 * See comments for struct TM_FailureData for additional info.
 *
 * See README.tuplock for a thorough explanation of this mechanism.
 */</comment>
<function><type><name>TM_Result</name></type>
<name>heap_lock_tuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
				<parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>LockWaitPolicy</name></type> <name>wait_policy</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>follow_updates</name></decl></parameter>,
				<parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TM_Result</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>tid</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>block</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>,
				<decl><type ref="prev"/><name>xmax</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>old_infomask</name></decl>,
				<decl><type ref="prev"/><name>new_infomask</name></decl>,
				<decl><type ref="prev"/><name>new_infomask2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first_time</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skip_tuple_lock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_tuple_lock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>cleared_all_frozen</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before locking the buffer, pin the visibility map page if it appears to
	 * be necessary.  Since we haven't got the lock yet, someone else might be
	 * in the middle of changing this, so we'll need to recheck after we have
	 * the lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>l3</name>:</label>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleSatisfiesUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_Invisible</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is possible, but only when locking a tuple for ON CONFLICT
		 * UPDATE.  We return this value here rather than throwing an error in
		 * order to give that case the opportunity to throw a more specific
		 * error.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Invisible</name></expr>;</expr_stmt>
		<goto>goto <name>out_locked</name>;</goto>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_BeingModified</name> <operator>||</operator>
			 <name>result</name> <operator>==</operator> <name>TM_Updated</name> <operator>||</operator>
			 <name>result</name> <operator>==</operator> <name>TM_Deleted</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xwait</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint16</name></type>		<name>infomask</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint16</name></type>		<name>infomask2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>require_sleep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>t_ctid</name></decl>;</decl_stmt>

		<comment type="block">/* must copy state data before unlocking buffer */</comment>
		<expr_stmt><expr><name>xwait</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>infomask</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>infomask2</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_ctid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If any subtransaction of the current top transaction already holds
		 * a lock as strong as or stronger than what we're requesting, we
		 * effectively hold the desired lock already.  We *must* succeed
		 * without trying to take the tuple lock, else we will deadlock
		 * against anyone wanting to acquire a stronger lock.
		 *
		 * Note we only do this the first time we loop on the HTSU result;
		 * there is no point in testing in subsequent passes, because
		 * evidently our own transaction cannot have acquired a new lock after
		 * the first time we checked.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>first_time</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>first_time</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * We don't need to allow old multixacts here; if that had
				 * been the case, HeapTupleSatisfiesUpdate would have returned
				 * MayBeUpdated and we wouldn't be here.
				 */</comment>
				<expr_stmt><expr><name>nmembers</name> <operator>=</operator>
					<call><name>GetMultiXactIdMembers</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<comment type="block">/* only consider members of our own transaction */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>TUPLOCK_from_mxstatus</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>mode</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt>
						<goto>goto <name>out_unlocked</name>;</goto>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Disable acquisition of the heavyweight tuple lock.
						 * Otherwise, when promoting a weaker lock, we might
						 * deadlock with another locker that has acquired the
						 * heavyweight tuple lock and is waiting for our
						 * transaction to finish.
						 *
						 * Note that in this case we still need to wait for
						 * the multixact if required, to avoid acquiring
						 * conflicting locks.
						 */</comment>
						<expr_stmt><expr><name>skip_tuple_lock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></for>

				<if_stmt><if>if <condition>(<expr><name>members</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<switch>switch <condition>(<expr><name>mode</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>LockTupleKeyShare</name></expr>:</case>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HEAP_XMAX_IS_KEYSHR_LOCKED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>||</operator>
							   <call><name>HEAP_XMAX_IS_SHR_LOCKED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>||</operator>
							   <call><name>HEAP_XMAX_IS_EXCL_LOCKED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt>
						<goto>goto <name>out_unlocked</name>;</goto>
					<case>case <expr><name>LockTupleShare</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_SHR_LOCKED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>||</operator>
							<call><name>HEAP_XMAX_IS_EXCL_LOCKED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt>
							<goto>goto <name>out_unlocked</name>;</goto>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>LockTupleNoKeyExclusive</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_EXCL_LOCKED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt>
							<goto>goto <name>out_unlocked</name>;</goto>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>LockTupleExclusive</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_EXCL_LOCKED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
							<name>infomask2</name> <operator>&amp;</operator> <name>HEAP_KEYS_UPDATED</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt>
							<goto>goto <name>out_unlocked</name>;</goto>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Initially assume that we will have to wait for the locking
		 * transaction(s) to finish.  We check various cases below in which
		 * this can be turned off.
		 */</comment>
		<expr_stmt><expr><name>require_sleep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>LockTupleKeyShare</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we're requesting KeyShare, and there's no update present, we
			 * don't need to wait.  Even if there is an update, we can still
			 * continue if the key hasn't been modified.
			 *
			 * However, if there are updates, we need to walk the update chain
			 * to mark future versions of the row as locked, too.  That way,
			 * if somebody deletes that future version, we're protected
			 * against the key going away.  This locking of future versions
			 * could block momentarily, if a concurrent transaction is
			 * deleting a key; or it could return a value to the effect that
			 * the transaction deleting the key has already committed.  So we
			 * do this before re-locking the buffer; otherwise this would be
			 * prone to deadlocks.
			 *
			 * Note that the TID we're locking was grabbed before we unlocked
			 * the buffer.  For it to change while we're not looking, the
			 * other properties we're testing for below after re-locking the
			 * buffer would also change, in which case we would restart this
			 * loop above.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>infomask2</name> <operator>&amp;</operator> <name>HEAP_KEYS_UPDATED</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>updated</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>updated</name> <operator>=</operator> <operator>!</operator><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If there are updates, follow the update chain; bail out if
				 * that cannot be done.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>follow_updates</name> <operator>&amp;&amp;</operator> <name>updated</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TM_Result</name></type>	<name>res</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>heap_lock_updated_tuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_ctid</name></expr></argument>,
												  <argument><expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></argument>,
												  <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>TM_Ok</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
						<comment type="block">/* recovery code expects to have buffer lock held */</comment>
						<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>failed</name>;</goto>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Make sure it's still an appropriate lock, else start over.
				 * Also, if it wasn't updated before we released the lock, but
				 * is updated now, we start over too; the reason is that we
				 * now need to follow the update chain to lock the new
				 * versions.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderIsOnlyLocked</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;</operator> <name>HEAP_KEYS_UPDATED</name><operator>)</operator> <operator>||</operator>
					 <operator>!</operator><name>updated</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>l3</name>;</goto></block_content></block></if></if_stmt>

				<comment type="block">/* Things look okay, so we can skip sleeping */</comment>
				<expr_stmt><expr><name>require_sleep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Note we allow Xmax to change here; other updaters/lockers
				 * could have modified it before we grabbed the buffer lock.
				 * However, this is not a problem, because with the recheck we
				 * just did we ensure that they still don't conflict with the
				 * lock we want.
				 */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>LockTupleShare</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we're requesting Share, we can similarly avoid sleeping if
			 * there's no update and no exclusive lock present.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>HEAP_XMAX_IS_EXCL_LOCKED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Make sure it's still an appropriate lock, else start over.
				 * See above about allowing xmax to change.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>HEAP_XMAX_IS_EXCL_LOCKED</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>l3</name>;</goto></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>require_sleep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>LockTupleNoKeyExclusive</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we're requesting NoKeyExclusive, we might also be able to
			 * avoid sleeping; just ensure that there no conflicting lock
			 * already acquired.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DoesMultiXactIdConflict</name><argument_list>(<argument><expr><operator>(</operator><name>MultiXactId</name><operator>)</operator> <name>xwait</name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>,
											 <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * No conflict, but if the xmax changed under us in the
					 * meantime, start over.
					 */</comment>
					<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>xmax_infomask_changed</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>||</operator>
						<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>l3</name>;</goto></block_content></block></if></if_stmt>

					<comment type="block">/* otherwise, we're good */</comment>
					<expr_stmt><expr><name>require_sleep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>HEAP_XMAX_IS_KEYSHR_LOCKED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* if the xmax changed in the meantime, start over */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>xmax_infomask_changed</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(
										 <argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>l3</name>;</goto></block_content></block></if></if_stmt>
				<comment type="block">/* otherwise, we're good */</comment>
				<expr_stmt><expr><name>require_sleep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * As a check independent from those above, we can also avoid sleeping
		 * if the current transaction is the sole locker of the tuple.  Note
		 * that the strength of the lock already held is irrelevant; this is
		 * not about recording the lock in Xmax (which will be done regardless
		 * of this optimization, below).  Also, note that the cases where we
		 * hold a lock stronger than we are requesting are already handled
		 * above by not doing anything.
		 *
		 * Note we only deal with the non-multixact case here; MultiXactIdWait
		 * is well equipped to deal with this situation on its own.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>require_sleep</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ... but if the xmax changed in the meantime, start over */</comment>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>xmax_infomask_changed</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>l3</name>;</goto></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>require_sleep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Time to sleep on the other transaction/multixact, if necessary.
		 *
		 * If the other transaction is an update/delete that's already
		 * committed, then sleeping cannot possibly do any good: if we're
		 * required to sleep, get out to raise an error instead.
		 *
		 * By here, we either have already acquired the buffer exclusive lock,
		 * or we must wait for the locking transaction or multixact; so below
		 * we ensure that we grab buffer lock after the sleep.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>require_sleep</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>result</name> <operator>==</operator> <name>TM_Updated</name> <operator>||</operator> <name>result</name> <operator>==</operator> <name>TM_Deleted</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>failed</name>;</goto>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>require_sleep</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Acquire tuple lock to establish our priority for the tuple, or
			 * die trying.  LockTuple will release us when we are next-in-line
			 * for the tuple.  We must do this even if we are share-locking,
			 * but not if we already have a weaker lock on the tuple.
			 *
			 * If we are forced to "start over" below, we keep the tuple lock;
			 * this arranges that we stay at the head of the line while
			 * rechecking tuple state.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_tuple_lock</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>heap_acquire_tuplock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>wait_policy</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>have_tuple_lock</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This can only happen if wait_policy is Skip and the lock
				 * couldn't be obtained.
				 */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_WouldBlock</name></expr>;</expr_stmt>
				<comment type="block">/* recovery code expects to have buffer lock held */</comment>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>failed</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MultiXactStatus</name></type> <name>status</name> <init>= <expr><call><name>get_mxact_status_for_lock</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* We only ever lock tuples, never update them */</comment>
				<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&gt;=</operator> <name>MultiXactStatusNoKeyUpdate</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid lock mode in heap_lock_tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* wait for multixact to end, or die trying  */</comment>
				<switch>switch <condition>(<expr><name>wait_policy</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>LockWaitBlock</name></expr>:</case>
						<expr_stmt><expr><call><name>MultiXactIdWait</name><argument_list>(<argument><expr><operator>(</operator><name>MultiXactId</name><operator>)</operator> <name>xwait</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>,
										<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>XLTW_Lock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>LockWaitSkip</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalMultiXactIdWait</name><argument_list>(<argument><expr><operator>(</operator><name>MultiXactId</name><operator>)</operator> <name>xwait</name></expr></argument>,
														<argument><expr><name>status</name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>,
														<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_WouldBlock</name></expr>;</expr_stmt>
							<comment type="block">/* recovery code expects to have buffer lock held */</comment>
							<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>failed</name>;</goto>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>LockWaitError</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalMultiXactIdWait</name><argument_list>(<argument><expr><operator>(</operator><name>MultiXactId</name><operator>)</operator> <name>xwait</name></expr></argument>,
														<argument><expr><name>status</name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>,
														<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not obtain lock on row in relation \"%s\""</literal></expr></argument>,
											<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<break>break;</break>
				</block_content>}</block></switch>

				<comment type="block">/*
				 * Of course, the multixact might not be done here: if we're
				 * requesting a light lock mode, other transactions with light
				 * locks could still be alive, as well as locks owned by our
				 * own xact or other subxacts of this backend.  We need to
				 * preserve the surviving MultiXact members.  Note that it
				 * isn't absolutely necessary in the latter case, but doing so
				 * is simpler.
				 */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* wait for regular transaction to end, or die trying */</comment>
				<switch>switch <condition>(<expr><name>wait_policy</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>LockWaitBlock</name></expr>:</case>
						<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>,
										  <argument><expr><name>XLTW_Lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>LockWaitSkip</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalXactLockTableWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_WouldBlock</name></expr>;</expr_stmt>
							<comment type="block">/* recovery code expects to have buffer lock held */</comment>
							<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>failed</name>;</goto>
						</block_content>}</block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>LockWaitError</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalXactLockTableWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not obtain lock on row in relation \"%s\""</literal></expr></argument>,
											<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* if there are updates, follow the update chain */</comment>
			<if_stmt><if>if <condition>(<expr><name>follow_updates</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TM_Result</name></type>	<name>res</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>heap_lock_updated_tuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_ctid</name></expr></argument>,
											  <argument><expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></argument>,
											  <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>TM_Ok</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
					<comment type="block">/* recovery code expects to have buffer lock held */</comment>
					<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>failed</name>;</goto>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * xwait is done, but if xwait had just locked the tuple then some
			 * other xact could update this tuple before we get to this point.
			 * Check for xmax change, and start over if so.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>xmax_infomask_changed</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>l3</name>;</goto></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Otherwise check if it committed or aborted.  Note we cannot
				 * be here if the tuple was only locked by somebody who didn't
				 * conflict with us; that would have been handled above.  So
				 * that transaction must necessarily be gone by now.  But
				 * don't check for this in the multixact case, because some
				 * locker transactions might still be running.
				 */</comment>
				<expr_stmt><expr><call><name>UpdateXmaxHintBits</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* By here, we're certain that we hold buffer exclusive lock again */</comment>

		<comment type="block">/*
		 * We may lock if previous xmax aborted, or if it committed but only
		 * locked the tuple without updating it; or if we didn't have to wait
		 * at all for whatever reason.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>require_sleep</name> <operator>||</operator>
			<operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name><operator>)</operator> <operator>||</operator>
			<call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>HeapTupleHeaderIsOnlyLocked</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				 <call><name>HeapTupleHeaderIndicatesMovedPartitions</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Updated</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Deleted</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

<label><name>failed</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>TM_Ok</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>==</operator> <name>TM_SelfModified</name> <operator>||</operator> <name>result</name> <operator>==</operator> <name>TM_Updated</name> <operator>||</operator>
			   <name>result</name> <operator>==</operator> <name>TM_Deleted</name> <operator>||</operator> <name>result</name> <operator>==</operator> <name>TM_WouldBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name> <operator>!=</operator> <name>TM_Updated</name> <operator>||</operator>
			   <operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>ctid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_SelfModified</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetCmax</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <name>InvalidCommandId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<goto>goto <name>out_locked</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we didn't pin the visibility map page and the page has become all
	 * visible while we were busy locking the buffer, or during some
	 * subsequent window during which we had it unlocked, we'll have to unlock
	 * and re-lock, to avoid holding the buffer lock across I/O.  That's a bit
	 * unfortunate, especially since we'll now have to recheck whether the
	 * tuple has been locked or updated under us, but hopefully it won't
	 * happen very often.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>vmbuffer</name> <operator>==</operator> <name>InvalidBuffer</name> <operator>&amp;&amp;</operator> <call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>l3</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>xmax</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_infomask</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is the first possibly-multixact-able operation in the current
	 * transaction, set my per-backend OldestMemberMXactId setting. We can be
	 * certain that the transaction will never become a member of any older
	 * MultiXactIds than that.  (We have to do this even if we end up just
	 * using our own TransactionId below, since some other backend could
	 * incorporate our XID into a MultiXact immediately afterwards.)
	 */</comment>
	<expr_stmt><expr><call><name>MultiXactIdSetOldestMember</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute the new xmax and infomask to store into the tuple.  Note we do
	 * not modify the tuple just yet, because that would leave it in the wrong
	 * state if multixact.c elogs.
	 */</comment>
	<expr_stmt><expr><call><name>compute_new_xmax_infomask</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>, <argument><expr><name>old_infomask</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>,
							  <argument><expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>xid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store transaction information of xact locking the tuple.
	 *
	 * Note: Cmax is meaningless in this context, so don't set it; this avoids
	 * possibly generating a useless combo CID.  Moreover, if we're locking a
	 * previously updated tuple, it's important to preserve the Cmax.
	 *
	 * Also reset the HOT UPDATE bit, but only if there's no update; otherwise
	 * we would break the HOT chain.
	 */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XMAX_BITS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>new_infomask</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>|=</operator> <name>new_infomask2</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>new_infomask</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HeapTupleHeaderClearHotUpdated</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure there is no forward chain link in t_ctid.  Note that in the
	 * cases where the tuple has been updated, we must not overwrite t_ctid,
	 * because it was set by the updater.  Moreover, if the tuple has been
	 * updated, we need to follow the update chain to lock the new versions of
	 * the tuple as well.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>new_infomask</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clear only the all-frozen bit on visibility map if needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>,
							<argument><expr><name>VISIBILITYMAP_ALL_FROZEN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cleared_all_frozen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XLOG stuff.  You might think that we don't need an XLOG record because
	 * there is no state change worth restoring after a crash.  You would be
	 * wrong however: we have just written either a TransactionId or a
	 * MultiXactId that may never have been seen on disk before, and we need
	 * to make sure that there are XLOG entries covering those ID numbers.
	 * Else the same IDs might be re-used after a crash, which would be
	 * disastrous if this page made it to disk before the crash.  Essentially
	 * we have to enforce the WAL log-before-data rule even in this case.
	 * (Also, in a PITR log-shipping or 2PC environment, we have to have XLOG
	 * entries for everything anyway.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_heap_lock</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>locking_xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>infobits_set</name></name> <operator>=</operator> <call><name>compute_infobits</name><argument_list>(<argument><expr><name>new_infomask</name></expr></argument>,
											  <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <ternary><condition><expr><name>cleared_all_frozen</name></expr> ?</condition><then> <expr><name>XLH_LOCK_ALL_FROZEN_CLEARED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we don't decode row locks atm, so no need to log the origin */</comment>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt>

<label><name>out_locked</name>:</label>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><operator>*</operator><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>out_unlocked</name>:</label>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't update the visibility map here. Locking a tuple doesn't change
	 * visibility info.
	 */</comment>

	<comment type="block">/*
	 * Now that we have successfully marked the tuple as locked, we can
	 * release the lmgr tuple lock, if we had it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_tuple_lock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockTupleTuplock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Acquire heavyweight lock on the given tuple, in preparation for acquiring
 * its normal, Xmax-based tuple lock.
 *
 * have_tuple_lock is an input and output parameter: on input, it indicates
 * whether the lock has previously been acquired (and this function does
 * nothing in that case).  If this function returns success, have_tuple_lock
 * has been flipped to true.
 *
 * Returns false if it was unable to obtain the lock; this can only happen if
 * wait_policy is Skip.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heap_acquire_tuplock</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>,
					 <parameter><decl><type><name>LockWaitPolicy</name></type> <name>wait_policy</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>have_tuple_lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>have_tuple_lock</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>wait_policy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>LockWaitBlock</name></expr>:</case>
			<expr_stmt><expr><call><name>LockTupleTuplock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>LockWaitSkip</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockTupleTuplock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>LockWaitError</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockTupleTuplock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not obtain lock on row in relation \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><operator>*</operator><name>have_tuple_lock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given an original set of Xmax and infomask, and a transaction (identified by
 * add_to_xmax) acquiring a new lock of some mode, compute the new Xmax and
 * corresponding infomasks to use on the tuple.
 *
 * Note that this might have side effects such as creating a new MultiXactId.
 *
 * Most callers will have called HeapTupleSatisfiesUpdate before this function;
 * that will have set the HEAP_XMAX_INVALID bit if the xmax was a MultiXactId
 * but it was not running anymore. There is a race condition, which is that the
 * MultiXactId may have finished since then, but that uncommon case is handled
 * either here, or within MultiXactIdExpand.
 *
 * There is a similar race condition possible when the old xmax was a regular
 * TransactionId.  We test TransactionIdIsInProgress again just to narrow the
 * window, but it's still possible to end up creating an unnecessary
 * MultiXactId.  Fortunately this is harmless.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_new_xmax_infomask</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xmax</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>old_infomask</name></decl></parameter>,
						  <parameter><decl><type><name>uint16</name></type> <name>old_infomask2</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>add_to_xmax</name></decl></parameter>,
						  <parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_update</name></decl></parameter>,
						  <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>result_xmax</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>result_infomask</name></decl></parameter>,
						  <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>result_infomask2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>new_xmax</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>new_infomask</name></decl>,
				<decl><type ref="prev"/><name>new_infomask2</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>add_to_xmax</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>l5</name>:</label>
	<expr_stmt><expr><name>new_infomask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_infomask2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>old_infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No previous locker; we just insert our own TransactionId.
		 *
		 * Note that it's critical that this case be the first one checked,
		 * because there are several blocks below that come back to this one
		 * to implement certain optimizations; old_infomask might contain
		 * other dirty bits in those cases, but we don't really care.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_update</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>new_xmax</name> <operator>=</operator> <name>add_to_xmax</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>LockTupleExclusive</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>new_infomask2</name> <operator>|=</operator> <name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>new_infomask</name> <operator>|=</operator> <name>HEAP_XMAX_LOCK_ONLY</name></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name>mode</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>LockTupleKeyShare</name></expr>:</case>
					<expr_stmt><expr><name>new_xmax</name> <operator>=</operator> <name>add_to_xmax</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>new_infomask</name> <operator>|=</operator> <name>HEAP_XMAX_KEYSHR_LOCK</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LockTupleShare</name></expr>:</case>
					<expr_stmt><expr><name>new_xmax</name> <operator>=</operator> <name>add_to_xmax</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>new_infomask</name> <operator>|=</operator> <name>HEAP_XMAX_SHR_LOCK</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LockTupleNoKeyExclusive</name></expr>:</case>
					<expr_stmt><expr><name>new_xmax</name> <operator>=</operator> <name>add_to_xmax</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>new_infomask</name> <operator>|=</operator> <name>HEAP_XMAX_EXCL_LOCK</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LockTupleExclusive</name></expr>:</case>
					<expr_stmt><expr><name>new_xmax</name> <operator>=</operator> <name>add_to_xmax</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>new_infomask</name> <operator>|=</operator> <name>HEAP_XMAX_EXCL_LOCK</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>new_infomask2</name> <operator>|=</operator> <name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>new_xmax</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>	<comment type="block">/* silence compiler */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid lock mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>old_infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiXactStatus</name></type> <name>new_status</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Currently we don't allow XMAX_COMMITTED to be set for multis, so
		 * cross-check.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>old_infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_COMMITTED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * A multixact together with LOCK_ONLY set but neither lock bit set
		 * (i.e. a pg_upgraded share locked tuple) cannot possibly be running
		 * anymore.  This check is critical for databases upgraded by
		 * pg_upgrade; both MultiXactIdIsRunning and MultiXactIdExpand assume
		 * that such multis are never passed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HEAP_LOCKED_UPGRADED</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_infomask</name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XMAX_IS_MULTI</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_infomask</name> <operator>|=</operator> <name>HEAP_XMAX_INVALID</name></expr>;</expr_stmt>
			<goto>goto <name>l5</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the XMAX is already a MultiXactId, then we need to expand it to
		 * include add_to_xmax; but if all the members were lockers and are
		 * all gone, we can do away with the IS_MULTI bit and just set
		 * add_to_xmax as the only locker/updater.  If all lockers are gone
		 * and we have an updater that aborted, we can also do without a
		 * multi.
		 *
		 * The cost of doing GetMultiXactIdMembers would be paid by
		 * MultiXactIdExpand if we weren't to do this, so this check is not
		 * incurring extra work anyhow.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MultiXactIdIsRunning</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>, <argument><expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>!</operator><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><call><name>MultiXactIdGetUpdateXid</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>,
																<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Reset these bits and restart; otherwise fall through to
				 * create a new multi below.
				 */</comment>
				<expr_stmt><expr><name>old_infomask</name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XMAX_IS_MULTI</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>old_infomask</name> <operator>|=</operator> <name>HEAP_XMAX_INVALID</name></expr>;</expr_stmt>
				<goto>goto <name>l5</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>new_status</name> <operator>=</operator> <call><name>get_mxact_status_for_lock</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>is_update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_xmax</name> <operator>=</operator> <call><name>MultiXactIdExpand</name><argument_list>(<argument><expr><operator>(</operator><name>MultiXactId</name><operator>)</operator> <name>xmax</name></expr></argument>, <argument><expr><name>add_to_xmax</name></expr></argument>,
									 <argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GetMultiXactIdHintBits</name><argument_list>(<argument><expr><name>new_xmax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>old_infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_COMMITTED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It's a committed update, so we need to preserve him as updater of
		 * the tuple.
		 */</comment>
		<decl_stmt><decl><type><name>MultiXactStatus</name></type> <name>status</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiXactStatus</name></type> <name>new_status</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>old_infomask2</name> <operator>&amp;</operator> <name>HEAP_KEYS_UPDATED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <name>MultiXactStatusUpdate</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <name>MultiXactStatusNoKeyUpdate</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>new_status</name> <operator>=</operator> <call><name>get_mxact_status_for_lock</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>is_update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * since it's not running, it's obviously impossible for the old
		 * updater to be identical to the current one, so we need not check
		 * for that case as we do in the block above.
		 */</comment>
		<expr_stmt><expr><name>new_xmax</name> <operator>=</operator> <call><name>MultiXactIdCreate</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>add_to_xmax</name></expr></argument>, <argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GetMultiXactIdHintBits</name><argument_list>(<argument><expr><name>new_xmax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TransactionIdIsInProgress</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the XMAX is a valid, in-progress TransactionId, then we need to
		 * create a new MultiXactId that includes both the old locker or
		 * updater and our own TransactionId.
		 */</comment>
		<decl_stmt><decl><type><name>MultiXactStatus</name></type> <name>new_status</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiXactStatus</name></type> <name>old_status</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LockTupleMode</name></type> <name>old_mode</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_KEYSHR_LOCKED</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>old_status</name> <operator>=</operator> <name>MultiXactStatusForKeyShare</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>HEAP_XMAX_IS_SHR_LOCKED</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>old_status</name> <operator>=</operator> <name>MultiXactStatusForShare</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>HEAP_XMAX_IS_EXCL_LOCKED</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>old_infomask2</name> <operator>&amp;</operator> <name>HEAP_KEYS_UPDATED</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>old_status</name> <operator>=</operator> <name>MultiXactStatusForUpdate</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>old_status</name> <operator>=</operator> <name>MultiXactStatusForNoKeyUpdate</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * LOCK_ONLY can be present alone only when a page has been
				 * upgraded by pg_upgrade.  But in that case,
				 * TransactionIdIsInProgress() should have returned false.  We
				 * assume it's no longer locked in this case.
				 */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"LOCK_ONLY found for Xid in progress %u"</literal></expr></argument>, <argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>old_infomask</name> <operator>|=</operator> <name>HEAP_XMAX_INVALID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>old_infomask</name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XMAX_LOCK_ONLY</name></expr>;</expr_stmt>
				<goto>goto <name>l5</name>;</goto>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* it's an update, but which kind? */</comment>
			<if_stmt><if>if <condition>(<expr><name>old_infomask2</name> <operator>&amp;</operator> <name>HEAP_KEYS_UPDATED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>old_status</name> <operator>=</operator> <name>MultiXactStatusUpdate</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>old_status</name> <operator>=</operator> <name>MultiXactStatusNoKeyUpdate</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>old_mode</name> <operator>=</operator> <call><name>TUPLOCK_from_mxstatus</name><argument_list>(<argument><expr><name>old_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the lock to be acquired is for the same TransactionId as the
		 * existing lock, there's an optimization possible: consider only the
		 * strongest of both locks as the only one present, and restart.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>xmax</name> <operator>==</operator> <name>add_to_xmax</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note that it's not possible for the original tuple to be
			 * updated: we wouldn't be here because the tuple would have been
			 * invisible and we wouldn't try to update it.  As a subtlety,
			 * this code can also run when traversing an update chain to lock
			 * future versions of a tuple.  But we wouldn't be here either,
			 * because the add_to_xmax would be different from the original
			 * updater.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* acquire the strongest of both */</comment>
			<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>&lt;</operator> <name>old_mode</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>mode</name> <operator>=</operator> <name>old_mode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* mustn't touch is_update */</comment>

			<expr_stmt><expr><name>old_infomask</name> <operator>|=</operator> <name>HEAP_XMAX_INVALID</name></expr>;</expr_stmt>
			<goto>goto <name>l5</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* otherwise, just fall back to creating a new multixact */</comment>
		<expr_stmt><expr><name>new_status</name> <operator>=</operator> <call><name>get_mxact_status_for_lock</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>is_update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_xmax</name> <operator>=</operator> <call><name>MultiXactIdCreate</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>, <argument><expr><name>old_status</name></expr></argument>,
									 <argument><expr><name>add_to_xmax</name></expr></argument>, <argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GetMultiXactIdHintBits</name><argument_list>(<argument><expr><name>new_xmax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It's a committed update, so we gotta preserve him as updater of the
		 * tuple.
		 */</comment>
		<decl_stmt><decl><type><name>MultiXactStatus</name></type> <name>status</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiXactStatus</name></type> <name>new_status</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>old_infomask2</name> <operator>&amp;</operator> <name>HEAP_KEYS_UPDATED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <name>MultiXactStatusUpdate</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <name>MultiXactStatusNoKeyUpdate</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>new_status</name> <operator>=</operator> <call><name>get_mxact_status_for_lock</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>is_update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * since it's not running, it's obviously impossible for the old
		 * updater to be identical to the current one, so we need not check
		 * for that case as we do in the block above.
		 */</comment>
		<expr_stmt><expr><name>new_xmax</name> <operator>=</operator> <call><name>MultiXactIdCreate</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>add_to_xmax</name></expr></argument>, <argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GetMultiXactIdHintBits</name><argument_list>(<argument><expr><name>new_xmax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Can get here iff the locking/updating transaction was running when
		 * the infomask was extracted from the tuple, but finished before
		 * TransactionIdIsInProgress got to run.  Deal with it as if there was
		 * no locker at all in the first place.
		 */</comment>
		<expr_stmt><expr><name>old_infomask</name> <operator>|=</operator> <name>HEAP_XMAX_INVALID</name></expr>;</expr_stmt>
		<goto>goto <name>l5</name>;</goto>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>result_infomask</name> <operator>=</operator> <name>new_infomask</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>result_infomask2</name> <operator>=</operator> <name>new_infomask2</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>result_xmax</name> <operator>=</operator> <name>new_xmax</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for heap_lock_updated_tuple_rec.
 *
 * Given a hypothetical multixact status held by the transaction identified
 * with the given xid, does the current transaction need to wait, fail, or can
 * it continue if it wanted to acquire a lock of the given mode?  "needwait"
 * is set to true if waiting is necessary; if it can continue, then TM_Ok is
 * returned.  If the lock is already held by the current transaction, return
 * TM_SelfModified.  In case of a conflict with another transaction, a
 * different HeapTupleSatisfiesUpdate return code is returned.
 *
 * The held status is said to be hypothetical because it might correspond to a
 * lock held by a single Xid, i.e. not a real MultiXactId; we express it this
 * way for simplicity of API.
 */</comment>
<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>test_lockmode_for_conflict</name><parameter_list>(<parameter><decl><type><name>MultiXactStatus</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
						   <parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>needwait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactStatus</name></type> <name>wantedstatus</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>needwait</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>wantedstatus</name> <operator>=</operator> <call><name>get_mxact_status_for_lock</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: we *must* check TransactionIdIsInProgress before
	 * TransactionIdDidAbort/Commit; see comment at top of heapam_visibility.c
	 * for an explanation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The tuple has already been locked by our own transaction.  This is
		 * very rare but can happen if multiple transactions are trying to
		 * lock an ancient version of the same tuple.
		 */</comment>
		<return>return <expr><name>TM_SelfModified</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TransactionIdIsInProgress</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the locking transaction is running, what we do depends on
		 * whether the lock modes conflict: if they do, then we must wait for
		 * it to finish; otherwise we can fall through to lock this tuple
		 * version without waiting.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>DoLockModesConflict</name><argument_list>(<argument><expr><call><name>LOCKMODE_from_mxstatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>LOCKMODE_from_mxstatus</name><argument_list>(<argument><expr><name>wantedstatus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>needwait</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we set needwait above, then this value doesn't matter;
		 * otherwise, this value signals to caller that it's okay to proceed.
		 */</comment>
		<return>return <expr><name>TM_Ok</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TransactionIdDidAbort</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>TM_Ok</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The other transaction committed.  If it was only a locker, then the
		 * lock is completely gone now and we can return success; but if it
		 * was an update, then what we do depends on whether the two lock
		 * modes conflict.  If they conflict, then we must report error to
		 * caller. But if they don't, we can fall through to allow the current
		 * transaction to lock the tuple.
		 *
		 * Note: the reason we worry about ISUPDATE here is because as soon as
		 * a transaction ends, all its locks are gone and meaningless, and
		 * thus we can ignore them; whereas its updates persist.  In the
		 * TransactionIdIsInProgress case, above, we don't need to check
		 * because we know the lock is still "alive" and thus a conflict needs
		 * always be checked.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISUPDATE_from_mxstatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>TM_Ok</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>DoLockModesConflict</name><argument_list>(<argument><expr><call><name>LOCKMODE_from_mxstatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>LOCKMODE_from_mxstatus</name><argument_list>(<argument><expr><name>wantedstatus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* bummer */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>HeapTupleHeaderIndicatesMovedPartitions</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>TM_Updated</name></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>TM_Deleted</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>TM_Ok</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Not in progress, not aborted, not committed -- must have crashed */</comment>
	<return>return <expr><name>TM_Ok</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Recursive part of heap_lock_updated_tuple
 *
 * Fetch the tuple pointed to by tid in rel, and mark it as locked by the given
 * xid with the given mode; if this tuple is updated, recurse to lock the new
 * version as well.
 */</comment>
<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>heap_lock_updated_tuple_rec</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
							<parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TM_Result</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tupid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>mytup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>new_infomask</name></decl>,
				<decl><type ref="prev"/><name>new_infomask2</name></decl>,
				<decl><type ref="prev"/><name>old_infomask</name></decl>,
				<decl><type ref="prev"/><name>old_infomask2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmax</name></decl>,
				<decl><type ref="prev"/><name>new_xmax</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>priorXmax</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>cleared_all_frozen</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pinned_desired_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>block</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>new_infomask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_xmax</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tupid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tupid</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>mytup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>heap_fetch</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mytup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * if we fail to find the updated version of the tuple, it's
			 * because it was vacuumed/pruned away after its creator
			 * transaction aborted.  So behave as if we got to the end of the
			 * chain, and there's no further tuple to lock: return success to
			 * caller.
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt>
			<goto>goto <name>out_unlocked</name>;</goto>
		</block_content>}</block></if></if_stmt>

<label><name>l4</name>:</label>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Before locking the buffer, pin the visibility map page if it
		 * appears to be necessary.  Since we haven't got the lock yet,
		 * someone else might be in the middle of changing this, so we'll need
		 * to recheck after we have the lock.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pinned_desired_page</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>pinned_desired_page</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we didn't pin the visibility map page and the page has become
		 * all visible while we were busy locking the buffer, we'll have to
		 * unlock and re-lock, to avoid holding the buffer lock across I/O.
		 * That's a bit unfortunate, but hopefully shouldn't happen often.
		 *
		 * Note: in some paths through this function, we will reach here
		 * holding a pin on a vm page that may or may not be the one matching
		 * this page.  If this page isn't all-visible, we won't use the vm
		 * page, but we hold onto such a pin till the end of the function.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pinned_desired_page</name> <operator>&amp;&amp;</operator> <call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check the tuple XMIN against prior XMAX, if any.  If we reached the
		 * end of the chain, we're done, so return success.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>priorXmax</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>mytup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>priorXmax</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt>
			<goto>goto <name>out_locked</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Also check Xmin: if this tuple was created by an aborted
		 * (sub)transaction, then we already locked the last live one in the
		 * chain, thus we're done, so return success.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdDidAbort</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>mytup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt>
			<goto>goto <name>out_locked</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>old_infomask</name> <operator>=</operator> <name><name>mytup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>old_infomask2</name> <operator>=</operator> <name><name>mytup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>xmax</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>mytup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this tuple version has been updated or locked by some concurrent
		 * transaction(s), what we do depends on whether our lock mode
		 * conflicts with what those other transactions hold, and also on the
		 * status of them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>old_infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>rawxmax</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>needwait</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rawxmax</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>mytup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>old_infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * We don't need a test for pg_upgrade'd tuples: this is only
				 * applied to tuples after the first in an update chain.  Said
				 * first tuple in the chain may well be locked-in-9.2-and-
				 * pg_upgraded, but that one was already locked by our caller,
				 * not us; and any subsequent ones cannot be because our
				 * caller must necessarily have obtained a snapshot later than
				 * the pg_upgrade itself.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HEAP_LOCKED_UPGRADED</name><argument_list>(<argument><expr><name><name>mytup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>nmembers</name> <operator>=</operator> <call><name>GetMultiXactIdMembers</name><argument_list>(<argument><expr><name>rawxmax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												 <argument><expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>test_lockmode_for_conflict</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name></expr></argument>,
														<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>,
														<argument><expr><name>mode</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>mytup</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>needwait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If the tuple was already locked by ourselves in a
					 * previous iteration of this (say heap_lock_tuple was
					 * forced to restart the locking loop because of a change
					 * in xmax), then we hold the lock already on this tuple
					 * version and we don't need to do anything; and this is
					 * not an error condition either.  We just need to skip
					 * this tuple and continue locking the next version in the
					 * update chain.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_SelfModified</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>next</name>;</goto>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>needwait</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>mytup</name><operator>.</operator><name>t_self</name></name></expr></argument>,
										  <argument><expr><name>XLTW_LockUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>l4</name>;</goto>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>TM_Ok</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<goto>goto <name>out_locked</name>;</goto>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><name>members</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>MultiXactStatus</name></type> <name>status</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * For a non-multi Xmax, we first need to compute the
				 * corresponding MultiXactStatus by using the infomask bits.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_KEYSHR_LOCKED</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>status</name> <operator>=</operator> <name>MultiXactStatusForKeyShare</name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>HEAP_XMAX_IS_SHR_LOCKED</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>status</name> <operator>=</operator> <name>MultiXactStatusForShare</name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>HEAP_XMAX_IS_EXCL_LOCKED</name><argument_list>(<argument><expr><name>old_infomask</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>old_infomask2</name> <operator>&amp;</operator> <name>HEAP_KEYS_UPDATED</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>status</name> <operator>=</operator> <name>MultiXactStatusForUpdate</name></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>status</name> <operator>=</operator> <name>MultiXactStatusForNoKeyUpdate</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * LOCK_ONLY present alone (a pg_upgraded tuple marked
						 * as share-locked in the old cluster) shouldn't be
						 * seen in the middle of an update chain.
						 */</comment>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid lock status in tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* it's an update, but which kind? */</comment>
					<if_stmt><if>if <condition>(<expr><name>old_infomask2</name> <operator>&amp;</operator> <name>HEAP_KEYS_UPDATED</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>status</name> <operator>=</operator> <name>MultiXactStatusUpdate</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>status</name> <operator>=</operator> <name>MultiXactStatusNoKeyUpdate</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>test_lockmode_for_conflict</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>rawxmax</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>mytup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>needwait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the tuple was already locked by ourselves in a previous
				 * iteration of this (say heap_lock_tuple was forced to
				 * restart the locking loop because of a change in xmax), then
				 * we hold the lock already on this tuple version and we don't
				 * need to do anything; and this is not an error condition
				 * either.  We just need to skip this tuple and continue
				 * locking the next version in the update chain.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_SelfModified</name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>next</name>;</goto></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>needwait</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name>rawxmax</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mytup</name><operator>.</operator><name>t_self</name></name></expr></argument>,
									  <argument><expr><name>XLTW_LockUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>l4</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>TM_Ok</name></expr>)</condition>
				<block>{<block_content>
					<goto>goto <name>out_locked</name>;</goto>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* compute the new Xmax and infomask values for the tuple ... */</comment>
		<expr_stmt><expr><call><name>compute_new_xmax_infomask</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>, <argument><expr><name>old_infomask</name></expr></argument>, <argument><expr><name><name>mytup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>,
								  <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>new_xmax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_infomask2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>,
								<argument><expr><name>VISIBILITYMAP_ALL_FROZEN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cleared_all_frozen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ... and set them */</comment>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name><name>mytup</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>new_xmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mytup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XMAX_BITS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mytup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mytup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>new_infomask</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mytup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>|=</operator> <name>new_infomask2</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* XLOG stuff */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_heap_lock_updated</name></type> <name>xlrec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mytup</name><operator>.</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>xmax</name></name> <operator>=</operator> <name>new_xmax</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>infobits_set</name></name> <operator>=</operator> <call><name>compute_infobits</name><argument_list>(<argument><expr><name>new_infomask</name></expr></argument>, <argument><expr><name>new_infomask2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>=</operator>
				<ternary><condition><expr><name>cleared_all_frozen</name></expr> ?</condition><then> <expr><name>XLH_LOCK_ALL_FROZEN_CLEARED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapLockUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP2_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP2_LOCK_UPDATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>next</name>:</label>
		<comment type="block">/* if we find the end of update chain, we're done. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mytup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name> <operator>||</operator>
			<call><name>HeapTupleHeaderIndicatesMovedPartitions</name><argument_list>(<argument><expr><name><name>mytup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mytup</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mytup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>HeapTupleHeaderIsOnlyLocked</name><argument_list>(<argument><expr><name><name>mytup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt>
			<goto>goto <name>out_locked</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* tail recursion */</comment>
		<expr_stmt><expr><name>priorXmax</name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>mytup</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>mytup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>TM_Ok</name></expr>;</expr_stmt>

<label><name>out_locked</name>:</label>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>out_unlocked</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>vmbuffer</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_lock_updated_tuple
 *		Follow update chain when locking an updated tuple, acquiring locks (row
 *		marks) on the updated versions.
 *
 * The initial tuple is assumed to be already locked.
 *
 * This function doesn't check visibility, it just unconditionally marks the
 * tuple(s) as locked.  If any tuple in the updated chain is being deleted
 * concurrently (or updated with the key being modified), sleep until the
 * transaction doing it is finished.
 *
 * Note that we don't acquire heavyweight tuple locks on the tuples we walk
 * when we have to wait for other transactions to release them, as opposed to
 * what heap_lock_tuple does.  The reason is that having more than one
 * transaction walking the chain is probably uncommon enough that risk of
 * starvation is not likely: one of the preconditions for being here is that
 * the snapshot in use predates the update that created this tuple (because we
 * started at an earlier version of the tuple), but at the same time such a
 * transaction cannot be using repeatable read or serializable isolation
 * levels, because that would lead to a serializability failure.
 */</comment>
<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>heap_lock_updated_tuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>ctid</name></decl></parameter>,
						<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the tuple has not been updated, or has moved into another partition
	 * (effectively a delete) stop here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderIndicatesMovedPartitions</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>ctid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If this is the first possibly-multixact-able operation in the
		 * current transaction, set my per-backend OldestMemberMXactId
		 * setting. We can be certain that the transaction will never become a
		 * member of any older MultiXactIds than that.  (We have to do this
		 * even if we end up just using our own TransactionId below, since
		 * some other backend could incorporate our XID into a MultiXact
		 * immediately afterwards.)
		 */</comment>
		<expr_stmt><expr><call><name>MultiXactIdSetOldestMember</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>heap_lock_updated_tuple_rec</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ctid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* nothing to lock */</comment>
	<return>return <expr><name>TM_Ok</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	heap_finish_speculative - mark speculative insertion as successful
 *
 * To successfully finish a speculative insertion we have to clear speculative
 * token from tuple.  To do so the t_ctid field, which will contain a
 * speculative token value, is modified in place to point to the tuple itself,
 * which is characteristic of a newly inserted ordinary tuple.
 *
 * NB: It is not ok to commit without either finishing or aborting a
 * speculative insertion.  We could treat speculative tuples of committed
 * transactions implicitly as completed, but then we would have to be prepared
 * to deal with speculative tokens on committed tuples.  That wouldn't be
 * difficult - no-one looks at the ctid field of a tuple with invalid xmax -
 * but clearing the token at completion isn't very expensive either.
 * An explicit confirmation WAL record also makes logical decoding simpler.
 */</comment>
<function><type><name>void</name></type>
<name>heap_finish_speculative</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>offnum</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid lp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* SpecTokenOffsetNumber should be distinguishable from any real offset */</comment>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><name>MaxOffsetNumber</name> <operator>&lt;</operator> <name>SpecTokenOffsetNumber</name></expr></argument>,
					 <argument><expr><literal type="string">"invalid speculative token constant"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NO EREPORT(ERROR) from here till changes are logged */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderIsSpeculative</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace the speculative insertion token with a real t_ctid, pointing to
	 * itself like it does on regular tuples.
	 */</comment>
	<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_heap_confirm</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We want the same filtering on this as on a plain insert */</comment>
		<expr_stmt><expr><call><name>XLogSetRecordFlags</name><argument_list>(<argument><expr><name>XLOG_INCLUDE_ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapConfirm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP_CONFIRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	heap_abort_speculative - kill a speculatively inserted tuple
 *
 * Marks a tuple that was speculatively inserted in the same command as dead,
 * by setting its xmin as invalid.  That makes it immediately appear as dead
 * to all transactions, including our own.  In particular, it makes
 * HeapTupleSatisfiesDirty() regard the tuple as dead, so that another backend
 * inserting a duplicate key value won't unnecessarily wait for our whole
 * transaction to finish (it'll just wait for our speculative insertion to
 * finish).
 *
 * Killing the tuple prevents "unprincipled deadlocks", which are deadlocks
 * that arise due to a mutual dependency that is not user visible.  By
 * definition, unprincipled deadlocks cannot be prevented by the user
 * reordering lock acquisition in client code, because the implementation level
 * lock acquisitions are not under the user's direct control.  If speculative
 * inserters did not take this precaution, then under high concurrency they
 * could deadlock with each other, which would not be acceptable.
 *
 * This is somewhat redundant with heap_delete, but we prefer to have a
 * dedicated routine with stripped down requirements.  Note that this is also
 * used to delete the TOAST tuples created during speculative insertion.
 *
 * This routine does not affect logical decoding as it only looks at
 * confirmation records.
 */</comment>
<function><type><name>void</name></type>
<name>heap_abort_speculative</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>block</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Page can't be all visible, we just inserted into it, and are still
	 * running.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sanity check that the tuple really is a speculatively inserted tuple,
	 * inserted by us.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_choice</name><operator>.</operator><name>t_heap</name><operator>.</operator><name>t_xmin</name></name> <operator>!=</operator> <name>xid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attempted to kill a tuple inserted by another transaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsToastRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>HeapTupleHeaderIsSpeculative</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attempted to kill a non-speculative tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HeapTupleHeaderIsHeapOnly</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No need to check for serializable conflicts here.  There is never a
	 * need for a combocid, either.  No need to extract replica identity, or
	 * do anything special with infomask bits.
	 */</comment>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The tuple will become DEAD immediately.  Flag that this page
	 * immediately is a candidate for pruning by setting xmin to
	 * RecentGlobalXmin.  That's not pretty, but it doesn't seem worth
	 * inventing a nicer API for this.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>RecentGlobalXmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageSetPrunable</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>RecentGlobalXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* store transaction information of xact deleting the tuple */</comment>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XMAX_BITS</name> <operator>|</operator> <name>HEAP_MOVED</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the tuple header xmin to InvalidTransactionId.  This makes the
	 * tuple immediately invisible everyone.  (In particular, to any
	 * transactions waiting on the speculative token, woken up later.)
	 */</comment>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear the speculative insertion token too */</comment>
	<expr_stmt><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name><name>tp</name><operator>.</operator><name>t_self</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XLOG stuff
	 *
	 * The WAL records generated here match heap_delete().  The same recovery
	 * routines are used.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_heap_delete</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>XLH_DELETE_IS_SUPER</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>infobits_set</name></name> <operator>=</operator> <call><name>compute_infobits</name><argument_list>(<argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
											  <argument><expr><name><name>tp</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tp</name><operator>.</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>xmax</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* No replica identity &amp; replication origin logged */</comment>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsToastRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>toast_delete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Never need to mark tuple for invalidation, since catalogs don't support
	 * speculative insertion
	 */</comment>

	<comment type="block">/* Now we can release the buffer */</comment>
	<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* count deletion, as we counted the insertion too */</comment>
	<expr_stmt><expr><call><name>pgstat_count_heap_delete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * heap_inplace_update - update a tuple "in place" (ie, overwrite it)
 *
 * Overwriting violates both MVCC and transactional safety, so the uses
 * of this function in Postgres are extremely limited.  Nonetheless we
 * find some places to use it.
 *
 * The tuple cannot change size, and therefore it's reasonable to assume
 * that its null bitmap (if any) doesn't change either.  So we just
 * overwrite the data portion of the tuple without touching the null
 * bitmap or any of the header fields.
 *
 * tuple is an in-memory tuple structure containing the data to be written
 * over the target tuple.  Also, tuple-&gt;t_self identifies the target tuple.
 */</comment>
<function><type><name>void</name></type>
<name>heap_inplace_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>oldlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>newlen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For now, parallel operations are required to be strictly read-only.
	 * Unlike a regular update, this should never create a combo CID, so it
	 * might be possible to relax this restriction, but not without more
	 * thought and testing.  It's not clear that it would be useful, anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot update tuples during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>offnum</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid lp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldlen</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newlen</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldlen</name> <operator>!=</operator> <name>newlen</name> <operator>||</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>!=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong tuple length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* NO EREPORT(ERROR) from here till changes are logged */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name> <operator>+</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></argument>,
		   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></argument>,
		   <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_heap_inplace</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapInplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name> <operator>+</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* inplace updates aren't decoded atm, don't log the origin */</comment>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP_INPLACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send out shared cache inval if necessary.  Note that because we only
	 * pass the new version of the tuple, this mustn't be used for any
	 * operations that could change catcache lookup keys.  But we aren't
	 * bothering with index updates either, so that's true a fortiori.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CacheInvalidateHeapTuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>FRM_NOOP</name></cpp:macro>				<cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>FRM_INVALIDATE_XMAX</name></cpp:macro>		<cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>FRM_RETURN_IS_XID</name></cpp:macro>		<cpp:value>0x0004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>FRM_RETURN_IS_MULTI</name></cpp:macro>		<cpp:value>0x0008</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>FRM_MARK_COMMITTED</name></cpp:macro>		<cpp:value>0x0010</cpp:value></cpp:define>

<comment type="block">/*
 * FreezeMultiXactId
 *		Determine what to do during freezing when a tuple is marked by a
 *		MultiXactId.
 *
 * NB -- this might have the side-effect of creating a new MultiXactId!
 *
 * "flags" is an output value; it's used to tell caller what to do on return.
 * Possible flags are:
 * FRM_NOOP
 *		don't do anything -- keep existing Xmax
 * FRM_INVALIDATE_XMAX
 *		mark Xmax as InvalidTransactionId and set XMAX_INVALID flag.
 * FRM_RETURN_IS_XID
 *		The Xid return value is a single update Xid to set as xmax.
 * FRM_MARK_COMMITTED
 *		Xmax can be marked as HEAP_XMAX_COMMITTED
 * FRM_RETURN_IS_MULTI
 *		The return value is a new MultiXactId to set as new Xmax.
 *		(caller must obtain proper infomask bits using GetMultiXactIdHintBits)
 */</comment>
<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>FreezeMultiXactId</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>t_infomask</name></decl></parameter>,
				  <parameter><decl><type><name>TransactionId</name></type> <name>relfrozenxid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>relminmxid</name></decl></parameter>,
				  <parameter><decl><type><name>TransactionId</name></type> <name>cutoff_xid</name></decl></parameter>, <parameter><decl><type><name>MultiXactId</name></type> <name>cutoff_multi</name></decl></parameter>,
				  <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_replace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_lockers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>update_xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>update_committed</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* We should only be called in Multis */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>t_infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>HEAP_LOCKED_UPGRADED</name><argument_list>(<argument><expr><name>t_infomask</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ensure infomask bits are appropriately set/reset */</comment>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FRM_INVALIDATE_XMAX</name></expr>;</expr_stmt>
		<return>return <expr><name>InvalidTransactionId</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>relminmxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"found multixact %u from before relminmxid %u"</literal></expr></argument>,
								 <argument><expr><name>multi</name></expr></argument>, <argument><expr><name>relminmxid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>cutoff_multi</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This old multi cannot possibly have members still running, but
		 * verify just in case.  If it was a locker only, it can be removed
		 * without any further consideration; but if it contained an update,
		 * we might need to preserve it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdIsRunning</name><argument_list>(<argument><expr><name>multi</name></expr></argument>,
								 <argument><expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>t_infomask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"multixact %u from before cutoff %u found to be still running"</literal></expr></argument>,
									 <argument><expr><name>multi</name></expr></argument>, <argument><expr><name>cutoff_multi</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>t_infomask</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FRM_INVALIDATE_XMAX</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>xid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt> <comment type="block">/* not strictly necessary */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* replace multi by update xid */</comment>
			<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>MultiXactIdGetUpdateXid</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>t_infomask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* wasn't only a lock, xid needs to be valid */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>relfrozenxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"found update xid %u from before relfrozenxid %u"</literal></expr></argument>,
										 <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>relfrozenxid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If the xid is older than the cutoff, it has to have aborted,
			 * otherwise the tuple would have gotten pruned away.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>cutoff_xid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"cannot freeze committed update xid %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FRM_INVALIDATE_XMAX</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>xid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt> <comment type="block">/* not strictly necessary */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FRM_RETURN_IS_XID</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<return>return <expr><name>xid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This multixact might have or might not have members still running, but
	 * we know it's valid and is newer than the cutoff point for multis.
	 * However, some member(s) of it may be below the cutoff for Xids, so we
	 * need to walk the whole members array to figure out what to do, if
	 * anything.
	 */</comment>

	<expr_stmt><expr><name>nmembers</name> <operator>=</operator>
		<call><name>GetMultiXactIdMembers</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>t_infomask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nmembers</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Nothing worth keeping */</comment>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FRM_INVALIDATE_XMAX</name></expr>;</expr_stmt>
		<return>return <expr><name>InvalidTransactionId</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* is there anything older than the cutoff? */</comment>
	<expr_stmt><expr><name>need_replace</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>, <argument><expr><name>cutoff_xid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>need_replace</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * In the simplest case, there is no member older than the cutoff; we can
	 * keep the existing MultiXactId as is.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_replace</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FRM_NOOP</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidTransactionId</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the multi needs to be updated, figure out which members do we need
	 * to keep.
	 */</comment>
	<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>newmembers</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactMember</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>has_lockers</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>update_xid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>update_committed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Determine whether to keep this member or ignore it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ISUPDATE_from_mxstatus</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>relfrozenxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"found update xid %u from before relfrozenxid %u"</literal></expr></argument>,
										 <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>relfrozenxid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * It's an update; should we keep it?  If the transaction is known
			 * aborted or crashed then it's okay to ignore it, otherwise not.
			 * Note that an updater older than cutoff_xid cannot possibly be
			 * committed, because HeapTupleSatisfiesVacuum would have returned
			 * HEAPTUPLE_DEAD and we would not be trying to freeze the tuple.
			 *
			 * As with all tuple visibility routines, it's critical to test
			 * TransactionIdIsInProgress before TransactionIdDidCommit,
			 * because of race conditions explained in detail in
			 * heapam_visibility.c.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>TransactionIdIsInProgress</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>update_xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>update_xid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The transaction committed, so we can tell caller to set
				 * HEAP_XMAX_COMMITTED.  (We can only do this because we know
				 * the transaction is not running.)
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>update_xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>update_committed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>update_xid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Not in progress, not committed -- must be aborted or
				 * crashed; we can ignore it.
				 */</comment>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Since the tuple wasn't marked HEAPTUPLE_DEAD by vacuum, the
			 * update Xid cannot possibly be older than the xid cutoff. The
			 * presence of such a tuple would cause corruption, so be paranoid
			 * and check.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>update_xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>update_xid</name></expr></argument>, <argument><expr><name>cutoff_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"found update xid %u from before xid cutoff %u"</literal></expr></argument>,
										 <argument><expr><name>update_xid</name></expr></argument>, <argument><expr><name>cutoff_xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If we determined that it's an Xid corresponding to an update
			 * that must be retained, additionally add it to the list of
			 * members of the new Multi, in case we end up using that.  (We
			 * might still decide to use only an update Xid and not a multi,
			 * but it's easier to maintain the list as we walk the old members
			 * list.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>update_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>newmembers</name><index>[<expr><name>nnewmembers</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>members</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* We only keep lockers if they are still running */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>TransactionIdIsInProgress</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* running locker cannot possibly be older than the cutoff */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>, <argument><expr><name>cutoff_xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newmembers</name><index>[<expr><name>nnewmembers</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>members</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>has_lockers</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nnewmembers</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing worth keeping!? Tell caller to remove the whole thing */</comment>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FRM_INVALIDATE_XMAX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>xid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>update_xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_lockers</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If there's a single member and it's an update, pass it back alone
		 * without creating a new Multi.  (XXX we could do this when there's a
		 * single remaining locker, too, but that would complicate the API too
		 * much; moreover, the case with the single updater is more
		 * interesting, because those are longer-lived.)
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nnewmembers</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FRM_RETURN_IS_XID</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>update_committed</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FRM_MARK_COMMITTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>xid</name> <operator>=</operator> <name>update_xid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Create a new multixact with the surviving members of the previous
		 * one, to set as new Xmax in the tuple.
		 */</comment>
		<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>MultiXactIdCreateFromMembers</name><argument_list>(<argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FRM_RETURN_IS_MULTI</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>xid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_prepare_freeze_tuple
 *
 * Check to see whether any of the XID fields of a tuple (xmin, xmax, xvac)
 * are older than the specified cutoff XID and cutoff MultiXactId.  If so,
 * setup enough state (in the *frz output argument) to later execute and
 * WAL-log what we would need to do, and return true.  Return false if nothing
 * is to be changed.  In addition, set *totally_frozen_p to true if the tuple
 * will be totally frozen after these operations are performed and false if
 * more freezing will eventually be required.
 *
 * Caller is responsible for setting the offset field, if appropriate.
 *
 * It is assumed that the caller has checked the tuple with
 * HeapTupleSatisfiesVacuum() and determined that it is not HEAPTUPLE_DEAD
 * (else we should be removing the tuple, not freezing it).
 *
 * NB: cutoff_xid *must* be &lt;= the current global xmin, to ensure that any
 * XID older than it could neither be running nor seen as running by any
 * open transaction.  This ensures that the replacement will not change
 * anyone's idea of the tuple state.
 * Similarly, cutoff_multi must be less than or equal to the smallest
 * MultiXactId used by any transaction currently open.
 *
 * If the tuple is in a shared buffer, caller must hold an exclusive lock on
 * that buffer.
 *
 * NB: It is not enough to set hint bits to indicate something is
 * committed/invalid -- they might not be set on a standby, or after crash
 * recovery.  We really need to remove old xids.
 */</comment>
<function><type><name>bool</name></type>
<name>heap_prepare_freeze_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>,
						  <parameter><decl><type><name>TransactionId</name></type> <name>relfrozenxid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>relminmxid</name></decl></parameter>,
						  <parameter><decl><type><name>TransactionId</name></type> <name>cutoff_xid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>cutoff_multi</name></decl></parameter>,
						  <parameter><decl><type><name>xl_heap_freeze_tuple</name> <modifier>*</modifier></type><name>frz</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>totally_frozen_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>xmax_already_frozen</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>xmin_frozen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>freeze_xmax</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>frzflags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process xmin.  xmin_frozen has two slightly different meanings: in the
	 * !XidIsNormal case, it means "the xmin doesn't need any freezing" (it's
	 * already a permanent value), while in the block below it is set true to
	 * mean "xmin won't need freezing after what we do to it here" (false
	 * otherwise).  In both cases we're allowed to set totally_frozen, as far
	 * as xmin is concerned.
	 */</comment>
	<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xmin_frozen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>relfrozenxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"found xmin %u from before relfrozenxid %u"</literal></expr></argument>,
									 <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>relfrozenxid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>xmin_frozen</name> <operator>=</operator> <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>cutoff_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>xmin_frozen</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"uncommitted xmin %u from before xid cutoff %u needs to be frozen"</literal></expr></argument>,
										 <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>cutoff_xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>HEAP_XMIN_FROZEN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>xmin_frozen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Process xmax.  To thoroughly examine the current Xmax value we need to
	 * resolve a MultiXactId to its member Xids, in case some of them are
	 * below the given cutoff for Xids.  In that case, those values might need
	 * freezing, too.  Also, if a multi needs freezing, we cannot simply take
	 * it out --- if there's a live updater Xid, it needs to be kept.
	 *
	 * Make sure to keep heap_tuple_needs_freeze in sync with this.
	 */</comment>
	<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>newxmax</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint16</name></type>		<name>flags</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newxmax</name> <operator>=</operator> <call><name>FreezeMultiXactId</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
									<argument><expr><name>relfrozenxid</name></expr></argument>, <argument><expr><name>relminmxid</name></expr></argument>,
									<argument><expr><name>cutoff_xid</name></expr></argument>, <argument><expr><name>cutoff_multi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>freeze_xmax</name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FRM_INVALIDATE_XMAX</name><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FRM_RETURN_IS_XID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * NB -- some of these transformations are only valid because we
			 * know the return Xid is a tuple updater (i.e. not merely a
			 * locker.) Also note that the only reason we don't explicitly
			 * worry about HEAP_KEYS_UPDATED is because it lives in
			 * t_infomask2 rather than t_infomask.
			 */</comment>
			<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XMAX_BITS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name>newxmax</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FRM_MARK_COMMITTED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>HEAP_XMAX_COMMITTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FRM_RETURN_IS_MULTI</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint16</name></type>		<name>newbits</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint16</name></type>		<name>newbits2</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We can't use GetMultiXactIdHintBits directly on the new multi
			 * here; that routine initializes the masks to all zeroes, which
			 * would lose other bits we need.  Doing it this way ensures all
			 * unrelated bits remain untouched.
			 */</comment>
			<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XMAX_BITS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GetMultiXactIdHintBits</name><argument_list>(<argument><expr><name>newxmax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newbits2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>newbits</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>|=</operator> <name>newbits2</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name>newxmax</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>relfrozenxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"found xmax %u from before relfrozenxid %u"</literal></expr></argument>,
									 <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>relfrozenxid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>cutoff_xid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we freeze xmax, make absolutely sure that it's not an XID
			 * that is important.  (Note, a lock-only xmax can be removed
			 * independent of committedness, since a committed lock holder has
			 * released the lock).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"cannot freeze committed xmax %u"</literal></expr></argument>,
										 <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>freeze_xmax</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>freeze_xmax</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name><operator>)</operator> <operator>||</operator>
			 <operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>freeze_xmax</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>xmax_already_frozen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"found xmax %u (infomask 0x%04x) not frozen, not multi, not normal"</literal></expr></argument>,
								 <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>freeze_xmax</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>xmax_already_frozen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The tuple might be marked either XMAX_INVALID or XMAX_COMMITTED +
		 * LOCKED.  Normalize to INVALID just to be sure no one gets confused.
		 * Also get rid of the HEAP_KEYS_UPDATED bit.
		 */</comment>
		<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XMAX_BITS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>HEAP_XMAX_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_HOT_UPDATED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Old-style VACUUM FULL is gone, but we have to keep this code as long as
	 * we support having MOVED_OFF/MOVED_IN tuples in the database.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_MOVED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXvac</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For Xvac, we ignore the cutoff_xid and just always perform the
		 * freeze operation.  The oldest release in which such a value can
		 * actually be set is PostgreSQL 8.4, because old-style VACUUM FULL
		 * was removed in PostgreSQL 9.0.  Note that if we were to respect
		 * cutoff_xid here, we'd need to make surely to clear totally_frozen
		 * when we skipped freezing on that basis.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If a MOVED_OFF tuple is not dead, the xvac transaction must
			 * have failed; whereas a non-dead MOVED_IN tuple must mean the
			 * xvac transaction succeeded.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_MOVED_OFF</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>frzflags</name></name> <operator>|=</operator> <name>XLH_INVALID_XVAC</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>frzflags</name></name> <operator>|=</operator> <name>XLH_FREEZE_XVAC</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Might as well fix the hint bits too; usually XMIN_COMMITTED
			 * will already be set here, but there's a small chance not.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMIN_INVALID</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>frz</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>|=</operator> <name>HEAP_XMIN_COMMITTED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>totally_frozen_p</name> <operator>=</operator> <operator>(</operator><name>xmin_frozen</name> <operator>&amp;&amp;</operator>
						 <operator>(</operator><name>freeze_xmax</name> <operator>||</operator> <name>xmax_already_frozen</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><name>changed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_execute_freeze_tuple
 *		Execute the prepared freezing of a tuple.
 *
 * Caller is responsible for ensuring that no other backend can access the
 * storage underlying this tuple, either by holding an exclusive lock on the
 * buffer containing it (which is what lazy VACUUM does), or by having it be
 * in private storage (which is what CLUSTER and friends do).
 *
 * Note: it might seem we could make the changes without exclusive lock, since
 * TransactionId read/write is assumed atomic anyway.  However there is a race
 * condition: someone who just fetched an old XID that we overwrite here could
 * conceivably not finish checking the XID against pg_xact before we finish
 * the VACUUM and perhaps truncate off the part of pg_xact he needs.  Getting
 * exclusive lock ensures no other backend is in process of checking the
 * tuple status.  Also, getting exclusive lock makes it safe to adjust the
 * infomask bits.
 *
 * NB: All code in here must be safe to execute during crash recovery!
 */</comment>
<function><type><name>void</name></type>
<name>heap_execute_freeze_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>xl_heap_freeze_tuple</name> <modifier>*</modifier></type><name>frz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>frz</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>frz</name><operator>-&gt;</operator><name>frzflags</name></name> <operator>&amp;</operator> <name>XLH_FREEZE_XVAC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetXvac</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>FrozenTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>frz</name><operator>-&gt;</operator><name>frzflags</name></name> <operator>&amp;</operator> <name>XLH_INVALID_XVAC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetXvac</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>frz</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>frz</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * heap_freeze_tuple
 *		Freeze tuple in place, without WAL logging.
 *
 * Useful for callers like CLUSTER that perform their own WAL logging.
 */</comment>
<function><type><name>bool</name></type>
<name>heap_freeze_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>,
				  <parameter><decl><type><name>TransactionId</name></type> <name>relfrozenxid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>relminmxid</name></decl></parameter>,
				  <parameter><decl><type><name>TransactionId</name></type> <name>cutoff_xid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>cutoff_multi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_freeze_tuple</name></type> <name>frz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>do_freeze</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tuple_totally_frozen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>do_freeze</name> <operator>=</operator> <call><name>heap_prepare_freeze_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
										  <argument><expr><name>relfrozenxid</name></expr></argument>, <argument><expr><name>relminmxid</name></expr></argument>,
										  <argument><expr><name>cutoff_xid</name></expr></argument>, <argument><expr><name>cutoff_multi</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>frz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple_totally_frozen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that because this is not a WAL-logged operation, we don't need to
	 * fill in the offset in the freeze record.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>do_freeze</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_execute_freeze_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>frz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>do_freeze</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For a given MultiXactId, return the hint bits that should be set in the
 * tuple's infomask.
 *
 * Normally this should be called for a multixact that was just created, and
 * so is on our local cache, so the GetMembers call is fast.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetMultiXactIdHintBits</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>new_infomask</name></decl></parameter>,
					   <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>new_infomask2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>bits</name> <init>= <expr><name>HEAP_XMAX_IS_MULTI</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>bits2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_update</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockTupleMode</name></type> <name>strongest</name> <init>= <expr><name>LockTupleKeyShare</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We only use this in multis we just created, so they cannot be values
	 * pre-pg_upgrade.
	 */</comment>
	<expr_stmt><expr><name>nmembers</name> <operator>=</operator> <call><name>GetMultiXactIdMembers</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Remember the strongest lock mode held by any member of the
		 * multixact.
		 */</comment>
		<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>TUPLOCK_from_mxstatus</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>&gt;</operator> <name>strongest</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>strongest</name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* See what other bits we need */</comment>
		<switch>switch <condition>(<expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>MultiXactStatusForKeyShare</name></expr>:</case>
			<case>case <expr><name>MultiXactStatusForShare</name></expr>:</case>
			<case>case <expr><name>MultiXactStatusForNoKeyUpdate</name></expr>:</case>
				<break>break;</break>

			<case>case <expr><name>MultiXactStatusForUpdate</name></expr>:</case>
				<expr_stmt><expr><name>bits2</name> <operator>|=</operator> <name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>MultiXactStatusNoKeyUpdate</name></expr>:</case>
				<expr_stmt><expr><name>has_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>MultiXactStatusUpdate</name></expr>:</case>
				<expr_stmt><expr><name>bits2</name> <operator>|=</operator> <name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>has_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>strongest</name> <operator>==</operator> <name>LockTupleExclusive</name> <operator>||</operator>
		<name>strongest</name> <operator>==</operator> <name>LockTupleNoKeyExclusive</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bits</name> <operator>|=</operator> <name>HEAP_XMAX_EXCL_LOCK</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>strongest</name> <operator>==</operator> <name>LockTupleShare</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bits</name> <operator>|=</operator> <name>HEAP_XMAX_SHR_LOCK</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>strongest</name> <operator>==</operator> <name>LockTupleKeyShare</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bits</name> <operator>|=</operator> <name>HEAP_XMAX_KEYSHR_LOCK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_update</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bits</name> <operator>|=</operator> <name>HEAP_XMAX_LOCK_ONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nmembers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>new_infomask</name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>new_infomask2</name> <operator>=</operator> <name>bits2</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MultiXactIdGetUpdateXid
 *
 * Given a multixact Xmax and corresponding infomask, which does not have the
 * HEAP_XMAX_LOCK_ONLY bit set, obtain and return the Xid of the updating
 * transaction.
 *
 * Caller is expected to check the status of the updating transaction, if
 * necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>MultiXactIdGetUpdateXid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xmax</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>t_infomask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>update_xact</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>t_infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_LOCK_ONLY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>t_infomask</name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we know the LOCK_ONLY bit is not set, this cannot be a multi from
	 * pre-pg_upgrade.
	 */</comment>
	<expr_stmt><expr><name>nmembers</name> <operator>=</operator> <call><name>GetMultiXactIdMembers</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nmembers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Ignore lockers */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISUPDATE_from_mxstatus</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* there can be at most one updater */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>update_xact</name> <operator>==</operator> <name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>update_xact</name> <operator>=</operator> <name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifndef>

			<comment type="block">/*
			 * in an assert-enabled build, walk the whole array to ensure
			 * there's no other updater.
			 */</comment>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>update_xact</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * HeapTupleGetUpdateXid
 *		As above, but use a HeapTupleHeader
 *
 * See also HeapTupleHeaderGetUpdateXid, which can be used without previously
 * checking the hint bits.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>HeapTupleGetUpdateXid</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>MultiXactIdGetUpdateXid</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the given multixact conflict with the current transaction grabbing a
 * tuple lock of the given strength?
 *
 * The passed infomask pairs up with the given multixact in the tuple header.
 *
 * If current_is_member is not NULL, it is set to 'true' if the current
 * transaction is a member of the given multixact.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DoesMultiXactIdConflict</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>infomask</name></decl></parameter>,
						<parameter><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>current_is_member</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>wanted</name> <init>= <expr><name><name>tupleLockExtraInfo</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>.</operator><name>hwlock</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HEAP_LOCKED_UPGRADED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nmembers</name> <operator>=</operator> <call><name>GetMultiXactIdMembers</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									 <argument><expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nmembers</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>memxid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>memlockmode</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>current_is_member</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>current_is_member</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>memlockmode</name> <operator>=</operator> <call><name>LOCKMODE_from_mxstatus</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* ignore members from current xact (but track their presence) */</comment>
			<expr_stmt><expr><name>memxid</name> <operator>=</operator> <name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>memxid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>current_is_member</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>current_is_member</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* ignore members that don't conflict with the lock we want */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DoLockModesConflict</name><argument_list>(<argument><expr><name>memlockmode</name></expr></argument>, <argument><expr><name>wanted</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>ISUPDATE_from_mxstatus</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ignore aborted updaters */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>TransactionIdDidAbort</name><argument_list>(<argument><expr><name>memxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* ignore lockers-only that are no longer in progress */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsInProgress</name><argument_list>(<argument><expr><name>memxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Whatever remains are either live lockers that conflict with our
			 * wanted lock, and updaters that are not aborted.  Those conflict
			 * with what we want.  Set up to return true, but keep going to
			 * look for the current transaction among the multixact members,
			 * if needed.
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do_MultiXactIdWait
 *		Actual implementation for the two functions below.
 *
 * 'multi', 'status' and 'infomask' indicate what to sleep on (the status is
 * needed to ensure we only sleep on conflicting members, and the infomask is
 * used to optimize multixact access in case it's a lock-only multi); 'nowait'
 * indicates whether to use conditional lock acquisition, to allow callers to
 * fail if lock is unavailable.  'rel', 'ctid' and 'oper' are used to set up
 * context information for error messages.  'remaining', if not NULL, receives
 * the number of members that are still running, including any (non-aborted)
 * subtransactions of our own transaction.
 *
 * We do this by sleeping on each member using XactLockTableWait.  Any
 * members that belong to the current backend are *not* waited for, however;
 * this would not merely be useless but would lead to Assert failure inside
 * XactLockTableWait.  By the time this returns, it is certain that all
 * transactions *of other backends* that were members of the MultiXactId
 * that conflict with the requested status are dead (and no new ones can have
 * been added, since it is not legal to add members to an existing
 * MultiXactId).
 *
 * But by the time we finish sleeping, someone else may have changed the Xmax
 * of the containing tuple, so the caller needs to iterate on us somehow.
 *
 * Note that in case we return false, the number of remaining members is
 * not to be trusted.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>Do_MultiXactIdWait</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>MultiXactStatus</name></type> <name>status</name></decl></parameter>,
				   <parameter><decl><type><name>uint16</name></type> <name>infomask</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>,
				   <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>ctid</name></decl></parameter>, <parameter><decl><type><name>XLTW_Oper</name></type> <name>oper</name></decl></parameter>,
				   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>remain</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* for pre-pg_upgrade tuples, no need to sleep at all */</comment>
	<expr_stmt><expr><name>nmembers</name> <operator>=</operator> <ternary><condition><expr><call><name>HEAP_LOCKED_UPGRADED</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>:
		<expr><call><name>GetMultiXactIdMembers</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nmembers</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>memxid</name> <init>= <expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MultiXactStatus</name></type> <name>memstatus</name> <init>= <expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>memxid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>remain</name><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DoLockModesConflict</name><argument_list>(<argument><expr><call><name>LOCKMODE_from_mxstatus</name><argument_list>(<argument><expr><name>memstatus</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>LOCKMODE_from_mxstatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>&amp;&amp;</operator> <call><name>TransactionIdIsInProgress</name><argument_list>(<argument><expr><name>memxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>remain</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * This member conflicts with our multi, so we have to sleep (or
			 * return failure, if asked to avoid waiting.)
			 *
			 * Note that we don't set up an error context callback ourselves,
			 * but instead we pass the info down to XactLockTableWait.  This
			 * might seem a bit wasteful because the context is set up and
			 * tore down for each member of the multixact, but in reality it
			 * should be barely noticeable, and it avoids duplicate code.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>nowait</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ConditionalXactLockTableWait</name><argument_list>(<argument><expr><name>memxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name>memxid</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ctid</name></expr></argument>, <argument><expr><name>oper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>remaining</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>remaining</name> <operator>=</operator> <name>remain</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MultiXactIdWait
 *		Sleep on a MultiXactId.
 *
 * By the time we finish sleeping, someone else may have changed the Xmax
 * of the containing tuple, so the caller needs to iterate on us somehow.
 *
 * We return (in *remaining, if not NULL) the number of members that are still
 * running, including any (non-aborted) subtransactions of our own transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MultiXactIdWait</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>MultiXactStatus</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>infomask</name></decl></parameter>,
				<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>ctid</name></decl></parameter>, <parameter><decl><type><name>XLTW_Oper</name></type> <name>oper</name></decl></parameter>,
				<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>Do_MultiXactIdWait</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ctid</name></expr></argument>, <argument><expr><name>oper</name></expr></argument>, <argument><expr><name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ConditionalMultiXactIdWait
 *		As above, but only lock if we can get the lock without blocking.
 *
 * By the time we finish sleeping, someone else may have changed the Xmax
 * of the containing tuple, so the caller needs to iterate on us somehow.
 *
 * If the multixact is now all gone, return true.  Returns false if some
 * transactions might still be running.
 *
 * We return (in *remaining, if not NULL) the number of members that are still
 * running, including any (non-aborted) subtransactions of our own transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ConditionalMultiXactIdWait</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>MultiXactStatus</name></type> <name>status</name></decl></parameter>,
						   <parameter><decl><type><name>uint16</name></type> <name>infomask</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>remaining</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>Do_MultiXactIdWait</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>infomask</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>XLTW_None</name></expr></argument>, <argument><expr><name>remaining</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_tuple_needs_eventual_freeze
 *
 * Check to see whether any of the XID fields of a tuple (xmin, xmax, xvac)
 * will eventually require freezing.  Similar to heap_tuple_needs_freeze,
 * but there's no cutoff, since we're trying to figure out whether freezing
 * will ever be needed, not whether it's needed now.
 */</comment>
<function><type><name>bool</name></type>
<name>heap_tuple_needs_eventual_freeze</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If xmin is a normal transaction ID, this tuple is definitely not
	 * frozen.
	 */</comment>
	<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If xmax is a valid xact or multixact, this tuple is also not frozen.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multi</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>multi</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_MOVED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXvac</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * heap_tuple_needs_freeze
 *
 * Check to see whether any of the XID fields of a tuple (xmin, xmax, xvac)
 * are older than the specified cutoff XID or MultiXactId.  If so, return true.
 *
 * It doesn't matter whether the tuple is alive or dead, we are checking
 * to see if a tuple needs to be removed or frozen to avoid wraparound.
 *
 * NB: Cannot rely on hint bits here, they might not be set after a crash or
 * on a standby.
 */</comment>
<function><type><name>bool</name></type>
<name>heap_tuple_needs_freeze</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>cutoff_xid</name></decl></parameter>,
						<parameter><decl><type><name>MultiXactId</name></type> <name>cutoff_multi</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>cutoff_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The considerations for multixacts are complicated; look at
	 * heap_prepare_freeze_tuple for justifications.  This routine had better
	 * be in sync with that one!
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_IS_MULTI</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multi</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>multi</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no xmax set, ignore */</comment>
			<empty_stmt>;</empty_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>HEAP_LOCKED_UPGRADED</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>cutoff_multi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<comment type="block">/* need to check whether any member of the mxact is too old */</comment>

			<expr_stmt><expr><name>nmembers</name> <operator>=</operator> <call><name>GetMultiXactIdMembers</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>, <argument><expr><name>cutoff_xid</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>nmembers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>cutoff_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_MOVED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>xid</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXvac</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>cutoff_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If 'tuple' contains any visible XID greater than latestRemovedXid,
 * ratchet forwards latestRemovedXid to the greatest one found.
 * This is used as the basis for generating Hot Standby conflicts, so
 * if a tuple was never visible then removing it should not conflict
 * with queries.
 */</comment>
<function><type><name>void</name></type>
<name>HeapTupleHeaderAdvanceLatestRemovedXid</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl></parameter>,
									   <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>latestRemovedXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name> <init>= <expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmax</name> <init>= <expr><call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xvac</name> <init>= <expr><call><name>HeapTupleHeaderGetXvac</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_MOVED</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><operator>*</operator><name>latestRemovedXid</name></expr></argument>, <argument><expr><name>xvac</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>latestRemovedXid</name> <operator>=</operator> <name>xvac</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Ignore tuples inserted by an aborted transaction or if the tuple was
	 * updated/deleted by the inserting transaction.
	 *
	 * Look for a committed hint bit, or if no xmin bit is set, check clog.
	 * This needs to work on both master and standby, where it is used to
	 * assess btree delete records.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHeaderXminCommitted</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><operator>!</operator><call><name>HeapTupleHeaderXminInvalid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>xmax</name> <operator>!=</operator> <name>xmin</name> <operator>&amp;&amp;</operator>
			<call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>xmax</name></expr></argument>, <argument><expr><operator>*</operator><name>latestRemovedXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>latestRemovedXid</name> <operator>=</operator> <name>xmax</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* *latestRemovedXid may still be invalid at end */</comment>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
<comment type="block">/*
 * Helper function for heap_compute_xid_horizon_for_tuples.  Issue prefetch
 * requests for the number of buffers indicated by prefetch_count.  The
 * prefetch_state keeps track of all the buffers that we can prefetch and
 * which ones have already been prefetched; each call to this function picks
 * up where the previous call left off.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>xid_horizon_prefetch_buffer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							<parameter><decl><type><name>XidHorizonPrefetchState</name> <modifier>*</modifier></type><name>prefetch_state</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>prefetch_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>cur_hblkno</name> <init>= <expr><name><name>prefetch_state</name><operator>-&gt;</operator><name>cur_hblkno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name> <init>= <expr><name><name>prefetch_state</name><operator>-&gt;</operator><name>nitems</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>tids</name> <init>= <expr><name><name>prefetch_state</name><operator>-&gt;</operator><name>tids</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>prefetch_state</name><operator>-&gt;</operator><name>next_item</name></name></expr>;</init>
		 <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>&lt;</operator> <name>prefetch_count</name></expr>;</condition>
		 <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>htid</name> <init>= <expr><operator>&amp;</operator><name><name>tids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>cur_hblkno</name> <operator>==</operator> <name>InvalidBlockNumber</name> <operator>||</operator>
			<call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>htid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>cur_hblkno</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cur_hblkno</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>htid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PrefetchBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>cur_hblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Save the prefetch position so that next time we can continue from that
	 * position.
	 */</comment>
	<expr_stmt><expr><name><name>prefetch_state</name><operator>-&gt;</operator><name>next_item</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prefetch_state</name><operator>-&gt;</operator><name>cur_hblkno</name></name> <operator>=</operator> <name>cur_hblkno</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Get the latestRemovedXid from the heap pages pointed at by the index
 * tuples being deleted.
 *
 * We used to do this during recovery rather than on the primary, but that
 * approach now appears inferior.  It meant that the master could generate
 * a lot of work for the standby without any back-pressure to slow down the
 * master, and it required the standby to have reached consistency, whereas
 * we want to have correct information available even before that point.
 *
 * It's possible for this to generate a fair amount of I/O, since we may be
 * deleting hundreds of tuples from a single index block.  To amortize that
 * cost to some degree, this uses prefetching and combines repeat accesses to
 * the same block.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>heap_compute_xid_horizon_for_tuples</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
									<parameter><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>tids</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>hblkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>hpage</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
	<decl_stmt><decl><type><name>XidHorizonPrefetchState</name></type> <name>prefetch_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>io_concurrency</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prefetch_distance</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Sort to avoid repeated lookups for the same page, and to make it more
	 * likely to access items in an efficient order. In particular, this
	 * ensures that if there are multiple pointers to the same page, they all
	 * get processed looking up and locking the page just once.
	 */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tids</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		  <argument><expr><operator>(</operator><call><call><name>int</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator> <name>ItemPointerCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
	<comment type="block">/* Initialize prefetch state. */</comment>
	<expr_stmt><expr><name><name>prefetch_state</name><operator>.</operator><name>cur_hblkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prefetch_state</name><operator>.</operator><name>next_item</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prefetch_state</name><operator>.</operator><name>nitems</name></name> <operator>=</operator> <name>nitems</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prefetch_state</name><operator>.</operator><name>tids</name></name> <operator>=</operator> <name>tids</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute the prefetch distance that we will attempt to maintain.
	 *
	 * We don't use the regular formula to determine how much to prefetch
	 * here, but instead just add a constant to effective_io_concurrency.
	 * That's because it seems best to do some prefetching here even when
	 * effective_io_concurrency is set to 0, but if the DBA thinks it's OK to
	 * do more prefetching for other operations, then it's probably OK to do
	 * more prefetching in this case, too. It may be that this formula is too
	 * simplistic, but at the moment there is no evidence of that or any idea
	 * about what would work better.
	 *
	 * Since the caller holds a buffer lock somewhere in rel, we'd better make
	 * sure that isn't a catalog relation before we call code that does
	 * syscache lookups, to avoid risk of deadlock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCatalogRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>io_concurrency</name> <operator>=</operator> <name>effective_io_concurrency</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>io_concurrency</name> <operator>=</operator> <call><name>get_tablespace_io_concurrency</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>prefetch_distance</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><operator>(</operator><name>io_concurrency</name><operator>)</operator> <operator>+</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><name>MAX_IO_CONCURRENCY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Start prefetching. */</comment>
	<expr_stmt><expr><call><name>xid_horizon_prefetch_buffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prefetch_state</name></expr></argument>, <argument><expr><name>prefetch_distance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Iterate over all tids, and check their horizon */</comment>
	<expr_stmt><expr><name>hblkno</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hpage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>htid</name> <init>= <expr><operator>&amp;</operator><name><name>tids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>hitemid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>hoffnum</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Read heap buffer, but avoid refetching if it's the same block as
		 * required for the last tid.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hblkno</name> <operator>==</operator> <name>InvalidBlockNumber</name> <operator>||</operator>
			<call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>htid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>hblkno</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* release old buffer */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>hblkno</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>htid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>hblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>

			<comment type="block">/*
			 * To maintain the prefetch distance, prefetch one more page for
			 * each page we read.
			 */</comment>
			<expr_stmt><expr><call><name>xid_horizon_prefetch_buffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prefetch_state</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<expr_stmt><expr><name>hpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>hoffnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>htid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hitemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>hpage</name></expr></argument>, <argument><expr><name>hoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Follow any redirections until we find something useful.
		 */</comment>
		<while>while <condition>(<expr><call><name>ItemIdIsRedirected</name><argument_list>(<argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hoffnum</name> <operator>=</operator> <call><name>ItemIdGetRedirect</name><argument_list>(<argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hitemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>hpage</name></expr></argument>, <argument><expr><name>hoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * If the heap item has storage, then read the header and use that to
		 * set latestRemovedXid.
		 *
		 * Some LP_DEAD items may not be accessible, so we ignore them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ItemIdHasStorage</name><argument_list>(<argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htuphdr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>htuphdr</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>hpage</name></expr></argument>, <argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>HeapTupleHeaderAdvanceLatestRemovedXid</name><argument_list>(<argument><expr><name>htuphdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>latestRemovedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Conjecture: if hitemid is dead then it had xids before the xids
			 * marked on LP_NORMAL items. So we just ignore this item and move
			 * onto the next, for the purposes of calculating
			 * latestRemovedXid.
			 */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>hitemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If all heap tuples were LP_DEAD then we will be returning
	 * InvalidTransactionId here, which avoids conflicts. This matches
	 * existing logic which assumes that LP_DEAD tuples must already be older
	 * than the latestRemovedXid on the cleanup record that set them as
	 * LP_DEAD, hence must already have generated a conflict.
	 */</comment>

	<return>return <expr><name>latestRemovedXid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform XLogInsert to register a heap cleanup info message. These
 * messages are sent once per VACUUM and are required because
 * of the phasing of removal operations during a lazy VACUUM.
 * see comments for vacuum_log_cleanup_info().
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>log_heap_cleanup_info</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_cleanup_info</name></type> <name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>rnode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>latestRemovedXid</name></name> <operator>=</operator> <name>latestRemovedXid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapCleanupInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP2_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP2_CLEANUP_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>recptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform XLogInsert for a heap-clean operation.  Caller must already
 * have modified the buffer and marked it dirty.
 *
 * Note: prior to Postgres 8.3, the entries in the nowunused[] array were
 * zero-based tuple indexes.  Now they are one-based like other uses
 * of OffsetNumber.
 *
 * We also include latestRemovedXid, which is the greatest XID present in
 * the removed tuples. That allows recovery processing to cancel or wait
 * for long standby queries that can still see these tuples.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>log_heap_clean</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
			   <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>redirected</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nredirected</name></decl></parameter>,
			   <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>nowdead</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndead</name></decl></parameter>,
			   <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>nowunused</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nunused</name></decl></parameter>,
			   <parameter><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_clean</name></type> <name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

	<comment type="block">/* Caller should not call me on a non-WAL-logged relation */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>latestRemovedXid</name></name> <operator>=</operator> <name>latestRemovedXid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nredirected</name></name> <operator>=</operator> <name>nredirected</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>ndead</name></name> <operator>=</operator> <name>ndead</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapClean</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The OffsetNumber arrays are not actually in the buffer, but we pretend
	 * that they are.  When XLogInsert stores the whole buffer, the offset
	 * arrays need not be stored too.  Note that even if all three arrays are
	 * empty, we want to expose the buffer as a candidate for whole-page
	 * storage, since this record type implies a defragmentation operation
	 * even if no line pointers changed state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nredirected</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>redirected</name></expr></argument>,
							<argument><expr><name>nredirected</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ndead</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>nowdead</name></expr></argument>,
							<argument><expr><name>ndead</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nunused</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>nowunused</name></expr></argument>,
							<argument><expr><name>nunused</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP2_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP2_CLEAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>recptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform XLogInsert for a heap-freeze operation.  Caller must have already
 * modified the buffer and marked it dirty.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>log_heap_freeze</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>cutoff_xid</name></decl></parameter>,
				<parameter><decl><type><name>xl_heap_freeze_tuple</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_freeze_page</name></type> <name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

	<comment type="block">/* Caller should not call me on a non-WAL-logged relation */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* nor when there are no tuples to freeze */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ntuples</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>cutoff_xid</name></name> <operator>=</operator> <name>cutoff_xid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>ntuples</name></name> <operator>=</operator> <name>ntuples</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapFreezePage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The freeze plan array is not actually in the buffer, but pretend that
	 * it is.  When XLogInsert stores the whole buffer, the freeze plan need
	 * not be stored too.
	 */</comment>
	<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuples</name></expr></argument>,
						<argument><expr><name>ntuples</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>xl_heap_freeze_tuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP2_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP2_FREEZE_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>recptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform XLogInsert for a heap-visible operation.  'block' is the block
 * being marked all-visible, and vm_buffer is the buffer containing the
 * corresponding visibility map block.  Both should have already been modified
 * and dirtied.
 *
 * If checksums are enabled, we also generate a full-page image of
 * heap_buffer, if necessary.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>log_heap_visible</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>heap_buffer</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>vm_buffer</name></decl></parameter>,
				 <parameter><decl><type><name>TransactionId</name></type> <name>cutoff_xid</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>vmflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_visible</name></type> <name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>flags</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>heap_buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>vm_buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>cutoff_xid</name></name> <operator>=</operator> <name>cutoff_xid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>vmflags</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapVisible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>vm_buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>REGBUF_STANDARD</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogHintBitIsNeeded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REGBUF_NO_IMAGE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>heap_buffer</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP2_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP2_VISIBLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>recptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform XLogInsert for a heap-update operation.  Caller must already
 * have modified the buffer(s) and marked them dirty.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>log_heap_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>oldbuf</name></decl></parameter>,
				<parameter><decl><type><name>Buffer</name></type> <name>newbuf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>oldtup</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>newtup</name></decl></parameter>,
				<parameter><decl><type><name>HeapTuple</name></type> <name>old_key_tuple</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>all_visible_cleared</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>new_all_visible_cleared</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_update</name></type> <name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_header</name></type> <name>xlhdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_header</name></type> <name>xlhdr_idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name><name>prefix_suffix</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>prefixlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>suffixlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_tuple_data</name> <init>= <expr><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>init</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bufflags</name></decl>;</decl_stmt>

	<comment type="block">/* Caller should not call me on a non-WAL-logged relation */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsHeapOnly</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <name>XLOG_HEAP_HOT_UPDATE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <name>XLOG_HEAP_UPDATE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If the old and new tuple are on the same page, we only need to log the
	 * parts of the new tuple that were changed.  That saves on the amount of
	 * WAL we need to write.  Currently, we just count any unchanged bytes in
	 * the beginning and end of the tuple.  That's quick to check, and
	 * perfectly covers the common case that only one field is updated.
	 *
	 * We could do this even if the old and new tuple are on different pages,
	 * but only if we don't make a full-page image of the old page, which is
	 * difficult to know in advance.  Also, if the old tuple is corrupt for
	 * some reason, it would allow the corruption to propagate the new page,
	 * so it seems best to avoid.  Under the general assumption that most
	 * updates tend to create the new tuple version on the same page, there
	 * isn't much to be gained by doing this across pages anyway.
	 *
	 * Skip this if we're taking a full-page image of the new page, as we
	 * don't include the new tuple in the WAL record in that case.  Also
	 * disable if wal_level='logical', as logical decoding needs to be able to
	 * read the new tuple in whole from the WAL record alone.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldbuf</name> <operator>==</operator> <name>newbuf</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>need_tuple_data</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>XLogCheckBufferNeedsBackup</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldp</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>oldtup</name><operator>-&gt;</operator><name>t_data</name></name> <operator>+</operator> <name><name>oldtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newp</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_data</name></name> <operator>+</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>oldlen</name> <init>= <expr><name><name>oldtup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name><name>oldtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>newlen</name> <init>= <expr><name><name>newtup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Check for common prefix between old and new tuple */</comment>
		<for>for <control>(<init><expr><name>prefixlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>prefixlen</name> <operator>&lt;</operator> <call><name>Min</name><argument_list>(<argument><expr><name>oldlen</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>prefixlen</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>newp</name><index>[<expr><name>prefixlen</name></expr>]</index></name> <operator>!=</operator> <name><name>oldp</name><index>[<expr><name>prefixlen</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Storing the length of the prefix takes 2 bytes, so we need to save
		 * at least 3 bytes or there's no point.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>prefixlen</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prefixlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Same for suffix */</comment>
		<for>for <control>(<init><expr><name>suffixlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>suffixlen</name> <operator>&lt;</operator> <call><name>Min</name><argument_list>(<argument><expr><name>oldlen</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>prefixlen</name></expr>;</condition> <incr><expr><name>suffixlen</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>newp</name><index>[<expr><name>newlen</name> <operator>-</operator> <name>suffixlen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>oldp</name><index>[<expr><name>oldlen</name> <operator>-</operator> <name>suffixlen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>suffixlen</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>suffixlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Prepare main WAL data chain */</comment>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>all_visible_cleared</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>new_all_visible_cleared</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_UPDATE_NEW_ALL_VISIBLE_CLEARED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>prefixlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_UPDATE_PREFIX_FROM_OLD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>suffixlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_UPDATE_SUFFIX_FROM_OLD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>need_tuple_data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_UPDATE_CONTAINS_NEW_TUPLE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>old_key_tuple</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_FULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_UPDATE_CONTAINS_OLD_TUPLE</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_UPDATE_CONTAINS_OLD_KEY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If new tuple is the single and first tuple on page... */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newtup</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator>
		<call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FirstOffsetNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>info</name> <operator>|=</operator> <name>XLOG_HEAP_INIT_PAGE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>init</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>init</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Prepare WAL data for the old page */</comment>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>old_offnum</name></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>old_xmax</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>old_infobits_set</name></name> <operator>=</operator> <call><name>compute_infobits</name><argument_list>(<argument><expr><name><name>oldtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
											  <argument><expr><name><name>oldtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare WAL data for the new page */</comment>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>new_offnum</name></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>new_xmax</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmax</name><argument_list>(<argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bufflags</name> <operator>=</operator> <name>REGBUF_STANDARD</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>init</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bufflags</name> <operator>|=</operator> <name>REGBUF_WILL_INIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>need_tuple_data</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bufflags</name> <operator>|=</operator> <name>REGBUF_KEEP_DATA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newbuf</name></expr></argument>, <argument><expr><name>bufflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldbuf</name> <operator>!=</operator> <name>newbuf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>oldbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare WAL data for the new tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>prefixlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>suffixlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>prefixlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>suffixlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>prefix_suffix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>prefixlen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prefix_suffix</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>suffixlen</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>prefix_suffix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>prefixlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>prefixlen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>suffixlen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>xlhdr</name><operator>.</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlhdr</name><operator>.</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlhdr</name><operator>.</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SizeofHeapTupleHeader</name> <operator>+</operator> <name>prefixlen</name> <operator>+</operator> <name>suffixlen</name> <operator>&lt;=</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * PG73FORMAT: write bitmap [+ padding] [+ oid] + data
	 *
	 * The 'data' doesn't include the common prefix or suffix.
	 */</comment>
	<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlhdr</name></expr></argument>, <argument><expr><name>SizeOfHeapHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>prefixlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_data</name></name><operator>)</operator> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr></argument>,
							<argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name>SizeofHeapTupleHeader</name> <operator>-</operator> <name>suffixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Have to write the null bitmap and data after the common prefix as
		 * two separate rdata entries.
		 */</comment>
		<comment type="block">/* bitmap [+ padding] [+ oid] */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>-</operator> <name>SizeofHeapTupleHeader</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_data</name></name><operator>)</operator> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr></argument>,
								<argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>-</operator> <name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* data after common prefix */</comment>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_data</name></name><operator>)</operator> <operator>+</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>+</operator> <name>prefixlen</name></expr></argument>,
							<argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name><name>newtup</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>-</operator> <name>prefixlen</name> <operator>-</operator> <name>suffixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* We need to log a tuple identity */</comment>
	<if_stmt><if>if <condition>(<expr><name>need_tuple_data</name> <operator>&amp;&amp;</operator> <name>old_key_tuple</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* don't really need this, but its more comfy to decode */</comment>
		<expr_stmt><expr><name><name>xlhdr_idx</name><operator>.</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>old_key_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlhdr_idx</name><operator>.</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>old_key_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlhdr_idx</name><operator>.</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>old_key_tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlhdr_idx</name></expr></argument>, <argument><expr><name>SizeOfHeapHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* PG73FORMAT: write bitmap [+ padding] [+ oid] + data */</comment>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>old_key_tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr></argument>,
						 <argument><expr><name><name>old_key_tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* filtering by origin on a row level is much more efficient */</comment>
	<expr_stmt><expr><call><name>XLogSetRecordFlags</name><argument_list>(<argument><expr><name>XLOG_INCLUDE_ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP_ID</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>recptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform XLogInsert of an XLOG_HEAP2_NEW_CID record
 *
 * This is only used in wal_level &gt;= WAL_LEVEL_LOGICAL, and only for catalog
 * tuples.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>log_heap_new_cid</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_new_cid</name></type> <name>xlrec</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>hdr</name> <init>= <expr><name><name>tup</name><operator>-&gt;</operator><name>t_data</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tup</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>top_xid</name></name> <operator>=</operator> <call><name>GetTopTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>target_node</name></name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>target_tid</name></name> <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the tuple got inserted &amp; deleted in the same TX we definitely have a
	 * combocid, set cmin and cmax.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_COMBOCID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HeapTupleHeaderXminInvalid</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>cmin</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetCmin</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>cmax</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetCmax</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>combocid</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawCommandId</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* No combocid, so only cmin or cmax can be set by this TX */</comment>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Tuple inserted.
		 *
		 * We need to check for LOCK ONLY because multixacts might be
		 * transferred to the new tuple in case of FOR KEY SHARE updates in
		 * which case there will be an xmax, although the tuple just got
		 * inserted.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_XMAX_INVALID</name> <operator>||</operator>
			<call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>cmin</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawCommandId</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>cmax</name></name> <operator>=</operator> <name>InvalidCommandId</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* Tuple from a different tx updated or deleted. */</comment>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>cmin</name></name> <operator>=</operator> <name>InvalidCommandId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>cmax</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawCommandId</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>combocid</name></name> <operator>=</operator> <name>InvalidCommandId</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Note that we don't need to register the buffer here, because this
	 * operation does not modify the page. The insert/update/delete that
	 * called us certainly did, but that's WAL-logged separately.
	 */</comment>
	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapNewCid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* will be looked at irrespective of origin */</comment>

	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP2_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP2_NEW_CID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>recptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a heap tuple representing the configured REPLICA IDENTITY to represent
 * the old tuple in a UPDATE or DELETE.
 *
 * Returns NULL if there's no need to log an identity or if there's no suitable
 * key in the Relation relation.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>ExtractReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tp</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>key_changed</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>copy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>replidindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>idx_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>replident</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relreplident</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>key_tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>MaxHeapAttributeNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natt</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>copy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>replident</name> <operator>==</operator> <name>REPLICA_IDENTITY_NOTHING</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>replident</name> <operator>==</operator> <name>REPLICA_IDENTITY_FULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When logging the entire old tuple, it very well could contain
		 * toasted columns. If so, force them to be inlined.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>copy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>toast_flatten_tuple</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>tp</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if the key hasn't changed and we're only logging the key, we're done */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>key_changed</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* find the replica identity index */</comment>
	<expr_stmt><expr><name>replidindex</name> <operator>=</operator> <call><name>RelationGetReplicaIndex</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>replidindex</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"could not find configured replica identity for table \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>idx_rel</name> <operator>=</operator> <call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>replidindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CheckRelationLockedByMe</name><argument_list>(<argument><expr><name>idx_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* deform tuple, so we have fast access to columns */</comment>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set all columns to NULL, regardless of whether they actually are */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now set all columns contained in the index to NOT NULL, they cannot
	 * currently be NULL.
	 */</comment>
	<for>for <control>(<init><expr><name>natt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>natt</name> <operator>&lt;</operator> <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>idx_rel</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>natt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><name><name>idx_rel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>natt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"system column in index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>key_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>copy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>idx_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the tuple, which by here only contains indexed columns, still has
	 * toasted columns, force them to be inlined. This is somewhat unlikely
	 * since there's limits on the size of indexed columns, so we don't
	 * duplicate toast_flatten_tuple()s functionality in the above loop over
	 * the indexed columns, even if it would be more efficient.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><name>key_tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtup</name> <init>= <expr><name>key_tuple</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>key_tuple</name> <operator>=</operator> <call><name>toast_flatten_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>key_tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handles CLEANUP_INFO
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_xlog_cleanup_info</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_heap_cleanup_info</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_cleanup_info</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>InHotStandby</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Actual operation is a no-op. Record type exists to provide a means for
	 * conflict processing to occur before we begin index vacuum actions. see
	 * vacuumlazy.c and also comments in btvacuumpage()
	 */</comment>

	<comment type="block">/* Backup blocks are not used in cleanup_info records */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecHasAnyBlockRefs</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handles XLOG_HEAP2_CLEAN record type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_xlog_clean</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_clean</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_clean</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We're about to remove tuples. In Hot Standby mode, ensure that there's
	 * no queries running for which the removed tuples are still visible.
	 *
	 * Not all HEAP2_CLEAN records remove tuples with xids, so we only want to
	 * conflict on the records that cause MVCC failures for user queries. If
	 * latestRemovedXid is invalid, skip conflict processing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>InHotStandby</name> <operator>&amp;&amp;</operator> <call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we have a full-page image, restore it (using a cleanup lock) and
	 * we're done.
	 */</comment>
	<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>redirected</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>nowdead</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>nowunused</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nredirected</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndead</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nunused</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>datalen</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>redirected</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>nredirected</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>nredirected</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndead</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>ndead</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>redirected</name> <operator>+</operator> <name>datalen</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nowdead</name> <operator>=</operator> <name>redirected</name> <operator>+</operator> <operator>(</operator><name>nredirected</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nowunused</name> <operator>=</operator> <name>nowdead</name> <operator>+</operator> <name>ndead</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nunused</name> <operator>=</operator> <operator>(</operator><name>end</name> <operator>-</operator> <name>nowunused</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nunused</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update all line pointers per the record, and repair fragmentation */</comment>
		<expr_stmt><expr><call><name>heap_page_prune_execute</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
								<argument><expr><name>redirected</name></expr></argument>, <argument><expr><name>nredirected</name></expr></argument>,
								<argument><expr><name>nowdead</name></expr></argument>, <argument><expr><name>ndead</name></expr></argument>,
								<argument><expr><name>nowunused</name></expr></argument>, <argument><expr><name>nunused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note: we don't worry about updating the page's prunability hints.
		 * At worst this will cause an extra prune cycle to occur soon.
		 */</comment>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>freespace</name> <init>= <expr><call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * After cleaning records from a page, it's useful to update the FSM
		 * about it, as it may cause the page become target for insertions
		 * later even if vacuum decides not to visit it (which is possible if
		 * gets marked all-visible.)
		 *
		 * Do this regardless of a full-page image being applied, since the
		 * FSM data is not in the page anyway.
		 */</comment>
		<expr_stmt><expr><call><name>XLogRecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Replay XLOG_HEAP2_VISIBLE record.
 *
 * The critical integrity requirement here is that we must never end up with
 * a situation where the visibility map bit is set, and the page-level
 * PD_ALL_VISIBLE bit is clear.  If that were to occur, then a subsequent
 * page modification would fail to clear the visibility map bit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_xlog_visible</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_visible</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_visible</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are any Hot Standby transactions running that have an xmin
	 * horizon old enough that this page isn't all-visible for them, they
	 * might incorrectly decide that an index-only scan can skip a heap fetch.
	 *
	 * NB: It might be better to throw some kind of "soft" conflict here that
	 * forces any index-only scan that is in flight to perform heap fetches,
	 * rather than killing the transaction outright.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>InHotStandby</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>cutoff_xid</name></name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Read the heap page, if it still exists. If the heap file has dropped or
	 * truncated later in recovery, we don't need to update the page, but we'd
	 * better still update the visibility map.
	 */</comment>
	<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We don't bump the LSN of the heap page when setting the visibility
		 * map bit (unless checksums or wal_hint_bits is enabled, in which
		 * case we must), because that would generate an unworkable volume of
		 * full-page writes.  This exposes us to torn page hazards, but since
		 * we're not inspecting the existing page contents in any way, we
		 * don't care.
		 *
		 * However, all operations that clear the visibility map bit *do* bump
		 * the LSN, and those operations will only be replayed if the XLOG LSN
		 * follows the page LSN.  Thus, if the page LSN has advanced past our
		 * XLOG record's LSN, we mustn't mark the page all-visible, because
		 * the subsequent update won't be replayed to clear the flag.
		 */</comment>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_RESTORED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If heap block was backed up, we already restored it and there's
		 * nothing more to do. (This can only happen with checksums or
		 * wal_log_hints enabled.)
		 */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>space</name> <init>= <expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since FSM is not WAL-logged and only updated heuristically, it
		 * easily becomes stale in standbys.  If the standby is later promoted
		 * and runs VACUUM, it will skip updating individual free space
		 * figures for pages that became all-visible (or all-frozen, depending
		 * on the vacuum mode,) which is troublesome when FreeSpaceMapVacuum
		 * propagates too optimistic free space values to upper FSM layers;
		 * later inserters try to use such pages only to find out that they
		 * are unusable.  This can cause long stalls when there are many such
		 * pages.
		 *
		 * Forestall those problems by updating FSM's idea about a page that
		 * is becoming all-visible or all-frozen.
		 *
		 * Do this regardless of a full-page image being applied, since the
		 * FSM data is not in the page anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>VISIBILITYMAP_VALID_BITS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Even if we skipped the heap page update due to the LSN interlock, it's
	 * still safe to update the visibility map.  Any WAL record that clears
	 * the visibility map bit does so before checking the page LSN, so any
	 * bits that need to be cleared will still be cleared.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedoExtended</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RBM_ZERO_ON_ERROR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>vmpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>reln</name></decl>;</decl_stmt>

		<comment type="block">/* initialize the page if it was read as zeros */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>vmpage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>vmpage</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * XLogReadBufferForRedoExtended locked the buffer. But
		 * visibilitymap_set will handle locking itself.
		 */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>reln</name> <operator>=</operator> <call><name>CreateFakeRelcacheEntry</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Don't set the bit if replay has already passed this point.
		 *
		 * It might be safe to do this unconditionally; if replay has passed
		 * this point, we'll replay at least as far this time as we did
		 * before, and if this bit needs to be cleared, the record responsible
		 * for doing so should be again replayed, and clear it.  For right
		 * now, out of an abundance of conservatism, we use the same test here
		 * we did for the heap page.  If this results in a dropped bit, no
		 * real harm is done; and the next VACUUM will fix it.
		 */</comment>

		<comment type="block">/*
		 * CDB: don't use PageGetLSN here, GPDB PageGetLSN checks the buffer
		 * is locked. But here vmbuffer is in function visibilitymap_set().
		 *
		 * if (lsn &gt; PageGetLSN(vmpage))
		 * 		visibilitymap_set(reln, blkno, InvalidBuffer, lsn, vmbuffer,
		 * 				xlrec-&gt;cutoff_xid);
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&gt;</operator> <call><name>PageXLogRecPtrGet</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>vmpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_lsn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>visibilitymap_set</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>,
							  <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>cutoff_xid</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeFakeRelcacheEntry</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Replay XLOG_HEAP2_FREEZE_PAGE records
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_xlog_freeze_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_freeze_page</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_freeze_page</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>cutoff_xid</name> <init>= <expr><name><name>xlrec</name><operator>-&gt;</operator><name>cutoff_xid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In Hot Standby mode, ensure that there's no queries running which still
	 * consider the frozen xids as running.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>InHotStandby</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name> <init>= <expr><name>cutoff_xid</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TransactionIdRetreat</name><argument_list>(<argument><expr><name>latestRemovedXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name>latestRemovedXid</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_heap_freeze_tuple</name> <modifier>*</modifier></type><name>tuples</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuples</name> <operator>=</operator> <operator>(</operator><name>xl_heap_freeze_tuple</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* now execute freeze plan for each frozen tuple */</comment>
		<for>for <control>(<init><expr><name>ntup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ntup</name> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</condition> <incr><expr><name>ntup</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_heap_freeze_tuple</name> <modifier>*</modifier></type><name>xlrec_tp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>xlrec_tp</name> <operator>=</operator> <operator>&amp;</operator><name><name>tuples</name><index>[<expr><name>ntup</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xlrec_tp</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* offsets are one-based */</comment>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_execute_freeze_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>xlrec_tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given an "infobits" field from an XLog record, set the correct bits in the
 * given infomask and infomask2 for the tuple touched by the record.
 *
 * (This is the reverse of compute_infobits).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fix_infomask_from_infobits</name><parameter_list>(<parameter><decl><type><name>uint8</name></type> <name>infobits</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>infomask</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>infomask2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XMAX_IS_MULTI</name> <operator>|</operator> <name>HEAP_XMAX_LOCK_ONLY</name> <operator>|</operator>
				   <name>HEAP_XMAX_KEYSHR_LOCK</name> <operator>|</operator> <name>HEAP_XMAX_EXCL_LOCK</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>infomask2</name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>infobits</name> <operator>&amp;</operator> <name>XLHL_XMAX_IS_MULTI</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>|=</operator> <name>HEAP_XMAX_IS_MULTI</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>infobits</name> <operator>&amp;</operator> <name>XLHL_XMAX_LOCK_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>|=</operator> <name>HEAP_XMAX_LOCK_ONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>infobits</name> <operator>&amp;</operator> <name>XLHL_XMAX_EXCL_LOCK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>|=</operator> <name>HEAP_XMAX_EXCL_LOCK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* note HEAP_XMAX_SHR_LOCK isn't considered here */</comment>
	<if_stmt><if>if <condition>(<expr><name>infobits</name> <operator>&amp;</operator> <name>XLHL_XMAX_KEYSHR_LOCK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>infomask</name> <operator>|=</operator> <name>HEAP_XMAX_KEYSHR_LOCK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>infobits</name> <operator>&amp;</operator> <name>XLHL_KEYS_UPDATED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>infomask2</name> <operator>|=</operator> <name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_xlog_delete</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_delete</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_delete</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>target_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>target_tid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target_tid</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target_tid</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The visibility map may need to be fixed even if the heap page is
	 * already up-to-date.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_DELETE_ALL_VISIBLE_CLEARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>reln</name> <init>= <expr><call><name>CreateFakeRelcacheEntry</name><argument_list>(<argument><expr><name>target_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeFakeRelcacheEntry</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid lp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XMAX_BITS</name> <operator>|</operator> <name>HEAP_MOVED</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderClearHotUpdated</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fix_infomask_from_infobits</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>infobits_set</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_DELETE_IS_SUPER</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetCmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>FirstCommandId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark the page as a candidate for pruning */</comment>
		<expr_stmt><expr><call><name>PageSetPrunable</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_DELETE_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Make sure t_ctid is set correctly */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_DELETE_IS_PARTITION_MOVE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetMovedPartitions</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name>target_tid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_xlog_insert</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_insert</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_insert</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<union>union
	<block>{
		<decl_stmt><decl><type><name>HeapTupleHeaderData</name></type> <name>hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>data</name><index>[<expr><name>MaxHeapTupleSize</name></expr>]</index></name></decl>;</decl_stmt>
	}</block>			<decl><name>tbuf</name></decl>;</union>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_header</name></type> <name>xlhdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>newlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>freespace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>target_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>target_tid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target_tid</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>target_tid</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The visibility map may need to be fixed even if the heap page is
	 * already up-to-date.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>reln</name> <init>= <expr><call><name>CreateFakeRelcacheEntry</name><argument_list>(<argument><expr><name>target_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeFakeRelcacheEntry</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we inserted the first and only tuple on the page, re-initialize the
	 * page from scratch.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_HEAP_INIT_PAGE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>datalen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid max offset number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newlen</name> <operator>=</operator> <name>datalen</name> <operator>-</operator> <name>SizeOfHeapHeader</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>datalen</name> <operator>&gt;</operator> <name>SizeOfHeapHeader</name> <operator>&amp;&amp;</operator> <name>newlen</name> <operator>&lt;=</operator> <name>MaxHeapTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlhdr</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>SizeOfHeapHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>SizeOfHeapHeader</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbuf</name><operator>.</operator><name>hdr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* PG73FORMAT: get bitmap [+ padding] [+ oid] + data */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr></argument>,
			   <argument><expr><name>data</name></expr></argument>,
			   <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newlen</name> <operator>+=</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_infomask</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_hoff</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetCmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>FirstCommandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name>target_tid</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>htup</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>,
						<argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* needed to update FSM below */</comment>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the page is running low on free space, update the FSM as well.
	 * Arbitrarily, our definition of "low" is less than 20%. We can't do much
	 * better than that without knowing the fill-factor for the table.
	 *
	 * XXX: Don't do this if the page was restored from full page image. We
	 * don't bother to update the FSM in that case, it doesn't need to be
	 * totally accurate anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name> <operator>&amp;&amp;</operator> <name>freespace</name> <operator>&lt;</operator> <name>BLCKSZ</name> <operator>/</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>target_node</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handles MULTI_INSERT record type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_xlog_multi_insert</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_multi_insert</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<union>union
	<block>{
		<decl_stmt><decl><type><name>HeapTupleHeaderData</name></type> <name>hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>data</name><index>[<expr><name>MaxHeapTupleSize</name></expr>]</index></name></decl>;</decl_stmt>
	}</block>			<decl><name>tbuf</name></decl>;</union>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>newlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>freespace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isinit</name> <init>= <expr><operator>(</operator><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_HEAP_INIT_PAGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Insertion doesn't overwrite MVCC data, so no conflict processing is
	 * required.
	 */</comment>
	<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_heap_multi_insert</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The visibility map may need to be fixed even if the heap page is
	 * already up-to-date.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>reln</name> <init>= <expr><call><name>CreateFakeRelcacheEntry</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeFakeRelcacheEntry</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isinit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tupdata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>

		<comment type="block">/* Tuples are stored as block data */</comment>
		<expr_stmt><expr><name>tupdata</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>tupdata</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>xl_multi_insert_tuple</name> <modifier>*</modifier></type><name>xlhdr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If we're reinitializing the page, the tuples are stored in
			 * order from FirstOffsetNumber. Otherwise there's an array of
			 * offsets in the WAL record, and the tuples come after that.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>isinit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid max offset number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>xlhdr</name> <operator>=</operator> <operator>(</operator><name>xl_multi_insert_tuple</name> <operator>*</operator><operator>)</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>tupdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tupdata</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>xlhdr</name><operator>)</operator> <operator>+</operator> <name>SizeOfMultiInsertTuple</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>newlen</name> <operator>=</operator> <name><name>xlhdr</name><operator>-&gt;</operator><name>datalen</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newlen</name> <operator>&lt;=</operator> <name>MaxHeapTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbuf</name><operator>.</operator><name>hdr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* PG73FORMAT: get bitmap [+ padding] [+ oid] + data */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tupdata</name></expr></argument>,
				   <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tupdata</name> <operator>+=</operator> <name>newlen</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>newlen</name> <operator>+=</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>-&gt;</operator><name>t_infomask</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetCmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>FirstCommandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>htup</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>tupdata</name> <operator>!=</operator> <name>endptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"total tuple length mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* needed to update FSM below */</comment>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_INSERT_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the page is running low on free space, update the FSM as well.
	 * Arbitrarily, our definition of "low" is less than 20%. We can't do much
	 * better than that without knowing the fill-factor for the table.
	 *
	 * XXX: Don't do this if the page was restored from full page image. We
	 * don't bother to update the FSM in that case, it doesn't need to be
	 * totally accurate anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name> <operator>&amp;&amp;</operator> <name>freespace</name> <operator>&lt;</operator> <name>BLCKSZ</name> <operator>/</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handles UPDATE and HOT_UPDATE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_xlog_update</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hot_update</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_update</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_update</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>oldblk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>newblk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>newtid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>obuffer</name></decl>,
				<decl><type ref="prev"/><name>nbuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>oldtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>prefixlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>suffixlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newp</name></decl>;</decl_stmt>
	<union>union
	<block>{
		<decl_stmt><decl><type><name>HeapTupleHeaderData</name></type> <name>hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>data</name><index>[<expr><name>MaxHeapTupleSize</name></expr>]</index></name></decl>;</decl_stmt>
	}</block>			<decl><name>tbuf</name></decl>;</union>
	<decl_stmt><decl><type><name>xl_heap_header</name></type> <name>xlhdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>newlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>freespace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>oldaction</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>newaction</name></decl>;</decl_stmt>

	<comment type="block">/* initialize to keep the compiler quiet */</comment>
	<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newblk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldblk</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* HOT updates are never done across pages */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>hot_update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldblk</name> <operator>=</operator> <name>newblk</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newtid</name></expr></argument>, <argument><expr><name>newblk</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>new_offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The visibility map may need to be fixed even if the heap page is
	 * already up-to-date.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>reln</name> <init>= <expr><call><name>CreateFakeRelcacheEntry</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>oldblk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>oldblk</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeFakeRelcacheEntry</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In normal operation, it is important to lock the two pages in
	 * page-number order, to avoid possible deadlocks against other update
	 * operations going the other way.  However, during WAL replay there can
	 * be no other update happening, so we don't need to worry about that. But
	 * we *do* need to worry that we don't expose an inconsistent state to Hot
	 * Standby queries --- so the original page can't be unlocked before we've
	 * added the new tuple to the new page.
	 */</comment>

	<comment type="block">/* Deal with old tuple version */</comment>
	<expr_stmt><expr><name>oldaction</name> <operator>=</operator> <call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>oldblk</name> <operator>==</operator> <name>newblk</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>obuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldaction</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>obuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>old_offnum</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>offnum</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid lp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>htup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldtup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XMAX_BITS</name> <operator>|</operator> <name>HEAP_MOVED</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hot_update</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>HeapTupleHeaderSetHotUpdated</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>HeapTupleHeaderClearHotUpdated</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>fix_infomask_from_infobits</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>old_infobits_set</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>old_xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetCmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>FirstCommandId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Set forward chain link in t_ctid */</comment>
		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name>newtid</name></expr>;</expr_stmt>

		<comment type="block">/* Mark the page as a candidate for pruning */</comment>
		<expr_stmt><expr><call><name>PageSetPrunable</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>obuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Read the page the new tuple goes into, if different from old.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldblk</name> <operator>==</operator> <name>newblk</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nbuffer</name> <operator>=</operator> <name>obuffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newaction</name> <operator>=</operator> <name>oldaction</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_HEAP_INIT_PAGE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nbuffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>nbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>nbuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newaction</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newaction</name> <operator>=</operator> <call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * The visibility map may need to be fixed even if the heap page is
	 * already up-to-date.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_NEW_ALL_VISIBLE_CLEARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>reln</name> <init>= <expr><call><name>CreateFakeRelcacheEntry</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>newblk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>newblk</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_VALID_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeFakeRelcacheEntry</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Deal with new tuple */</comment>
	<if_stmt><if>if <condition>(<expr><name>newaction</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>recdata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>recdata_end</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>datalen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>tuplen</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>recdata</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>recdata_end</name> <operator>=</operator> <name>recdata</name> <operator>+</operator> <name>datalen</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>nbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>new_offnum</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid max offset number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_PREFIX_FROM_OLD</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newblk</name> <operator>==</operator> <name>oldblk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefixlen</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>recdata</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_SUFFIX_FROM_OLD</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newblk</name> <operator>==</operator> <name>oldblk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>suffixlen</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>recdata</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlhdr</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><name>SizeOfHeapHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>recdata</name> <operator>+=</operator> <name>SizeOfHeapHeader</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <name>recdata_end</name> <operator>-</operator> <name>recdata</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuplen</name> <operator>&lt;=</operator> <name>MaxHeapTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbuf</name><operator>.</operator><name>hdr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reconstruct the new tuple using the prefix and/or suffix from the
		 * old tuple, and the data stored in the WAL record.
		 */</comment>
		<expr_stmt><expr><name>newp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>prefixlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

			<comment type="block">/* copy bitmap [+ padding] [+ oid] from WAL record */</comment>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_hoff</name></name> <operator>-</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>recdata</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newp</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

			<comment type="block">/* copy prefix from old tuple */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>oldtup</name><operator>.</operator><name>t_data</name></name> <operator>+</operator> <name><name>oldtup</name><operator>.</operator><name>t_data</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newp</name> <operator>+=</operator> <name>prefixlen</name></expr>;</expr_stmt>

			<comment type="block">/* copy new tuple data from WAL record */</comment>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <name>tuplen</name> <operator>-</operator> <operator>(</operator><name><name>xlhdr</name><operator>.</operator><name>t_hoff</name></name> <operator>-</operator> <name>SizeofHeapTupleHeader</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>recdata</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newp</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * copy bitmap [+ padding] [+ oid] + data from record, all in one
			 * go
			 */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>recdata</name> <operator>+=</operator> <name>tuplen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newp</name> <operator>+=</operator> <name>tuplen</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>recdata</name> <operator>==</operator> <name>recdata_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* copy suffix from old tuple */</comment>
		<if_stmt><if>if <condition>(<expr><name>suffixlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newp</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>oldtup</name><operator>.</operator><name>t_data</name></name> <operator>+</operator> <name><name>oldtup</name><operator>.</operator><name>t_len</name></name> <operator>-</operator> <name>suffixlen</name></expr></argument>, <argument><expr><name>suffixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>newlen</name> <operator>=</operator> <name>SizeofHeapTupleHeader</name> <operator>+</operator> <name>tuplen</name> <operator>+</operator> <name>prefixlen</name> <operator>+</operator> <name>suffixlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_infomask2</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_infomask</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>xlhdr</name><operator>.</operator><name>t_hoff</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>HeapTupleHeaderSetXmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetCmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>FirstCommandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>new_xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Make sure there is no forward chain link in t_ctid */</comment>
		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name> <operator>=</operator> <name>newtid</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>htup</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_UPDATE_NEW_ALL_VISIBLE_CLEARED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PageClearAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* needed to update FSM below */</comment>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>nbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>nbuffer</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>nbuffer</name> <operator>!=</operator> <name>obuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>nbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>obuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>obuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the new page is running low on free space, update the FSM as well.
	 * Arbitrarily, our definition of "low" is less than 20%. We can't do much
	 * better than that without knowing the fill-factor for the table.
	 *
	 * However, don't update the FSM on HOT updates, because after crash
	 * recovery, either the old or the new tuple will certainly be dead and
	 * prunable. After pruning, the page will have roughly as much free space
	 * as it did before the update, assuming the new tuple is about the same
	 * size as the old one.
	 *
	 * XXX: Don't do this if the page was restored from full page image. We
	 * don't bother to update the FSM in that case, it doesn't need to be
	 * totally accurate anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newaction</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hot_update</name> <operator>&amp;&amp;</operator> <name>freespace</name> <operator>&lt;</operator> <name>BLCKSZ</name> <operator>/</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRecordPageWithFreeSpace</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>newblk</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_xlog_confirm</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_confirm</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_confirm</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>offnum</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid lp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Confirm tuple as actually inserted
		 */</comment>
		<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_xlog_lock</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_lock</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_lock</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The visibility map may need to be fixed even if the heap page is
	 * already up-to-date.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_LOCK_ALL_FROZEN_CLEARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>block</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>reln</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reln</name> <operator>=</operator> <call><name>CreateFakeRelcacheEntry</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_ALL_FROZEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeFakeRelcacheEntry</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>offnum</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid lp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XMAX_BITS</name> <operator>|</operator> <name>HEAP_MOVED</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fix_infomask_from_infobits</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>infobits_set</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Clear relevant update flags, but only if the modified infomask says
		 * there's no update.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HEAP_XMAX_IS_LOCKED_ONLY</name><argument_list>(<argument><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HeapTupleHeaderClearHotUpdated</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Make sure there is no forward chain link in t_ctid */</comment>
			<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>,
						   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>locking_xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetCmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>FirstCommandId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_xlog_lock_updated</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_lock_updated</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>xl_heap_lock_updated</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The visibility map may need to be fixed even if the heap page is
	 * already up-to-date.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>XLH_LOCK_ALL_FROZEN_CLEARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>vmbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>block</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>reln</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reln</name> <operator>=</operator> <call><name>CreateFakeRelcacheEntry</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>visibilitymap_pin</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>visibilitymap_clear</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>vmbuffer</name></expr></argument>, <argument><expr><name>VISIBILITYMAP_ALL_FROZEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>vmbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeFakeRelcacheEntry</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>offnum</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid lp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>HEAP_XMAX_BITS</name> <operator>|</operator> <name>HEAP_MOVED</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_KEYS_UPDATED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fix_infomask_from_infobits</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>infobits_set</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_infomask2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetXmax</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_xlog_inplace</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_heap_inplace</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_heap_inplace</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>oldlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>newlen</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newtup</name> <init>= <expr><call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>newlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>offnum</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>offnum</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>offnum</name> <operator>||</operator> <operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"invalid lp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldlen</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>oldlen</name> <operator>!=</operator> <name>newlen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"wrong tuple length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>htup</name> <operator>+</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_hoff</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>heap_redo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * These operations don't overwrite MVCC data so no conflict processing is
	 * required. The ones in heap2 rmgr do.
	 */</comment>

	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_insert</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_delete</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_update</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP_TRUNCATE</name></expr>:</case>

			<comment type="block">/*
			 * TRUNCATE is a no-op because the actions are already logged as
			 * SMGR WAL records.  TRUNCATE WAL record only exists for logical
			 * decoding.
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP_HOT_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_update</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP_CONFIRM</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_confirm</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP_LOCK</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_lock</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP_INPLACE</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_inplace</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"heap_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>heap2_redo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>info</name> <operator>&amp;</operator> <name>XLOG_HEAP_OPMASK</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_HEAP2_CLEAN</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_clean</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP2_FREEZE_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_freeze_page</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP2_CLEANUP_INFO</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_cleanup_info</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP2_VISIBLE</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_visible</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP2_MULTI_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_multi_insert</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP2_LOCK_UPDATED</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_lock_updated</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP2_NEW_CID</name></expr>:</case>

			<comment type="block">/*
			 * Nothing to do on a real replay, only used during logical
			 * decoding.
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>XLOG_HEAP2_REWRITE</name></expr>:</case>
			<expr_stmt><expr><call><name>heap_xlog_logical_rewrite</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"heap2_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 *	heap_sync		- sync a heap, for use when no WAL has been written
 *
 * This forces the heap contents (including TOAST heap if any) down to disk.
 * If we skipped using WAL, and WAL is otherwise needed, we must force the
 * relation down to disk before it's safe to commit the transaction.  This
 * requires writing out any dirty buffers and then doing a forced fsync.
 *
 * Indexes are not touched.  (Currently, index operations associated with
 * the commands that use this are WAL-logged and so do not need fsync.
 * That behavior might change someday, but in any case it's likely that
 * any fsync decisions required would be per-index and hence not appropriate
 * to be done here.)
 */</comment>
<function><type><name>void</name></type>
<name>heap_sync</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* non-WAL-logged tables never need fsync */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* main heap */</comment>
	<expr_stmt><expr><call><name>FlushRelationBuffers</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* FlushRelationBuffers will have opened rd_smgr */</comment>
	<expr_stmt><expr><call><name>smgrimmedsync</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* FSM is not critical, don't bother syncing it */</comment>

	<comment type="block">/* toast heap, if any */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>toastrel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushRelationBuffers</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>smgrimmedsync</name><argument_list>(<argument><expr><name><name>toastrel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Mask a heap page before performing consistency checks on it.
 */</comment>
<function><type><name>void</name></type>
<name>heap_mask</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pagedata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <name>pagedata</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>mask_page_lsn_and_checksum</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mask_page_hint_bits</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mask_unused_space</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>page_item</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>page_item</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>page</name> <operator>+</operator> <call><name>ItemIdGetOffset</name><argument_list>(<argument><expr><name>iid</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>page_htup</name> <init>= <expr><operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <name>page_item</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If xmin of a tuple is not yet frozen, we should ignore
			 * differences in hint bits, since they can be set without
			 * emitting WAL.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderXminFrozen</name><argument_list>(<argument><expr><name>page_htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>page_htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XACT_MASK</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Still we need to mask xmax hint bits. */</comment>
				<expr_stmt><expr><name><name>page_htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XMAX_INVALID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>page_htup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XMAX_COMMITTED</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* mask out GPDB specific hint-bits */</comment>
			<expr_stmt><expr><name><name>page_htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XMIN_DISTRIBUTED_SNAPSHOT_IGNORE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>page_htup</name><operator>-&gt;</operator><name>t_infomask2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>HEAP_XMAX_DISTRIBUTED_SNAPSHOT_IGNORE</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * During replay, we set Command Id to FirstCommandId. Hence, mask
			 * it. See heap_xlog_insert() for details.
			 */</comment>
			<expr_stmt><expr><name><name>page_htup</name><operator>-&gt;</operator><name>t_choice</name><operator>.</operator><name>t_heap</name><operator>.</operator><name>t_field3</name><operator>.</operator><name>t_cid</name></name> <operator>=</operator> <name>MASK_MARKER</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * For a speculative tuple, heap_insert() does not set ctid in the
			 * caller-passed heap tuple itself, leaving the ctid field to
			 * contain a speculative token value - a per-backend monotonically
			 * increasing identifier. Besides, it does not WAL-log ctid under
			 * any circumstances.
			 *
			 * During redo, heap_xlog_insert() sets t_ctid to current block
			 * number and self offset number. It doesn't care about any
			 * speculative insertions in master. Hence, we set t_ctid to
			 * current block number and self offset number to ignore any
			 * inconsistency.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHeaderIsSpeculative</name><argument_list>(<argument><expr><name>page_htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page_htup</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * NB: Not ignoring ctid changes due to the tuple having moved
			 * (i.e. HeapTupleHeaderIndicatesMovedPartitions), because that's
			 * important information that needs to be in-sync between primary
			 * and standby, and thus is WAL logged.
			 */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Ignore any padding bytes after the tuple, when the length of the
		 * item is not MAXALIGNed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ItemIdHasStorage</name><argument_list>(<argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>padlen</name> <init>= <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>len</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>padlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>page_item</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>MASK_MARKER</name></expr></argument>, <argument><expr><name>padlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
