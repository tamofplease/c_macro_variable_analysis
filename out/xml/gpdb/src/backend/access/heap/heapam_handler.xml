<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/access/heap/heapam_handler.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * heapam_handler.c
 *	  heap table access method code
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/heap/heapam_handler.c
 *
 *
 * NOTES
 *	  This files wires up the lower level heapam.c et al routines with the
 *	  tableam abstraction.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/rewriteheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tsmapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufpage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reform_and_rewrite_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
									 <parameter><decl><type><name>Relation</name></type> <name>OldHeap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>NewHeap</name></decl></parameter>,
									 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>RewriteState</name></type> <name>rwstate</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SampleHeapTupleVisible</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
								   <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
								   <parameter><decl><type><name>OffsetNumber</name></type> <name>tupoffset</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>BlockNumber</name></type> <name>heapam_scan_get_blocks_done</name><parameter_list>(<parameter><decl><type><name>HeapScanDesc</name></type> <name>hscan</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TableAmRoutine</name></type> <name>heapam_methods</name></decl>;</decl_stmt>


<comment type="block">/* ------------------------------------------------------------------------
 * Slot related callbacks for heap AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type>
<name>heapam_slot_callbacks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>TTSOpsBufferHeapTuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * Index Scan Callbacks for heap AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>IndexFetchTableData</name> <modifier>*</modifier></type>
<name>heapam_index_fetch_begin</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexFetchHeapData</name> <modifier>*</modifier></type><name>hscan</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexFetchHeapData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_base</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_cbuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>hscan</name><operator>-&gt;</operator><name>xs_base</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapam_index_fetch_reset</name><parameter_list>(<parameter><decl><type><name>IndexFetchTableData</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexFetchHeapData</name> <modifier>*</modifier></type><name>hscan</name> <init>= <expr><operator>(</operator><name>IndexFetchHeapData</name> <operator>*</operator><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_cbuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapam_index_fetch_end</name><parameter_list>(<parameter><decl><type><name>IndexFetchTableData</name> <modifier>*</modifier></type><name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexFetchHeapData</name> <modifier>*</modifier></type><name>hscan</name> <init>= <expr><operator>(</operator><name>IndexFetchHeapData</name> <operator>*</operator><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>heapam_index_fetch_reset</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heapam_index_fetch_tuple</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>IndexFetchTableData</name></name> <modifier>*</modifier></type><name>scan</name></decl></parameter>,
						 <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
						 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>call_again</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>all_dead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexFetchHeapData</name> <modifier>*</modifier></type><name>hscan</name> <init>= <expr><operator>(</operator><name>IndexFetchHeapData</name> <operator>*</operator><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>got_heap_tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TTS_IS_BUFFERTUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can skip the buffer-switching logic if we're in mid-HOT chain. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>call_again</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Switch to correct buffer if we don't have it already */</comment>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>prev_buf</name> <init>= <expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_cbuf</name></name> <operator>=</operator> <call><name>ReleaseAndReadBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>,
											  <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_base</name><operator>.</operator><name>rel</name></name></expr></argument>,
											  <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Prune page, but only if we weren't already on this page
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>prev_buf</name> <operator>!=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_page_prune_opt</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_base</name><operator>.</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Obtain share-lock on the buffer so we can examine visibility */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>got_heap_tuple</name> <operator>=</operator> <call><name>heap_hot_search_buffer</name><argument_list>(<argument><expr><name>tid</name></expr></argument>,
											<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_base</name><operator>.</operator><name>rel</name></name></expr></argument>,
											<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>,
											<argument><expr><name>snapshot</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tupdata</name></name></expr></argument>,
											<argument><expr><name>all_dead</name></expr></argument>,
											<argument><expr><operator>!</operator><operator>*</operator><name>call_again</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tupdata</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>got_heap_tuple</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Only in a non-MVCC snapshot can more than one member of the HOT
		 * chain be visible.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>call_again</name> <operator>=</operator> <operator>!</operator><call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecStoreBufferHeapTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tupdata</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>xs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We've reached the end of the HOT chain. */</comment>
		<expr_stmt><expr><operator>*</operator><name>call_again</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>got_heap_tuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * Callbacks for non-modifying operations on individual tuples for heap AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heapam_fetch_row_version</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
						 <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
						 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TTS_IS_BUFFERTUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tupdata</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>heap_fetch</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tupdata</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* store in slot, transferring existing pin */</comment>
		<expr_stmt><expr><call><name>ExecStorePinnedBufferHeapTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tupdata</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heapam_tuple_tid_valid</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>hscan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heapam_tuple_satisfies_snapshot</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
								<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TTS_IS_BUFFERTUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need buffer pin and lock to call HeapTupleSatisfiesVisibility.
	 * Caller should be holding pin, but not lock.
	 */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>HeapTupleSatisfiesVisibility</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>,
									   <argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>bslot</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ------------------------------------------------------------------------
 * GPDB: DML state manipulation functions (not implemented by heap AM)
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>heap_dml_init</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>heap_dml_finish</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------------------
 *  Functions for manipulations of physical tuples for heap AM.
 * ----------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapam_tuple_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Update the tuple with table oid */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name></expr>;</expr_stmt>

	<comment type="block">/* Perform the insertion, and copy the resulting ItemPointer */</comment>
	<expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapam_tuple_insert_speculative</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
								<parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,
								<parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>specToken</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Update the tuple with table oid */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>HeapTupleHeaderSetSpeculativeToken</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>specToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>HEAP_INSERT_SPECULATIVE</name></expr>;</expr_stmt>

	<comment type="block">/* Perform the insertion, and copy the resulting ItemPointer */</comment>
	<expr_stmt><expr><call><name>heap_insert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapam_tuple_complete_speculative</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
								  <parameter><decl><type><name>uint32</name></type> <name>specToken</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>succeeded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* adjust the tuple's state accordingly */</comment>
	<if_stmt><if>if <condition>(<expr><name>succeeded</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_finish_speculative</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_abort_speculative</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>heapam_tuple_delete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>,
					<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>,
					<parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changingPart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Currently Deleting of index tuples are handled at vacuum, in case if
	 * the storage itself is cleaning the dead tuples by itself, it is the
	 * time to call the index tuple deletion also.
	 */</comment>
	<return>return <expr><call><name>heap_delete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>crosscheck</name></expr></argument>, <argument><expr><name>wait</name></expr></argument>, <argument><expr><name>tmfd</name></expr></argument>, <argument><expr><name>changingPart</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>heapam_tuple_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>otid</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					<parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>, <parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>,
					<parameter><decl><type><name>LockTupleMode</name> <modifier>*</modifier></type><name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>update_indexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_Result</name></type>	<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Update the tuple with table oid */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_update</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>otid</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>crosscheck</name></expr></argument>, <argument><expr><name>wait</name></expr></argument>,
						 <argument><expr><name>tmfd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decide whether new index entries are needed for the tuple
	 *
	 * Note: heap_update returns the tid (location) of the new tuple in the
	 * t_self field.
	 *
	 * If it's a HOT update, we mustn't insert new index entries.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>update_indexes</name> <operator>=</operator> <name>result</name> <operator>==</operator> <name>TM_Ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HeapTupleIsHeapOnly</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>heapam_tuple_lock</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
				  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>,
				  <parameter><decl><type><name>LockWaitPolicy</name></type> <name>wait_policy</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>flags</name></decl></parameter>,
				  <parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>bslot</name> <init>= <expr><operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TM_Result</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>bslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tupdata</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>follow_updates</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>follow_updates</name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TUPLE_LOCK_FLAG_LOCK_UPDATE_IN_PROGRESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>traversed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TTS_IS_BUFFERTUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>tuple_lock_retry</name>:</label>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_lock_tuple</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>wait_policy</name></expr></argument>,
							 <argument><expr><name>follow_updates</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>tmfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>TM_Updated</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TUPLE_LOCK_FLAG_FIND_LAST_VERSION</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Should not encounter speculative tuple on recheck */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HeapTupleHeaderIsSpeculative</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmfd</name><operator>-&gt;</operator><name>ctid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SnapshotData</name></type> <name>SnapshotDirty</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>priorXmax</name></decl>;</decl_stmt>

			<comment type="block">/* it was updated, so look at the updated version */</comment>
			<expr_stmt><expr><operator>*</operator><name>tid</name> <operator>=</operator> <name><name>tmfd</name><operator>-&gt;</operator><name>ctid</name></name></expr>;</expr_stmt>
			<comment type="block">/* updated row should have xmin matching this xmax */</comment>
			<expr_stmt><expr><name>priorXmax</name> <operator>=</operator> <name><name>tmfd</name><operator>-&gt;</operator><name>xmax</name></name></expr>;</expr_stmt>

			<comment type="block">/* signal that a tuple later in the chain is getting locked */</comment>
			<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>traversed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * fetch target tuple
			 *
			 * Loop here to deal with updated or busy tuples
			 */</comment>
			<expr_stmt><expr><call><name>InitDirtySnapshot</name><argument_list>(<argument><expr><name>SnapshotDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<comment type="block">/*
				 * Greenplum specific error message
				 * Split-update is used to implment update on distribute keys
				 * of hash partitioned table in Greenplum. UPDATE on distkeys
				 * is similar to upstream's UPDATE on partition keys. We will
				 * store bit info in the tuple's head to mark it is split-updated,
				 * so the blocked transaction which also wants to update or delete
				 * the same tuple will abort. We re-use upstream's code to implement
				 * this, just modify a little of the following error message.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>ItemPointerIndicatesMovedPartitions</name><argument_list>(<argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tuple to be locked was already moved to another partition or segment due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>heap_fetch</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SnapshotDirty</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * If xmin isn't what we're expecting, the slot must have
					 * been recycled and reused for an unrelated tuple.  This
					 * implies that the latest version of the row was deleted,
					 * so we need do nothing.  (Should be safe to examine xmin
					 * without getting buffer's content lock.  We assume
					 * reading a TransactionId to be atomic, and Xmin never
					 * changes in an existing tuple, except to invalid or
					 * frozen, and neither of those can match priorXmax.)
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>priorXmax</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>TM_Deleted</name></expr>;</return>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* otherwise xmin should not be dirty... */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"t_xmin is uncommitted in tuple to be updated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * If tuple is being updated by other transaction then we
					 * have to wait for its commit/abort, or die trying.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<switch>switch <condition>(<expr><name>wait_policy</name></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><name>LockWaitBlock</name></expr>:</case>
								<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmax</name></name></expr></argument>,
												  <argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>,
												  <argument><expr><name>XLTW_FetchUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><name>LockWaitSkip</name></expr>:</case>
								<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalXactLockTableWait</name><argument_list>(<argument><expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
									<comment type="block">/* skip instead of waiting */</comment>
									<return>return <expr><name>TM_WouldBlock</name></expr>;</return></block_content></block></if></if_stmt>
								<break>break;</break>
							<case>case <expr><name>LockWaitError</name></expr>:</case>
								<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalXactLockTableWait</name><argument_list>(<argument><expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
											<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
											 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not obtain lock on row in relation \"%s\""</literal></expr></argument>,
													<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<break>break;</break>
						</block_content>}</block></switch>
						<continue>continue;</continue>	<comment type="block">/* loop back to repeat heap_fetch */</comment>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If tuple was inserted by our own transaction, we have
					 * to check cmin against cid: cmin &gt;= current CID means
					 * our command cannot see the tuple, so we should ignore
					 * it. Otherwise heap_lock_tuple() will throw an error,
					 * and so would any later attempt to update or delete the
					 * tuple.  (We need not check cmax because
					 * HeapTupleSatisfiesDirty will consider a tuple deleted
					 * by our transaction dead, regardless of cmax.)  We just
					 * checked that priorXmax == xmin, so we can test that
					 * variable instead of doing HeapTupleHeaderGetXmin again.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>priorXmax</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						<call><name>HeapTupleHeaderGetCmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>cid</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name>priorXmax</name></expr>;</expr_stmt>

						<comment type="block">/*
						 * Cmin is the problematic value, so store that. See
						 * above.
						 */</comment>
						<expr_stmt><expr><name><name>tmfd</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetCmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>TM_SelfModified</name></expr>;</return>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * This is a live tuple, so try to lock it again.
					 */</comment>
					<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>tuple_lock_retry</name>;</goto>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * If the referenced slot was actually empty, the latest
				 * version of the row must have been deleted, so we need do
				 * nothing.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>TM_Deleted</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * As above, if xmin isn't what we're expecting, do nothing.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>priorXmax</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>TM_Deleted</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * If we get here, the tuple was found but failed
				 * SnapshotDirty. Assuming the xmin is either a committed xact
				 * or our own xact (as it certainly should be if we're trying
				 * to modify the tuple), this must mean that the row was
				 * updated or deleted by either a committed xact or our own
				 * xact.  If it was deleted, we can ignore it; if it was
				 * updated then chain up to the next version and repeat the
				 * whole process.
				 *
				 * As above, it should be safe to examine xmax and t_ctid
				 * without the buffer content lock, because they can't be
				 * changing.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* deleted, so forget about it */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>TM_Deleted</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* updated, so look at the updated row */</comment>
				<expr_stmt><expr><operator>*</operator><name>tid</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name><operator>-&gt;</operator><name>t_ctid</name></name></expr>;</expr_stmt>
				<comment type="block">/* updated row should have xmin matching this xmax */</comment>
				<expr_stmt><expr><name>priorXmax</name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* loop back to fetch next in chain */</comment>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* tuple was deleted, so give up */</comment>
			<return>return <expr><name>TM_Deleted</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name></expr>;</expr_stmt>

	<comment type="block">/* store in slot, transferring existing pin */</comment>
	<expr_stmt><expr><call><name>ExecStorePinnedBufferHeapTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapam_finish_bulk_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we skipped writing WAL, then we need to sync the heap (but not
	 * indexes since those use WAL anyway / don't go through tableam)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>HEAP_INSERT_SKIP_WAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_sync</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * DDL related callbacks for heap AM.
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapam_relation_set_new_filenode</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								 <parameter><decl><type><specifier>const</specifier> <name>RelFileNode</name> <modifier>*</modifier></type><name>newrnode</name></decl></parameter>,
								 <parameter><decl><type><name>char</name></type> <name>persistence</name></decl></parameter>,
								 <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>freezeXid</name></decl></parameter>,
								 <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>minmulti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>srel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize to the minimum XID that could put tuples in the table. We
	 * know that no xacts older than RecentXmin are still running, so that
	 * will do.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>freezeXid</name> <operator>=</operator> <name>RecentXmin</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Similarly, initialize the minimum Multixact to the first value that
	 * could possibly be stored in tuples in the table.  Running transactions
	 * could reuse values from their local cache, so we are careful to
	 * consider all currently running multis.
	 *
	 * XXX this could be refined further, but is it worth the hassle?
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>minmulti</name> <operator>=</operator> <call><name>GetOldestMultiXactId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>srel</name> <operator>=</operator> <call><name>RelationCreateStorage</name><argument_list>(<argument><expr><operator>*</operator><name>newrnode</name></expr></argument>, <argument><expr><name>persistence</name></expr></argument>, <argument><expr><name>SMGR_MD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If required, set up an init fork for an unlogged table so that it can
	 * be correctly reinitialized on restart.  An immediate sync is required
	 * even if the page has been logged, because the write did not go through
	 * shared_buffers and therefore a concurrent checkpoint may have moved the
	 * redo pointer past our xlog record.  Recovery may as well remove it
	 * while replaying, for example, XLOG_DBASE_CREATE or XLOG_TBLSPC_CREATE
	 * record. Therefore, logging is necessary even if wal_level=minimal.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>persistence</name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
			   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name> <operator>||</operator>
			   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_AOSEGMENTS</name> <operator>||</operator>
			   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_AOVISIMAP</name> <operator>||</operator>
			   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_AOBLOCKDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>smgrcreate</name><argument_list>(<argument><expr><name>srel</name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>log_smgrcreate</name><argument_list>(<argument><expr><name>newrnode</name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>, <argument><expr><name>SMGR_MD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>smgrimmedsync</name><argument_list>(<argument><expr><name>srel</name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>srel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapam_relation_nontransactional_truncate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RelationTruncate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapam_relation_copy_data</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelFileNode</name> <modifier>*</modifier></type><name>newrnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>dstrel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dstrel</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><operator>*</operator><name>newrnode</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>, <argument><expr><name>SMGR_MD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we copy the file directly without looking at the shared buffers,
	 * we'd better first flush out any pages of the source relation that are
	 * in shared buffers.  We assume no new changes will be made while we are
	 * holding exclusive lock on the rel.
	 */</comment>
	<expr_stmt><expr><call><name>FlushRelationBuffers</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create and copy all forks of the relation, and schedule unlinking of
	 * old physical files.
	 *
	 * NOTE: any conflict in relfilenode value will be caught in
	 * RelationCreateStorage().
	 */</comment>
	<expr_stmt><expr><call><name>RelationCreateStorage</name><argument_list>(<argument><expr><operator>*</operator><name>newrnode</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>, <argument><expr><name>SMGR_MD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy main fork */</comment>
	<expr_stmt><expr><call><name>RelationCopyStorage</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>dstrel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>,
						<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy those extra forks that exist */</comment>
	<for>for <control>(<init><decl><type><name>ForkNumber</name></type> <name>forkNum</name> <init>= <expr><name>MAIN_FORKNUM</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init>
		 <condition><expr><name>forkNum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forkNum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>smgrexists</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>smgrcreate</name><argument_list>(<argument><expr><name>dstrel</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * WAL log creation if the relation is persistent, or this is the
			 * init fork of an unlogged relation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name> <operator>||</operator>
				<operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name> <operator>&amp;&amp;</operator>
				 <name>forkNum</name> <operator>==</operator> <name>INIT_FORKNUM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>log_smgrcreate</name><argument_list>(<argument><expr><name>newrnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>SMGR_MD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>RelationCopyStorage</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>dstrel</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>,
								<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>


	<comment type="block">/* drop old relation, and close new one */</comment>
	<expr_stmt><expr><call><name>RelationDropStorage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>dstrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapam_relation_copy_for_cluster</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>OldHeap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>NewHeap</name></decl></parameter>,
								 <parameter><decl><type><name>Relation</name></type> <name>OldIndex</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_sort</name></decl></parameter>,
								 <parameter><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl></parameter>,
								 <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xid_cutoff</name></decl></parameter>,
								 <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>multi_cutoff</name></decl></parameter>,
								 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>num_tuples</name></decl></parameter>,
								 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tups_vacuumed</name></decl></parameter>,
								 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tups_recently_dead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RewriteState</name></type> <name>rwstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>indexScan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>tableScan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>heapScan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_wal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_system_catalog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>tuplesort</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>oldTupDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>newTupDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>hslot</name></decl>;</decl_stmt>

	<comment type="block">/* Remember if it's a system catalog */</comment>
	<expr_stmt><expr><name>is_system_catalog</name> <operator>=</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to log the copied data in WAL iff WAL archiving/streaming is
	 * enabled AND it's a WAL-logged rel.
	 */</comment>
	<expr_stmt><expr><name>use_wal</name> <operator>=</operator> <call><name>XLogIsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* use_wal off requires smgr_targblock be initially invalid */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationGetTargetBlock</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Preallocate values/isnull arrays */</comment>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>natts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the rewrite operation */</comment>
	<expr_stmt><expr><name>rwstate</name> <operator>=</operator> <call><name>begin_heap_rewrite</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NewHeap</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>, <argument><expr><operator>*</operator><name>xid_cutoff</name></expr></argument>,
								 <argument><expr><operator>*</operator><name>multi_cutoff</name></expr></argument>, <argument><expr><name>use_wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* Set up sorting if wanted */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuplesort</name> <operator>=</operator> <call><name>tuplesort_begin_cluster</name><argument_list>(<argument><expr><name>oldTupDesc</name></expr></argument>, <argument><expr><name>OldIndex</name></expr></argument>,
											<argument><expr><name>maintenance_work_mem</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuplesort</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Prepare to scan the OldHeap.  To ensure we see recently-dead tuples
	 * that still need to be copied, we scan with SnapshotAny and use
	 * HeapTupleSatisfiesVacuum for the visibility test.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>OldIndex</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_sort</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name><name>ci_index</name><index>[]</index></name> <init>= <expr><block>{
			<expr><name>PROGRESS_CLUSTER_PHASE</name></expr>,
			<expr><name>PROGRESS_CLUSTER_INDEX_RELID</name></expr>
		}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name><name>ci_val</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* Set phase and OIDOldIndex to columns */</comment>
		<expr_stmt><expr><name><name>ci_val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>PROGRESS_CLUSTER_PHASE_INDEX_SCAN_HEAP</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ci_val</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>OldIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_progress_update_multi_param</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ci_index</name></expr></argument>, <argument><expr><name>ci_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tableScan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>heapScan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexScan</name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>OldIndex</name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>indexScan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* In scan-and-sort mode and also VACUUM FULL, set phase */</comment>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CLUSTER_PHASE</name></expr></argument>,
									 <argument><expr><name>PROGRESS_CLUSTER_PHASE_SEQ_SCAN_HEAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tableScan</name> <operator>=</operator> <call><name>table_beginscan</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>heapScan</name> <operator>=</operator> <operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>tableScan</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexScan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Set total heap blocks */</comment>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CLUSTER_TOTAL_HEAP_BLKS</name></expr></argument>,
									 <argument><expr><name><name>heapScan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hslot</name> <operator>=</operator> <operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan through the OldHeap, either in OldIndex order or sequentially;
	 * copy each tuple into the NewHeap, or transiently to the tuplesort
	 * module.  Note that we don't bother sorting dead tuples (they won't get
	 * to the new table anyway).
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isdead</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>indexScan</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>index_getnext_slot</name><argument_list>(<argument><expr><name>indexScan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* Since we used no scan keys, should never need to recheck */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>indexScan</name><operator>-&gt;</operator><name>xs_recheck</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER does not support lossy index conditions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_scan_getnextslot</name><argument_list>(<argument><expr><name>tableScan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * In scan-and-sort mode and also VACUUM FULL, set heap blocks
			 * scanned
			 */</comment>
			<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CLUSTER_HEAP_BLKS_SCANNED</name></expr></argument>,
										 <argument><expr><name><name>heapScan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>hslot</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><call><name>HeapTupleSatisfiesVacuum</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>HEAPTUPLE_DEAD</name></expr>:</case>
				<comment type="block">/* Definitely dead */</comment>
				<expr_stmt><expr><name>isdead</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>HEAPTUPLE_RECENTLY_DEAD</name></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>tups_recently_dead</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<comment type="block">/* fall through */</comment>
			<case>case <expr><name>HEAPTUPLE_LIVE</name></expr>:</case>
				<comment type="block">/* Live or recently dead, must copy it */</comment>
				<expr_stmt><expr><name>isdead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>HEAPTUPLE_INSERT_IN_PROGRESS</name></expr>:</case>

				<comment type="block">/*
				 * Since we hold exclusive lock on the relation, normally the
				 * only way to see this is if it was inserted earlier in our
				 * own transaction.  However, it can happen in system
				 * catalogs, since we tend to release write lock before commit
				 * there.  Give a warning if neither case applies; but in any
				 * case we had better copy it.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_system_catalog</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"concurrent insert in progress within table \"%s\""</literal></expr></argument>,
						 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* treat as live */</comment>
				<expr_stmt><expr><name>isdead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>HEAPTUPLE_DELETE_IN_PROGRESS</name></expr>:</case>

				<comment type="block">/*
				 * Similar situation to INSERT_IN_PROGRESS case.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_system_catalog</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"concurrent delete in progress within table \"%s\""</literal></expr></argument>,
						 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* treat as recently dead */</comment>
				<expr_stmt><expr><operator>*</operator><name>tups_recently_dead</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>isdead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected HeapTupleSatisfiesVacuum result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>isdead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isdead</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>tups_vacuumed</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<comment type="block">/* heap rewrite module still needs to see it... */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>rewrite_heap_dead_tuple</name><argument_list>(<argument><expr><name>rwstate</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* A previous recently-dead tuple is now known dead */</comment>
				<expr_stmt><expr><operator>*</operator><name>tups_vacuumed</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>tups_recently_dead</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>num_tuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tuplesort</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>tuplesort_putheaptuple</name><argument_list>(<argument><expr><name>tuplesort</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In scan-and-sort mode, report increase in number of tuples
			 * scanned
			 */</comment>
			<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CLUSTER_HEAP_TUPLES_SCANNED</name></expr></argument>,
										 <argument><expr><operator>*</operator><name>num_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name><name>ct_index</name><index>[]</index></name> <init>= <expr><block>{
				<expr><name>PROGRESS_CLUSTER_HEAP_TUPLES_SCANNED</name></expr>,
				<expr><name>PROGRESS_CLUSTER_HEAP_TUPLES_WRITTEN</name></expr>
			}</block></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type>		<name><name>ct_val</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>reform_and_rewrite_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NewHeap</name></expr></argument>,
									 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>rwstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In indexscan mode and also VACUUM FULL, report increase in
			 * number of tuples scanned and written
			 */</comment>
			<expr_stmt><expr><name><name>ct_val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>num_tuples</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ct_val</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>num_tuples</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_progress_update_multi_param</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ct_index</name></expr></argument>, <argument><expr><name>ct_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>indexScan</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>indexScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tableScan</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>tableScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>slot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * In scan-and-sort mode, complete the sort, then read out all live tuples
	 * from the tuplestore and write them to the new relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tuplesort</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>n_tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Report that we are now sorting tuples */</comment>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CLUSTER_PHASE</name></expr></argument>,
									 <argument><expr><name>PROGRESS_CLUSTER_PHASE_SORT_TUPLES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name>tuplesort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Report that we are now writing new heap */</comment>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CLUSTER_PHASE</name></expr></argument>,
									 <argument><expr><name>PROGRESS_CLUSTER_PHASE_WRITE_NEW_HEAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>tuplesort_getheaptuple</name><argument_list>(<argument><expr><name>tuplesort</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>n_tuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>reform_and_rewrite_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
									 <argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NewHeap</name></expr></argument>,
									 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
									 <argument><expr><name>rwstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Report n_tuples */</comment>
			<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CLUSTER_HEAP_TUPLES_WRITTEN</name></expr></argument>,
										 <argument><expr><name>n_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name>tuplesort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Write out any remaining tuples, and fsync if needed */</comment>
	<expr_stmt><expr><call><name>end_heap_rewrite</name><argument_list>(<argument><expr><name>rwstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heapam_scan_analyze_next_block</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl></parameter>,
							   <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>hscan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must maintain a pin on the target page's buffer to ensure that
	 * concurrent activity - e.g. HOT pruning - doesn't delete tuples out from
	 * under us.  Hence, pin the page until we are done looking at it.  We
	 * also choose to hold sharelock on the buffer throughout --- we could
	 * release and re-acquire sharelock for each tuple, but since we aren't
	 * doing much work per tuple, the extra lock traffic is probably better
	 * avoided.
	 */</comment>
	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>=</operator> <name>blockno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>,
										<argument><expr><name>blockno</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>bstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* in heap all blocks can contain tuples, so always return true */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heapam_scan_analyze_next_tuple</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl></parameter>,
							   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>liverows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>deadrows</name></decl></parameter>,
							   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>hscan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>targpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferHeapTupleTableSlot</name> <modifier>*</modifier></type><name>hslot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TTS_IS_BUFFERTUPLE</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hslot</name> <operator>=</operator> <operator>(</operator><name>BufferHeapTupleTableSlot</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>targpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoffset</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>targpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Inner loop over all tuples on the selected page */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>&lt;=</operator> <name>maxoffset</name></expr>;</condition> <incr><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cindex</name></name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>targtuple</name> <init>= <expr><operator>&amp;</operator><name><name>hslot</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>tupdata</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>sample_it</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>targpage</name></expr></argument>, <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We ignore unused and redirect line pointers.  DEAD line pointers
		 * should be counted as dead, because we need vacuum to run to get rid
		 * of them.  Note that this rule agrees with the way that
		 * heap_page_prune() counts things.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>deadrows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr></argument>, <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>targtuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targtuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>targpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targtuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><call><name>HeapTupleSatisfiesVacuum</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>,
										 <argument><expr><name>targtuple</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>,
										 <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>HEAPTUPLE_LIVE</name></expr>:</case>
				<expr_stmt><expr><name>sample_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>liverows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>HEAPTUPLE_DEAD</name></expr>:</case>
			<case>case <expr><name>HEAPTUPLE_RECENTLY_DEAD</name></expr>:</case>
				<comment type="block">/* Count dead and recently-dead rows */</comment>
				<expr_stmt><expr><operator>*</operator><name>deadrows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>HEAPTUPLE_INSERT_IN_PROGRESS</name></expr>:</case>

				<comment type="block">/*
				 * Insert-in-progress rows are not counted.  We assume that
				 * when the inserting transaction commits or aborts, it will
				 * send a stats message to increment the proper count.  This
				 * works right only if that transaction ends after we finish
				 * analyzing the table; if things happen in the other order,
				 * its stats update will be overwritten by ours.  However, the
				 * error will be large only if the other transaction runs long
				 * enough to insert many tuples, so assuming it will finish
				 * after us is the safer option.
				 *
				 * A special case is that the inserting transaction might be
				 * our own.  In this case we should count and sample the row,
				 * to accommodate users who load a table and analyze it in one
				 * transaction.  (pgstat_report_analyze has to adjust the
				 * numbers we send to the stats collector to make this come
				 * out right.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>targtuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>sample_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>liverows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>HEAPTUPLE_DELETE_IN_PROGRESS</name></expr>:</case>

				<comment type="block">/*
				 * We count and sample delete-in-progress rows the same as
				 * live ones, so that the stats counters come out right if the
				 * deleting transaction commits after us, per the same
				 * reasoning given above.
				 *
				 * If the delete was done by our own transaction, however, we
				 * must count the row as dead to make pgstat_report_analyze's
				 * stats adjustments come out right.  (Note: this works out
				 * properly when the row was both inserted and deleted in our
				 * xact.)
				 *
				 * The net effect of these choices is that we act as though an
				 * IN_PROGRESS transaction hasn't happened yet, except if it
				 * is our own transaction, which we assume has happened.
				 *
				 * This approach ensures that we behave sanely if we see both
				 * the pre-image and post-image rows for a row being updated
				 * by a concurrent transaction: we will sample the pre-image
				 * but not the post-image.  We also get sane results if the
				 * concurrent transaction never commits.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>targtuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>deadrows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>sample_it</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>liverows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected HeapTupleSatisfiesVacuum result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>sample_it</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecStoreBufferHeapTuple</name><argument_list>(<argument><expr><name>targtuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cindex</name></name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* note that we leave the buffer locked here! */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Now release the lock and pin on the page */</comment>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

	<comment type="block">/* also prevent old slot contents from having pin on page */</comment>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>heapam_index_build_range_scan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
							  <parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
							  <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>allow_sync</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>anyvisible</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>progress</name></decl></parameter>,
							  <parameter><decl><type><name>BlockNumber</name></type> <name>start_blockno</name></decl></parameter>,
							  <parameter><decl><type><name>BlockNumber</name></type> <name>numblocks</name></decl></parameter>,
							  <parameter><decl><type><name>IndexBuildCallback</name></type> <name>callback</name></decl></parameter>,
							  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>,
							  <parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>hscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_system_catalog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>checking_uniqueness</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heapTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>predicate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_unregister_snapshot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>previous_blkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>root_blkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>root_offsets</name><index>[<expr><name>MaxHeapTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remember if it's a system catalog */</comment>
	<expr_stmt><expr><name>is_system_catalog</name> <operator>=</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* See whether we're verifying uniqueness/exclusion properties */</comment>
	<expr_stmt><expr><name>checking_uniqueness</name> <operator>=</operator> <operator>(</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name> <operator>||</operator>
						   <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * "Any visible" mode is not compatible with uniqueness checks; make sure
	 * only one of those is requested.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>anyvisible</name> <operator>&amp;&amp;</operator> <name>checking_uniqueness</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need an EState for evaluation of index expressions and partial-index
	 * predicates.  Also a slot to hold the current tuple.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/* Set up execution state for predicate, if any. */</comment>
	<expr_stmt><expr><name>predicate</name> <operator>=</operator> <call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare for scan of the base relation.  In a normal index build, we use
	 * SnapshotAny because we must retrieve all tuples and do our own time
	 * qual checks (because we have to index RECENTLY_DEAD tuples). In a
	 * concurrent build, or during bootstrap, we take a regular MVCC snapshot
	 * and index whatever's live according to that.
	 */</comment>
	<expr_stmt><expr><name>OldestXmin</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

	<comment type="block">/* okay to ignore lazy VACUUMs here */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>OldestXmin</name> <operator>=</operator> <call><name>GetOldestXmin</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>PROCARRAY_FLAGS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Serial index build.
		 *
		 * Must begin our own heap scan in this case.  We may also need to
		 * register a snapshot whose lifetime is under our direct control.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>OldestXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>need_unregister_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name>SnapshotAny</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_strat</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,	<comment type="block">/* relation */</comment>
									 <argument><expr><name>snapshot</name></expr></argument>,	<comment type="block">/* snapshot */</comment>
									 <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* number of keys */</comment>
									 <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* scan key */</comment>
									 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* buffer access strategy OK */</comment>
									 <argument><expr><name>allow_sync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* syncscan OK? */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Parallel index build.
		 *
		 * Parallel case never registers/unregisters own snapshot.  Snapshot
		 * is taken from parallel heap scan, and is SnapshotAny or an MVCC
		 * snapshot, based on same criteria as serial case.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>allow_sync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_snapshot</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>hscan</name> <operator>=</operator> <operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>scan</name></expr>;</expr_stmt>

	<comment type="block">/* Publish number of blocks to scan */</comment>
	<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParallelBlockTableScanDesc</name></type> <name>pbscan</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>pbscan</name> <operator>=</operator> <operator>(</operator><name>ParallelBlockTableScanDesc</name><operator>)</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <name><name>pbscan</name><operator>-&gt;</operator><name>phs_nblocks</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_SCAN_BLOCKS_TOTAL</name></expr></argument>,
									 <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Must call GetOldestXmin() with SnapshotAny.  Should never call
	 * GetOldestXmin() with MVCC snapshot. (It's especially worth checking
	 * this for parallel builds, since ambuild routines that support parallel
	 * builds must work these details out for themselves.)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>snapshot</name> <operator>==</operator> <name>SnapshotAny</name> <operator>||</operator> <call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><ternary><condition><expr><name>snapshot</name> <operator>==</operator> <name>SnapshotAny</name></expr> ?</condition><then> <expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>OldestXmin</name></expr></argument>)</argument_list></call></expr> </then><else>:
		   <expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>OldestXmin</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>snapshot</name> <operator>==</operator> <name>SnapshotAny</name> <operator>||</operator> <operator>!</operator><name>anyvisible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set our scan endpoints */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_sync</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_setscanlimits</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>start_blockno</name></expr></argument>, <argument><expr><name>numblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* syncscan can only be requested on whole relation */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>start_blockno</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numblocks</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan all tuples in the base relation.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>heapTuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>tupleIsAlive</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Report scan progress, if asked to. */</comment>
		<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blocks_done</name> <init>= <expr><call><name>heapam_scan_get_blocks_done</name><argument_list>(<argument><expr><name>hscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>blocks_done</name> <operator>!=</operator> <name>previous_blkno</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_SCAN_BLOCKS_DONE</name></expr></argument>,
											 <argument><expr><name>blocks_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>previous_blkno</name> <operator>=</operator> <name>blocks_done</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * When dealing with a HOT-chain of updated tuples, we want to index
		 * the values of the live tuple (if any), but index it under the TID
		 * of the chain's root tuple.  This approach is necessary to preserve
		 * the HOT-chain structure in the heap. So we need to be able to find
		 * the root item offset for every tuple that's in a HOT-chain.  When
		 * first reaching a new page of the relation, call
		 * heap_get_root_tuples() to build a map of root item offsets on the
		 * page.
		 *
		 * It might look unsafe to use this information across buffer
		 * lock/unlock.  However, we hold ShareLock on the table so no
		 * ordinary insert/update/delete should occur; and we hold pin on the
		 * buffer continuously while visiting the page, so no pruning
		 * operation can occur either.
		 *
		 * Also, although our opinions about tuple liveness could change while
		 * we scan the page (due to concurrent transaction commits/aborts),
		 * the chain root locations won't, so this info doesn't need to be
		 * rebuilt after waiting for another transaction.
		 *
		 * Note the implied assumption that there is no more than one live
		 * tuple per HOT-chain --- else we could create more than one index
		 * entry pointing to the same root tuple.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>!=</operator> <name>root_blkno</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_get_root_tuples</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>root_offsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>root_blkno</name> <operator>=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>==</operator> <name>SnapshotAny</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* do our own time qual check */</comment>
			<decl_stmt><decl><type><name>bool</name></type>		<name>indexIt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>xwait</name></decl>;</decl_stmt>

	<label><name>recheck</name>:</label>

			<comment type="block">/*
			 * We could possibly get away with not locking the buffer here,
			 * since caller should hold ShareLock on the relation, but let's
			 * be conservative about it.  (This remark is still correct even
			 * with HOT-pruning: our pin on the buffer prevents pruning.)
			 */</comment>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The criteria for counting a tuple as live in this block need to
			 * match what analyze.c's heapam_scan_analyze_next_tuple() does,
			 * otherwise CREATE INDEX and ANALYZE may produce wildly different
			 * reltuples values, e.g. when there are many recently-dead
			 * tuples.
			 */</comment>
			<switch>switch <condition>(<expr><call><name>HeapTupleSatisfiesVacuum</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,
											 <argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>,
											 <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>HEAPTUPLE_DEAD</name></expr>:</case>
					<comment type="block">/* Definitely dead, we can ignore it */</comment>
					<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>HEAPTUPLE_LIVE</name></expr>:</case>
					<comment type="block">/* Normal case, index and unique-check it */</comment>
					<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<comment type="block">/* Count it as live, too */</comment>
					<expr_stmt><expr><name>reltuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>HEAPTUPLE_RECENTLY_DEAD</name></expr>:</case>

					<comment type="block">/*
					 * If tuple is recently deleted then we must index it
					 * anyway to preserve MVCC semantics.  (Pre-existing
					 * transactions could try to use the index after we finish
					 * building it, and may need to see such tuples.)
					 *
					 * However, if it was HOT-updated then we must only index
					 * the live tuple at the end of the HOT-chain.  Since this
					 * breaks semantics for pre-existing snapshots, mark the
					 * index as unusable for them.
					 *
					 * We don't count recently-dead tuples in reltuples, even
					 * if we index them; see heapam_scan_analyze_next_tuple().
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsHotUpdated</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<comment type="block">/* mark the index as unsafe for old snapshots */</comment>
						<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<comment type="block">/* In any case, exclude the tuple from unique-checking */</comment>
					<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>HEAPTUPLE_INSERT_IN_PROGRESS</name></expr>:</case>

					<comment type="block">/*
					 * In "anyvisible" mode, this tuple is visible and we
					 * don't need any further checks.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>anyvisible</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>reltuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Since caller should hold ShareLock or better, normally
					 * the only way to see this is if it was inserted earlier
					 * in our own transaction.  However, it can happen in
					 * system catalogs, since we tend to release write lock
					 * before commit there.  Give a warning if neither case
					 * applies.
					 */</comment>
					<expr_stmt><expr><name>xwait</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_system_catalog</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"concurrent insert in progress within table \"%s\""</literal></expr></argument>,
								 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * If we are performing uniqueness checks, indexing
						 * such a tuple could lead to a bogus uniqueness
						 * failure.  In that case we wait for the inserting
						 * transaction to finish and check again.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>checking_uniqueness</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Must drop the lock on the buffer before we wait
							 */</comment>
							<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>heapRelation</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>,
											  <argument><expr><name>XLTW_InsertIndexUnique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>recheck</name>;</goto>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * For consistency with
						 * heapam_scan_analyze_next_tuple(), count
						 * HEAPTUPLE_INSERT_IN_PROGRESS tuples as live only
						 * when inserted by our own transaction.
						 */</comment>
						<expr_stmt><expr><name>reltuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/*
					 * We must index such tuples, since if the index build
					 * commits then they're good.
					 */</comment>
					<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>HEAPTUPLE_DELETE_IN_PROGRESS</name></expr>:</case>

					<comment type="block">/*
					 * As with INSERT_IN_PROGRESS case, this is unexpected
					 * unless it's our own deletion or a system catalog; but
					 * in anyvisible mode, this tuple is visible.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>anyvisible</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>reltuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>xwait</name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_system_catalog</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"concurrent delete in progress within table \"%s\""</literal></expr></argument>,
								 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * If we are performing uniqueness checks, assuming
						 * the tuple is dead could lead to missing a
						 * uniqueness violation.  In that case we wait for the
						 * deleting transaction to finish and check again.
						 *
						 * Also, if it's a HOT-updated tuple, we should not
						 * index it but rather the live tuple at the end of
						 * the HOT-chain.  However, the deleting transaction
						 * could abort, possibly leaving this tuple as live
						 * after all, in which case it has to be indexed. The
						 * only way to know what to do is to wait for the
						 * deleting transaction to finish and check again.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>checking_uniqueness</name> <operator>||</operator>
							<call><name>HeapTupleIsHotUpdated</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Must drop the lock on the buffer before we wait
							 */</comment>
							<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>heapRelation</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>,
											  <argument><expr><name>XLTW_InsertIndexUnique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>recheck</name>;</goto>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/*
						 * Otherwise index it but don't check for uniqueness,
						 * the same as a RECENTLY_DEAD tuple.
						 */</comment>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

						<comment type="block">/*
						 * Count HEAPTUPLE_DELETE_IN_PROGRESS tuples as live,
						 * if they were not deleted by the current
						 * transaction.  That's what
						 * heapam_scan_analyze_next_tuple() does, and we want
						 * the behavior to be consistent.
						 */</comment>
						<expr_stmt><expr><name>reltuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><call><name>HeapTupleIsHotUpdated</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * It's a HOT-updated tuple deleted by our own xact.
						 * We can assume the deletion will commit (else the
						 * index contents don't matter), so treat the same as
						 * RECENTLY_DEAD HOT-updated tuples.
						 */</comment>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<comment type="block">/* mark the index as unsafe for old snapshots */</comment>
						<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * It's a regular tuple deleted by our own xact. Index
						 * it, but don't check for uniqueness nor count in
						 * reltuples, the same as a RECENTLY_DEAD tuple.
						 */</comment>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<comment type="block">/* In any case, exclude the tuple from unique-checking */</comment>
					<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected HeapTupleSatisfiesVacuum result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>tupleIsAlive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
					<break>break;</break>
			</block_content>}</block></switch>

			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>indexIt</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* heap_getnext did the time qual check */</comment>
			<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reltuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up for predicate or expression evaluation */</comment>
		<expr_stmt><expr><call><name>ExecStoreBufferHeapTuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In a partial index, discard tuples that don't satisfy the
		 * predicate.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * For the current heap tuple, extract all the attributes we use in
		 * this index, and note which are null.  This also performs evaluation
		 * of any expressions needed.
		 */</comment>
		<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
					   <argument><expr><name>slot</name></expr></argument>,
					   <argument><expr><name>estate</name></expr></argument>,
					   <argument><expr><name>values</name></expr></argument>,
					   <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * You'd think we should go ahead and build the index tuple here, but
		 * some index AMs want to do further processing on the data first.  So
		 * pass the values[] and isnull[] arrays, instead.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsHeapOnly</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For a heap-only tuple, pretend its TID is that of the root. See
			 * src/backend/access/heap/README.HOT for discussion.
			 */</comment>
			<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>rootTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rootTuple</name> <operator>=</operator> <operator>*</operator><name>heapTuple</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name><name>root_offsets</name><index>[<expr><name>offnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"failed to find parent tuple for heap-only tuple at (%u,%u) in table \"%s\""</literal></expr></argument>,
										 <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>offnum</name></expr></argument>,
										 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rootTuple</name><operator>.</operator><name>t_self</name></name></expr></argument>,
									   <argument><expr><name><name>root_offsets</name><index>[<expr><name>offnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Call the AM's callback routine to process the tuple */</comment>
			<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rootTuple</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>tupleIsAlive</name></expr></argument>,
					 <argument><expr><name>callback_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Call the AM's callback routine to process the tuple */</comment>
			<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>tupleIsAlive</name></expr></argument>,
					 <argument><expr><name>callback_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Report scan progress one last time. */</comment>
	<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blks_done</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParallelBlockTableScanDesc</name></type> <name>pbscan</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>pbscan</name> <operator>=</operator> <operator>(</operator><name>ParallelBlockTableScanDesc</name><operator>)</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>blks_done</name> <operator>=</operator> <name><name>pbscan</name><operator>-&gt;</operator><name>phs_nblocks</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>blks_done</name> <operator>=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_SCAN_BLOCKS_DONE</name></expr></argument>,
									 <argument><expr><name>blks_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we can now forget our snapshot, if set and registered by us */</comment>
	<if_stmt><if>if <condition>(<expr><name>need_unregister_snapshot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* These may have been pointing to the now-gone estate */</comment>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>reltuples</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapam_index_validate_scan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
						   <parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
						   <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
						   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						   <parameter><decl><type><name>ValidateIndexState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>hscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heapTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>predicate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>root_blkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>root_offsets</name><index>[<expr><name>MaxHeapTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>in_index</name><index>[<expr><name>MaxHeapTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>previous_blkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* state variables for the merge */</comment>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>indexcursor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>decoded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tuplesort_empty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need an EState for evaluation of index expressions and partial-index
	 * predicates.  Also a slot to hold the current tuple.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>TTSOpsHeapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/* Set up execution state for predicate, if any. */</comment>
	<expr_stmt><expr><name>predicate</name> <operator>=</operator> <call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare for scan of the base relation.  We need just those tuples
	 * satisfying the passed-in reference snapshot.  We must disable syncscan
	 * here, because it's critical that we read from block zero forward to
	 * match the sorted TIDs.
	 */</comment>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_strat</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,	<comment type="block">/* relation */</comment>
								 <argument><expr><name>snapshot</name></expr></argument>,	<comment type="block">/* snapshot */</comment>
								 <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* number of keys */</comment>
								 <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* scan key */</comment>
								 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* buffer access strategy OK */</comment>
								 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* syncscan not OK */</comment>
	<expr_stmt><expr><name>hscan</name> <operator>=</operator> <operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>scan</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_SCAN_BLOCKS_TOTAL</name></expr></argument>,
								 <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan all tuples matching the snapshot.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>heapTuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>heapcursor</name> <init>= <expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>rootTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>root_offnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>htups</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>previous_blkno</name> <operator>==</operator> <name>InvalidBlockNumber</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>!=</operator> <name>previous_blkno</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_SCAN_BLOCKS_DONE</name></expr></argument>,
										 <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>previous_blkno</name> <operator>=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * As commented in table_index_build_scan, we should index heap-only
		 * tuples under the TIDs of their root tuples; so when we advance onto
		 * a new heap page, build a map of root item offsets on the page.
		 *
		 * This complicates merging against the tuplesort output: we will
		 * visit the live tuples in order by their offsets, but the root
		 * offsets that we need to compare against the index contents might be
		 * ordered differently.  So we might have to "look back" within the
		 * tuplesort output, but only within the current page.  We handle that
		 * by keeping a bool array in_index[] showing all the
		 * already-passed-over tuplesort output TIDs of the current page. We
		 * clear that array here, when advancing onto a new heap page.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>!=</operator> <name>root_blkno</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_get_root_tuples</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>root_offsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>in_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>in_index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>root_blkno</name> <operator>=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Convert actual tuple TID to root TID */</comment>
		<expr_stmt><expr><name>rootTuple</name> <operator>=</operator> <operator>*</operator><name>heapcursor</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>root_offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>heapcursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsHeapOnly</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>root_offnum</name> <operator>=</operator> <name><name>root_offsets</name><index>[<expr><name>root_offnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name>root_offnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"failed to find parent tuple for heap-only tuple at (%u,%u) in table \"%s\""</literal></expr></argument>,
										 <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>heapcursor</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>heapcursor</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>, <argument><expr><name>root_offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * "merge" by skipping through the index tuples until we find or pass
		 * the current root tuple.
		 */</comment>
		<while>while <condition>(<expr><operator>!</operator><name>tuplesort_empty</name> <operator>&amp;&amp;</operator>
			   <operator>(</operator><operator>!</operator><name>indexcursor</name> <operator>||</operator>
				<call><name>ItemPointerCompare</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>ts_val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>ts_isnull</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>indexcursor</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Remember index items seen earlier on the current heap page
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>root_blkno</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>in_index</name><index>[<expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>tuplesort_empty</name> <operator>=</operator> <operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuplesort</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>ts_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts_isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuplesort_empty</name> <operator>||</operator> <operator>!</operator><name>ts_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tuplesort_empty</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>itemptr_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>decoded</name></expr></argument>, <argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>ts_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>indexcursor</name> <operator>=</operator> <operator>&amp;</operator><name>decoded</name></expr>;</expr_stmt>

				<comment type="block">/* If int8 is pass-by-ref, free (encoded) TID Datum memory */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_FLOAT8_BYVAL</name></cpp:ifndef>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>ts_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Be tidy */</comment>
				<expr_stmt><expr><name>indexcursor</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * If the tuplesort has overshot *and* we didn't see a match earlier,
		 * then this tuple is missing from the index, so insert it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tuplesort_empty</name> <operator>||</operator>
			 <call><name>ItemPointerCompare</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>in_index</name><index>[<expr><name>root_offnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Set up for predicate or expression evaluation */</comment>
			<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In a partial index, discard tuples that don't satisfy the
			 * predicate.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * For the current heap tuple, extract all the attributes we use
			 * in this index, and note which are null.  This also performs
			 * evaluation of any expressions needed.
			 */</comment>
			<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
						   <argument><expr><name>slot</name></expr></argument>,
						   <argument><expr><name>estate</name></expr></argument>,
						   <argument><expr><name>values</name></expr></argument>,
						   <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * You'd think we should go ahead and build the index tuple here,
			 * but some index AMs want to do further processing on the data
			 * first. So pass the values[] and isnull[] arrays, instead.
			 */</comment>

			<comment type="block">/*
			 * If the tuple is already committed dead, you might think we
			 * could suppress uniqueness checking, but this is no longer true
			 * in the presence of HOT, because the insert is actually a proxy
			 * for a uniqueness check on the whole HOT-chain.  That is, the
			 * tuple we have here could be dead because it was already
			 * HOT-updated, and if so the updating transaction will not have
			 * thought it should insert index entries.  The index AM will
			 * check the whole HOT-chain and correctly detect a conflict if
			 * there is one.
			 */</comment>

			<expr_stmt><expr><call><name>index_insert</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>,
						 <argument><expr><name>values</name></expr></argument>,
						 <argument><expr><name>isnull</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>,
						 <argument><expr><name>heapRelation</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr> ?</condition><then>
						 <expr><name>UNIQUE_CHECK_YES</name></expr> </then><else>: <expr><name>UNIQUE_CHECK_NO</name></expr></else></ternary></expr></argument>,
						 <argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tups_inserted</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* These may have been pointing to the now-gone estate */</comment>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the number of blocks that have been read by this scan since
 * starting.  This is meant for progress reporting rather than be fully
 * accurate: in a parallel scan, workers can be concurrently reading blocks
 * further ahead than what we report.
 */</comment>
<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>heapam_scan_get_blocks_done</name><parameter_list>(<parameter><decl><type><name>HeapScanDesc</name></type> <name>hscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelBlockTableScanDesc</name></type> <name>bpscan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>startblock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blocks_done</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bpscan</name> <operator>=</operator> <operator>(</operator><name>ParallelBlockTableScanDesc</name><operator>)</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_base</name><operator>.</operator><name>rs_parallel</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>startblock</name> <operator>=</operator> <name><name>bpscan</name><operator>-&gt;</operator><name>phs_startblock</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>startblock</name> <operator>=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_startblock</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Might have wrapped around the end of the relation, if startblock was
	 * not zero.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>&gt;</operator> <name>startblock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>blocks_done</name> <operator>=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>-</operator> <name>startblock</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <ternary><condition><expr><name>bpscan</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>bpscan</name><operator>-&gt;</operator><name>phs_nblocks</name></name></expr> </then><else>: <expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>blocks_done</name> <operator>=</operator> <name>nblocks</name> <operator>-</operator> <name>startblock</name> <operator>+</operator>
			<name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>blocks_done</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * Miscellaneous callbacks for the heap AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>heapam_relation_size</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>nblocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Open it at the smgr level if not already done */</comment>
	<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* InvalidForkNumber indicates returning the size for all forks */</comment>
	<if_stmt><if>if <condition>(<expr><name>forkNumber</name> <operator>==</operator> <name>InvalidForkNumber</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nblocks</name> <operator>+=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>forkNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>nblocks</name> <operator>*</operator> <name>BLCKSZ</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check to see whether the table needs a TOAST table.  It does only if
 * (1) there are any toastable attributes, and (2) the maximum length
 * of a tuple could exceed TOAST_TUPLE_THRESHOLD.  (We don't want to
 * create a toast table for something like "f1 varchar(20)".)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heapam_relation_needs_toast_table</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>data_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>maxlength_unknown</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_toastable_attrs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tuple_length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Fixed-length types are never toastable */</comment>
			<expr_stmt><expr><name>data_length</name> <operator>+=</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type>		<name>maxlen</name> <init>= <expr><call><name>type_maximum_size</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
												   <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>maxlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>maxlength_unknown</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>data_length</name> <operator>+=</operator> <name>maxlen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>!=</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>has_toastable_attrs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_toastable_attrs</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* nothing to toast? */</comment>
	<if_stmt><if>if <condition>(<expr><name>maxlength_unknown</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* any unlimited-length attrs? */</comment>
	<expr_stmt><expr><name>tuple_length</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofHeapTupleHeader</name> <operator>+</operator>
							<call><name>BITMAPLEN</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>tuple_length</name> <operator>&gt;</operator> <name>TOAST_TUPLE_THRESHOLD</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------------------------------------------------------------
 * Planner related callbacks for the heap AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>heapam_estimate_rel_size</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>attr_widths</name></decl></parameter>,
						 <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>pages</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>,
						 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>allvisfrac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>curpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relallvisible</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>density</name></decl>;</decl_stmt>

	<comment type="block">/* it has storage, ok to call the smgr */</comment>
	<expr_stmt><expr><name>curpages</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* coerce values in pg_class to more desirable types */</comment>
	<expr_stmt><expr><name>relpages</name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>relallvisible</name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relallvisible</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * HACK: if the relation has never yet been vacuumed, use a minimum size
	 * estimate of 10 pages.  The idea here is to avoid assuming a
	 * newly-created table is really small, even if it currently is, because
	 * that may not be true once some data gets loaded into it.  Once a vacuum
	 * or analyze cycle has been done on it, it's more reasonable to believe
	 * the size is somewhat stable.
	 *
	 * (Note that this is only an issue if the plan gets cached and used again
	 * after the table has been filled.  What we're trying to avoid is using a
	 * nestloop-type plan on a table that has grown substantially since the
	 * plan was made.  Normally, autovacuum/autoanalyze will occur once enough
	 * inserts have happened and cause cached-plan invalidation; but that
	 * doesn't happen instantaneously, and it won't happen at all for cases
	 * such as temporary tables.)
	 *
	 * We approximate "never vacuumed" by "has relpages = 0", which means this
	 * will also fire on genuinely empty relations.  Not great, but
	 * fortunately that's a seldom-seen case in the real world, and it
	 * shouldn't degrade the quality of the plan too much anyway to err in
	 * this direction.
	 *
	 * If the table has inheritance children, we don't apply this heuristic.
	 * Totally empty parent tables are quite common, so we should be willing
	 * to believe that they are empty.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>curpages</name> <operator>&lt;</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator>
		<name>relpages</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhassubclass</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>curpages</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* report estimated # pages */</comment>
	<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <name>curpages</name></expr>;</expr_stmt>
	<comment type="block">/* quick exit if rel is clearly empty */</comment>
	<if_stmt><if>if <condition>(<expr><name>curpages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* estimate number of tuples from previous tuple density */</comment>
	<if_stmt><if>if <condition>(<expr><name>relpages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>density</name> <operator>=</operator> <name>reltuples</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>relpages</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * When we have no data because the relation was truncated, estimate
		 * tuple width from attribute datatypes.  We assume here that the
		 * pages are completely full, which is OK for tables (since they've
		 * presumably not been VACUUMed yet) but is probably an overestimate
		 * for indexes.  Fortunately get_relation_info() can clamp the
		 * overestimate to the parent table's size.
		 *
		 * Note: this code intentionally disregards alignment considerations,
		 * because (a) that would be gilding the lily considering how crude
		 * the estimate is, and (b) it creates platform dependencies in the
		 * default plans which are kind of a headache for regression testing.
		 */</comment>
		<decl_stmt><decl><type><name>int32</name></type>		<name>tuple_width</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple_width</name> <operator>=</operator> <call><name>get_rel_data_width</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attr_widths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple_width</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<comment type="block">/* note: integer division is intentional here */</comment>
		<expr_stmt><expr><name>density</name> <operator>=</operator> <operator>(</operator><name>BLCKSZ</name> <operator>-</operator> <name>SizeOfPageHeaderData</name><operator>)</operator> <operator>/</operator> <name>tuple_width</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>density</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>curpages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We use relallvisible as-is, rather than scaling it up like we do for
	 * the pages and tuples counts, on the theory that any pages added since
	 * the last VACUUM are most likely not marked all-visible.  But costsize.c
	 * wants it converted to a fraction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relallvisible</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>curpages</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>double</name><operator>)</operator> <name>relallvisible</name> <operator>&gt;=</operator> <name>curpages</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>relallvisible</name> <operator>/</operator> <name>curpages</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * Executor related callbacks for the heap AM
 * ------------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heapam_scan_bitmap_next_block</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>,
							  <parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmres</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>hscan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>page</name> <init>= <expr><name><name>tbmres</name><operator>-&gt;</operator><name>blockno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ignore any claimed entries past what we think is the end of the
	 * relation. It may have been extended after the start of our scan (we
	 * only hold an AccessShareLock, and it could be inserts from this
	 * backend).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>page</name> <operator>&gt;=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Acquire pin on the target heap page, trading in any pin we held before.
	 */</comment>
	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name> <operator>=</operator> <call><name>ReleaseAndReadBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>,
										  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>,
										  <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_snapshot</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prune and repair fragmentation for the whole page, if possible.
	 */</comment>
	<expr_stmt><expr><call><name>heap_page_prune_opt</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must hold share lock on the buffer content while examining tuple
	 * visibility.  Afterwards, however, the tuples we have found to be
	 * visible are guaranteed good as long as we hold the buffer pin.
	 */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need two separate strategies for lossy and non-lossy cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbmres</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Bitmap is non-lossy, so we just look through the offsets listed in
		 * tbmres; but we have to follow any HOT chain starting at each such
		 * offset.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>curslot</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>curslot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>curslot</name> <operator>&lt;</operator> <name><name>tbmres</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</condition> <incr><expr><name>curslot</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name> <init>= <expr><name><name>tbmres</name><operator>-&gt;</operator><name>offsets</name><index>[<expr><name>curslot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>heapTuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>heap_hot_search_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>heapTuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_vistuples</name><index>[<expr><name>ntup</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Bitmap is lossy, so we must examine each line pointer on the page.
		 * But we can ignore HOT chains, since we'll check each tuple anyway.
		 */</comment>
		<decl_stmt><decl><type><name>Page</name></type>		<name>dp</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>loctup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>loctup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>dp</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>loctup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>loctup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>loctup</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>valid</name> <operator>=</operator> <call><name>HeapTupleSatisfiesVisibility</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loctup</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_vistuples</name><index>[<expr><name>ntup</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PredicateLockTuple</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loctup</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>CheckForSerializableConflictOut</name><argument_list>(<argument><expr><name>valid</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loctup</name></expr></argument>,
											<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ntup</name> <operator>&lt;=</operator> <name>MaxHeapTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_ntuples</name></name> <operator>=</operator> <name>ntup</name></expr>;</expr_stmt>

	<return>return <expr><name>ntup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heapam_scan_bitmap_next_tuple</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>,
							  <parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>tbmres</name></decl></parameter>,
							  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>hscan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>targoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Out of range?  If so, nothing more to look at on this page
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_cindex</name></name> <operator>&gt;=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_ntuples</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>targoffset</name> <operator>=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_vistuples</name><index>[<expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cindex</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dp</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>targoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_ctup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><operator>(</operator><name>Page</name><operator>)</operator> <name>dp</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_ctup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_ctup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hscan</name><operator>-&gt;</operator><name>rs_ctup</name><operator>.</operator><name>t_self</name></name></expr></argument>, <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr></argument>, <argument><expr><name>targoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_count_heap_fetch</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up the result slot to point to this tuple.  Note that the slot
	 * acquires a pin on the buffer.
	 */</comment>
	<expr_stmt><expr><call><name>ExecStoreBufferHeapTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hscan</name><operator>-&gt;</operator><name>rs_ctup</name></name></expr></argument>,
							 <argument><expr><name>slot</name></expr></argument>,
							 <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cindex</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heapam_scan_sample_next_block</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>SampleScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>hscan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsmRoutine</name> <modifier>*</modifier></type><name>tsm</name> <init>= <expr><name><name>scanstate</name><operator>-&gt;</operator><name>tsmroutine</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl>;</decl_stmt>

	<comment type="block">/* return false immediately if relation is empty */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_nblocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tsm</name><operator>-&gt;</operator><name>NextSampleBlock</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>blockno</name> <operator>=</operator> <call><name><name>tsm</name><operator>-&gt;</operator><name>NextSampleBlock</name></name><argument_list>(<argument><expr><name>scanstate</name></expr></argument>, <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>=</operator> <name>blockno</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* scanning table sequentially */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>hscan</name><operator>-&gt;</operator><name>rs_inited</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>blockno</name> <operator>=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_startblock</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_inited</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>blockno</name> <operator>=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>blockno</name> <operator>&gt;=</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_nblocks</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* wrap to beginning of rel, might not have started at 0 */</comment>
				<expr_stmt><expr><name>blockno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Report our new scan position for synchronization purposes.
			 *
			 * Note: we do this before checking for end of scan so that the
			 * final state of the position hint is back at the start of the
			 * rel.  That's not strictly necessary, but otherwise when you run
			 * the same query multiple times the starting position would shift
			 * a little bit backwards on every invocation, which is confusing.
			 * We don't guarantee any specific ordering in general, though.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_ALLOW_SYNC</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ss_report_location</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>blockno</name> <operator>==</operator> <name><name>hscan</name><operator>-&gt;</operator><name>rs_startblock</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>blockno</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_inited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>heapgetpage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_inited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heapam_scan_sample_next_tuple</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>SampleScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>,
							  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>hscan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TsmRoutine</name> <modifier>*</modifier></type><name>tsm</name> <init>= <expr><name><name>scanstate</name><operator>-&gt;</operator><name>tsmroutine</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockno</name> <init>= <expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pagemode</name> <init>= <expr><operator>(</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_ALLOW_PAGEMODE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_visible</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoffset</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * When not using pagemode, we must lock the buffer during tuple
	 * visibility checks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pagemode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>all_visible</name> <operator>=</operator> <call><name>PageIsAllVisible</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>rs_snapshot</name><operator>-&gt;</operator><name>takenDuringRecovery</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoffset</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>tupoffset</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Ask the tablesample method which tuples to check on this page. */</comment>
		<expr_stmt><expr><name>tupoffset</name> <operator>=</operator> <call><name><name>tsm</name><operator>-&gt;</operator><name>NextSampleTuple</name></name><argument_list>(<argument><expr><name>scanstate</name></expr></argument>,
										 <argument><expr><name>blockno</name></expr></argument>,
										 <argument><expr><name>maxoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name>tupoffset</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>hscan</name><operator>-&gt;</operator><name>rs_ctup</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Skip invalid tuple pointers. */</comment>
			<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>tupoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><name>blockno</name></expr></argument>, <argument><expr><name>tupoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


			<if_stmt><if>if <condition>(<expr><name>all_visible</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>visible</name> <operator>=</operator> <call><name>SampleHeapTupleVisible</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>,
												 <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* in pagemode, heapgetpage did this for us */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pagemode</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CheckForSerializableConflictOut</name><argument_list>(<argument><expr><name>visible</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
												<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Try next tuple from same page. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>visible</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Found visible tuple, return it. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pagemode</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ExecStoreBufferHeapTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Count successfully-fetched tuples as heap fetches */</comment>
			<expr_stmt><expr><call><name>pgstat_count_heap_getnext</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If we get here, it means we've exhausted the items on this page
			 * and it's time to move to the next.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pagemode</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------------------
 *  Helper functions for the above.
 * ----------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Reconstruct and rewrite the given tuple
 *
 * We cannot simply copy the tuple as-is, for several reasons:
 *
 * 1. We'd like to squeeze out the values of any dropped columns, both
 * to save space and to ensure we have no corner-case failures. (It's
 * possible for example that the new table hasn't got a TOAST table
 * and so is unable to store any large values of dropped cols.)
 *
 * 2. The tuple might not even be legal for the new table; this is
 * currently only known to happen as an after-effect of ALTER TABLE
 * SET WITHOUT OIDS.
 *
 * So, we must reconstruct the tuple from component Datums.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reform_and_rewrite_tuple</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
						 <parameter><decl><type><name>Relation</name></type> <name>OldHeap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>NewHeap</name></decl></parameter>,
						 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>RewriteState</name></type> <name>rwstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>oldTupDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>newTupDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copiedTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>oldTupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Be sure to null out any dropped columns */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>copiedTuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The heap rewrite module does the rest */</comment>
	<expr_stmt><expr><call><name>rewrite_heap_tuple</name><argument_list>(<argument><expr><name>rwstate</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>copiedTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copiedTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check visibility of the tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SampleHeapTupleVisible</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
					   <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
					   <parameter><decl><type><name>OffsetNumber</name></type> <name>tupoffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>hscan</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <name>scan</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_ALLOW_PAGEMODE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In pageatatime mode, heapgetpage() already did visibility checks,
		 * so just look at the info it left in rs_vistuples[].
		 *
		 * We use a binary search over the known-sorted array.  Note: we could
		 * save some effort if we insisted that NextSampleTuple select tuples
		 * in increasing order, but it's not clear that there would be enough
		 * gain to justify the restriction.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
					<decl><type ref="prev"/><name>end</name> <init>= <expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_ntuples</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>start</name> <operator>&lt;=</operator> <name>end</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>mid</name> <init>= <expr><operator>(</operator><name>start</name> <operator>+</operator> <name>end</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>curoffset</name> <init>= <expr><name><name>hscan</name><operator>-&gt;</operator><name>rs_vistuples</name><index>[<expr><name>mid</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>tupoffset</name> <operator>==</operator> <name>curoffset</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>tupoffset</name> <operator>&lt;</operator> <name>curoffset</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>end</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>start</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Otherwise, we have to check the tuple individually. */</comment>
		<return>return <expr><call><name>HeapTupleSatisfiesVisibility</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></argument>,
											<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_snapshot</name></name></expr></argument>,
											<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------------------
 * Definition of the heap table access method.
 * ------------------------------------------------------------------------
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TableAmRoutine</name></type> <name>heapam_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_TableAmRoutine</name></expr>,

	<expr><operator>.</operator><name>slot_callbacks</name> <operator>=</operator> <name>heapam_slot_callbacks</name></expr>,

	<expr><operator>.</operator><name>scan_begin</name> <operator>=</operator> <name>heap_beginscan</name></expr>,
	<expr><operator>.</operator><name>scan_end</name> <operator>=</operator> <name>heap_endscan</name></expr>,
	<expr><operator>.</operator><name>scan_rescan</name> <operator>=</operator> <name>heap_rescan</name></expr>,
	<expr><operator>.</operator><name>scan_getnextslot</name> <operator>=</operator> <name>heap_getnextslot</name></expr>,

	<expr><operator>.</operator><name>parallelscan_estimate</name> <operator>=</operator> <name>table_block_parallelscan_estimate</name></expr>,
	<expr><operator>.</operator><name>parallelscan_initialize</name> <operator>=</operator> <name>table_block_parallelscan_initialize</name></expr>,
	<expr><operator>.</operator><name>parallelscan_reinitialize</name> <operator>=</operator> <name>table_block_parallelscan_reinitialize</name></expr>,

	<expr><operator>.</operator><name>dml_init</name> <operator>=</operator> <name>heap_dml_init</name></expr>,
	<expr><operator>.</operator><name>dml_finish</name> <operator>=</operator> <name>heap_dml_finish</name></expr>,

	<expr><operator>.</operator><name>index_fetch_begin</name> <operator>=</operator> <name>heapam_index_fetch_begin</name></expr>,
	<expr><operator>.</operator><name>index_fetch_reset</name> <operator>=</operator> <name>heapam_index_fetch_reset</name></expr>,
	<expr><operator>.</operator><name>index_fetch_end</name> <operator>=</operator> <name>heapam_index_fetch_end</name></expr>,
	<expr><operator>.</operator><name>index_fetch_tuple</name> <operator>=</operator> <name>heapam_index_fetch_tuple</name></expr>,

	<expr><operator>.</operator><name>tuple_insert</name> <operator>=</operator> <name>heapam_tuple_insert</name></expr>,
	<expr><operator>.</operator><name>tuple_insert_speculative</name> <operator>=</operator> <name>heapam_tuple_insert_speculative</name></expr>,
	<expr><operator>.</operator><name>tuple_complete_speculative</name> <operator>=</operator> <name>heapam_tuple_complete_speculative</name></expr>,
	<expr><operator>.</operator><name>multi_insert</name> <operator>=</operator> <name>heap_multi_insert</name></expr>,
	<expr><operator>.</operator><name>tuple_delete</name> <operator>=</operator> <name>heapam_tuple_delete</name></expr>,
	<expr><operator>.</operator><name>tuple_update</name> <operator>=</operator> <name>heapam_tuple_update</name></expr>,
	<expr><operator>.</operator><name>tuple_lock</name> <operator>=</operator> <name>heapam_tuple_lock</name></expr>,
	<expr><operator>.</operator><name>finish_bulk_insert</name> <operator>=</operator> <name>heapam_finish_bulk_insert</name></expr>,

	<expr><operator>.</operator><name>tuple_fetch_row_version</name> <operator>=</operator> <name>heapam_fetch_row_version</name></expr>,
	<expr><operator>.</operator><name>tuple_get_latest_tid</name> <operator>=</operator> <name>heap_get_latest_tid</name></expr>,
	<expr><operator>.</operator><name>tuple_tid_valid</name> <operator>=</operator> <name>heapam_tuple_tid_valid</name></expr>,
	<expr><operator>.</operator><name>tuple_satisfies_snapshot</name> <operator>=</operator> <name>heapam_tuple_satisfies_snapshot</name></expr>,
	<expr><operator>.</operator><name>compute_xid_horizon_for_tuples</name> <operator>=</operator> <name>heap_compute_xid_horizon_for_tuples</name></expr>,

	<expr><operator>.</operator><name>relation_set_new_filenode</name> <operator>=</operator> <name>heapam_relation_set_new_filenode</name></expr>,
	<expr><operator>.</operator><name>relation_nontransactional_truncate</name> <operator>=</operator> <name>heapam_relation_nontransactional_truncate</name></expr>,
	<expr><operator>.</operator><name>relation_copy_data</name> <operator>=</operator> <name>heapam_relation_copy_data</name></expr>,
	<expr><operator>.</operator><name>relation_copy_for_cluster</name> <operator>=</operator> <name>heapam_relation_copy_for_cluster</name></expr>,
	<expr><operator>.</operator><name>relation_vacuum</name> <operator>=</operator> <name>lazy_vacuum_rel_heap</name></expr>,
	<expr><operator>.</operator><name>scan_analyze_next_block</name> <operator>=</operator> <name>heapam_scan_analyze_next_block</name></expr>,
	<expr><operator>.</operator><name>scan_analyze_next_tuple</name> <operator>=</operator> <name>heapam_scan_analyze_next_tuple</name></expr>,
	<expr><operator>.</operator><name>index_build_range_scan</name> <operator>=</operator> <name>heapam_index_build_range_scan</name></expr>,
	<expr><operator>.</operator><name>index_validate_scan</name> <operator>=</operator> <name>heapam_index_validate_scan</name></expr>,

	<expr><operator>.</operator><name>relation_size</name> <operator>=</operator> <name>heapam_relation_size</name></expr>,
	<expr><operator>.</operator><name>relation_needs_toast_table</name> <operator>=</operator> <name>heapam_relation_needs_toast_table</name></expr>,

	<expr><operator>.</operator><name>relation_estimate_size</name> <operator>=</operator> <name>heapam_estimate_rel_size</name></expr>,

	<expr><operator>.</operator><name>scan_bitmap_next_block</name> <operator>=</operator> <name>heapam_scan_bitmap_next_block</name></expr>,
	<expr><operator>.</operator><name>scan_bitmap_next_tuple</name> <operator>=</operator> <name>heapam_scan_bitmap_next_tuple</name></expr>,
	<expr><operator>.</operator><name>scan_sample_next_block</name> <operator>=</operator> <name>heapam_scan_sample_next_block</name></expr>,
	<expr><operator>.</operator><name>scan_sample_next_tuple</name> <operator>=</operator> <name>heapam_scan_sample_next_tuple</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>const</specifier> <name>TableAmRoutine</name> <modifier>*</modifier></type>
<name>GetHeapamTableAmRoutine</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>heapam_methods</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>heap_tableam_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><operator>&amp;</operator><name>heapam_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
