<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/jit/llvm/llvmjit.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * llvmjit.c
 *	  Core part of the LLVM JIT provider.
 *
 * Copyright (c) 2016-2019, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/jit/llvm/llvmjit.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/llvmjit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/llvmjit_emit.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/instr_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/Analysis.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/BitReader.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/BitWriter.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/Core.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/ExecutionEngine.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">11</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/Orc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/OrcEE.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/LLJIT.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/OrcBindings.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/Support.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/Target.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/Transforms/IPO.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/Transforms/PassManagerBuilder.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/Transforms/Scalar.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">6</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;llvm-c/Transforms/Utils.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Handle of a module emitted via ORC JIT */</comment>
<typedef>typedef <type><struct>struct <name>LLVMJitHandle</name>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">11</literal></expr></cpp:if>
	<decl_stmt><decl><type><name>LLVMOrcLLJITRef</name></type> <name>lljit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMOrcResourceTrackerRef</name></type> <name>resource_tracker</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>LLVMOrcJITStackRef</name></type> <name>stack</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMOrcModuleHandle</name></type> <name>orc_handle</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>LLVMJitHandle</name>;</typedef>


<comment type="block">/* types &amp; functions commonly needed for JITing */</comment>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>TypeSizeT</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>TypeParamBool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>TypeStorageBool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>TypePGFunction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructNullableDatum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructHeapTupleFieldsField3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructHeapTupleFields</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructHeapTupleHeaderData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructHeapTupleDataChoice</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructHeapTupleData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructMinimalTupleData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructItemPointerData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructBlockId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructFormPgAttribute</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructTupleConstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructTupleDescData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructTupleTableSlot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructHeapTupleTableSlot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructMinimalTupleTableSlot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructMemoryContextData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructPGFinfoRecord</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructFmgrInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructFunctionCallInfoData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructExprContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructExprEvalStep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructExprState</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructAggState</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructAggStatePerGroupData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>StructAggStatePerTransData</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>AttributeTemplate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>FuncStrlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>FuncVarsizeAny</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>FuncSlotGetsomeattrsInt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>FuncSlotGetmissingattrs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>FuncMakeExpandedObjectReadOnlyInternal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>FuncExecEvalSubscriptingRef</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>FuncExecEvalSysVar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>FuncExecAggTransReparent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>FuncExecAggInitGroup</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>llvm_session_initialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>llvm_generation</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>llvm_triple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>llvm_layout</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>LLVMTargetRef</name></type> <name>llvm_targetref</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">11</literal></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>LLVMOrcThreadSafeContextRef</name></type> <name>llvm_ts_context</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>LLVMOrcLLJITRef</name></type> <name>llvm_opt0_orc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>LLVMOrcLLJITRef</name></type> <name>llvm_opt3_orc</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* LLVM_VERSION_MAJOR &gt; 11 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>LLVMOrcJITStackRef</name></type> <name>llvm_opt0_orc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>LLVMOrcJITStackRef</name></type> <name>llvm_opt3_orc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* LLVM_VERSION_MAJOR &gt; 11 */</comment>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>llvm_release_context</name><parameter_list>(<parameter><decl><type><name>JitContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>llvm_session_initialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>llvm_shutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>llvm_compile_module</name><parameter_list>(<parameter><decl><type><name>LLVMJitContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>llvm_optimize_module</name><parameter_list>(<parameter><decl><type><name>LLVMJitContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>LLVMModuleRef</name></type> <name>module</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>llvm_create_types</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>llvm_resolve_symbol</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">11</literal></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>LLVMOrcLLJITRef</name></type> <name>llvm_create_jit_instance</name><parameter_list>(<parameter><decl><type><name>LLVMTargetMachineRef</name></type> <name>tm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>llvm_error_message</name><parameter_list>(<parameter><decl><type><name>LLVMErrorRef</name></type> <name>error</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* LLVM_VERSION_MAJOR &gt; 11 */</comment>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>


<comment type="block">/*
 * Initialize LLVM JIT provider.
 */</comment>
<function><type><name>void</name></type>
<name>_PG_jit_provider_init</name><parameter_list>(<parameter><decl><type><name>JitProviderCallbacks</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>reset_after_error</name></name> <operator>=</operator> <name>llvm_reset_after_error</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>release_context</name></name> <operator>=</operator> <name>llvm_release_context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>compile_expr</name></name> <operator>=</operator> <name>llvm_compile_expr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a context for JITing work.
 *
 * The context, including subsidiary resources, will be cleaned up either when
 * the context is explicitly released, or when the lifetime of
 * CurrentResourceOwner ends (usually the end of the current [sub]xact).
 */</comment>
<function><type><name>LLVMJitContext</name> <modifier>*</modifier></type>
<name>llvm_create_context</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>jitFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LLVMJitContext</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>llvm_assert_in_fatal_section</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>llvm_session_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResourceOwnerEnlargeJIT</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
									 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LLVMJitContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>jitFlags</name></expr>;</expr_stmt>

	<comment type="block">/* ensure cleanup */</comment>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>resowner</name></name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerRememberJIT</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>context</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Release resources required by one llvm context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>llvm_release_context</name><parameter_list>(<parameter><decl><type><name>JitContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LLVMJitContext</name> <modifier>*</modifier></type><name>llvm_context</name> <init>= <expr><operator>(</operator><name>LLVMJitContext</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * When this backend is exiting, don't clean up LLVM. As an error might
	 * have occurred from within LLVM, we do not want to risk reentering. All
	 * resource cleanup is going to happen through process exit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>llvm_enter_fatal_on_oom</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>llvm_context</name><operator>-&gt;</operator><name>module</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LLVMDisposeModule</name><argument_list>(<argument><expr><name><name>llvm_context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>llvm_context</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name><name>llvm_context</name><operator>-&gt;</operator><name>handles</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMJitHandle</name> <modifier>*</modifier></type><name>jit_handle</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>jit_handle</name> <operator>=</operator> <operator>(</operator><name>LLVMJitHandle</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>llvm_context</name><operator>-&gt;</operator><name>handles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>llvm_context</name><operator>-&gt;</operator><name>handles</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>llvm_context</name><operator>-&gt;</operator><name>handles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">11</literal></expr></cpp:if>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LLVMOrcExecutionSessionRef</name></type> <name>ee</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>LLVMOrcSymbolStringPoolRef</name></type> <name>sp</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>LLVMOrcResourceTrackerRemove</name><argument_list>(<argument><expr><name><name>jit_handle</name><operator>-&gt;</operator><name>resource_tracker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMOrcReleaseResourceTracker</name><argument_list>(<argument><expr><name><name>jit_handle</name><operator>-&gt;</operator><name>resource_tracker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Without triggering cleanup of the string pool, we'd leak
			 * memory. It'd be sufficient to do this far less often, but in
			 * experiments the required time was small enough to just always
			 * do it.
			 */</comment>
			<expr_stmt><expr><name>ee</name> <operator>=</operator> <call><name>LLVMOrcLLJITGetExecutionSession</name><argument_list>(<argument><expr><name><name>jit_handle</name><operator>-&gt;</operator><name>lljit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>LLVMOrcExecutionSessionGetSymbolStringPool</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMOrcSymbolStringPoolClearDeadEntries</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* LLVM_VERSION_MAJOR &gt; 11 */</comment>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LLVMOrcRemoveModule</name><argument_list>(<argument><expr><name><name>jit_handle</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><name><name>jit_handle</name><operator>-&gt;</operator><name>orc_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* LLVM_VERSION_MAJOR &gt; 11 */</comment>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>jit_handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Return module which may be modified, e.g. by creating new functions.
 */</comment>
<function><type><name>LLVMModuleRef</name></type>
<name>llvm_mutable_module</name><parameter_list>(<parameter><decl><type><name>LLVMJitContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>llvm_assert_in_fatal_section</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there's no in-progress module, create a new one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>compiled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>module_generation</name></name> <operator>=</operator> <name>llvm_generation</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <call><name>LLVMModuleCreateWithName</name><argument_list>(<argument><expr><literal type="string">"pg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMSetTarget</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>, <argument><expr><name>llvm_triple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMSetDataLayout</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>, <argument><expr><name>llvm_layout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Expand function name to be non-conflicting. This should be used by code
 * generating code, when adding new externally visible function definitions to
 * a Module.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>llvm_expand_funcname</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>LLVMJitContext</name></name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>basename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>instr</name><operator>.</operator><name>created_functions</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Previously we used dots to separate, but turns out some tools, e.g.
	 * GDB, don't like that and truncate name.
	 */</comment>
	<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s_%zu_%d"</literal></expr></argument>,
					<argument><expr><name>basename</name></expr></argument>,
					<argument><expr><name><name>context</name><operator>-&gt;</operator><name>module_generation</name></name></expr></argument>,
					<argument><expr><name><name>context</name><operator>-&gt;</operator><name>counter</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return pointer to function funcname, which has to exist. If there's pending
 * code to be optimized and emitted, do so first.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>llvm_get_function</name><parameter_list>(<parameter><decl><type><name>LLVMJitContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">11</literal> <operator>||</operator> \
	<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DECL_LLVMORCGETSYMBOLADDRESSIN</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_DECL_LLVMORCGETSYMBOLADDRESSIN</name></expr></cpp:if>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>llvm_assert_in_fatal_section</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is a pending / not emitted module, compile and emit now.
	 * Otherwise we might not find the [correct] function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>compiled</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>llvm_compile_module</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * ORC's symbol table is of *unmangled* symbols. Therefore we don't need
	 * to mangle here.
	 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">11</literal></expr></cpp:if>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>context-&gt;handles</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMJitHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>(</operator><name>LLVMJitHandle</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>instr_time</name></type>	<name>starttime</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>instr_time</name></type>	<name>endtime</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LLVMErrorRef</name></type> <name>error</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LLVMOrcJITTargetAddress</name></type> <name>addr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>addr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>LLVMOrcLLJITLookup</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>lljit</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to look up symbol \"%s\": %s"</literal></expr></argument>,
				 <argument><expr><name>funcname</name></expr></argument>, <argument><expr><call><name>llvm_error_message</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * LLJIT only actually emits code the first time a symbol is
		 * referenced. Thus add lookup time to emission time. That's counting
		 * a bit more than with older LLVM versions, but unlikely to ever
		 * matter.
		 */</comment>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>endtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_ACCUM_DIFF</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>instr</name><operator>.</operator><name>emission_counter</name></name></expr></argument>,
							  <argument><expr><name>endtime</name></expr></argument>, <argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>addr</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>addr</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DECL_LLVMORCGETSYMBOLADDRESSIN</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_DECL_LLVMORCGETSYMBOLADDRESSIN</name></expr></cpp:elif>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>context-&gt;handles</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMOrcTargetAddress</name></type> <name>addr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LLVMJitHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>(</operator><name>LLVMJitHandle</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>addr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>LLVMOrcGetSymbolAddressIn</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>orc_handle</name></name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to look up symbol \"%s\""</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>addr</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>addr</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">5</literal></expr></cpp:elif>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMOrcTargetAddress</name></type> <name>addr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>addr</name> <operator>=</operator> <call><name>LLVMOrcGetSymbolAddress</name><argument_list>(<argument><expr><name>llvm_opt0_orc</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>addr</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>addr</name> <operator>=</operator> <call><name>LLVMOrcGetSymbolAddress</name><argument_list>(<argument><expr><name>llvm_opt3_orc</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>addr</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMOrcTargetAddress</name></type> <name>addr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>LLVMOrcGetSymbolAddress</name><argument_list>(<argument><expr><name>llvm_opt0_orc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to look up symbol \"%s\""</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>addr</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>addr</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>LLVMOrcGetSymbolAddress</name><argument_list>(<argument><expr><name>llvm_opt3_orc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to look up symbol \"%s\""</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>addr</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>addr</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to JIT: %s"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return declaration for passed function, adding it to the module if
 * necessary.
 *
 * This is used to make functions imported by llvm_create_types() known to the
 * module that's currently being worked on.
 */</comment>
<function><type><name>LLVMValueRef</name></type>
<name>llvm_get_decl</name><parameter_list>(<parameter><decl><type><name>LLVMModuleRef</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>LLVMValueRef</name></type> <name>v_src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_fn</name></decl>;</decl_stmt>

	<comment type="block">/* don't repeatedly add function */</comment>
	<expr_stmt><expr><name>v_fn</name> <operator>=</operator> <call><name>LLVMGetNamedFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><call><name>LLVMGetValueName</name><argument_list>(<argument><expr><name>v_src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>v_fn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>v_fn</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>v_fn</name> <operator>=</operator> <call><name>LLVMAddFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>,
						   <argument><expr><call><name>LLVMGetValueName</name><argument_list>(<argument><expr><name>v_src</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>LLVMGetElementType</name><argument_list>(<argument><expr><call><name>LLVMTypeOf</name><argument_list>(<argument><expr><name>v_src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>llvm_copy_attributes</name><argument_list>(<argument><expr><name>v_src</name></expr></argument>, <argument><expr><name>v_fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>v_fn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy attributes from one function to another, for a specific index (an
 * index can reference return value, function and parameter attributes).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>llvm_copy_attributes_at_index</name><parameter_list>(<parameter><decl><type><name>LLVMValueRef</name></type> <name>v_from</name></decl></parameter>, <parameter><decl><type><name>LLVMValueRef</name></type> <name>v_to</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_attributes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMAttributeRef</name> <modifier>*</modifier></type><name>attrs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>num_attributes</name> <operator>=</operator> <call><name>LLVMGetAttributeCountAtIndexPG</name><argument_list>(<argument><expr><name>v_from</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Not just for efficiency: LLVM &lt;= 3.9 crashes when
	 * LLVMGetAttributesAtIndex() is called for an index with 0 attributes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_attributes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attrs</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LLVMAttributeRef</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LLVMGetAttributesAtIndex</name><argument_list>(<argument><expr><name>v_from</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name>num_attributes</name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LLVMAddAttributeAtIndex</name><argument_list>(<argument><expr><name>v_to</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>attrs</name><index>[<expr><name>attno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy all attributes from one function to another. I.e. function, return and
 * parameters will be copied.
 */</comment>
<function><type><name>void</name></type>
<name>llvm_copy_attributes</name><parameter_list>(<parameter><decl><type><name>LLVMValueRef</name></type> <name>v_from</name></decl></parameter>, <parameter><decl><type><name>LLVMValueRef</name></type> <name>v_to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>param_count</name></decl>;</decl_stmt>

	<comment type="block">/* copy function attributes */</comment>
	<expr_stmt><expr><call><name>llvm_copy_attributes_at_index</name><argument_list>(<argument><expr><name>v_from</name></expr></argument>, <argument><expr><name>v_to</name></expr></argument>, <argument><expr><name>LLVMAttributeFunctionIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* and the return value attributes */</comment>
	<expr_stmt><expr><call><name>llvm_copy_attributes_at_index</name><argument_list>(<argument><expr><name>v_from</name></expr></argument>, <argument><expr><name>v_to</name></expr></argument>, <argument><expr><name>LLVMAttributeReturnIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* and each function parameter's attribute */</comment>
	<expr_stmt><expr><name>param_count</name> <operator>=</operator> <call><name>LLVMCountParams</name><argument_list>(<argument><expr><name>v_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>paramidx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>paramidx</name> <operator>&lt;=</operator> <name>param_count</name></expr>;</condition> <incr><expr><name>paramidx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>llvm_copy_attributes_at_index</name><argument_list>(<argument><expr><name>v_from</name></expr></argument>, <argument><expr><name>v_to</name></expr></argument>, <argument><expr><name>paramidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Return a callable LLVMValueRef for fcinfo.
 */</comment>
<function><type><name>LLVMValueRef</name></type>
<name>llvm_function_reference</name><parameter_list>(<parameter><decl><type><name>LLVMJitContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						<parameter><decl><type><name>LLVMBuilderRef</name></type> <name>builder</name></decl></parameter>,
						<parameter><decl><type><name>LLVMModuleRef</name></type> <name>mod</name></decl></parameter>,
						<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>modname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>basename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcname</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_fn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_symbol</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>modname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>basename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>modname</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>basename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* external function in loadable library */</comment>
		<expr_stmt><expr><name>funcname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"pgextern.%s.%s"</literal></expr></argument>, <argument><expr><name>modname</name></expr></argument>, <argument><expr><name>basename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>basename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* internal function */</comment>
		<expr_stmt><expr><name>funcname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>basename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Function we don't know to handle, return pointer. We do so by
		 * creating a global constant containing a pointer to the function.
		 * Makes IR more readable.
		 */</comment>
		<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>v_fn_addr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>funcname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"pgoidextern.%u"</literal></expr></argument>,
							<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>v_fn</name> <operator>=</operator> <call><name>LLVMGetNamedGlobal</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>v_fn</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>LLVMBuildLoad</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>v_fn</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>v_fn_addr</name> <operator>=</operator> <call><name>l_ptr_const</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_addr</name></name></expr></argument>, <argument><expr><name>TypePGFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>v_fn</name> <operator>=</operator> <call><name>LLVMAddGlobal</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>TypePGFunction</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMSetInitializer</name><argument_list>(<argument><expr><name>v_fn</name></expr></argument>, <argument><expr><name>v_fn_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMSetGlobalConstant</name><argument_list>(<argument><expr><name>v_fn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMSetLinkage</name><argument_list>(<argument><expr><name>v_fn</name></expr></argument>, <argument><expr><name>LLVMPrivateLinkage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMSetUnnamedAddr</name><argument_list>(<argument><expr><name>v_fn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>LLVMBuildLoad</name><argument_list>(<argument><expr><name>builder</name></expr></argument>, <argument><expr><name>v_fn</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* check if function already has been added */</comment>
	<expr_stmt><expr><name>v_fn</name> <operator>=</operator> <call><name>LLVMGetNamedFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>v_fn</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>v_fn</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>v_fn</name> <operator>=</operator> <call><name>LLVMAddFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><call><name>LLVMGetElementType</name><argument_list>(<argument><expr><name>TypePGFunction</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>v_fn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Optimize code in module using the flags set in context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>llvm_optimize_module</name><parameter_list>(<parameter><decl><type><name>LLVMJitContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>LLVMModuleRef</name></type> <name>module</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LLVMPassManagerBuilderRef</name></type> <name>llvm_pmb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMPassManagerRef</name></type> <name>llvm_mpm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMPassManagerRef</name></type> <name>llvm_fpm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>compile_optlevel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGJIT_OPT3</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>compile_optlevel</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>compile_optlevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Have to create a new pass manager builder every pass through, as the
	 * inliner has some per-builder state. Otherwise one ends up only inlining
	 * a function the first time though.
	 */</comment>
	<expr_stmt><expr><name>llvm_pmb</name> <operator>=</operator> <call><name>LLVMPassManagerBuilderCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LLVMPassManagerBuilderSetOptLevel</name><argument_list>(<argument><expr><name>llvm_pmb</name></expr></argument>, <argument><expr><name>compile_optlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>llvm_fpm</name> <operator>=</operator> <call><name>LLVMCreateFunctionPassManagerForModule</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGJIT_OPT3</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* TODO: Unscientifically determined threshold */</comment>
		<expr_stmt><expr><call><name>LLVMPassManagerBuilderUseInlinerWithThreshold</name><argument_list>(<argument><expr><name>llvm_pmb</name></expr></argument>, <argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* we rely on mem2reg heavily, so emit even in the O0 case */</comment>
		<expr_stmt><expr><call><name>LLVMAddPromoteMemoryToRegisterPass</name><argument_list>(<argument><expr><name>llvm_fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LLVMPassManagerBuilderPopulateFunctionPassManager</name><argument_list>(<argument><expr><name>llvm_pmb</name></expr></argument>, <argument><expr><name>llvm_fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do function level optimization. This could be moved to the point where
	 * functions are emitted, to reduce memory usage a bit.
	 */</comment>
	<expr_stmt><expr><call><name>LLVMInitializeFunctionPassManager</name><argument_list>(<argument><expr><name>llvm_fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>func</name> <operator>=</operator> <call><name>LLVMGetFirstFunction</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>func</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>func</name> <operator>=</operator> <call><name>LLVMGetNextFunction</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LLVMRunFunctionPassManager</name><argument_list>(<argument><expr><name>llvm_fpm</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>LLVMFinalizeFunctionPassManager</name><argument_list>(<argument><expr><name>llvm_fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LLVMDisposePassManager</name><argument_list>(<argument><expr><name>llvm_fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Perform module level optimization. We do so even in the non-optimized
	 * case, so always-inline functions etc get inlined. It's cheap enough.
	 */</comment>
	<expr_stmt><expr><name>llvm_mpm</name> <operator>=</operator> <call><name>LLVMCreatePassManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LLVMPassManagerBuilderPopulateModulePassManager</name><argument_list>(<argument><expr><name>llvm_pmb</name></expr></argument>,
													<argument><expr><name>llvm_mpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* always use always-inliner pass */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGJIT_OPT3</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LLVMAddAlwaysInlinerPass</name><argument_list>(<argument><expr><name>llvm_mpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* if doing inlining, but no expensive optimization, add inlining pass */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGJIT_INLINE</name>
		<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGJIT_OPT3</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LLVMAddFunctionInliningPass</name><argument_list>(<argument><expr><name>llvm_mpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>LLVMRunPassManager</name><argument_list>(<argument><expr><name>llvm_mpm</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LLVMDisposePassManager</name><argument_list>(<argument><expr><name>llvm_mpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LLVMPassManagerBuilderDispose</name><argument_list>(<argument><expr><name>llvm_pmb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Emit code for the currently pending module.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>llvm_compile_module</name><parameter_list>(<parameter><decl><type><name>LLVMJitContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LLVMJitHandle</name> <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>starttime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>endtime</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">11</literal></expr></cpp:if>
	<decl_stmt><decl><type><name>LLVMOrcLLJITRef</name></type> <name>compile_orc</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>LLVMOrcJITStackRef</name></type> <name>compile_orc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGJIT_OPT3</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>compile_orc</name> <operator>=</operator> <name>llvm_opt3_orc</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>compile_orc</name> <operator>=</operator> <name>llvm_opt0_orc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* perform inlining */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGJIT_INLINE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>llvm_inline</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>endtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_ACCUM_DIFF</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>instr</name><operator>.</operator><name>inlining_counter</name></name></expr></argument>,
							  <argument><expr><name>endtime</name></expr></argument>, <argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>jit_dump_bitcode</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%u.%zu.bc"</literal></expr></argument>,
							<argument><expr><name>MyProcPid</name></expr></argument>,
							<argument><expr><name><name>context</name><operator>-&gt;</operator><name>module_generation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMWriteBitcodeToFile</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/* optimize according to the chosen optimization settings */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>llvm_optimize_module</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>endtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_ACCUM_DIFF</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>instr</name><operator>.</operator><name>optimization_counter</name></name></expr></argument>,
						  <argument><expr><name>endtime</name></expr></argument>, <argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>jit_dump_bitcode</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%u.%zu.optimized.bc"</literal></expr></argument>,
							<argument><expr><name>MyProcPid</name></expr></argument>,
							<argument><expr><name><name>context</name><operator>-&gt;</operator><name>module_generation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LLVMWriteBitcodeToFile</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>(</operator><name>LLVMJitHandle</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LLVMJitHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Emit the code. Note that this can, depending on the optimization
	 * settings, take noticeable resources as code emission executes low-level
	 * instruction combining/selection passes etc. Without optimization a
	 * faster instruction selection mechanism is used.
	 */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">11</literal></expr></cpp:if>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMOrcThreadSafeModuleRef</name></type> <name>ts_module</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LLVMErrorRef</name></type> <name>error</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LLVMOrcJITDylibRef</name></type> <name>jd</name> <init>= <expr><call><name>LLVMOrcLLJITGetMainJITDylib</name><argument_list>(<argument><expr><name>compile_orc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>ts_module</name> <operator>=</operator> <call><name>LLVMOrcCreateNewThreadSafeModule</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>, <argument><expr><name>llvm_ts_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>lljit</name></name> <operator>=</operator> <name>compile_orc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>resource_tracker</name></name> <operator>=</operator> <call><name>LLVMOrcJITDylibCreateResourceTracker</name><argument_list>(<argument><expr><name>jd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * NB: This doesn't actually emit code. That happens lazily the first
		 * time a symbol defined in the module is requested. Due to that
		 * llvm_get_function() also accounts for emission time.
		 */</comment>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* will be owned by LLJIT */</comment>
		<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>LLVMOrcLLJITAddLLVMIRModuleWithRT</name><argument_list>(<argument><expr><name>compile_orc</name></expr></argument>,
												  <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>resource_tracker</name></name></expr></argument>,
												  <argument><expr><name>ts_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to JIT module: %s"</literal></expr></argument>,
				 <argument><expr><call><name>llvm_error_message</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>lljit</name></name> <operator>=</operator> <name>compile_orc</name></expr>;</expr_stmt>

		<comment type="block">/* LLVMOrcLLJITAddLLVMIRModuleWithRT takes ownership of the module */</comment>
	</block_content>}</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">6</literal></expr></cpp:elif>
	<block>{<block_content>
		<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>compile_orc</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>LLVMOrcAddEagerlyCompiledIR</name><argument_list>(<argument><expr><name>compile_orc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>handle</name><operator>-&gt;</operator><name>orc_handle</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>,
										<argument><expr><name>llvm_resolve_symbol</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to JIT module"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* LLVMOrcAddEagerlyCompiledIR takes ownership of the module */</comment>
	</block_content>}</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">4</literal></expr></cpp:elif>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMSharedModuleRef</name></type> <name>smod</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>smod</name> <operator>=</operator> <call><name>LLVMOrcMakeSharedModule</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>compile_orc</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>LLVMOrcAddEagerlyCompiledIR</name><argument_list>(<argument><expr><name>compile_orc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>handle</name><operator>-&gt;</operator><name>orc_handle</name></name></expr></argument>, <argument><expr><name>smod</name></expr></argument>,
										<argument><expr><name>llvm_resolve_symbol</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to JIT module"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>LLVMOrcDisposeSharedModuleRef</name><argument_list>(<argument><expr><name>smod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* LLVM 4.0 and 3.9 */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>compile_orc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>orc_handle</name></name> <operator>=</operator> <call><name>LLVMOrcAddEagerlyCompiledIR</name><argument_list>(<argument><expr><name>compile_orc</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>,
														 <argument><expr><name>llvm_resolve_symbol</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LLVMDisposeModule</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>endtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_ACCUM_DIFF</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>instr</name><operator>.</operator><name>emission_counter</name></name></expr></argument>,
						  <argument><expr><name>endtime</name></expr></argument>, <argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>compiled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* remember emitted code for cleanup and lookups */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>handles</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>handles</name></name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time to inline: %.3fs, opt: %.3fs, emit: %.3fs"</literal></expr></argument>,
					<argument><expr><call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>instr</name><operator>.</operator><name>inlining_counter</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>instr</name><operator>.</operator><name>optimization_counter</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>instr</name><operator>.</operator><name>emission_counter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhidecontext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Per session initialization.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>llvm_session_initialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>error</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cpu</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>features</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMTargetMachineRef</name></type> <name>opt0_tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMTargetMachineRef</name></type> <name>opt3_tm</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>llvm_session_initialized</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LLVMInitializeNativeTarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LLVMInitializeNativeAsmPrinter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LLVMInitializeNativeAsmParser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Synchronize types early, as that also includes inferring the target
	 * triple.
	 */</comment>
	<expr_stmt><expr><call><name>llvm_create_types</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>LLVMGetTargetFromTriple</name><argument_list>(<argument><expr><name>llvm_triple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>llvm_targetref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to query triple %s\n"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We want the generated code to use all available features. Therefore
	 * grab the host CPU string and detect features of the current CPU. The
	 * latter is needed because some CPU architectures default to enabling
	 * features not all CPUs have (weird, huh).
	 */</comment>
	<expr_stmt><expr><name>cpu</name> <operator>=</operator> <call><name>LLVMGetHostCPUName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>features</name> <operator>=</operator> <call><name>LLVMGetHostCPUFeatures</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"LLVMJIT detected CPU \"%s\", with features \"%s\""</literal></expr></argument>,
		 <argument><expr><name>cpu</name></expr></argument>, <argument><expr><name>features</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>opt0_tm</name> <operator>=</operator>
		<call><name>LLVMCreateTargetMachine</name><argument_list>(<argument><expr><name>llvm_targetref</name></expr></argument>, <argument><expr><name>llvm_triple</name></expr></argument>, <argument><expr><name>cpu</name></expr></argument>, <argument><expr><name>features</name></expr></argument>,
								<argument><expr><name>LLVMCodeGenLevelNone</name></expr></argument>,
								<argument><expr><name>LLVMRelocDefault</name></expr></argument>,
								<argument><expr><name>LLVMCodeModelJITDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opt3_tm</name> <operator>=</operator>
		<call><name>LLVMCreateTargetMachine</name><argument_list>(<argument><expr><name>llvm_targetref</name></expr></argument>, <argument><expr><name>llvm_triple</name></expr></argument>, <argument><expr><name>cpu</name></expr></argument>, <argument><expr><name>features</name></expr></argument>,
								<argument><expr><name>LLVMCodeGenLevelAggressive</name></expr></argument>,
								<argument><expr><name>LLVMRelocDefault</name></expr></argument>,
								<argument><expr><name>LLVMCodeModelJITDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LLVMDisposeMessage</name><argument_list>(<argument><expr><name>cpu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpu</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LLVMDisposeMessage</name><argument_list>(<argument><expr><name>features</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>features</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* force symbols in main binary to be loaded */</comment>
	<expr_stmt><expr><call><name>LLVMLoadLibraryPermanently</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">11</literal></expr></cpp:if>
	<block>{<block_content>
		<expr_stmt><expr><name>llvm_ts_context</name> <operator>=</operator> <call><name>LLVMOrcCreateNewThreadSafeContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>llvm_opt0_orc</name> <operator>=</operator> <call><name>llvm_create_jit_instance</name><argument_list>(<argument><expr><name>opt0_tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opt0_tm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>llvm_opt3_orc</name> <operator>=</operator> <call><name>llvm_create_jit_instance</name><argument_list>(<argument><expr><name>opt3_tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opt3_tm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* LLVM_VERSION_MAJOR &gt; 11 */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>llvm_opt0_orc</name> <operator>=</operator> <call><name>LLVMOrcCreateInstance</name><argument_list>(<argument><expr><name>opt0_tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>llvm_opt3_orc</name> <operator>=</operator> <call><name>LLVMOrcCreateInstance</name><argument_list>(<argument><expr><name>opt3_tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DECL_LLVMCREATEGDBREGISTRATIONLISTENER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_DECL_LLVMCREATEGDBREGISTRATIONLISTENER</name></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><name>jit_debugging_support</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LLVMJITEventListenerRef</name></type> <name>l</name> <init>= <expr><call><name>LLVMCreateGDBRegistrationListener</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>LLVMOrcRegisterJITEventListener</name><argument_list>(<argument><expr><name>llvm_opt0_orc</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMOrcRegisterJITEventListener</name><argument_list>(<argument><expr><name>llvm_opt3_orc</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DECL_LLVMCREATEPERFJITEVENTLISTENER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_DECL_LLVMCREATEPERFJITEVENTLISTENER</name></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><name>jit_profiling_support</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>LLVMJITEventListenerRef</name></type> <name>l</name> <init>= <expr><call><name>LLVMCreatePerfJITEventListener</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>LLVMOrcRegisterJITEventListener</name><argument_list>(<argument><expr><name>llvm_opt0_orc</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LLVMOrcRegisterJITEventListener</name><argument_list>(<argument><expr><name>llvm_opt3_orc</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* LLVM_VERSION_MAJOR &gt; 11 */</comment>

	<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>llvm_shutdown</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>llvm_session_initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>llvm_shutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If llvm_shutdown() is reached while in a fatal-on-oom section an error
	 * has occurred in the middle of LLVM code. It is not safe to call back
	 * into LLVM (which is why a FATAL error was thrown).
	 *
	 * We do need to shutdown LLVM in other shutdown cases, otherwise
	 * e.g. profiling data won't be written out.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>llvm_in_fatal_on_oom</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>proc_exit_inprogress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">11</literal></expr></cpp:if>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>llvm_opt3_orc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LLVMOrcDisposeLLJIT</name><argument_list>(<argument><expr><name>llvm_opt3_orc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>llvm_opt3_orc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>llvm_opt0_orc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LLVMOrcDisposeLLJIT</name><argument_list>(<argument><expr><name>llvm_opt0_orc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>llvm_opt0_orc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>llvm_ts_context</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LLVMOrcDisposeThreadSafeContext</name><argument_list>(<argument><expr><name>llvm_ts_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>llvm_ts_context</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* LLVM_VERSION_MAJOR &gt; 11 */</comment>
	<block>{<block_content>
		<comment type="block">/* unregister profiling support, needs to be flushed to be useful */</comment>

		<if_stmt><if>if <condition>(<expr><name>llvm_opt3_orc</name></expr>)</condition>
		<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DECL_LLVMORCREGISTERPERF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_DECL_LLVMORCREGISTERPERF</name></expr></cpp:if>
			<if_stmt><if>if <condition>(<expr><name>jit_profiling_support</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LLVMOrcUnregisterPerf</name><argument_list>(<argument><expr><name>llvm_opt3_orc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>LLVMOrcDisposeInstance</name><argument_list>(<argument><expr><name>llvm_opt3_orc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>llvm_opt3_orc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>llvm_opt0_orc</name></expr>)</condition>
		<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DECL_LLVMORCREGISTERPERF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_DECL_LLVMORCREGISTERPERF</name></expr></cpp:if>
			<if_stmt><if>if <condition>(<expr><name>jit_profiling_support</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LLVMOrcUnregisterPerf</name><argument_list>(<argument><expr><name>llvm_opt0_orc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>LLVMOrcDisposeInstance</name><argument_list>(<argument><expr><name>llvm_opt0_orc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>llvm_opt0_orc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* LLVM_VERSION_MAJOR &gt; 11 */</comment>
</block_content>}</block></function>

<comment type="block">/* helper for llvm_create_types, returning a global var's type */</comment>
<function><type><specifier>static</specifier> <name>LLVMTypeRef</name></type>
<name>load_type</name><parameter_list>(<parameter><decl><type><name>LLVMModuleRef</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>typ</name></decl>;</decl_stmt>

	<comment type="block">/* this'll return a *pointer* to the global */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>LLVMGetNamedGlobal</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"type %s is unknown"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* therefore look at the contained type and return that */</comment>
	<expr_stmt><expr><name>typ</name> <operator>=</operator> <call><name>LLVMTypeOf</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typ</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typ</name> <operator>=</operator> <call><name>LLVMGetElementType</name><argument_list>(<argument><expr><name>typ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typ</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>typ</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper for llvm_create_types, returning a function's return type */</comment>
<function><type><specifier>static</specifier> <name>LLVMTypeRef</name></type>
<name>load_return_type</name><parameter_list>(<parameter><decl><type><name>LLVMModuleRef</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LLVMValueRef</name></type> <name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMTypeRef</name></type> <name>typ</name></decl>;</decl_stmt>

	<comment type="block">/* this'll return a *pointer* to the function */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>LLVMGetNamedFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function %s is unknown"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* get type of function pointer */</comment>
	<expr_stmt><expr><name>typ</name> <operator>=</operator> <call><name>LLVMTypeOf</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typ</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* dereference pointer */</comment>
	<expr_stmt><expr><name>typ</name> <operator>=</operator> <call><name>LLVMGetElementType</name><argument_list>(<argument><expr><name>typ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typ</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* and look at return type */</comment>
	<expr_stmt><expr><name>typ</name> <operator>=</operator> <call><name>LLVMGetReturnType</name><argument_list>(<argument><expr><name>typ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typ</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>typ</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Load required information, types, function signatures from llvmjit_types.c
 * and make them available in global variables.
 *
 * Those global variables are then used while emitting code.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>llvm_create_types</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMMemoryBufferRef</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMModuleRef</name></type> <name>mod</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>pkglib_path</name></expr></argument>, <argument><expr><literal type="string">"llvmjit_types.bc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* open file */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>LLVMCreateMemoryBufferWithContentsOfFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"LLVMCreateMemoryBufferWithContentsOfFile(%s) failed: %s"</literal></expr></argument>,
			 <argument><expr><name>path</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* eagerly load contents, going to need it all */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>LLVMParseBitcode2</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"LLVMParseBitcode2 of %s failed"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LLVMDisposeMemoryBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Load triple &amp; layout from clang emitted file so we're guaranteed to be
	 * compatible.
	 */</comment>
	<expr_stmt><expr><name>llvm_triple</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>LLVMGetTarget</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>llvm_layout</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>LLVMGetDataLayoutStr</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>TypeSizeT</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"TypeSizeT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>TypeParamBool</name> <operator>=</operator> <call><name>load_return_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"FunctionReturningBool"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>TypeStorageBool</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"TypeStorageBool"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>TypePGFunction</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"TypePGFunction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructNullableDatum</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructNullableDatum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructExprContext</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructExprContext"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructExprEvalStep</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructExprEvalStep"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructExprState</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructExprState"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructFunctionCallInfoData</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructFunctionCallInfoData"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructMemoryContextData</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructMemoryContextData"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructTupleTableSlot</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructTupleTableSlot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructHeapTupleTableSlot</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructHeapTupleTableSlot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructMinimalTupleTableSlot</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructMinimalTupleTableSlot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructHeapTupleData</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructHeapTupleData"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructTupleDescData</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructTupleDescData"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructAggState</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructAggState"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructAggStatePerGroupData</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructAggStatePerGroupData"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>StructAggStatePerTransData</name> <operator>=</operator> <call><name>load_type</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"StructAggStatePerTransData"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>AttributeTemplate</name> <operator>=</operator> <call><name>LLVMGetNamedFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"AttributeTemplate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>FuncStrlen</name> <operator>=</operator> <call><name>LLVMGetNamedFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"strlen"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>FuncVarsizeAny</name> <operator>=</operator> <call><name>LLVMGetNamedFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"varsize_any"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>FuncSlotGetsomeattrsInt</name> <operator>=</operator> <call><name>LLVMGetNamedFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"slot_getsomeattrs_int"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>FuncSlotGetmissingattrs</name> <operator>=</operator> <call><name>LLVMGetNamedFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"slot_getmissingattrs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>FuncMakeExpandedObjectReadOnlyInternal</name> <operator>=</operator> <call><name>LLVMGetNamedFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"MakeExpandedObjectReadOnlyInternal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>FuncExecEvalSubscriptingRef</name> <operator>=</operator> <call><name>LLVMGetNamedFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"ExecEvalSubscriptingRef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>FuncExecEvalSysVar</name> <operator>=</operator> <call><name>LLVMGetNamedFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"ExecEvalSysVar"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>FuncExecAggTransReparent</name> <operator>=</operator> <call><name>LLVMGetNamedFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"ExecAggTransReparent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>FuncExecAggInitGroup</name> <operator>=</operator> <call><name>LLVMGetNamedFunction</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"ExecAggInitGroup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Leave the module alive, otherwise references to function would be
	 * dangling.
	 */</comment>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Split a symbol into module / function parts.  If the function is in the
 * main binary (or an external library) *modname will be NULL.
 */</comment>
<function><type><name>void</name></type>
<name>llvm_split_symbol_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>modname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>modname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>funcname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Module function names are pgextern.$module.$funcname
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"pgextern."</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"pgextern."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Symbol names cannot contain a ., therefore we can split based on
		 * first and last occurrence of one.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>funcname</name> <operator>=</operator> <call><name>rindex</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>funcname</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>			<comment type="block">/* jump over . */</comment>

		<expr_stmt><expr><operator>*</operator><name>modname</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"pgextern."</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><operator>*</operator><name>funcname</name> <operator>-</operator> <name>name</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"pgextern."</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>funcname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><operator>*</operator><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>modname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>funcname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to resolve symbol, so LLVM can emit a reference to it.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>llvm_resolve_symbol</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>symname</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uintptr_t</name></type>	<name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>modname</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * macOS prefixes all object level symbols with an underscore. But neither
	 * dlsym() nor PG's inliner expect that. So undo.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>symname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected prefixed symbol name, but got \"%s\""</literal></expr></argument>, <argument><expr><name>symname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>symname</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>llvm_split_symbol_name</name><argument_list>(<argument><expr><name>symname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>modname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* functions that aren't resolved to names shouldn't ever get here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>modname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <call><name>load_external_function</name><argument_list>(<argument><expr><name>modname</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <call><name>LLVMSearchForAddressOfSymbol</name><argument_list>(<argument><expr><name>symname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>modname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* let LLVM will error out - should never happen */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"failed to resolve name %s"</literal></expr></argument>, <argument><expr><name>symname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>addr</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">11</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <name>LLVMErrorRef</name></type>
<name>llvm_resolve_symbols</name><parameter_list>(<parameter><decl><type><name>LLVMOrcDefinitionGeneratorRef</name></type> <name>GeneratorObj</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>Ctx</name></decl></parameter>,
					 <parameter><decl><type><name>LLVMOrcLookupStateRef</name> <modifier>*</modifier></type><name>LookupState</name></decl></parameter>, <parameter><decl><type><name>LLVMOrcLookupKind</name></type> <name>Kind</name></decl></parameter>,
					 <parameter><decl><type><name>LLVMOrcJITDylibRef</name></type> <name>JD</name></decl></parameter>, <parameter><decl><type><name>LLVMOrcJITDylibLookupFlags</name></type> <name>JDLookupFlags</name></decl></parameter>,
					 <parameter><decl><type><name>LLVMOrcCLookupSet</name></type> <name>LookupSet</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>LookupSetSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LLVMOrcCSymbolMapPairs</name></type> <name>symbols</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LLVMJITCSymbolMapPair</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>LookupSetSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMErrorRef</name></type> <name>error</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMOrcMaterializationUnitRef</name></type> <name>mu</name></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LookupSetSize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>LLVMOrcSymbolStringPoolEntryStr</name><argument_list>(<argument><expr><name><name>LookupSet</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_VERSION_MAJOR</name> <operator>&gt;</operator> <literal type="number">12</literal></expr></cpp:if>
		<expr_stmt><expr><call><name>LLVMOrcRetainSymbolStringPoolEntry</name><argument_list>(<argument><expr><name><name>LookupSet</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Name</name> <operator>=</operator> <name><name>LookupSet</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Name</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>Sym</name><operator>.</operator><name>Address</name></name> <operator>=</operator> <call><name>llvm_resolve_symbol</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>symbols</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>Sym</name><operator>.</operator><name>Flags</name><operator>.</operator><name>GenericFlags</name></name> <operator>=</operator> <name>LLVMJITSymbolGenericFlagsExported</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>mu</name> <operator>=</operator> <call><name>LLVMOrcAbsoluteSymbols</name><argument_list>(<argument><expr><name>symbols</name></expr></argument>, <argument><expr><name>LookupSetSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>LLVMOrcJITDylibDefine</name><argument_list>(<argument><expr><name>JD</name></expr></argument>, <argument><expr><name>mu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name>LLVMErrorSuccess</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LLVMOrcDisposeMaterializationUnit</name><argument_list>(<argument><expr><name>mu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>symbols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>error</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * We cannot throw errors through LLVM (without causing a FATAL at least), so
 * just use WARNING here. That's OK anyway, as the error is also reported at
 * the top level action (with less detail) and there might be multiple
 * invocations of errors with details.
 *
 * This doesn't really happen during normal operation, but in cases like
 * symbol resolution breakage. So just using elog(WARNING) is fine.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>llvm_log_jit_error</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>LLVMErrorRef</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"error during JITing: %s"</literal></expr></argument>,
		 <argument><expr><call><name>llvm_error_message</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create our own object layer, so we can add event listeners.
 */</comment>
<function><type><specifier>static</specifier> <name>LLVMOrcObjectLayerRef</name></type>
<name>llvm_create_object_layer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>Ctx</name></decl></parameter>, <parameter><decl><type><name>LLVMOrcExecutionSessionRef</name></type> <name>ES</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Triple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LLVMOrcObjectLayerRef</name></type> <name>objlayer</name> <init>=
	<expr><call><name>LLVMOrcCreateRTDyldObjectLinkingLayerWithSectionMemoryManager</name><argument_list>(<argument><expr><name>ES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DECL_LLVMCREATEGDBREGISTRATIONLISTENER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_DECL_LLVMCREATEGDBREGISTRATIONLISTENER</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>jit_debugging_support</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMJITEventListenerRef</name></type> <name>l</name> <init>= <expr><call><name>LLVMCreateGDBRegistrationListener</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LLVMOrcRTDyldObjectLinkingLayerRegisterJITEventListener</name><argument_list>(<argument><expr><name>objlayer</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DECL_LLVMCREATEPERFJITEVENTLISTENER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>HAVE_DECL_LLVMCREATEPERFJITEVENTLISTENER</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>jit_profiling_support</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LLVMJITEventListenerRef</name></type> <name>l</name> <init>= <expr><call><name>LLVMCreatePerfJITEventListener</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LLVMOrcRTDyldObjectLinkingLayerRegisterJITEventListener</name><argument_list>(<argument><expr><name>objlayer</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>objlayer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create LLJIT instance, using the passed in target machine. Note that the
 * target machine afterwards is owned by the LLJIT instance.
 */</comment>
<function><type><specifier>static</specifier> <name>LLVMOrcLLJITRef</name></type>
<name>llvm_create_jit_instance</name><parameter_list>(<parameter><decl><type><name>LLVMTargetMachineRef</name></type> <name>tm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LLVMOrcLLJITRef</name></type> <name>lljit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMOrcJITTargetMachineBuilderRef</name></type> <name>tm_builder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMOrcLLJITBuilderRef</name></type> <name>lljit_builder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMErrorRef</name></type> <name>error</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMOrcDefinitionGeneratorRef</name></type> <name>main_gen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LLVMOrcDefinitionGeneratorRef</name></type> <name>ref_gen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lljit_builder</name> <operator>=</operator> <call><name>LLVMOrcCreateLLJITBuilder</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tm_builder</name> <operator>=</operator> <call><name>LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LLVMOrcLLJITBuilderSetJITTargetMachineBuilder</name><argument_list>(<argument><expr><name>lljit_builder</name></expr></argument>, <argument><expr><name>tm_builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LLVMOrcLLJITBuilderSetObjectLinkingLayerCreator</name><argument_list>(<argument><expr><name>lljit_builder</name></expr></argument>,
													<argument><expr><name>llvm_create_object_layer</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>LLVMOrcCreateLLJIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lljit</name></expr></argument>, <argument><expr><name>lljit_builder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to create lljit instance: %s"</literal></expr></argument>,
			 <argument><expr><call><name>llvm_error_message</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LLVMOrcExecutionSessionSetErrorReporter</name><argument_list>(<argument><expr><call><name>LLVMOrcLLJITGetExecutionSession</name><argument_list>(<argument><expr><name>lljit</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>llvm_log_jit_error</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Symbol resolution support for symbols in the postgres binary /
	 * libraries already loaded.
	 */</comment>
	<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess</name><argument_list>(<argument><expr><operator>&amp;</operator><name>main_gen</name></expr></argument>,
																 <argument><expr><call><name>LLVMOrcLLJITGetGlobalPrefix</name><argument_list>(<argument><expr><name>lljit</name></expr></argument>)</argument_list></call></expr></argument>,
																 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to create generator: %s"</literal></expr></argument>,
			 <argument><expr><call><name>llvm_error_message</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>LLVMOrcJITDylibAddGenerator</name><argument_list>(<argument><expr><call><name>LLVMOrcLLJITGetMainJITDylib</name><argument_list>(<argument><expr><name>lljit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>main_gen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Symbol resolution support for "special" functions, e.g. a call into an
	 * SQL callable function.
	 */</comment>
	<expr_stmt><expr><name>ref_gen</name> <operator>=</operator> <call><name>LLVMOrcCreateCustomCAPIDefinitionGenerator</name><argument_list>(<argument><expr><name>llvm_resolve_symbols</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LLVMOrcJITDylibAddGenerator</name><argument_list>(<argument><expr><call><name>LLVMOrcLLJITGetMainJITDylib</name><argument_list>(<argument><expr><name>lljit</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ref_gen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>lljit</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>llvm_error_message</name><parameter_list>(<parameter><decl><type><name>LLVMErrorRef</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>orig</name> <init>= <expr><call><name>LLVMGetErrorMessage</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LLVMDisposeErrorMessage</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>msg</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* LLVM_VERSION_MAJOR &gt; 11 */</comment>
</unit>
