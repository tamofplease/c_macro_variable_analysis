<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/replication/gp_replication.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * gp_replication.c
 *
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/replication/gp_replication.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/gp_replication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<comment type="block">/* Set at database system is ready to accept connections */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>pg_time_t</name></type> <name>PMAcceptingConnectionsStartTime</name></decl>;</decl_stmt>

<comment type="block">/*
 * FTSRepStatusCtl is only used for GPDB primary-mirror replication,
 * so set to a small value for now.
 */</comment>
<decl_stmt><decl><type><name>uint32</name></type> <name>max_replication_status</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Control array for replication status management which used in FTS.
 * The reason for not using WalSndCtl to track replication status is
 * the WalSnd is used to track walsender status. And when FTS probe
 * happens, the WalSnd for a replication may already get freed.
 */</comment>
<decl_stmt><decl><type><name>FTSReplicationStatusCtlData</name> <modifier>*</modifier></type><name>FTSRepStatusCtl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FTSReplicationStatusClearDisconnectTime</name><parameter_list>(<parameter><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>replication_status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FTSReplicationStatusClearAttempts</name><parameter_list>(<parameter><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>replication_status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>FTSReplicationStatusRetrieveAttempts</name><parameter_list>(<parameter><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>replication_status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pg_time_t</name></type> <name>FTSReplicationStatusRetrieveDisconnectTime</name><parameter_list>(<parameter><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>replication_status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FTSReplicationStatusMarkDisconnect</name><parameter_list>(<parameter><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>replication_status</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Report shared-memory space needed by FTSReplicationStatusShmemInit */</comment>
<function><type><name>Size</name></type>
<name>FTSReplicationStatusShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>FTSReplicationStatusCtlData</name></expr></argument>, <argument><expr><name>replications</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>max_replication_status</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FTSReplicationStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Allocate and initialize FTSReplicationStatus related shared memory */</comment>
<function><type><name>void</name></type>
<name>FTSReplicationStatusShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FTSReplicationStatusShmemSize</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>FTSRepStatusCtl</name> <operator>=</operator> <operator>(</operator><name>FTSReplicationStatusCtlData</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"FTSReplicationStatus Ctl"</literal></expr></argument>, <argument><expr><call><name>FTSReplicationStatusShmemSize</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through, so initialize */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>FTSRepStatusCtl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>FTSReplicationStatusShmemSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_replication_status</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>FTSRepStatusCtl</name><operator>-&gt;</operator><name>replications</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* everything else is zeroed by the memset above */</comment>
			<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FTSReplicationStatusCreateIfNotExist - Init a FTSReplicationStatus for current
 * replication application. Use application_name to identify the primary-mirror pair.
 * If FTSReplicationStatus for current application_name already exist, skip
 * create.
 *
 * This function is called under walsender, walsender's application_name is used.
 */</comment>
<function><type><name>void</name></type>
<name>FTSReplicationStatusCreateIfNotExist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>app_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>replication_status</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* FTSRepStatusCtl should be set already. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>FTSRepStatusCtl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use FTSReplicationStatusLock to protect concurrent create/drop */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_replication_status</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>FTSRepStatusCtl</name><operator>-&gt;</operator><name>replications</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>app_name</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* FTSReplicationStatus for current application already exists */</comment>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Find a free slot, but this does not mean the slot for app_name is not exist.
			 * Cause the slot may get freed and reused.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>replication_status</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>replication_status</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If find a free slot, create a new FTSReplicationStatus */</comment>
	<if_stmt><if>if <condition>(<expr><name>replication_status</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>replication_status</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>replication_status</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>application_name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replication_status</name><operator>-&gt;</operator><name>con_attempt_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replication_status</name><operator>-&gt;</operator><name>replica_disconnected_at</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* No need to release LWLock before fatal since abort will release it */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of requested standby connections "</literal>
					   <literal type="string">"exceeds max_replication_status (currently %d)"</literal></expr></argument>,
					   <argument><expr><name>max_replication_status</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FTSReplicationStatusDrop - Drop a FTSReplicationStatus.
 *
 * This function is called in FTS probe process, so an app_name is used
 * to specify which FTSReplicationStatus should be dropped.
 */</comment>
<function><type><name>void</name></type>
<name>FTSReplicationStatusDrop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>app_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<comment type="block">/* FTSRepStatusCtl should be set already. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>FTSRepStatusCtl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use FTSReplicationStatusLock to protect concurrent create/drop */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_replication_status</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>FTSRepStatusCtl</name><operator>-&gt;</operator><name>replications</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>app_name</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RetrieveFTSReplicationStatus - Get the FTSReplicationStatus from FTSRepStatusCtl.
 *
 * FTSReplicationStatusLock should be held before call this function.
 */</comment>
<function><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type>
<name>RetrieveFTSReplicationStatus</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>app_name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_warn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* FTSRepStatusCtl should be set already. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>FTSRepStatusCtl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_replication_status</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>FTSRepStatusCtl</name><operator>-&gt;</operator><name>replications</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>app_name</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>slot</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_warn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FTSReplicationStatus \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>app_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FTSReplicationStatusMarkDisconnect - Mark current replication's disconnect by
 * increase the con_attempt_count and set current time as disconnect time.
 *
 * This function is called under walsender to mark wal replication disconnected.
 *
 * FTSReplicationStatusLock should be held before call this function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FTSReplicationStatusMarkDisconnect</name><parameter_list>(<parameter><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>replication_status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>replication_status</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* FTSRepStatusCtl should be set already. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>FTSRepStatusCtl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use FTSReplicationStatusLock to prevent concurrent create/drop */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Since we need to modify the slot's value, lock the mutex. */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication_status</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>replication_status</name><operator>-&gt;</operator><name>con_attempt_count</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>replication_status</name><operator>-&gt;</operator><name>replica_disconnected_at</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication_status</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_fts</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"FTSReplicationStatus: Mark replication disconnected. "</literal>
		   <literal type="string">"Current attempt count: %d, disconnect at %ld, for application %s"</literal></expr></argument>,
		   <argument><expr><name><name>replication_status</name><operator>-&gt;</operator><name>con_attempt_count</name></name></expr></argument>,
		   <argument><expr><name><name>replication_status</name><operator>-&gt;</operator><name>replica_disconnected_at</name></name></expr></argument>,
		   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>replication_status</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FTSReplicationStatusUpdateForWalState - Update replication status for an replication
 * application and it's WalSndState.
 *
 * This function is called under walsender to update replication status.
 */</comment>
<function><type><name>void</name></type>
<name>FTSReplicationStatusUpdateForWalState</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>app_name</name></decl></parameter>, <parameter><decl><type><name>WalSndState</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>replication_status</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>replication_status</name> <operator>=</operator> <call><name>RetrieveFTSReplicationStatus</name><argument_list>(<argument><expr><name>app_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/*skip_warn*/</comment>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* replication_status must exist */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>replication_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>WALSNDSTATE_CATCHUP</name> <operator>||</operator> <name>state</name> <operator>==</operator> <name>WALSNDSTATE_STREAMING</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can clear the disconnect time once the connection established.
		 * We only clean the failure count when the wal start streaming, since
		 * although the connection established, and start to send wal, but there
		 * still chance to fail. Since the blocked transaction will get released
		 * only when wal start streaming. More details, see SyncRepReleaseWaiters.
		 */</comment>
		<expr_stmt><expr><call><name>FTSReplicationStatusClearDisconnectTime</name><argument_list>(<argument><expr><name>replication_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If current replication start streaming, clear the failure attempt count */</comment>
		<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>WALSNDSTATE_STREAMING</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FTSReplicationStatusClearAttempts</name><argument_list>(<argument><expr><name>replication_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>FTSReplicationStatusRetrieveDisconnectTime</name><argument_list>(<argument><expr><name>replication_status</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Mark the replication failure if's it the first time set the failure
		 * WalSndState. Since if the disconnect time is not 0, we already mark
		 * the replication failure.
		 */</comment>
		<expr_stmt><expr><call><name>FTSReplicationStatusMarkDisconnect</name><argument_list>(<argument><expr><name>replication_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FTSReplicationStatusMarkDisconnectForReplication - Mark a replication disconnected
 * base on replication's application name.
 *
 * This function is called under walsender to mark wal replication disconnected.
 */</comment>
<function><type><name>void</name></type>
<name>FTSReplicationStatusMarkDisconnectForReplication</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>app_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>replication_status</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * FTS may already mark the mirror down and free the replication status.
	 * For this case, a NULL pointer will return.
	 */</comment>
	<expr_stmt><expr><name>replication_status</name> <operator>=</operator> <call><name>RetrieveFTSReplicationStatus</name><argument_list>(<argument><expr><name>app_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* skip_warn */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if replication_status is NULL, do nothing */</comment>
	<expr_stmt><expr><call><name>FTSReplicationStatusMarkDisconnect</name><argument_list>(<argument><expr><name>replication_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FTSReplicationStatusClearAttempts - Clear current replication's continuously
 * connection attempts since the replication start steaming data.
 *
 * This function is called under walsender to mark the replication start
 * steaming.
 *
 * FTSReplicationStatusLock should be held before call this function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FTSReplicationStatusClearAttempts</name><parameter_list>(<parameter><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>replication_status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>replication_status</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* FTSRepStatusCtl should be set already. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>FTSRepStatusCtl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use FTSReplicationStatusLock to prevent concurrent create/drop */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Since we need to modify the slot's value, lock the mutex. */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication_status</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>replication_status</name><operator>-&gt;</operator><name>con_attempt_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication_status</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_fts</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"FTSReplicationStatus: Clear replication connection attempts, for application %s"</literal></expr></argument>,
		   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>replication_status</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FTSReplicationStatusRetrieveAttempts - Retrieve the replication connection attempts
 * for a replication application.
 *
 * This function is called under FTS probe process.
 *
 * FTSReplicationStatusLock should be held before call this function.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>FTSReplicationStatusRetrieveAttempts</name><parameter_list>(<parameter><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>replication_status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>			 	<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>replication_status</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* FTSRepStatusCtl should be set already. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>FTSRepStatusCtl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use FTSReplicationStatusLock to prevent concurrent create/drop */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* To prevent partial read, lock the mutex. */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication_status</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>replication_status</name><operator>-&gt;</operator><name>con_attempt_count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication_status</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FTSReplicationStatusClearDisconnectTime - Clear replication disconnect time.
 *
 * This function is called under walsender to clear replication disconnect time.
 *
 * FTSReplicationStatusLock should be held before call this function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FTSReplicationStatusClearDisconnectTime</name><parameter_list>(<parameter><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>replication_status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>replication_status</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* FTSRepStatusCtl should be set already. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>FTSRepStatusCtl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use FTSReplicationStatusLock to prevent concurrent create/drop */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Since we need to modify the slot's value, lock the mutex. */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication_status</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>replication_status</name><operator>-&gt;</operator><name>replica_disconnected_at</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication_status</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_fts</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"FTSReplicationStatus: Clear replication disconnect time, for application %s"</literal></expr></argument>,
		   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>replication_status</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FTSReplicationStatusRetrieveDisconnectTime - Retrieve replication disconnect time.
 *
 * This function is called under FTS probe process to retrieve replication disconnect time.
 *
 * FTSReplicationStatusLock should be held before call this function.
 */</comment>
<function><type><specifier>static</specifier> <name>pg_time_t</name></type>
<name>FTSReplicationStatusRetrieveDisconnectTime</name><parameter_list>(<parameter><decl><type><name>FTSReplicationStatus</name> <modifier>*</modifier></type><name>replication_status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>			<name>disconn_time</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>replication_status</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* FTSRepStatusCtl should be set already. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>FTSRepStatusCtl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use FTSReplicationStatusLock to prevent concurrent create/drop */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Since we need to modify the slot's value, lock the mutex. */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication_status</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>disconn_time</name> <operator>=</operator> <name><name>replication_status</name><operator>-&gt;</operator><name>replica_disconnected_at</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>replication_status</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>disconn_time</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* FTSGetReplicationDisconnectTime - used in FTS probe process.
 *
 * Detect the primary-mirror replication attempt count.
 * If the replication keeps crash, we should consider mark
 * mirror down directly. Since the walsender keeps resarting,
 * walsender-&gt;replica_disconnected_at keeps updated.
 * So ignore it.
 *
 * The reason why we want mark mirror down for this case is because,
 * when current situation happens, and a transaction try to sync wal
 * to mirror at the same time, the transaction will block. If walsender
 * keeps fail, the transaction will block forever.
 * Please see more details in SyncRepWaitForLSN and SyncRepReleaseWaiters.
 *
 * If the FTSReplicationStatus for GP_WALRECEIVER_APPNAME is not exist,
 * it means the replication has already been stopped.
 */</comment>
<function><type><name>pg_time_t</name></type>
<name>FTSGetReplicationDisconnectTime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>app_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>			<name>walsender_replica_disconnected_at</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>				<name>attempt_replication_times</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FTSReplicationStatus</name>	   <modifier>*</modifier></type><name>replication_status</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>replication_status</name> <operator>=</operator> <call><name>RetrieveFTSReplicationStatus</name><argument_list>(<argument><expr><name>app_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* skip_warn */</comment>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>replication_status</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>attempt_replication_times</name> <operator>=</operator> <call><name>FTSReplicationStatusRetrieveAttempts</name><argument_list>(<argument><expr><name>replication_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>attempt_replication_times</name> <operator>&lt;=</operator> <name>gp_fts_replication_attempt_count</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>walsender_replica_disconnected_at</name> <operator>=</operator> <call><name>FTSReplicationStatusRetrieveDisconnectTime</name><argument_list>(<argument><expr><name>replication_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Primary-mirror replication streaming already attempted %d times exceed"</literal>
					<literal type="string">" limit gp_fts_replication_attempt_count %d"</literal></expr></argument>,
					<argument><expr><name>attempt_replication_times</name></expr></argument>, <argument><expr><name>gp_fts_replication_attempt_count</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>FTSReplicationStatusLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>walsender_replica_disconnected_at</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_mirror_up</name><parameter_list>(<parameter><decl><type><name>WalSnd</name> <modifier>*</modifier></type><name>walsender</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>walsender</name><operator>-&gt;</operator><name>is_for_gp_walreceiver</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>walsender_has_pid</name> <init>= <expr><name><name>walsender</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * WalSndSetState() resets replica_disconnected_at for
	 * below states. If modifying below states then be sure
	 * to update corresponding logic in WalSndSetState() as
	 * well.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_communicating_with_mirror</name> <init>= <expr><name><name>walsender</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>WALSNDSTATE_CATCHUP</name> <operator>||</operator>
		<name><name>walsender</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>WALSNDSTATE_STREAMING</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>walsender_has_pid</name> <operator>&amp;&amp;</operator> <name>is_communicating_with_mirror</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_probe_retry_needed</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>			<name>walsender_replica_disconnected_at</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the walsender disconnect time, if current replication failed too
	 * many times continuously, the walsender_replica_disconnected_at should
	 * not take into consider. See more details in FTSGetReplicationDisconnectTime.
	 */</comment>
	<expr_stmt><expr><name>walsender_replica_disconnected_at</name> <operator>=</operator> <call><name>FTSGetReplicationDisconnectTime</name><argument_list>(<argument><expr><name>GP_WALRECEIVER_APPNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * PMAcceptingConnectionStartTime is process-local variable, set in
	 * postmaster process and inherited by the FTS handler child
	 * process. This works because the timestamp is set only once by
	 * postmaster, and is guaranteed to be set before FTS handler child
	 * processes can be spawned.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PMAcceptingConnectionsStartTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type> <name>delta</name> <init>= <expr><operator>(</operator><operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>-</operator>
		<call><name>Max</name><argument_list>(<argument><expr><name>walsender_replica_disconnected_at</name></expr></argument>, <argument><expr><name>PMAcceptingConnectionsStartTime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Report mirror as down, only if it didn't connect for below
	 * grace period to primary. This helps to avoid marking mirror
	 * down unnecessarily when restarting primary or due to small n/w
	 * glitch. During this period, request FTS to probe again.
	 *
	 * If the delta is negative, then it's overflowed, meaning it's
	 * over gp_fts_mark_mirror_down_grace_period since either last
	 * database accepting connections or last time wal sender
	 * died. Then, we can safely mark the mirror is down.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <name>gp_fts_mark_mirror_down_grace_period</name> <operator>&amp;&amp;</operator> <name>delta</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requesting fts retry as mirror didn't connect yet but in grace period: "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"pid zero at time: "</literal> <name>INT64_FORMAT</name> <literal type="string">" accept connections start time: "</literal> <name>INT64_FORMAT</name></expr></argument>,
							<argument><expr><name>walsender_replica_disconnected_at</name></expr></argument>, <argument><expr><name>PMAcceptingConnectionsStartTime</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check the WalSndCtl to obtain if mirror is up or down, if the wal sender is
 * in streaming, and if synchronous replication is enabled or not, decide if
 * the primary is ready for syncrep if needed.
 */</comment>
<function><type><name>void</name></type>
<name>GetMirrorStatus</name><parameter_list>(<parameter><decl><type><name>FtsResponse</name> <modifier>*</modifier></type><name>response</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>ready_for_syncrep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>response</name><operator>-&gt;</operator><name>IsMirrorUp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>response</name><operator>-&gt;</operator><name>IsInSync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>response</name><operator>-&gt;</operator><name>RequestRetry</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ready_for_syncrep</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>ready_for_syncrep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SyncRepLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_senders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_up</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_streaming</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WalSnd</name> <modifier>*</modifier></type><name>walsender</name> <init>= <expr><operator>&amp;</operator><name><name>WalSndCtl</name><operator>-&gt;</operator><name>walsnds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsender</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>walsender</name><operator>-&gt;</operator><name>is_for_gp_walreceiver</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsender</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>is_up</name> <operator>=</operator> <call><name>is_mirror_up</name><argument_list>(<argument><expr><name>walsender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_streaming</name> <operator>=</operator> <operator>(</operator><name><name>walsender</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>WALSNDSTATE_STREAMING</name><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ready_for_syncrep</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>ready_for_syncrep</name> <operator>=</operator> <name>is_up</name> <operator>&amp;&amp;</operator>
								<operator>(</operator><operator>(</operator><name><name>walsender</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>WALSNDSTATE_STREAMING</name><operator>)</operator> <operator>||</operator>
								 <operator>(</operator><name><name>walsender</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>WALSNDSTATE_CATCHUP</name> <operator>&amp;&amp;</operator>
								  <name><name>walsender</name><operator>-&gt;</operator><name>caughtup_within_range</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>response</name><operator>-&gt;</operator><name>IsMirrorUp</name></name> <operator>=</operator> <name>is_up</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>response</name><operator>-&gt;</operator><name>IsInSync</name></name> <operator>=</operator> <operator>(</operator><name>is_up</name> <operator>&amp;&amp;</operator> <name>is_streaming</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsender</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>response</name><operator>-&gt;</operator><name>IsSyncRepEnabled</name></name> <operator>=</operator> <name><name>WalSndCtl</name><operator>-&gt;</operator><name>sync_standbys_defined</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SyncRepLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>response</name><operator>-&gt;</operator><name>IsMirrorUp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>response</name><operator>-&gt;</operator><name>RequestRetry</name></name> <operator>=</operator> <call><name>is_probe_retry_needed</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set WalSndCtl-&gt;sync_standbys_defined to true to enable synchronous segment
 * WAL replication and insert synchronous_standby_names="*" into the
 * gp_replication.conf to persist this state in case of segment crash.
 */</comment>
<function><type><name>void</name></type>
<name>SetSyncStandbysDefined</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>WalSndCtl</name><operator>-&gt;</operator><name>sync_standbys_defined</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_gp_replication_config</name><argument_list>(<argument><expr><literal type="string">"synchronous_standby_names"</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Signal a reload to the postmaster. */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"signaling configuration reload: setting synchronous_standby_names to '*'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_reload_conf</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument> <comment type="block">/* unused */</comment>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>UnsetSyncStandbysDefined</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>WalSndCtl</name><operator>-&gt;</operator><name>sync_standbys_defined</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_gp_replication_config</name><argument_list>(<argument><expr><literal type="string">"synchronous_standby_names"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Signal a reload to the postmaster. */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"signaling configuration reload: setting synchronous_standby_names to ''"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_reload_conf</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument> <comment type="block">/* unused */</comment>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FTSReplicationStatusDrop</name><argument_list>(<argument><expr><name>GP_WALRECEIVER_APPNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>gp_replication_error</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>WalSndCtl</name><operator>-&gt;</operator><name>error</name></name> <operator>==</operator> <name>WALSNDERROR_WALREAD</name></expr> ?</condition><then> <expr><literal type="string">"walread"</literal></expr> </then><else>: <expr><literal type="string">"none"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
