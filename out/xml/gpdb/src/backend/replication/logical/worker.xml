<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/replication/logical/worker.c"><comment type="block">/*-------------------------------------------------------------------------
 * worker.c
 *	   PostgreSQL logical replication worker (apply)
 *
 * Copyright (c) 2016-2019, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/replication/logical/worker.c
 *
 * NOTES
 *	  This file contains the worker which applies logical changes as they come
 *	  from remote logical replication stream.
 *
 *	  The main worker (apply) is started by logical replication worker
 *	  launcher for every enabled subscription in a database. It uses
 *	  walsender protocol to communicate with publisher.
 *
 *	  This module includes server facing code and shares libpqwalreceiver
 *	  module with walreceiver for providing the libpq specific functionality.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription_rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/walwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/decode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logical.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicalproto.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicalrelation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicalworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/origin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/reorderbuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/snapbuild.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/worker_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAPTIME_PER_CYCLE</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>	<comment type="block">/* max sleep time between cycles (1s) */</comment>

<typedef>typedef <type><struct>struct <name>FlushPosition</name>
<block>{
	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>local_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>remote_end</name></decl>;</decl_stmt>
}</block></struct></type> <name>FlushPosition</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>dlist_head</name></type> <name>lsn_mapping</name> <init>= <expr><call><name>DLIST_STATIC_INIT</name><argument_list>(<argument><expr><name>lsn_mapping</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>SlotErrCallbackArg</name>
<block>{
	<decl_stmt><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>local_attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>remote_attnum</name></decl>;</decl_stmt>
}</block></struct></type> <name>SlotErrCallbackArg</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>ApplyMessageContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>ApplyContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>WalReceiverConn</name> <modifier>*</modifier></type><name>wrconn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Subscription</name> <modifier>*</modifier></type><name>MySubscription</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>MySubscriptionValid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>in_remote_transaction</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>remote_final_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>send_feedback</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>recvpos</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>requestReply</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>store_flush_position</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>remote_lsn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>maybe_reread_subscription</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Flags set by signal handlers */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Should this worker apply changes for given relation.
 *
 * This is mainly needed for initial relation data sync as that runs in
 * separate worker process running in parallel and we need some way to skip
 * changes coming to the main apply worker during the sync of a table.
 *
 * Note we need to do smaller or equals comparison for SYNCDONE state because
 * it might hold position of end of initial slot consistent point WAL
 * record + 1 (ie start of next record) and next record can be COMMIT of
 * transaction we are now processing (which is what we set remote_final_lsn
 * to in apply_handle_begin).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>should_apply_changes_for_rel</name><parameter_list>(<parameter><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>am_tablesync_worker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>localreloid</name></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SUBREL_STATE_READY</name> <operator>||</operator>
				<operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SUBREL_STATE_SYNCDONE</name> <operator>&amp;&amp;</operator>
				 <name><name>rel</name><operator>-&gt;</operator><name>statelsn</name></name> <operator>&lt;=</operator> <name>remote_final_lsn</name><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make sure that we started local transaction.
 *
 * Also switches to ApplyMessageContext as necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ensure_transaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>CurrentMemoryContext</name> <operator>!=</operator> <name>ApplyMessageContext</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ApplyMessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>maybe_reread_subscription</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ApplyMessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Executor state preparation for evaluation of constraint expressions,
 * indexes and triggers.
 *
 * This is based on similar code in copy.c
 */</comment>
<function><type><specifier>static</specifier> <name>EState</name> <modifier>*</modifier></type>
<name>create_estate_for_relation</name><parameter_list>(<parameter><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>localrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecInitRangeTable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare to catch AFTER triggers. */</comment>
	<expr_stmt><expr><call><name>AfterTriggerBeginQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>estate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Executes default values for columns for which we can't map to remote
 * relation columns.
 *
 * This allows us to support tables which have more columns on the downstream
 * than on the upstream.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>slot_fill_defaults</name><parameter_list>(<parameter><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
				   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_phys_attrs</name> <init>= <expr><name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>,
				<decl><type ref="prev"/><name>num_defaults</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>defmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier><modifier>*</modifier></type><name>defexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We got all the data via replication, no need to evaluate anything. */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_phys_attrs</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>defmap</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>defexprs</name> <operator>=</operator> <operator>(</operator><name>ExprState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_phys_attrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExprState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;</operator> <name>num_phys_attrs</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>defexpr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name> <operator>||</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attgenerated</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>attrmap</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>defexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>defexpr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Run the expression through planner */</comment>
			<expr_stmt><expr><name>defexpr</name> <operator>=</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><name>defexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Initialize executable expression in copycontext */</comment>
			<expr_stmt><expr><name><name>defexprs</name><index>[<expr><name>num_defaults</name></expr>]</index></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>defexpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>defmap</name><index>[<expr><name>num_defaults</name></expr>]</index></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>num_defaults</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_defaults</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name><name>defmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator>
			<call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>defexprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name><name>defmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Error callback to give more context info about type conversion failure.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>slot_store_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlotErrCallbackArg</name> <modifier>*</modifier></type><name>errarg</name> <init>= <expr><operator>(</operator><name>SlotErrCallbackArg</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>remotetypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>remotetypoid</name></decl>,
				<decl><type ref="prev"/><name>localtypoid</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if remote attribute number is not set */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>errarg</name><operator>-&gt;</operator><name>remote_attnum</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>errarg</name><operator>-&gt;</operator><name>rel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>remotetypoid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>atttyps</name><index>[<expr><name><name>errarg</name><operator>-&gt;</operator><name>remote_attnum</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Fetch remote type name from the LogicalRepTypMap cache */</comment>
	<expr_stmt><expr><name>remotetypname</name> <operator>=</operator> <call><name>logicalrep_typmap_gettypname</name><argument_list>(<argument><expr><name>remotetypoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch local type OID from the local sys cache */</comment>
	<expr_stmt><expr><name>localtypoid</name> <operator>=</operator> <call><name>get_atttype</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localreloid</name></name></expr></argument>, <argument><expr><name><name>errarg</name><operator>-&gt;</operator><name>local_attnum</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"processing remote data for replication target relation \"%s.%s\" column \"%s\", "</literal>
			   <literal type="string">"remote type %s, local type %s"</literal></expr></argument>,
			   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>relname</name></name></expr></argument>,
			   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>attnames</name><index>[<expr><name><name>errarg</name><operator>-&gt;</operator><name>remote_attnum</name></name></expr>]</index></name></expr></argument>,
			   <argument><expr><name>remotetypname</name></expr></argument>,
			   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>localtypoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Store data in C string form into slot.
 * This is similar to BuildTupleFromCStrings but TupleTableSlot fits our
 * use better.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>slot_store_cstrings</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlotErrCallbackArg</name></type> <name>errarg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Push callback + info on the error context stack */</comment>
	<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>local_attnum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>remote_attnum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>slot_store_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>errarg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

	<comment type="block">/* Call the "in" function for each non-dropped attribute */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>remoteattnum</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>attrmap</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>&amp;&amp;</operator> <name>remoteattnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>values</name><index>[<expr><name>remoteattnum</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typinput</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>local_attnum</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>remote_attnum</name></name> <operator>=</operator> <name>remoteattnum</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>remoteattnum</name></expr>]</index></name></expr></argument>,
									 <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>local_attnum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>remote_attnum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We assign NULL to dropped attributes, NULL values, and missing
			 * values (missing values should be later filled using
			 * slot_fill_defaults).
			 */</comment>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Pop the error context stack */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Modify slot with user data provided as C strings.
 * This is somewhat similar to heap_modify_tuple but also calls the type
 * input function on the user data as the input is the text representation
 * of the types.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>slot_modify_cstrings</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>replaces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlotErrCallbackArg</name></type> <name>errarg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errcallback</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Push callback + info on the error context stack */</comment>
	<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>local_attnum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>remote_attnum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>slot_store_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>errarg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errcallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errcallback</name></expr>;</expr_stmt>

	<comment type="block">/* Call the "in" function for each replaced attribute */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>remoteattnum</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>attrmap</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>remoteattnum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>replaces</name><index>[<expr><name>remoteattnum</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>values</name><index>[<expr><name>remoteattnum</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typinput</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>local_attnum</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>remote_attnum</name></name> <operator>=</operator> <name>remoteattnum</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>remoteattnum</name></expr>]</index></name></expr></argument>,
									 <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>local_attnum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>errarg</name><operator>.</operator><name>remote_attnum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Pop the error context stack */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errcallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle BEGIN message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_handle_begin</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalRepBeginData</name></type> <name>begin_data</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>logicalrep_read_begin</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>begin_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>remote_final_lsn</name> <operator>=</operator> <name><name>begin_data</name><operator>.</operator><name>final_lsn</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>in_remote_transaction</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle COMMIT message.
 *
 * TODO, support tracking of multiple origins
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_handle_commit</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalRepCommitData</name></type> <name>commit_data</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>logicalrep_read_commit</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>commit_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>commit_data</name><operator>.</operator><name>commit_lsn</name></name> <operator>==</operator> <name>remote_final_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The synchronization worker runs in single transaction. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>am_tablesync_worker</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Update origin state so we can restart streaming from correct
		 * position in case of crash.
		 */</comment>
		<expr_stmt><expr><name>replorigin_session_origin_lsn</name> <operator>=</operator> <name><name>commit_data</name><operator>.</operator><name>end_lsn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>replorigin_session_origin_timestamp</name> <operator>=</operator> <name><name>commit_data</name><operator>.</operator><name>committime</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_stat</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>store_flush_position</name><argument_list>(<argument><expr><name><name>commit_data</name><operator>.</operator><name>end_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Process any invalidation messages that might have accumulated. */</comment>
		<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>maybe_reread_subscription</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>in_remote_transaction</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Process any tables that are being synchronized in parallel. */</comment>
	<expr_stmt><expr><call><name>process_syncing_tables</name><argument_list>(<argument><expr><name><name>commit_data</name><operator>.</operator><name>end_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle ORIGIN message.
 *
 * TODO, support tracking of multiple origins
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_handle_origin</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * ORIGIN message can only come inside remote transaction and before any
	 * actual writes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_remote_transaction</name> <operator>||</operator>
		<operator>(</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>am_tablesync_worker</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ORIGIN message sent out of order"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle RELATION message.
 *
 * Note we don't do validation against local schema here. The validation
 * against local schema is postponed until first change for given relation
 * comes as we only care about it when applying changes for it anyway and we
 * do less locking this way.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_handle_relation</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalRepRelation</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>logicalrep_read_rel</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>logicalrep_relmap_update</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle TYPE message.
 *
 * Note we don't do local mapping here, that's done when the type is
 * actually used.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_handle_type</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalRepTyp</name></type> <name>typ</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>logicalrep_read_typ</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>logicalrep_typmap_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>typ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get replica identity index or if it is not defined a primary key.
 *
 * If neither is defined, returns InvalidOid
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>GetRelationIdentityOrPK</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>idxoid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>idxoid</name> <operator>=</operator> <call><name>RelationGetReplicaIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>idxoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>idxoid</name> <operator>=</operator> <call><name>RelationGetPrimaryKeyIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>idxoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handle INSERT message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_handle_insert</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRepTupleData</name></type> <name>newtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRepRelId</name></type> <name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>remoteslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ensure_transaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>logicalrep_read_insert</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>logicalrep_rel_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>should_apply_changes_for_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The relation can't become interesting in the middle of the
		 * transaction so it's safe to unlock it.
		 */</comment>
		<expr_stmt><expr><call><name>logicalrep_rel_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Initialize the executor state. */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>create_estate_for_relation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>remoteslot</name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
										<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Input functions may need an active snapshot, so get one */</comment>
	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process and store remote tuple in the slot */</comment>
	<expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>slot_store_cstrings</name><argument_list>(<argument><expr><name>remoteslot</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>newtup</name><operator>.</operator><name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>slot_fill_defaults</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>remoteslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do the insert. */</comment>
	<expr_stmt><expr><call><name>ExecSimpleRelationInsert</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>remoteslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle queued AFTER triggers. */</comment>
	<expr_stmt><expr><call><name>AfterTriggerEndQuery</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecResetTupleTable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>logicalrep_rel_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check if the logical replication relation is updatable and throw
 * appropriate error if it isn't.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_relation_updatable</name><parameter_list>(<parameter><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Updatable, no error. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>updatable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We are in error mode so it's fine this is somewhat slow. It's better to
	 * give user correct error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>GetRelationIdentityOrPK</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"publisher did not send replica identity column "</literal>
						<literal type="string">"expected by the logical replication target relation \"%s.%s\""</literal></expr></argument>,
						<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication target relation \"%s.%s\" has "</literal>
					<literal type="string">"neither REPLICA IDENTITY index nor PRIMARY "</literal>
					<literal type="string">"KEY and published relation does not have "</literal>
					<literal type="string">"REPLICA IDENTITY FULL"</literal></expr></argument>,
					<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle UPDATE message.
 *
 * TODO: FDW support
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_handle_update</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRepRelId</name></type> <name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>idxoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EPQState</name></type>	<name>epqstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRepTupleData</name></type> <name>oldtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRepTupleData</name></type> <name>newtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_oldtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>localslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>remoteslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ensure_transaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>logicalrep_read_update</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>has_oldtup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>logicalrep_rel_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>should_apply_changes_for_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The relation can't become interesting in the middle of the
		 * transaction so it's safe to unlock it.
		 */</comment>
		<expr_stmt><expr><call><name>logicalrep_rel_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check if we can do the update. */</comment>
	<expr_stmt><expr><call><name>check_relation_updatable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the executor state. */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>create_estate_for_relation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>remoteslot</name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
										<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>localslot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EvalPlanQualInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>epqstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build the search tuple. */</comment>
	<expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>slot_store_cstrings</name><argument_list>(<argument><expr><name>remoteslot</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
						<argument><expr><ternary><condition><expr><name>has_oldtup</name></expr> ?</condition><then> <expr><name><name>oldtup</name><operator>.</operator><name>values</name></name></expr> </then><else>: <expr><name><name>newtup</name><operator>.</operator><name>values</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to find tuple using either replica identity index, primary key or
	 * if needed, sequential scan.
	 */</comment>
	<expr_stmt><expr><name>idxoid</name> <operator>=</operator> <call><name>GetRelationIdentityOrPK</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>idxoid</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>replident</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_FULL</name> <operator>&amp;&amp;</operator> <name>has_oldtup</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>idxoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>RelationFindReplTupleByIndex</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>, <argument><expr><name>idxoid</name></expr></argument>,
											 <argument><expr><name>LockTupleExclusive</name></expr></argument>,
											 <argument><expr><name>remoteslot</name></expr></argument>, <argument><expr><name>localslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>RelationFindReplTupleSeq</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>, <argument><expr><name>LockTupleExclusive</name></expr></argument>,
										 <argument><expr><name>remoteslot</name></expr></argument>, <argument><expr><name>localslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>remoteslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Tuple found.
	 *
	 * Note this will fail if there are other conflicting unique indexes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Process and store remote tuple in the slot */</comment>
		<expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecCopySlot</name><argument_list>(<argument><expr><name>remoteslot</name></expr></argument>, <argument><expr><name>localslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>slot_modify_cstrings</name><argument_list>(<argument><expr><name>remoteslot</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>newtup</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>newtup</name><operator>.</operator><name>changed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>EvalPlanQualSetSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>epqstate</name></expr></argument>, <argument><expr><name>remoteslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do the actual update. */</comment>
		<expr_stmt><expr><call><name>ExecSimpleRelationUpdate</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>epqstate</name></expr></argument>, <argument><expr><name>localslot</name></expr></argument>, <argument><expr><name>remoteslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The tuple to be updated could not be found.
		 *
		 * TODO what to do here, change the log level to LOG perhaps?
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			 <argument><expr><literal type="string">"logical replication did not find row for update "</literal>
			 <literal type="string">"in replication target relation \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle queued AFTER triggers. */</comment>
	<expr_stmt><expr><call><name>AfterTriggerEndQuery</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EvalPlanQualEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>epqstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecResetTupleTable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>logicalrep_rel_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle DELETE message.
 *
 * TODO: FDW support
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_handle_delete</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRepTupleData</name></type> <name>oldtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRepRelId</name></type> <name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>idxoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EPQState</name></type>	<name>epqstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>remoteslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>localslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ensure_transaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>logicalrep_read_delete</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>logicalrep_rel_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>should_apply_changes_for_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The relation can't become interesting in the middle of the
		 * transaction so it's safe to unlock it.
		 */</comment>
		<expr_stmt><expr><call><name>logicalrep_rel_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check if we can do the delete. */</comment>
	<expr_stmt><expr><call><name>check_relation_updatable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the executor state. */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>create_estate_for_relation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>remoteslot</name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
										<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>localslot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EvalPlanQualInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>epqstate</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the tuple using the replica identity index. */</comment>
	<expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>slot_store_cstrings</name><argument_list>(<argument><expr><name>remoteslot</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>oldtup</name><operator>.</operator><name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to find tuple using either replica identity index, primary key or
	 * if needed, sequential scan.
	 */</comment>
	<expr_stmt><expr><name>idxoid</name> <operator>=</operator> <call><name>GetRelationIdentityOrPK</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>idxoid</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>replident</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_FULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>idxoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>RelationFindReplTupleByIndex</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>, <argument><expr><name>idxoid</name></expr></argument>,
											 <argument><expr><name>LockTupleExclusive</name></expr></argument>,
											 <argument><expr><name>remoteslot</name></expr></argument>, <argument><expr><name>localslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>RelationFindReplTupleSeq</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>, <argument><expr><name>LockTupleExclusive</name></expr></argument>,
										 <argument><expr><name>remoteslot</name></expr></argument>, <argument><expr><name>localslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<comment type="block">/* If found delete it. */</comment>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EvalPlanQualSetSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>epqstate</name></expr></argument>, <argument><expr><name>localslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do the actual delete. */</comment>
		<expr_stmt><expr><call><name>ExecSimpleRelationDelete</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>epqstate</name></expr></argument>, <argument><expr><name>localslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* The tuple to be deleted could not be found. */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			 <argument><expr><literal type="string">"logical replication could not find row for delete "</literal>
			 <literal type="string">"in replication target relation \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle queued AFTER triggers. */</comment>
	<expr_stmt><expr><call><name>AfterTriggerEndQuery</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EvalPlanQualEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>epqstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecResetTupleTable</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>logicalrep_rel_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle TRUNCATE message.
 *
 * TODO: FDW support
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_handle_truncate</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>cascade</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>restart_seqs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>remote_relids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>remote_rels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relids_logged</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ensure_transaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>remote_relids</name> <operator>=</operator> <call><name>logicalrep_read_truncate</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cascade</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restart_seqs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>remote_relids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LogicalRepRelId</name></type> <name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>logicalrep_rel_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>should_apply_changes_for_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The relation can't become interesting in the middle of the
			 * transaction so it's safe to unlock it.
			 */</comment>
			<expr_stmt><expr><call><name>logicalrep_rel_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>remote_rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>remote_rels</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localreloid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>relids_logged</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>localreloid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Even if we used CASCADE on the upstream master we explicitly default to
	 * replaying changes without further cascading. This might be later
	 * changeable with a user specified option.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteTruncateGuts</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>, <argument><expr><name>relids_logged</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>restart_seqs</name></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>remote_rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>logicalrep_rel_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Logical replication protocol message dispatcher.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_dispatch</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>action</name> <init>= <expr><call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>action</name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* BEGIN */</comment>
		<case>case <expr><literal type="char">'B'</literal></expr>:</case>
			<expr_stmt><expr><call><name>apply_handle_begin</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
			<comment type="block">/* COMMIT */</comment>
		<case>case <expr><literal type="char">'C'</literal></expr>:</case>
			<expr_stmt><expr><call><name>apply_handle_commit</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
			<comment type="block">/* INSERT */</comment>
		<case>case <expr><literal type="char">'I'</literal></expr>:</case>
			<expr_stmt><expr><call><name>apply_handle_insert</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
			<comment type="block">/* UPDATE */</comment>
		<case>case <expr><literal type="char">'U'</literal></expr>:</case>
			<expr_stmt><expr><call><name>apply_handle_update</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
			<comment type="block">/* DELETE */</comment>
		<case>case <expr><literal type="char">'D'</literal></expr>:</case>
			<expr_stmt><expr><call><name>apply_handle_delete</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
			<comment type="block">/* TRUNCATE */</comment>
		<case>case <expr><literal type="char">'T'</literal></expr>:</case>
			<expr_stmt><expr><call><name>apply_handle_truncate</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
			<comment type="block">/* RELATION */</comment>
		<case>case <expr><literal type="char">'R'</literal></expr>:</case>
			<expr_stmt><expr><call><name>apply_handle_relation</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
			<comment type="block">/* TYPE */</comment>
		<case>case <expr><literal type="char">'Y'</literal></expr>:</case>
			<expr_stmt><expr><call><name>apply_handle_type</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
			<comment type="block">/* ORIGIN */</comment>
		<case>case <expr><literal type="char">'O'</literal></expr>:</case>
			<expr_stmt><expr><call><name>apply_handle_origin</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid logical replication message type \"%c\""</literal></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Figure out which write/flush positions to report to the walsender process.
 *
 * We can't simply report back the last LSN the walsender sent us because the
 * local transaction might not yet be flushed to disk locally. Instead we
 * build a list that associates local with remote LSNs for every commit. When
 * reporting back the flush position to the sender we iterate that list and
 * check which entries on it are already locally flushed. Those we can report
 * as having been flushed.
 *
 * The have_pending_txes is true if there are outstanding transactions that
 * need to be flushed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_flush_position</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>write</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>flush</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>have_pending_txes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>local_flush</name> <init>= <expr><call><name>GetFlushRecPtr</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>write</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>flush</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;lsn_mapping</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FlushPosition</name> <modifier>*</modifier></type><name>pos</name> <init>=
		<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>FlushPosition</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>write</name> <operator>=</operator> <name><name>pos</name><operator>-&gt;</operator><name>remote_end</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pos</name><operator>-&gt;</operator><name>local_end</name></name> <operator>&lt;=</operator> <name>local_flush</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>flush</name> <operator>=</operator> <name><name>pos</name><operator>-&gt;</operator><name>remote_end</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Don't want to uselessly iterate over the rest of the list which
			 * could potentially be long. Instead get the last element and
			 * grab the write position from there.
			 */</comment>
			<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>dlist_tail_element</name><argument_list>(<argument><expr><name>FlushPosition</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>lsn_mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>write</name> <operator>=</operator> <name><name>pos</name><operator>-&gt;</operator><name>remote_end</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>have_pending_txes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name>have_pending_txes</name> <operator>=</operator> <operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lsn_mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Store current remote/local lsn pair in the tracking list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>store_flush_position</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>remote_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FlushPosition</name> <modifier>*</modifier></type><name>flushpos</name></decl>;</decl_stmt>

	<comment type="block">/* Need to do this in permanent context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ApplyContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Track commit lsn  */</comment>
	<expr_stmt><expr><name>flushpos</name> <operator>=</operator> <operator>(</operator><name>FlushPosition</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FlushPosition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>flushpos</name><operator>-&gt;</operator><name>local_end</name></name> <operator>=</operator> <name>XactLastCommitEnd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>flushpos</name><operator>-&gt;</operator><name>remote_end</name></name> <operator>=</operator> <name>remote_lsn</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lsn_mapping</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>flushpos</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ApplyMessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Update statistics of the worker. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateWorkerStats</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>last_lsn</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>send_time</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reply</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>last_lsn</name></name> <operator>=</operator> <name>last_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>last_send_time</name></name> <operator>=</operator> <name>send_time</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>last_recv_time</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>reply</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>reply_lsn</name></name> <operator>=</operator> <name>last_lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>reply_time</name></name> <operator>=</operator> <name>send_time</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Apply main loop.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogicalRepApplyLoop</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>last_received</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Init the ApplyMessageContext which we clean up after each replication
	 * protocol message.
	 */</comment>
	<expr_stmt><expr><name>ApplyMessageContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>ApplyContext</name></expr></argument>,
												<argument><expr><literal type="string">"ApplyMessageContext"</literal></expr></argument>,
												<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* mark as idle, before starting to loop */</comment>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pgsocket</name></type>	<name>fd</name> <init>= <expr><name>PGINVALID_SOCKET</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>endofstream</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_recv_timestamp</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>ping_sent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type>		<name>wait_time</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ApplyMessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>walrcv_receive</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Process the data */</comment>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data stream from publisher has ended"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>endofstream</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>StringInfoData</name></type> <name>s</name></decl>;</decl_stmt>

					<comment type="block">/* Reset timeout. */</comment>
					<expr_stmt><expr><name>last_recv_timestamp</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ping_sent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

					<comment type="block">/* Ensure we are reading the data into our memory context. */</comment>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ApplyMessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>s</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>s</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>s</name><operator>.</operator><name>cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>s</name><operator>.</operator><name>maxlen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

					<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'w'</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>start_lsn</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>end_lsn</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>TimestampTz</name></type> <name>send_time</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>start_lsn</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>end_lsn</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>send_time</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>last_received</name> <operator>&lt;</operator> <name>start_lsn</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>last_received</name> <operator>=</operator> <name>start_lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name>last_received</name> <operator>&lt;</operator> <name>end_lsn</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>last_received</name> <operator>=</operator> <name>end_lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><call><name>UpdateWorkerStats</name><argument_list>(<argument><expr><name>last_received</name></expr></argument>, <argument><expr><name>send_time</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>apply_dispatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'k'</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>end_lsn</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>bool</name></type>		<name>reply_requested</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>end_lsn</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>reply_requested</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>last_received</name> <operator>&lt;</operator> <name>end_lsn</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>last_received</name> <operator>=</operator> <name>end_lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><call><name>send_feedback</name><argument_list>(<argument><expr><name>last_received</name></expr></argument>, <argument><expr><name>reply_requested</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>UpdateWorkerStats</name><argument_list>(<argument><expr><name>last_received</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* other message types are purposefully ignored */</comment>

					<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>ApplyMessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>walrcv_receive</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* confirm all writes so far */</comment>
		<expr_stmt><expr><call><name>send_feedback</name><argument_list>(<argument><expr><name>last_received</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_remote_transaction</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we didn't get any transactions for a while there might be
			 * unconsumed invalidation messages in the queue, consume them
			 * now.
			 */</comment>
			<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>maybe_reread_subscription</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Process any table synchronization changes. */</comment>
			<expr_stmt><expr><call><name>process_syncing_tables</name><argument_list>(<argument><expr><name>last_received</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Cleanup the memory. */</comment>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>ApplyMessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check if we need to exit the streaming loop. */</comment>
		<if_stmt><if>if <condition>(<expr><name>endofstream</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>tli</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>walrcv_endstreaming</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Wait for more data or latch.  If we have unflushed transactions,
		 * wake up after WalWriterDelay to see if they've been flushed yet (in
		 * which case we should send a feedback message).  Otherwise, there's
		 * no particular urgency about waking up unless we get data or a
		 * signal.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lsn_mapping</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>wait_time</name> <operator>=</operator> <name>WalWriterDelay</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>wait_time</name> <operator>=</operator> <name>NAPTIME_PER_CYCLE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
							   <argument><expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_LATCH_SET</name> <operator>|</operator>
							   <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_EXIT_ON_PM_DEATH</name></expr></argument>,
							   <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>wait_time</name></expr></argument>,
							   <argument><expr><name>WAIT_EVENT_LOGICAL_APPLY_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_TIMEOUT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We didn't receive anything new. If we haven't heard anything
			 * from the server for more than wal_receiver_timeout / 2, ping
			 * the server. Also, if it's been longer than
			 * wal_receiver_status_interval since the last update we sent,
			 * send a status update to the master anyway, to report any
			 * progress in applying WAL.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type>		<name>requestReply</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Check if time since last receive from standby has reached the
			 * configured limit.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>wal_receiver_timeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timeout</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>timeout</name> <operator>=</operator>
					<call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>last_recv_timestamp</name></expr></argument>,
												<argument><expr><name>wal_receiver_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>timeout</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating logical replication worker due to timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * We didn't receive anything new, for half of receiver
				 * replication timeout. Ping the server.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ping_sent</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>timeout</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>last_recv_timestamp</name></expr></argument>,
														  <argument><expr><operator>(</operator><name>wal_receiver_timeout</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>timeout</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>requestReply</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>ping_sent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>send_feedback</name><argument_list>(<argument><expr><name>last_received</name></expr></argument>, <argument><expr><name>requestReply</name></expr></argument>, <argument><expr><name>requestReply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Send a Standby Status Update message to server.
 *
 * 'recvpos' is the latest LSN we've received data to, force is set if we need
 * to send a response to avoid timeouts.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>send_feedback</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>recvpos</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>requestReply</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>reply_message</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>send_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>last_recvpos</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>last_writepos</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>last_flushpos</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>writepos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>flushpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_pending_txes</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the user doesn't want status to be reported to the publisher, be
	 * sure to exit before doing anything at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <name>wal_receiver_status_interval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* It's legal to not pass a recvpos */</comment>
	<if_stmt><if>if <condition>(<expr><name>recvpos</name> <operator>&lt;</operator> <name>last_recvpos</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recvpos</name> <operator>=</operator> <name>last_recvpos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>get_flush_position</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writepos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flushpos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>have_pending_txes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No outstanding transactions to flush, we can report the latest received
	 * position. This is important for synchronous replication.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_pending_txes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flushpos</name> <operator>=</operator> <name>writepos</name> <operator>=</operator> <name>recvpos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>writepos</name> <operator>&lt;</operator> <name>last_writepos</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>writepos</name> <operator>=</operator> <name>last_writepos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>flushpos</name> <operator>&lt;</operator> <name>last_flushpos</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flushpos</name> <operator>=</operator> <name>last_flushpos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we've already reported everything we're good */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator>
		<name>writepos</name> <operator>==</operator> <name>last_writepos</name> <operator>&amp;&amp;</operator>
		<name>flushpos</name> <operator>==</operator> <name>last_flushpos</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>send_time</name></expr></argument>, <argument><expr><name>now</name></expr></argument>,
									<argument><expr><name>wal_receiver_status_interval</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>send_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reply_message</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ApplyContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>reply_message</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><name>reply_message</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><name>reply_message</name></expr></argument>, <argument><expr><name>recvpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* write */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><name>reply_message</name></expr></argument>, <argument><expr><name>flushpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* flush */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><name>reply_message</name></expr></argument>, <argument><expr><name>writepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* apply */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><name>reply_message</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* sendTime */</comment>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><name>reply_message</name></expr></argument>, <argument><expr><name>requestReply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* replyRequested */</comment>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sending feedback (force %d) to recv %X/%X, write %X/%X, flush %X/%X"</literal></expr></argument>,
		 <argument><expr><name>force</name></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recvpos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recvpos</name></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>writepos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>writepos</name></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>flushpos</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>flushpos</name></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>walrcv_send</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name><name>reply_message</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>reply_message</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>recvpos</name> <operator>&gt;</operator> <name>last_recvpos</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_recvpos</name> <operator>=</operator> <name>recvpos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>writepos</name> <operator>&gt;</operator> <name>last_writepos</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_writepos</name> <operator>=</operator> <name>writepos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>flushpos</name> <operator>&gt;</operator> <name>last_flushpos</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_flushpos</name> <operator>=</operator> <name>flushpos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reread subscription info if needed. Most changes will be exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>maybe_reread_subscription</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Subscription</name> <modifier>*</modifier></type><name>newsub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>started_tx</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* When cache state is valid there is nothing to do here. */</comment>
	<if_stmt><if>if <condition>(<expr><name>MySubscriptionValid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* This function might be called inside or outside of transaction. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>started_tx</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Ensure allocations in permanent context. */</comment>
	<expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ApplyContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newsub</name> <operator>=</operator> <call><name>GetSubscription</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Exit if the subscription was removed. This normally should not happen
	 * as the worker gets killed during DROP SUBSCRIPTION.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newsub</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication apply worker for subscription \"%s\" will "</literal>
						<literal type="string">"stop because the subscription was removed"</literal></expr></argument>,
						<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Exit if the subscription was disabled. This normally should not happen
	 * as the worker gets killed during ALTER SUBSCRIPTION ... DISABLE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>newsub</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication apply worker for subscription \"%s\" will "</literal>
						<literal type="string">"stop because the subscription was disabled"</literal></expr></argument>,
						<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Exit if connection string was changed. The launcher will start new
	 * worker.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>newsub</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>, <argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication apply worker for subscription \"%s\" will "</literal>
						<literal type="string">"restart because the connection information was changed"</literal></expr></argument>,
						<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Exit if subscription name was changed (it's used for
	 * fallback_application_name). The launcher will start new worker.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>newsub</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication apply worker for subscription \"%s\" will "</literal>
						<literal type="string">"restart because subscription was renamed"</literal></expr></argument>,
						<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* !slotname should never happen when enabled is true. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>newsub</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to make new connection to new slot if slot name has changed so
	 * exit here as well if that's the case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>newsub</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>, <argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication apply worker for subscription \"%s\" will "</literal>
						<literal type="string">"restart because the replication slot name was changed"</literal></expr></argument>,
						<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Exit if publication list was changed. The launcher will start new
	 * worker.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>newsub</name><operator>-&gt;</operator><name>publications</name></name></expr></argument>, <argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>publications</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication apply worker for subscription \"%s\" will "</literal>
						<literal type="string">"restart because subscription's publications were changed"</literal></expr></argument>,
						<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check for other changes that should never happen too. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>newsub</name><operator>-&gt;</operator><name>dbid</name></name> <operator>!=</operator> <name><name>MySubscription</name><operator>-&gt;</operator><name>dbid</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subscription %u changed unexpectedly"</literal></expr></argument>,
			 <argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Clean old subscription info and switch to new one. */</comment>
	<expr_stmt><expr><call><name>FreeSubscription</name><argument_list>(<argument><expr><name>MySubscription</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>MySubscription</name> <operator>=</operator> <name>newsub</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Change synchronous commit according to the user's wishes */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"synchronous_commit"</literal></expr></argument>, <argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>synccommit</name></name></expr></argument>,
					<argument><expr><name>PGC_BACKEND</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>started_tx</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>MySubscriptionValid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback from subscription syscache invalidation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>subscription_change_cb</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>MySubscriptionValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGHUP: set flag to reload configuration at next convenient time */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>logicalrep_worker_sighup</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Waken anything waiting on the process latch */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Logical Replication Apply worker entry point */</comment>
<function><type><name>void</name></type>
<name>ApplyWorkerMain</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>main_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>worker_slot</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>main_arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>originname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>origin_startpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>myslotname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalRcvStreamOptions</name></type> <name>options</name></decl>;</decl_stmt>

	<comment type="block">/* Attach to slot */</comment>
	<expr_stmt><expr><call><name>logicalrep_worker_attach</name><argument_list>(<argument><expr><name>worker_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Setup signal handling */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>logicalrep_worker_sighup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't currently need any ResourceOwner in a walreceiver process, but
	 * if we did, we could call CreateAuxProcessResourceOwner here.
	 */</comment>

	<comment type="block">/* Initialise stats to a sanish value */</comment>
	<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>last_send_time</name></name> <operator>=</operator> <name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>last_recv_time</name></name> <operator>=</operator>
		<name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>reply_time</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Load the libpq-specific functions */</comment>
	<comment type="block">/*
	 * In GPDB, we build libpqwalreceiver functions, as well as a copy of
	 * libpq into the backend itself, to support QD-QE communication. See
	 * src/backend/libpq.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>WalReceiverFunctions</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>libpqwalreceiver_PG_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Run as replica session replication role. */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"session_replication_role"</literal></expr></argument>, <argument><expr><literal type="string">"replica"</literal></expr></argument>,
					<argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Connect to our database. */</comment>
	<expr_stmt><expr><call><name>BackgroundWorkerInitializeConnectionByOid</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>,
											  <argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>,
											  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Load the subscription into persistent memory context. */</comment>
	<expr_stmt><expr><name>ApplyContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
										 <argument><expr><literal type="string">"ApplyContext"</literal></expr></argument>,
										 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ApplyContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MySubscription</name> <operator>=</operator> <call><name>GetSubscription</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MySubscription</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication apply worker for subscription %u will not "</literal>
						<literal type="string">"start because the subscription was removed during startup"</literal></expr></argument>,
						<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>MySubscriptionValid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MySubscription</name><operator>-&gt;</operator><name>enabled</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication apply worker for subscription \"%s\" will not "</literal>
						<literal type="string">"start because the subscription was disabled during startup"</literal></expr></argument>,
						<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Setup synchronous commit according to the user's wishes */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"synchronous_commit"</literal></expr></argument>, <argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>synccommit</name></name></expr></argument>,
					<argument><expr><name>PGC_BACKEND</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Keep us informed about subscription changes. */</comment>
	<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>SUBSCRIPTIONOID</name></expr></argument>,
								  <argument><expr><name>subscription_change_cb</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>am_tablesync_worker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication table synchronization worker for subscription \"%s\", table \"%s\" has started"</literal></expr></argument>,
						<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication apply worker for subscription \"%s\" has started"</literal></expr></argument>,
						<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Connect to the origin and start the replication. */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"connecting to publisher using connection string \"%s\""</literal></expr></argument>,
		 <argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>am_tablesync_worker</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>syncslotname</name></decl>;</decl_stmt>

		<comment type="block">/* This is table synchroniation worker, call initial sync. */</comment>
		<expr_stmt><expr><name>syncslotname</name> <operator>=</operator> <call><name>LogicalRepSyncTableStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>origin_startpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The slot name needs to be allocated in permanent memory context. */</comment>
		<expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ApplyContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>myslotname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>syncslotname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>syncslotname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* This is main apply worker */</comment>
		<decl_stmt><decl><type><name>RepOriginId</name></type> <name>originid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>startpointTLI</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>myslotname</name> <operator>=</operator> <name><name>MySubscription</name><operator>-&gt;</operator><name>slotname</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * This shouldn't happen if the subscription is enabled, but guard
		 * against DDL bugs or manual catalog changes.  (libpqwalreceiver will
		 * crash if slot is NULL.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>myslotname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subscription has no replication slot set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Setup replication origin tracking. */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>originname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>originname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_%u"</literal></expr></argument>, <argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>originid</name> <operator>=</operator> <call><name>replorigin_by_name</name><argument_list>(<argument><expr><name>originname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>originid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>originid</name> <operator>=</operator> <call><name>replorigin_create</name><argument_list>(<argument><expr><name>originname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>replorigin_session_setup</name><argument_list>(<argument><expr><name>originid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>replorigin_session_origin</name> <operator>=</operator> <name>originid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>origin_startpos</name> <operator>=</operator> <call><name>replorigin_session_get_progress</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>wrconn</name> <operator>=</operator> <call><name>walrcv_connect</name><argument_list>(<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>wrconn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to the publisher: %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We don't really use the output identify_system for anything but it
		 * does some initializations on the upstream so let's still call it.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>walrcv_identify_system</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>startpointTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Setup callback for syscache so that we know when something changes in
	 * the subscription relation state.
	 */</comment>
	<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>SUBSCRIPTIONRELMAP</name></expr></argument>,
								  <argument><expr><name>invalidate_syncing_table_states</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build logical replication streaming options. */</comment>
	<expr_stmt><expr><name><name>options</name><operator>.</operator><name>logical</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>options</name><operator>.</operator><name>startpoint</name></name> <operator>=</operator> <name>origin_startpos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>options</name><operator>.</operator><name>slotname</name></name> <operator>=</operator> <name>myslotname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>options</name><operator>.</operator><name>proto</name><operator>.</operator><name>logical</name><operator>.</operator><name>proto_version</name></name> <operator>=</operator> <name>LOGICALREP_PROTO_VERSION_NUM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>options</name><operator>.</operator><name>proto</name><operator>.</operator><name>logical</name><operator>.</operator><name>publication_names</name></name> <operator>=</operator> <name><name>MySubscription</name><operator>-&gt;</operator><name>publications</name></name></expr>;</expr_stmt>

	<comment type="block">/* Start normal logical streaming replication. */</comment>
	<expr_stmt><expr><call><name>walrcv_startstreaming</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Run the main loop. */</comment>
	<expr_stmt><expr><call><name>LogicalRepApplyLoop</name><argument_list>(<argument><expr><name>origin_startpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Is current process a logical replication worker?
 */</comment>
<function><type><name>bool</name></type>
<name>IsLogicalWorker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>MyLogicalRepWorker</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>
</unit>
