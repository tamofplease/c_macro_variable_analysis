<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/replication/logical/tablesync.c"><comment type="block">/*-------------------------------------------------------------------------
 * tablesync.c
 *	  PostgreSQL logical replication
 *
 * Copyright (c) 2012-2019, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/replication/logical/tablesync.c
 *
 * NOTES
 *	  This file contains code for initial table data synchronization for
 *	  logical replication.
 *
 *	  The initial data synchronization is done separately for each table,
 *	  in a separate apply worker that only fetches the initial snapshot data
 *	  from the publisher and then synchronizes the position in the stream with
 *	  the main apply worker.
 *
 *	  There are several reasons for doing the synchronization this way:
 *	   - It allows us to parallelize the initial data synchronization
 *		 which lowers the time needed for it to happen.
 *	   - The initial synchronization does not have to hold the xid and LSN
 *		 for the time it takes to copy data of all tables, causing less
 *		 bloat and lower disk consumption compared to doing the
 *		 synchronization in a single process for the whole database.
 *	   - It allows us to synchronize any tables added after the initial
 *		 synchronization has finished.
 *
 *	  The stream position synchronization works in multiple steps.
 *	   - Sync finishes copy and sets worker state as SYNCWAIT and waits for
 *		 state to change in a loop.
 *	   - Apply periodically checks tables that are synchronizing for SYNCWAIT.
 *		 When the desired state appears, it will set the worker state to
 *		 CATCHUP and starts loop-waiting until either the table state is set
 *		 to SYNCDONE or the sync worker exits.
 *	   - After the sync worker has seen the state change to CATCHUP, it will
 *		 read the stream and apply changes (acting like an apply worker) until
 *		 it catches up to the specified stream position.  Then it sets the
 *		 state to SYNCDONE.  There might be zero changes applied between
 *		 CATCHUP and SYNCDONE, because the sync worker might be ahead of the
 *		 apply worker.
 *	   - Once the state was set to SYNCDONE, the apply will continue tracking
 *		 the table until it reaches the SYNCDONE stream position, at which
 *		 point it sets state to READY and stops tracking.  Again, there might
 *		 be zero changes in between.
 *
 *	  So the state progression is always: INIT -&gt; DATASYNC -&gt; SYNCWAIT -&gt; CATCHUP -&gt;
 *	  SYNCDONE -&gt; READY.
 *
 *	  The catalog pg_subscription_rel is used to keep information about
 *	  subscribed tables and their state.  Some transient state during data
 *	  synchronization is kept in shared memory.  The states SYNCWAIT and
 *	  CATCHUP only appear in memory.
 *
 *	  Example flows look like this:
 *	   - Apply is in front:
 *		  sync:8
 *			-&gt; set in memory SYNCWAIT
 *		  apply:10
 *			-&gt; set in memory CATCHUP
 *			-&gt; enter wait-loop
 *		  sync:10
 *			-&gt; set in catalog SYNCDONE
 *			-&gt; exit
 *		  apply:10
 *			-&gt; exit wait-loop
 *			-&gt; continue rep
 *		  apply:11
 *			-&gt; set in catalog READY
 *	   - Sync in front:
 *		  sync:10
 *			-&gt; set in memory SYNCWAIT
 *		  apply:8
 *			-&gt; set in memory CATCHUP
 *			-&gt; continue per-table filtering
 *		  sync:10
 *			-&gt; set in catalog SYNCDONE
 *			-&gt; exit
 *		  apply:10
 *			-&gt; set in catalog READY
 *			-&gt; stop per-table filtering
 *			-&gt; continue rep
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription_rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicallauncher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicalrelation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/worker_internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>table_states_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>StringInfo</name></type>	<name>copybuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Exit routine for synchronization worker.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_attribute_noreturn</name><parameter_list>()</parameter_list>
finish_sync_worker<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Commit any outstanding transaction. This is the usual case, unless
	 * there was nothing to do for the table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_stat</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* And flush all writes. */</comment>
	<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><call><name>GetXLogWriteRecPtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logical replication table synchronization worker for subscription \"%s\", table \"%s\" has finished"</literal></expr></argument>,
					<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
					<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the main apply worker and signal it. */</comment>
	<expr_stmt><expr><call><name>logicalrep_worker_wakeup</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Stop gracefully */</comment>
	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait until the relation synchronization state is set in the catalog to the
 * expected one.
 *
 * Used when transitioning from CATCHUP state to SYNCDONE.
 *
 * Returns false if the synchronization worker has disappeared or the table state
 * has been reset.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>wait_for_relation_state_change</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>expected_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>state</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LogicalRepWorker</name> <modifier>*</modifier></type><name>worker</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>statelsn</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* XXX use cache invalidation here to improve performance? */</comment>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>GetSubscriptionRelState</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>,
										<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statelsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>SUBREL_STATE_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>expected_state</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Check if the sync worker is still running and bail if not. */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LogicalRepWorkerLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check if the opposite worker is still running and bail if not. */</comment>
		<expr_stmt><expr><name>worker</name> <operator>=</operator> <call><name>logicalrep_worker_find</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>,
										<argument><expr><ternary><condition><expr><call><name>am_tablesync_worker</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>relid</name></expr></else></ternary></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LogicalRepWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>worker</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
						 <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_EXIT_ON_PM_DEATH</name></expr></argument>,
						 <argument><expr><literal type="number">1000L</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_LOGICAL_SYNC_STATE_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait until the apply worker changes the state of our synchronization
 * worker to the expected one.
 *
 * Used when transitioning from SYNCWAIT state to CATCHUP.
 *
 * Returns false if the apply worker has disappeared.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>wait_for_worker_state_change</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>expected_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LogicalRepWorker</name> <modifier>*</modifier></type><name>worker</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Done if already in correct state.  (We assume this fetch is atomic
		 * enough to not give a misleading answer if we do it with no lock.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate</name></name> <operator>==</operator> <name>expected_state</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Bail out if the apply worker has died, else signal it we're
		 * waiting.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LogicalRepWorkerLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>worker</name> <operator>=</operator> <call><name>logicalrep_worker_find</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>worker</name> <operator>&amp;&amp;</operator> <name><name>worker</name><operator>-&gt;</operator><name>proc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logicalrep_worker_wakeup_ptr</name><argument_list>(<argument><expr><name>worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LogicalRepWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>worker</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Wait.  We expect to get a latch signal back from the apply worker,
		 * but use a timeout in case it dies without sending one.
		 */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
					   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_EXIT_ON_PM_DEATH</name></expr></argument>,
					   <argument><expr><literal type="number">1000L</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_LOGICAL_SYNC_STATE_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Callback from syscache invalidation.
 */</comment>
<function><type><name>void</name></type>
<name>invalidate_syncing_table_states</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>table_states_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle table synchronization cooperation from the synchronization
 * worker.
 *
 * If the sync worker is in CATCHUP state and reached (or passed) the
 * predetermined synchronization point in the WAL stream, mark the table as
 * SYNCDONE and finish.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_syncing_tables_for_sync</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>current_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relmutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate</name></name> <operator>==</operator> <name>SUBREL_STATE_CATCHUP</name> <operator>&amp;&amp;</operator>
		<name>current_lsn</name> <operator>&gt;=</operator> <name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate_lsn</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>tli</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate</name></name> <operator>=</operator> <name>SUBREL_STATE_SYNCDONE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate_lsn</name></name> <operator>=</operator> <name>current_lsn</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relmutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>UpdateSubscriptionRelState</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>,
								   <argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
								   <argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate</name></name></expr></argument>,
								   <argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>walrcv_endstreaming</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>finish_sync_worker</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relmutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle table synchronization cooperation from the apply worker.
 *
 * Walk over all subscription tables that are individually tracked by the
 * apply process (currently, all that have state other than
 * SUBREL_STATE_READY) and manage synchronization for them.
 *
 * If there are tables that need synchronizing and are not being synchronized
 * yet, start sync workers for them (if there are free slots for sync
 * workers).  To prevent starting the sync worker for the same relation at a
 * high frequency after a failure, we store its last start time with each sync
 * state info.  We start the sync worker for the same relation after waiting
 * at least wal_retrieve_retry_interval.
 *
 * For tables that are being synchronized already, check if sync workers
 * either need action from the apply worker or have finished.  This is the
 * SYNCWAIT to CATCHUP transition.
 *
 * If the synchronization position is reached (SYNCDONE), then the table can
 * be marked as READY and is no longer tracked.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_syncing_tables_for_apply</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>current_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<struct>struct <name>tablesync_start_time_mapping</name>
	<block>{
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>last_start_time</name></decl>;</decl_stmt>
	}</block>;</struct>
	<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>table_states</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>last_start_times</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>started_tx</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We need up-to-date sync state info for subscription tables here. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>table_states_valid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rstates</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SubscriptionRelState</name> <modifier>*</modifier></type><name>rstate</name></decl>;</decl_stmt>

		<comment type="block">/* Clean the old list. */</comment>
		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>table_states</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>table_states</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>started_tx</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* Fetch all non-ready tables. */</comment>
		<expr_stmt><expr><name>rstates</name> <operator>=</operator> <call><name>GetSubscriptionNotReadyRelations</name><argument_list>(<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Allocate the tracking info in a permanent memory context. */</comment>
		<expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rstates</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>rstate</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SubscriptionRelState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>rstate</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SubscriptionRelState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>table_states</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>table_states</name></expr></argument>, <argument><expr><name>rstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>table_states_valid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Prepare a hash table for tracking last start times of workers, to avoid
	 * immediate restarts.  We don't need it if there are no tables that need
	 * syncing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>table_states</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>last_start_times</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>tablesync_start_time_mapping</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_start_times</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Logical replication table sync worker start times"</literal></expr></argument>,
									   <argument><expr><literal type="number">256</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * Clean up the hash table when we're done with all tables (just to
	 * release the bit of memory).
	 */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>table_states</name> <operator>&amp;&amp;</operator> <name>last_start_times</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>last_start_times</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_start_times</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process all tables that are being synchronized.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>table_states</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubscriptionRelState</name> <modifier>*</modifier></type><name>rstate</name> <init>= <expr><operator>(</operator><name>SubscriptionRelState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rstate</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SUBREL_STATE_SYNCDONE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Apply has caught up to the position where the table sync has
			 * finished.  Mark the table as ready so that the apply will just
			 * continue to replicate it normally.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>current_lsn</name> <operator>&gt;=</operator> <name><name>rstate</name><operator>-&gt;</operator><name>lsn</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>rstate</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>SUBREL_STATE_READY</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rstate</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <name>current_lsn</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>started_tx</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>started_tx</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>UpdateSubscriptionRelState</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>,
										   <argument><expr><name><name>rstate</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>rstate</name><operator>-&gt;</operator><name>state</name></name></expr></argument>,
										   <argument><expr><name><name>rstate</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>LogicalRepWorker</name> <modifier>*</modifier></type><name>syncworker</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Look for a sync worker for this relation.
			 */</comment>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>LogicalRepWorkerLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>syncworker</name> <operator>=</operator> <call><name>logicalrep_worker_find</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>,
												<argument><expr><name><name>rstate</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>syncworker</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found one, update our copy of its state */</comment>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>syncworker</name><operator>-&gt;</operator><name>relmutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rstate</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name><name>syncworker</name><operator>-&gt;</operator><name>relstate</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rstate</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <name><name>syncworker</name><operator>-&gt;</operator><name>relstate_lsn</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rstate</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SUBREL_STATE_SYNCWAIT</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Sync worker is waiting for apply.  Tell sync worker it
					 * can catchup now.
					 */</comment>
					<expr_stmt><expr><name><name>syncworker</name><operator>-&gt;</operator><name>relstate</name></name> <operator>=</operator> <name>SUBREL_STATE_CATCHUP</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>syncworker</name><operator>-&gt;</operator><name>relstate_lsn</name></name> <operator>=</operator>
						<call><name>Max</name><argument_list>(<argument><expr><name><name>syncworker</name><operator>-&gt;</operator><name>relstate_lsn</name></name></expr></argument>, <argument><expr><name>current_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>syncworker</name><operator>-&gt;</operator><name>relmutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* If we told worker to catch up, wait for it. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rstate</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>SUBREL_STATE_SYNCWAIT</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Signal the sync worker, as it may be waiting for us. */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>syncworker</name><operator>-&gt;</operator><name>proc</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>logicalrep_worker_wakeup_ptr</name><argument_list>(<argument><expr><name>syncworker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Now safe to release the LWLock */</comment>
					<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LogicalRepWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Enter busy loop and wait for synchronization worker to
					 * reach expected state (or die trying).
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>started_tx</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>started_tx</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>wait_for_relation_state_change</name><argument_list>(<argument><expr><name><name>rstate</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
												   <argument><expr><name>SUBREL_STATE_SYNCDONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LogicalRepWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * If there is no sync worker for this table yet, count
				 * running sync workers for this subscription, while we have
				 * the lock.
				 */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>nsyncworkers</name> <init>=
				<expr><call><name>logicalrep_sync_worker_count</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Now safe to release the LWLock */</comment>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>LogicalRepWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If there are free sync worker slot(s), start a new sync
				 * worker for the table.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>nsyncworkers</name> <operator>&lt;</operator> <name>max_sync_workers_per_subscription</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name><name>struct</name> <name>tablesync_start_time_mapping</name></name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>hentry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>last_start_times</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rstate</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
										 <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator>
						<call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>last_start_time</name></name></expr></argument>, <argument><expr><name>now</name></expr></argument>,
												   <argument><expr><name>wal_retrieve_retry_interval</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>logicalrep_worker_launch</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>,
												 <argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>,
												 <argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
												 <argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>userid</name></name></expr></argument>,
												 <argument><expr><name><name>rstate</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>last_start_time</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>started_tx</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_stat</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process possible state change(s) of tables that are being synchronized.
 */</comment>
<function><type><name>void</name></type>
<name>process_syncing_tables</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>current_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>am_tablesync_worker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>process_syncing_tables_for_sync</name><argument_list>(<argument><expr><name>current_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>process_syncing_tables_for_apply</name><argument_list>(<argument><expr><name>current_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create list of columns for COPY based on logical relation mapping.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>make_copy_attnamelist</name><parameter_list>(<parameter><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnamelist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>attnamelist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>attnamelist</name></expr></argument>,
							  <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>remoterel</name><operator>.</operator><name>attnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>


	<return>return <expr><name>attnamelist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Data source callback for the COPY FROM, which reads from the remote
 * connection and passes the data back to our local COPY.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>copy_read_data</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>outbuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minread</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxread</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytesread</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>avail</name></decl>;</decl_stmt>

	<comment type="block">/* If there are some leftover data from previous read, use it. */</comment>
	<expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>copybuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>copybuf</name><operator>-&gt;</operator><name>cursor</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>avail</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&gt;</operator> <name>maxread</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>avail</name> <operator>=</operator> <name>maxread</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copybuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>copybuf</name><operator>-&gt;</operator><name>cursor</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>copybuf</name><operator>-&gt;</operator><name>cursor</name></name> <operator>+=</operator> <name>avail</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxread</name> <operator>-=</operator> <name>avail</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesread</name> <operator>+=</operator> <name>avail</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>maxread</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bytesread</name> <operator>&lt;</operator> <name>minread</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pgsocket</name></type>	<name>fd</name> <init>= <expr><name>PGINVALID_SOCKET</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<comment type="block">/* Try read the data. */</comment>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>walrcv_receive</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>bytesread</name></expr>;</return></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Process the data */</comment>
				<expr_stmt><expr><name><name>copybuf</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>copybuf</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>copybuf</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>copybuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>copybuf</name><operator>-&gt;</operator><name>cursor</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>avail</name> <operator>&gt;</operator> <name>maxread</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>avail</name> <operator>=</operator> <name>maxread</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copybuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>copybuf</name><operator>-&gt;</operator><name>cursor</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>outbuf</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>outbuf</name> <operator>+</operator> <name>avail</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>copybuf</name><operator>-&gt;</operator><name>cursor</name></name> <operator>+=</operator> <name>avail</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>maxread</name> <operator>-=</operator> <name>avail</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>bytesread</name> <operator>+=</operator> <name>avail</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>maxread</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>bytesread</name> <operator>&gt;=</operator> <name>minread</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>bytesread</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Wait for more data or latch.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
								 <argument><expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_LATCH_SET</name> <operator>|</operator>
								 <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_EXIT_ON_PM_DEATH</name></expr></argument>,
								 <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">1000L</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_LOGICAL_SYNC_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>bytesread</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Get information about remote relation in similar fashion the RELATION
 * message provides during replication.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fetch_remote_table_info</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>,
						<parameter><decl><type><name>LogicalRepRelation</name> <modifier>*</modifier></type><name>lrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WalRcvExecResult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>tableRow</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>OIDOID</name></expr>, <expr><name>CHAROID</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>attrRow</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>TEXTOID</name></expr>, <expr><name>OIDOID</name></expr>, <expr><name>INT4OID</name></expr>, <expr><name>BOOLOID</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>lrel</name><operator>-&gt;</operator><name>nspname</name></name> <operator>=</operator> <name>nspname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lrel</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <name>relname</name></expr>;</expr_stmt>

	<comment type="block">/* First fetch Oid and replica identity. */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"SELECT c.oid, c.relreplident"</literal>
					 <literal type="string">"  FROM pg_catalog.pg_class c"</literal>
					 <literal type="string">"  INNER JOIN pg_catalog.pg_namespace n"</literal>
					 <literal type="string">"        ON (c.relnamespace = n.oid)"</literal>
					 <literal type="string">" WHERE n.nspname = %s"</literal>
					 <literal type="string">"   AND c.relname = %s"</literal>
					 <literal type="string">"   AND c.relkind = 'r'"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walrcv_exec</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>tableRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>WALRCV_OK_TUPLES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fetch table info for table \"%s.%s\" from publisher: %s"</literal></expr></argument>,
						<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>tupledesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>tuplestore</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s.%s\" not found on publisher"</literal></expr></argument>,
						<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>lrel</name><operator>-&gt;</operator><name>remoteid</name></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lrel</name><operator>-&gt;</operator><name>replident</name></name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>walrcv_clear_result</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now fetch columns. */</comment>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT a.attname,"</literal>
					 <literal type="string">"       a.atttypid,"</literal>
					 <literal type="string">"       a.atttypmod,"</literal>
					 <literal type="string">"       a.attnum = ANY(i.indkey)"</literal>
					 <literal type="string">"  FROM pg_catalog.pg_attribute a"</literal>
					 <literal type="string">"  LEFT JOIN pg_catalog.pg_index i"</literal>
					 <literal type="string">"       ON (i.indexrelid = pg_get_replica_identity_index(%u))"</literal>
					 <literal type="string">" WHERE a.attnum &gt; 0::pg_catalog.int2"</literal>
					 <literal type="string">"   AND NOT a.attisdropped %s"</literal>
					 <literal type="string">"   AND a.attrelid = %u"</literal>
					 <literal type="string">" ORDER BY a.attnum"</literal></expr></argument>,
					 <argument><expr><name><name>lrel</name><operator>-&gt;</operator><name>remoteid</name></name></expr></argument>,
					 <argument><expr><operator>(</operator><ternary><condition><expr><call><name>walrcv_server_version</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">120000</literal></expr> ?</condition><then> <expr><literal type="string">"AND a.attgenerated = ''"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
					 <argument><expr><name><name>lrel</name><operator>-&gt;</operator><name>remoteid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walrcv_exec</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>attrRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>WALRCV_OK_TUPLES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fetch table info for table \"%s.%s\": %s"</literal></expr></argument>,
						<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We don't know the number of rows coming, so allocate enough space. */</comment>
	<expr_stmt><expr><name><name>lrel</name><operator>-&gt;</operator><name>attnames</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>MaxTupleAttributeNumber</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lrel</name><operator>-&gt;</operator><name>atttyps</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>MaxTupleAttributeNumber</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lrel</name><operator>-&gt;</operator><name>attkeys</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>natt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>tupledesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>tuplestore</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lrel</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>natt</name></expr>]</index></name> <operator>=</operator>
			<call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lrel</name><operator>-&gt;</operator><name>atttyps</name><index>[<expr><name>natt</name></expr>]</index></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lrel</name><operator>-&gt;</operator><name>attkeys</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>lrel</name><operator>-&gt;</operator><name>attkeys</name></name></expr></argument>, <argument><expr><name>natt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Should never happen. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>++</operator><name>natt</name> <operator>&gt;=</operator> <name>MaxTupleAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many columns in remote table \"%s.%s\""</literal></expr></argument>,
				 <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lrel</name><operator>-&gt;</operator><name>natts</name></name> <operator>=</operator> <name>natt</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>walrcv_clear_result</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy existing data of a table from publisher.
 *
 * Caller is responsible for locking the local relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_table</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalRepRelMapEntry</name> <modifier>*</modifier></type><name>relmapentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRepRelation</name></type> <name>lrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalRcvExecResult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyState</name></type>	<name>cstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnamelist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>

	<comment type="block">/* Get the publisher relation info. */</comment>
	<expr_stmt><expr><call><name>fetch_remote_table_info</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>lrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Put the relation into relmap. */</comment>
	<expr_stmt><expr><call><name>logicalrep_relmap_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Map the publisher relation to local one. */</comment>
	<expr_stmt><expr><name>relmapentry</name> <operator>=</operator> <call><name>logicalrep_rel_open</name><argument_list>(<argument><expr><name><name>lrel</name><operator>.</operator><name>remoteid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rel</name> <operator>==</operator> <name><name>relmapentry</name><operator>-&gt;</operator><name>localrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Start copy on the publisher. */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"COPY %s TO STDOUT"</literal></expr></argument>,
					 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name><name>lrel</name><operator>.</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>lrel</name><operator>.</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walrcv_exec</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>WALRCV_OK_COPY_OUT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not start initial contents copy for table \"%s.%s\": %s"</literal></expr></argument>,
						<argument><expr><name><name>lrel</name><operator>.</operator><name>nspname</name></name></expr></argument>, <argument><expr><name><name>lrel</name><operator>.</operator><name>relname</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>walrcv_clear_result</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>copybuf</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnamelist</name> <operator>=</operator> <call><name>make_copy_attnamelist</name><argument_list>(<argument><expr><name>relmapentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cstate</name> <operator>=</operator> <call><name>BeginCopyFrom</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>copy_read_data</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* callback extra data */</comment>,
						   <argument><expr><name>attnamelist</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do the copy */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CopyFrom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>logicalrep_rel_close</name><argument_list>(<argument><expr><name>relmapentry</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Start syncing the table in the sync worker.
 *
 * The returned slot name is palloc'ed in current memory context.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>LogicalRepSyncTableStart</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>origin_startpos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>slotname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>relstate_lsn</name></decl>;</decl_stmt>

	<comment type="block">/* Check the state of the table synchronization. */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relstate</name> <operator>=</operator> <call><name>GetSubscriptionRelState</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>,
									   <argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>relstate_lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relmutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate</name></name> <operator>=</operator> <name>relstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate_lsn</name></name> <operator>=</operator> <name>relstate_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relmutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To build a slot name for the sync work, we are limited to NAMEDATALEN -
	 * 1 characters.  We cut the original slot name to NAMEDATALEN - 28 chars
	 * and append _%u_sync_%u (1 + 10 + 6 + 10 + '\0').  (It's actually the
	 * NAMEDATALEN on the remote that matters, but this scheme will also work
	 * reasonably if that is different.)
	 */</comment>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><name>NAMEDATALEN</name> <operator>&gt;=</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><literal type="string">"NAMEDATALEN too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* for sanity */</comment>
	<expr_stmt><expr><name>slotname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%.*s_%u_sync_%u"</literal></expr></argument>,
						<argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">28</literal></expr></argument>,
						<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>,
						<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>,
						<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Here we use the slot name instead of the subscription name as the
	 * application_name, so that it is different from the main apply worker,
	 * so that synchronous replication can distinguish them.
	 */</comment>
	<expr_stmt><expr><name>wrconn</name> <operator>=</operator> <call><name>walrcv_connect</name><argument_list>(<argument><expr><name><name>MySubscription</name><operator>-&gt;</operator><name>conninfo</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>slotname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>wrconn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to the publisher: %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SUBREL_STATE_INIT</name></expr>:</case>
		<case>case <expr><name>SUBREL_STATE_DATASYNC</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>WalRcvExecResult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relmutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate</name></name> <operator>=</operator> <name>SUBREL_STATE_DATASYNC</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relmutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Update the state and make it visible to others. */</comment>
				<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>UpdateSubscriptionRelState</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>,
										   <argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
										   <argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate</name></name></expr></argument>,
										   <argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_report_stat</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We want to do the table data sync in a single transaction.
				 */</comment>
				<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Use a standard write lock here. It might be better to
				 * disallow access to the table while it's being synchronized.
				 * But we don't want to block the main apply process from
				 * working and it has to open the relation in RowExclusiveLock
				 * when remapping remote relation id to local one.
				 */</comment>
				<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Create a temporary slot for the sync process. We do this
				 * inside the transaction so that we can use the snapshot made
				 * by the slot to get existing data.
				 */</comment>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walrcv_exec</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>,
								  <argument><expr><literal type="string">"BEGIN READ ONLY ISOLATION LEVEL "</literal>
								  <literal type="string">"REPEATABLE READ"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>WALRCV_OK_COMMAND</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table copy could not start transaction on publisher"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The error was: %s"</literal></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>walrcv_clear_result</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Create new temporary logical decoding slot.
				 *
				 * We'll use slot for data copy so make sure the snapshot is
				 * used for the transaction; that way the COPY will get data
				 * that is consistent with the lsn used by the slot to start
				 * decoding.
				 */</comment>
				<expr_stmt><expr><call><name>walrcv_create_slot</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><name>slotname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								   <argument><expr><name>CRS_USE_SNAPSHOT</name></expr></argument>, <argument><expr><name>origin_startpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>copy_table</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>walrcv_exec</name><argument_list>(<argument><expr><name>wrconn</name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>WALRCV_OK_COMMAND</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table copy could not finish transaction on publisher"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The error was: %s"</literal></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>walrcv_clear_result</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Make the copy visible. */</comment>
				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We are done with the initial data synchronization, update
				 * the state.
				 */</comment>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relmutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate</name></name> <operator>=</operator> <name>SUBREL_STATE_SYNCWAIT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate_lsn</name></name> <operator>=</operator> <operator>*</operator><name>origin_startpos</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relmutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Wait for main apply worker to tell us to catchup. */</comment>
				<expr_stmt><expr><call><name>wait_for_worker_state_change</name><argument_list>(<argument><expr><name>SUBREL_STATE_CATCHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*----------
				 * There are now two possible states here:
				 * a) Sync is behind the apply.  If that's the case we need to
				 *	  catch up with it by consuming the logical replication
				 *	  stream up to the relstate_lsn.  For that, we exit this
				 *	  function and continue in ApplyWorkerMain().
				 * b) Sync is caught up with the apply.  So it can just set
				 *	  the state to SYNCDONE and finish.
				 *----------
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>origin_startpos</name> <operator>&gt;=</operator> <name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate_lsn</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Update the new state in catalog.  No need to bother
					 * with the shmem state as we are exiting for good.
					 */</comment>
					<expr_stmt><expr><call><name>UpdateSubscriptionRelState</name><argument_list>(<argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>subid</name></name></expr></argument>,
											   <argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
											   <argument><expr><name>SUBREL_STATE_SYNCDONE</name></expr></argument>,
											   <argument><expr><operator>*</operator><name>origin_startpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>finish_sync_worker</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>SUBREL_STATE_SYNCDONE</name></expr>:</case>
		<case>case <expr><name>SUBREL_STATE_READY</name></expr>:</case>
		<case>case <expr><name>SUBREL_STATE_UNKNOWN</name></expr>:</case>

			<comment type="block">/*
			 * Nothing to do here but finish.  (UNKNOWN means the relation was
			 * removed from pg_subscription_rel before the sync worker could
			 * start.)
			 */</comment>
			<expr_stmt><expr><call><name>finish_sync_worker</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown relation state \"%c\""</literal></expr></argument>,
				 <argument><expr><name><name>MyLogicalRepWorker</name><operator>-&gt;</operator><name>relstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>slotname</name></expr>;</return>
</block_content>}</block></function>
</unit>
