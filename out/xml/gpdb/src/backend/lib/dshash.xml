<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/lib/dshash.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * dshash.c
 *	  Concurrent hash tables backed by dynamic shared memory areas.
 *
 * This is an open hashing hash table, with a linked list at each table
 * entry.  It supports dynamic resizing, as required to prevent the linked
 * lists from growing too long on average.  Currently, only growing is
 * supported: the hash table never becomes smaller.
 *
 * To deal with concurrency, it has a fixed size set of partitions, each of
 * which is independently locked.  Each bucket maps to a partition; so insert,
 * find and iterate operations normally only acquire one lock.  Therefore,
 * good concurrency is achieved whenever such operations don't collide at the
 * lock partition level.  However, when a resize operation begins, all
 * partition locks must be acquired simultaneously for a brief period.  This
 * is only expected to happen a small number of times until a stable size is
 * found, since growth is geometric.
 *
 * Future versions may support iterators and incremental resizing; for now
 * the implementation is minimalist.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/lib/dshash.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/dshash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/dsa.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * An item in the hash table.  This wraps the user's entry object in an
 * envelop that holds a pointer back to the bucket and a pointer to the next
 * item in the bucket.
 */</comment>
<struct>struct <name>dshash_table_item</name>
<block>{
	<comment type="block">/* The next item in the same bucket. */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>next</name></decl>;</decl_stmt>
	<comment type="block">/* The hashed key, to avoid having to recompute it. */</comment>
	<decl_stmt><decl><type><name>dshash_hash</name></type> <name>hash</name></decl>;</decl_stmt>
	<comment type="block">/* The user's entry object follows here.  See ENTRY_FROM_ITEM(item). */</comment>
}</block>;</struct>

<comment type="block">/*
 * The number of partitions for locking purposes.  This is set to match
 * NUM_BUFFER_PARTITIONS for now, on the basis that whatever's good enough for
 * the buffer pool must be good enough for any other purpose.  This could
 * become a runtime parameter in future.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSHASH_NUM_PARTITIONS_LOG2</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSHASH_NUM_PARTITIONS</name></cpp:macro> <cpp:value>(1 &lt;&lt; DSHASH_NUM_PARTITIONS_LOG2)</cpp:value></cpp:define>

<comment type="block">/* A magic value used to identify our hash tables. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSHASH_MAGIC</name></cpp:macro> <cpp:value>0x75ff6a20</cpp:value></cpp:define>

<comment type="block">/*
 * Tracking information for each lock partition.  Initially, each partition
 * corresponds to one bucket, but each time the hash table grows, the buckets
 * covered by each partition split so the number of buckets covered doubles.
 *
 * We might want to add padding here so that each partition is on a different
 * cache line, but doing so would bloat this structure considerably.
 */</comment>
<typedef>typedef <type><struct>struct <name>dshash_partition</name>
<block>{
	<decl_stmt><decl><type><name>LWLock</name></type>		<name>lock</name></decl>;</decl_stmt>			<comment type="block">/* Protects all buckets in this partition. */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>count</name></decl>;</decl_stmt>			<comment type="block">/* # of items in this partition's buckets */</comment>
}</block></struct></type> <name>dshash_partition</name>;</typedef>

<comment type="block">/*
 * The head object for a hash table.  This will be stored in dynamic shared
 * memory.
 */</comment>
<typedef>typedef <type><struct>struct <name>dshash_table_control</name>
<block>{
	<decl_stmt><decl><type><name>dshash_table_handle</name></type> <name>handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>magic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dshash_partition</name></type> <name><name>partitions</name><index>[<expr><name>DSHASH_NUM_PARTITIONS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lwlock_tranche_id</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The following members are written to only when ALL partitions locks are
	 * held.  They can be read when any one partition lock is held.
	 */</comment>

	<comment type="block">/* Number of buckets expressed as power of 2 (8 = 256 buckets). */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>size_log2</name></decl>;</decl_stmt>		<comment type="block">/* log2(number of buckets) */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>buckets</name></decl>;</decl_stmt>		<comment type="block">/* current bucket array */</comment>
}</block></struct></type> <name>dshash_table_control</name>;</typedef>

<comment type="block">/*
 * Per-backend state for a dynamic hash table.
 */</comment>
<struct>struct <name>dshash_table</name>
<block>{
	<decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>area</name></decl>;</decl_stmt>			<comment type="block">/* Backing dynamic shared memory area. */</comment>
	<decl_stmt><decl><type><name>dshash_parameters</name></type> <name>params</name></decl>;</decl_stmt>	<comment type="block">/* Parameters. */</comment>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>			<comment type="block">/* User-supplied data pointer. */</comment>
	<decl_stmt><decl><type><name>dshash_table_control</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt>	<comment type="block">/* Control object in DSM. */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>buckets</name></decl>;</decl_stmt>		<comment type="block">/* Current bucket pointers in DSM. */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>size_log2</name></decl>;</decl_stmt>		<comment type="block">/* log2(number of buckets) */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>find_locked</name></decl>;</decl_stmt>	<comment type="block">/* Is any partition lock held by 'find'? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>find_exclusively_locked</name></decl>;</decl_stmt>	<comment type="block">/* ... exclusively? */</comment>
}</block>;</struct>

<comment type="block">/* Given a pointer to an item, find the entry (user data) it holds. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTRY_FROM_ITEM</name><parameter_list>(<parameter><type><name>item</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((char *)(item) + MAXALIGN(sizeof(dshash_table_item)))</cpp:value></cpp:define>

<comment type="block">/* Given a pointer to an entry, find the item that holds it. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ITEM_FROM_ENTRY</name><parameter_list>(<parameter><type><name>entry</name></type></parameter>)</parameter_list></cpp:macro>											\
	<cpp:value>((dshash_table_item *)((char *)(entry) -							\
							 MAXALIGN(sizeof(dshash_table_item))))</cpp:value></cpp:define>

<comment type="block">/* How many resize operations (bucket splits) have there been? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_SPLITS</name><parameter_list>(<parameter><type><name>size_log2</name></type></parameter>)</parameter_list></cpp:macro>					\
	<cpp:value>(size_log2 - DSHASH_NUM_PARTITIONS_LOG2)</cpp:value></cpp:define>

<comment type="block">/* How many buckets are there in each partition at a given size? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKETS_PER_PARTITION</name><parameter_list>(<parameter><type><name>size_log2</name></type></parameter>)</parameter_list></cpp:macro>		\
	<cpp:value>(((size_t) 1) &lt;&lt; NUM_SPLITS(size_log2))</cpp:value></cpp:define>

<comment type="block">/* Max entries before we need to grow.  Half + quarter = 75% load factor. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_COUNT_PER_PARTITION</name><parameter_list>(<parameter><type><name>hash_table</name></type></parameter>)</parameter_list></cpp:macro>				\
	<cpp:value>(BUCKETS_PER_PARTITION(hash_table-&gt;size_log2) / 2 + \
	 BUCKETS_PER_PARTITION(hash_table-&gt;size_log2) / 4)</cpp:value></cpp:define>

<comment type="block">/* Choose partition based on the highest order bits of the hash. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARTITION_FOR_HASH</name><parameter_list>(<parameter><type><name>hash</name></type></parameter>)</parameter_list></cpp:macro>										\
	<cpp:value>(hash &gt;&gt; ((sizeof(dshash_hash) * CHAR_BIT) - DSHASH_NUM_PARTITIONS_LOG2))</cpp:value></cpp:define>

<comment type="block">/*
 * Find the bucket index for a given hash and table size.  Each time the table
 * doubles in size, the appropriate bucket for a given hash value doubles and
 * possibly adds one, depending on the newly revealed bit, so that all buckets
 * are split.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKET_INDEX_FOR_HASH_AND_SIZE</name><parameter_list>(<parameter><type><name>hash</name></type></parameter>, <parameter><type><name>size_log2</name></type></parameter>)</parameter_list></cpp:macro>		\
	<cpp:value>(hash &gt;&gt; ((sizeof(dshash_hash) * CHAR_BIT) - (size_log2)))</cpp:value></cpp:define>

<comment type="block">/* The index of the first bucket in a given partition. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKET_INDEX_FOR_PARTITION</name><parameter_list>(<parameter><type><name>partition</name></type></parameter>, <parameter><type><name>size_log2</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>((partition) &lt;&lt; NUM_SPLITS(size_log2))</cpp:value></cpp:define>

<comment type="block">/* The head of the active bucket for a given hash value (lvalue). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUCKET_FOR_HASH</name><parameter_list>(<parameter><type><name>hash_table</name></type></parameter>, <parameter><type><name>hash</name></type></parameter>)</parameter_list></cpp:macro>								\
	<cpp:value>(hash_table-&gt;buckets[												\
		BUCKET_INDEX_FOR_HASH_AND_SIZE(hash,							\
									   hash_table-&gt;size_log2)])</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>delete_item</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>,
						<parameter><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resize</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>new_size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>ensure_valid_bucket_pointers</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>dshash_table_item</name> <modifier>*</modifier></type><name>find_in_bucket</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>,
												<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
												<parameter><decl><type><name>dsa_pointer</name></type> <name>item_pointer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>insert_item_into_bucket</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>,
									<parameter><decl><type><name>dsa_pointer</name></type> <name>item_pointer</name></decl></parameter>,
									<parameter><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl></parameter>,
									<parameter><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>bucket</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>dshash_table_item</name> <modifier>*</modifier></type><name>insert_into_bucket</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>,
											 <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
											 <parameter><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>bucket</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>delete_key_from_bucket</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
								   <parameter><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>bucket_head</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>delete_item_from_bucket</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>,
									<parameter><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl></parameter>,
									<parameter><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>bucket_head</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>dshash_hash</name></type> <name>hash_key</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>equal_keys</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARTITION_LOCK</name><parameter_list>(<parameter><type><name>hash_table</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>			\
	<cpp:value>(&amp;(hash_table)-&gt;control-&gt;partitions[(i)].lock)</cpp:value></cpp:define>

<comment type="block">/*
 * Create a new hash table backed by the given dynamic shared area, with the
 * given parameters.  The returned object is allocated in backend-local memory
 * using the current MemoryContext.  'arg' will be passed through to the
 * compare and hash functions.
 */</comment>
<function><type><name>dshash_table</name> <modifier>*</modifier></type>
<name>dshash_create</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dshash_parameters</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>control</name></decl>;</decl_stmt>

	<comment type="block">/* Allocate the backend-local object representing the hash table. */</comment>
	<expr_stmt><expr><name>hash_table</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dshash_table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate the control object in shared memory. */</comment>
	<expr_stmt><expr><name>control</name> <operator>=</operator> <call><name>dsa_allocate</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dshash_table_control</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up the local and shared hash table structs. */</comment>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name> <operator>=</operator> <name>area</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <operator>*</operator><name>params</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name></name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>control</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <name>control</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>DSHASH_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>tranche_id</name></name></expr>;</expr_stmt>

	<comment type="block">/* Set up the array of lock partitions. */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dshash_partition</name> <modifier>*</modifier></type><name>partitions</name> <init>= <expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>partitions</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>tranche_id</name> <init>= <expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DSHASH_NUM_PARTITIONS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partitions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>tranche_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>partitions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_locked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_exclusively_locked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up the initial array of buckets.  Our initial size is the same as
	 * the number of partitions.
	 */</comment>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>size_log2</name></name> <operator>=</operator> <name>DSHASH_NUM_PARTITIONS_LOG2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator>
		<call><name>dsa_allocate_extended</name><argument_list>(<argument><expr><name>area</name></expr></argument>,
							  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>DSHASH_NUM_PARTITIONS</name></expr></argument>,
							  <argument><expr><name>DSA_ALLOC_NO_OOM</name> <operator>|</operator> <name>DSA_ALLOC_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>control</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on DSA request of size %zu."</literal></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>DSHASH_NUM_PARTITIONS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>,
										  <argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>size_log2</name></name> <operator>=</operator> <name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>size_log2</name></name></expr>;</expr_stmt>

	<return>return <expr><name>hash_table</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Attach to an existing hash table using a handle.  The returned object is
 * allocated in backend-local memory using the current MemoryContext.  'arg'
 * will be passed through to the compare and hash functions.
 */</comment>
<function><type><name>dshash_table</name> <modifier>*</modifier></type>
<name>dshash_attach</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dshash_parameters</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
			  <parameter><decl><type><name>dshash_table_handle</name></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>control</name></decl>;</decl_stmt>

	<comment type="block">/* Allocate the backend-local object representing the hash table. */</comment>
	<expr_stmt><expr><name>hash_table</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dshash_table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the control object in shared memory. */</comment>
	<expr_stmt><expr><name>control</name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>

	<comment type="block">/* Set up the local hash table struct. */</comment>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name> <operator>=</operator> <name>area</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <operator>*</operator><name>params</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name></name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>control</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_locked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_exclusively_locked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>DSHASH_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * These will later be set to the correct values by
	 * ensure_valid_bucket_pointers(), at which time we'll be holding a
	 * partition lock for interlocking against concurrent resizing.
	 */</comment>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>size_log2</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>hash_table</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Detach from a hash table.  This frees backend-local resources associated
 * with the hash table, but the hash table will continue to exist until it is
 * either explicitly destroyed (by a backend that is still attached to it), or
 * the area that backs it is returned to the operating system.
 */</comment>
<function><type><name>void</name></type>
<name>dshash_detach</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>hash_table</name><operator>-&gt;</operator><name>find_locked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The hash table may have been destroyed.  Just free local memory. */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Destroy a hash table, returning all memory to the area.  The caller must be
 * certain that no other backend will attempt to access the hash table before
 * calling this function.  Other backend must explicitly call dshash_detach to
 * free up backend-local memory associated with the hash table.  The backend
 * that calls dshash_destroy must not call dshash_detach.
 */</comment>
<function><type><name>void</name></type>
<name>dshash_destroy</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>DSHASH_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ensure_valid_bucket_pointers</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Free all the entries. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>hash_table</name><operator>-&gt;</operator><name>size_log2</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>item_pointer</name> <init>= <expr><name><name>hash_table</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name>item_pointer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>next_item_pointer</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name>item_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>next_item_pointer</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name>item_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>item_pointer</name> <operator>=</operator> <name>next_item_pointer</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Vandalize the control block to help catch programming errors where
	 * other backends access the memory formerly occupied by this hash table.
	 */</comment>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Free the active table and control object. */</comment>
	<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get a handle that can be used by other processes to attach to this hash
 * table.
 */</comment>
<function><type><name>dshash_table_handle</name></type>
<name>dshash_get_hash_table_handle</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>DSHASH_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>handle</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Look up an entry, given a key.  Returns a pointer to an entry if one can be
 * found with the given key.  Returns NULL if the key is not found.  If a
 * non-NULL value is returned, the entry is locked and must be released by
 * calling dshash_release_lock.  If an error is raised before
 * dshash_release_lock is called, the lock will be released automatically, but
 * the caller must take care to ensure that the entry is not left corrupted.
 * The lock mode is either shared or exclusive depending on 'exclusive'.
 *
 * The caller must not lock a lock already.
 *
 * Note that the lock held is in fact an LWLock, so interrupts will be held on
 * return from this function, and not resumed until dshash_release_lock is
 * called.  It is a very good idea for the caller to release the lock quickly.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>dshash_find</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>exclusive</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dshash_hash</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>partition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_key</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partition</name> <operator>=</operator> <call><name>PARTITION_FOR_HASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>DSHASH_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>hash_table</name><operator>-&gt;</operator><name>find_locked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><ternary><condition><expr><name>exclusive</name></expr> ?</condition><then> <expr><name>LW_EXCLUSIVE</name></expr> </then><else>: <expr><name>LW_SHARED</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ensure_valid_bucket_pointers</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Search the active bucket. */</comment>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>find_in_bucket</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>BUCKET_FOR_HASH</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Not found. */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* The caller will free the lock by calling dshash_release. */</comment>
		<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_locked</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_exclusively_locked</name></name> <operator>=</operator> <name>exclusive</name></expr>;</expr_stmt>
		<return>return <expr><call><name>ENTRY_FROM_ITEM</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a pointer to an exclusively locked item which must be released with
 * dshash_release_lock.  If the key is found in the hash table, 'found' is set
 * to true and a pointer to the existing entry is returned.  If the key is not
 * found, 'found' is set to false, and a pointer to a newly created entry is
 * returned.
 *
 * Notes above dshash_find() regarding locking and error handling equally
 * apply here.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>dshash_find_or_insert</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dshash_hash</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>partition_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dshash_partition</name> <modifier>*</modifier></type><name>partition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_key</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partition_index</name> <operator>=</operator> <call><name>PARTITION_FOR_HASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partition</name> <operator>=</operator> <operator>&amp;</operator><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>partition_index</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>DSHASH_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>hash_table</name><operator>-&gt;</operator><name>find_locked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>restart</name>:</label>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>partition_index</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ensure_valid_bucket_pointers</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Search the active bucket. */</comment>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>find_in_bucket</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>BUCKET_FOR_HASH</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Check if we are getting too full. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>partition</name><operator>-&gt;</operator><name>count</name></name> <operator>&gt;</operator> <call><name>MAX_COUNT_PER_PARTITION</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The load factor (= keys / buckets) for all buckets protected by
			 * this partition is &gt; 0.75.  Presumably the same applies
			 * generally across the whole hash table (though we don't attempt
			 * to track that directly to avoid contention on some kind of
			 * central counter; we just assume that this partition is
			 * representative).  This is a good time to resize.
			 *
			 * Give up our existing lock first, because resizing needs to
			 * reacquire all the locks in the right order to avoid deadlocks.
			 */</comment>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>partition_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>resize</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>size_log2</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<goto>goto <name>restart</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Finally we can try to insert the new item. */</comment>
		<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>insert_into_bucket</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><call><name>BUCKET_FOR_HASH</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
		<comment type="block">/* Adjust per-lock-partition counter for load factor knowledge. */</comment>
		<expr_stmt><expr><operator>++</operator><name><name>partition</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* The caller must release the lock with dshash_release_lock. */</comment>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_locked</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_exclusively_locked</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><call><name>ENTRY_FROM_ITEM</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove an entry by key.  Returns true if the key was found and the
 * corresponding entry was removed.
 *
 * To delete an entry that you already have a pointer to, see
 * dshash_delete_entry.
 */</comment>
<function><type><name>bool</name></type>
<name>dshash_delete_key</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dshash_hash</name></type> <name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>partition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>DSHASH_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>hash_table</name><operator>-&gt;</operator><name>find_locked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_key</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partition</name> <operator>=</operator> <call><name>PARTITION_FOR_HASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ensure_valid_bucket_pointers</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>delete_key_from_bucket</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><call><name>BUCKET_FOR_HASH</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>partition</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>partition</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove an entry.  The entry must already be exclusively locked, and must
 * have been obtained by dshash_find or dshash_find_or_insert.  Note that this
 * function releases the lock just like dshash_release_lock.
 *
 * To delete an entry by key, see dshash_delete_key.
 */</comment>
<function><type><name>void</name></type>
<name>dshash_delete_entry</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>ITEM_FROM_ENTRY</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>partition</name> <init>= <expr><call><name>PARTITION_FOR_HASH</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>DSHASH_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_locked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_exclusively_locked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>delete_item</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_locked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_exclusively_locked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unlock an entry which was locked by dshash_find or dshash_find_or_insert.
 */</comment>
<function><type><name>void</name></type>
<name>dshash_release_lock</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>ITEM_FROM_ENTRY</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>partition_index</name> <init>= <expr><call><name>PARTITION_FOR_HASH</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>DSHASH_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_locked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>partition_index</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><ternary><condition><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_exclusively_locked</name></name></expr>
								?</condition><then> <expr><name>LW_EXCLUSIVE</name></expr> </then><else>: <expr><name>LW_SHARED</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_locked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>find_exclusively_locked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>partition_index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * A compare function that forwards to memcmp.
 */</comment>
<function><type><name>int</name></type>
<name>dshash_memcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A hash function that forwards to tag_hash.
 */</comment>
<function><type><name>dshash_hash</name></type>
<name>dshash_memhash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>tag_hash</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Print debugging information about the internal state of the hash table to
 * stderr.  The caller must hold no partition locks.
 */</comment>
<function><type><name>void</name></type>
<name>dshash_dump</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>DSHASH_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>hash_table</name><operator>-&gt;</operator><name>find_locked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DSHASH_NUM_PARTITIONS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ensure_valid_bucket_pointers</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
			<argument><expr><literal type="string">"hash table size = %zu\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>hash_table</name><operator>-&gt;</operator><name>size_log2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DSHASH_NUM_PARTITIONS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dshash_partition</name> <modifier>*</modifier></type><name>partition</name> <init>= <expr><operator>&amp;</operator><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>begin</name> <init>= <expr><call><name>BUCKET_INDEX_FOR_PARTITION</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>size_log2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>end</name> <init>= <expr><call><name>BUCKET_INDEX_FOR_PARTITION</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>size_log2</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"  partition %zu\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
				<argument><expr><literal type="string">"    active buckets (key count = %zu)\n"</literal></expr></argument>, <argument><expr><name><name>partition</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>begin</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>bucket</name> <init>= <expr><name><name>hash_table</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>bucket</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"      bucket %zu (key count = %zu)\n"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DSHASH_NUM_PARTITIONS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Delete a locked item to which we have a pointer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>delete_item</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>, <parameter><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>hash</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>hash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>partition</name> <init>= <expr><call><name>PARTITION_FOR_HASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>delete_item_from_bucket</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>item</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><call><name>BUCKET_FOR_HASH</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>partition</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>partitions</name><index>[<expr><name>partition</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Grow the hash table if necessary to the requested number of buckets.  The
 * requested size must be double some previously observed size.
 *
 * Must be called without any partition lock held.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>resize</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>new_size_log2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>old_buckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>new_buckets_shared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>new_buckets</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>new_size</name> <init>= <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>new_size_log2</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Acquire the locks for all lock partitions.  This is expensive, but we
	 * shouldn't have to do it many times.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DSHASH_NUM_PARTITIONS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>size_log2</name></name> <operator>&gt;=</operator> <name>new_size_log2</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Another backend has already increased the size; we can avoid
			 * obtaining all the locks and return early.
			 */</comment>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_size_log2</name> <operator>==</operator> <name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>size_log2</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate the space for the new table. */</comment>
	<expr_stmt><expr><name>new_buckets_shared</name> <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>,
									   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsa_pointer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_buckets</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name>new_buckets_shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We've allocated the new bucket array; all that remains to do now is to
	 * reinsert all items, which amounts to adjusting all the pointers.
	 */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>size_log2</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>item_pointer</name> <init>= <expr><name><name>hash_table</name><operator>-&gt;</operator><name>buckets</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name>item_pointer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>next_item_pointer</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name>item_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>next_item_pointer</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>insert_item_into_bucket</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>item_pointer</name></expr></argument>, <argument><expr><name>item</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>new_buckets</name><index>[<expr><call><name>BUCKET_INDEX_FOR_HASH_AND_SIZE</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>,
																				<argument><expr><name>new_size_log2</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>item_pointer</name> <operator>=</operator> <name>next_item_pointer</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>

	<comment type="block">/* Swap the hash table into place and free the old one. */</comment>
	<expr_stmt><expr><name>old_buckets</name> <operator>=</operator> <name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>buckets</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator> <name>new_buckets_shared</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>size_log2</name></name> <operator>=</operator> <name>new_size_log2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator> <name>new_buckets</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name>old_buckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release all the locks. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DSHASH_NUM_PARTITIONS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>PARTITION_LOCK</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Make sure that our backend-local bucket pointers are up to date.  The
 * caller must have locked one lock partition, which prevents resize() from
 * running concurrently.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ensure_valid_bucket_pointers</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>hash_table</name><operator>-&gt;</operator><name>size_log2</name></name> <operator>!=</operator> <name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>size_log2</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>,
											  <argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_table</name><operator>-&gt;</operator><name>size_log2</name></name> <operator>=</operator> <name><name>hash_table</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>size_log2</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Scan a locked bucket for a match, using the provided compare function.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>dshash_table_item</name> <modifier>*</modifier></type>
<name>find_in_bucket</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
			   <parameter><decl><type><name>dsa_pointer</name></type> <name>item_pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name>item_pointer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name>item_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>equal_keys</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>ENTRY_FROM_ITEM</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>item</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>item_pointer</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Insert an already-allocated item into a bucket.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>insert_item_into_bucket</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>,
						<parameter><decl><type><name>dsa_pointer</name></type> <name>item_pointer</name></decl></parameter>,
						<parameter><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl></parameter>,
						<parameter><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>bucket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>item</name> <operator>==</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name>item_pointer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>bucket</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>bucket</name> <operator>=</operator> <name>item_pointer</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate space for an entry with the given key and insert it into the
 * provided bucket.
 */</comment>
<function><type><specifier>static</specifier> <name>dshash_table_item</name> <modifier>*</modifier></type>
<name>insert_into_bucket</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
				   <parameter><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>bucket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>item_pointer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>item_pointer</name> <operator>=</operator> <call><name>dsa_allocate</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>,
								<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>entry_size</name></name> <operator>+</operator>
								<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dshash_table_item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name>item_pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ENTRY_FROM_ITEM</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>key_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>insert_item_into_bucket</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>item_pointer</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>item</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Search a bucket for a matching key and delete it.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>delete_key_from_bucket</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
					   <parameter><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>bucket_head</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>bucket_head</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><operator>*</operator><name>bucket_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>equal_keys</name><argument_list>(<argument><expr><name>hash_table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>ENTRY_FROM_ITEM</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>next</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><operator>*</operator><name>bucket_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>bucket_head</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>bucket_head</name> <operator>=</operator> <operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Delete the specified item from the bucket.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>delete_item_from_bucket</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>,
						<parameter><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>item</name></decl></parameter>,
						<parameter><decl><type><name>dsa_pointer</name> <modifier>*</modifier></type><name>bucket_head</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>bucket_head</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dshash_table_item</name> <modifier>*</modifier></type><name>bucket_item</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>bucket_item</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><operator>*</operator><name>bucket_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>bucket_item</name> <operator>==</operator> <name>item</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>next</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><operator>*</operator><name>bucket_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>bucket_head</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>bucket_head</name> <operator>=</operator> <operator>&amp;</operator><name><name>bucket_item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the hash value for a key.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>dshash_hash</name></type>
<name>hash_key</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name><name>hash_table</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>hash_function</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>,
											<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>key_size</name></name></expr></argument>,
											<argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether two keys compare equal.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>equal_keys</name><parameter_list>(<parameter><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>hash_table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name><name>hash_table</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>compare_function</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>,
											   <argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>params</name><operator>.</operator><name>key_size</name></name></expr></argument>,
											   <argument><expr><name><name>hash_table</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
