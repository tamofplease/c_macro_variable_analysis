<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/commands/tablecmds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tablecmds.c
 *	  Commands for creating and altering table structures and settings
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/tablecmds.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupconvert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_appendonly.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute_encoding.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_compression.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/toasting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_fastsequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbaocsam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbcat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/memquota.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/cluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/typecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/instrument.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteDefine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/metrics_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/appendonly_compaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/external.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/aocatalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/oid_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/altertablenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbrelsize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdboidsync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autostats.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>synthetic_sql</name> <init>= <expr><literal type="string">"(internally generated SQL command)"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * ON COMMIT action list
 */</comment>
<typedef>typedef <type><struct>struct <name>OnCommitItem</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>			<comment type="block">/* relid of relation */</comment>
	<decl_stmt><decl><type><name>OnCommitAction</name></type> <name>oncommit</name></decl>;</decl_stmt>	<comment type="block">/* what to do at end of xact */</comment>

	<comment type="block">/*
	 * If this entry was created during the current transaction,
	 * creating_subid is the ID of the creating subxact; if created in a prior
	 * transaction, creating_subid is zero.  If deleted during the current
	 * transaction, deleting_subid is the ID of the deleting subxact; if no
	 * deletion request is pending, deleting_subid is zero.
	 */</comment>
	<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>creating_subid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>deleting_subid</name></decl>;</decl_stmt>
}</block></struct></type> <name>OnCommitItem</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>on_commits</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * State information for ALTER TABLE
 *
 * In GPDB, these are in nodes/altertablenodes.h
 */</comment>

<comment type="block">/*
 * Error-reporting support for RemoveRelations
 */</comment>
<struct>struct <name>dropmsgstrings</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name>kind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nonexistent_code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nonexistent_msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>skipping_msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nota_msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>drophint_msg</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>dropmsgstrings</name></name></type> <name><name>dropmsgstringarray</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><name>RELKIND_RELATION</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP TABLE to remove a table."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_SEQUENCE</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sequence \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sequence \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a sequence"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP SEQUENCE to remove a sequence."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_VIEW</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"view \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"view \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a view"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP VIEW to remove a view."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_MATVIEW</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"materialized view \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"materialized view \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a materialized view"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP MATERIALIZED VIEW to remove a materialized view."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_INDEX</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP INDEX to remove an index."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_COMPOSITE_TYPE</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a type"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP TYPE to remove a type."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_FOREIGN_TABLE</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a foreign table"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP FOREIGN TABLE to remove a foreign table."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_PARTITIONED_TABLE</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_TABLE</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP TABLE to remove a table."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><name>RELKIND_PARTITIONED_INDEX</name></expr>,
		<expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist, skipping"</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>)</argument_list></call></expr>,
	<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Use DROP INDEX to remove an index."</literal></argument>)</argument_list></macro>}</block></expr>,
	<expr><block>{<expr><literal type="char">'\0'</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* communication between RemoveRelations and RangeVarCallbackForDropRelation */</comment>
<struct>struct <name>DropRelationCallbackState</name>
<block>{
	<comment type="block">/* These fields are set by RemoveRelations: */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>expected_relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>heap_lockmode</name></decl>;</decl_stmt>
	<comment type="block">/* These fields are state to track which subsidiary locks are held: */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heapOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>partParentOid</name></decl>;</decl_stmt>
	<comment type="block">/* These fields are passed back by RangeVarCallbackForDropRelation: */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>actual_relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>actual_relpersistence</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Alter table target-type flags for ATSimplePermissions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_TABLE</name></cpp:macro>				<cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_VIEW</name></cpp:macro>				<cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_MATVIEW</name></cpp:macro>				<cpp:value>0x0004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_INDEX</name></cpp:macro>				<cpp:value>0x0008</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_COMPOSITE_TYPE</name></cpp:macro>		<cpp:value>0x0010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_FOREIGN_TABLE</name></cpp:macro>		<cpp:value>0x0020</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>		<cpp:macro><name>ATT_PARTITIONED_INDEX</name></cpp:macro>	<cpp:value>0x0040</cpp:value></cpp:define>

<comment type="block">/*
 * Partition tables are expected to be dropped when the parent partitioned
 * table gets dropped. Hence for partitioning we use AUTO dependency.
 * Otherwise, for regular inheritance use NORMAL dependency.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>child_dependency_type</name><parameter_list>(<parameter><type><name>child_is_partition</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>((child_is_partition) ? DEPENDENCY_AUTO : DEPENDENCY_NORMAL)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>truncate_check_rel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_class</name></type> <name>reltuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>truncate_check_activity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RangeVarCallbackForTruncate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
										<parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>MergeAttributes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>supers</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>is_partition</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>supconstr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>gp_alter_part</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MergeAttributesIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MergeCheckConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MergeConstraintsIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StoreCatalogInheritance</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>supers</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>child_is_partition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StoreCatalogInheritance1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentOid</name></decl></parameter>,
									 <parameter><decl><type><name>int32</name></type> <name>seqNumber</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>inhRelation</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name></type> <name>child_is_partition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>findAttrByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attributeName</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AlterIndexNamespaces</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AlterSeqNamespaces</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>,
							   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAlterConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
										   <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecValidateConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>,
											  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>transformColumnNameList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colList</name></decl></parameter>,
									<parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>atttypids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>transformFkeyGetPrimaryKey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>indexOid</name></decl></parameter>,
									   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>attnamelist</name></decl></parameter>,
									   <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>atttypids</name></decl></parameter>,
									   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opclasses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>transformFkeyCheckAttrs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>numattrs</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opclasses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkFkeyPermissions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CoercionPathType</name></type> <name>findFkeyCast</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sourceTypeId</name></decl></parameter>,
									 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>funcid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validateCheckConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>constrtup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validateForeignKeyConstraint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>,
										 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>,
										 <parameter><decl><type><name>Oid</name></type> <name>pkindOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATController</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
						 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepCmd</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATRewriteCatalogs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecCmd</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATRewriteTables</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATRewriteTable</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATAocsWriteSegFileNewColumns</name><parameter_list>(
		<parameter><decl><type><name>AOCSAddColumnDesc</name></type> <name>idesc</name></decl></parameter>, <parameter><decl><type><name>AOCSHeaderScanDesc</name></type> <name>sdesc</name></decl></parameter>,
		<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATAocsWriteNewColumns</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AlteredTableInfo</name> <modifier>*</modifier></type><name>ATGetQueueEntry</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATSimplePermissions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>allowed_targets</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATWrongRelkindError</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>allowed_targets</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATSimpleRecursion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATCheckPartitionsNotInUse</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATTypedTableRecursion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
								  <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>find_typed_table_dependencies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>,
										   <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepAddColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>is_view</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
									 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>colDef</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecSetColumnEncoding</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
									<parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_for_column_name_collision</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
											<parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_column_datatype_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_column_collation_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepDropNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDropNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepSetNotNull</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							 <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
							 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetNotNull</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
									  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecCheckNotNull</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NotNullImpliedByRelConstraints</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ConstraintImpliedByRelConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>scanrel</name></decl></parameter>,
											 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>testConstraint</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>provenConstraint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecColumnDefault</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
										 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newDefault</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
									   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
									   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDropIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepSetStatistics</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>colNum</name></decl></parameter>,
								<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetStatistics</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>colNum</name></decl></parameter>,
										 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
									  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isReset</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecSetStorage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
									  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepDropColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
							 <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDropColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
									  <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
									  <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddIndex</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
									<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_rebuild</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>,
										 <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
										 <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>newConstraint</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_readd</name></decl></parameter>,
										 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ChooseForeignKeyConstraintNameAddition</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colnames</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddIndexConstraint</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
											  <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATAddCheckConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>,
										  <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
										  <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name></decl></parameter>,
										  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_readd</name></decl></parameter>,
										  <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATAddForeignKeyConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
											   <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentConstr</name></decl></parameter>,
											   <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
											   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>addFkRecurseReferenced</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>,
											<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentConstr</name></decl></parameter>,
											<parameter><decl><type><name>int</name></type> <name>numfks</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>pkattnum</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>fkattnum</name></decl></parameter>,
											<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>pfeqoperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ppeqoperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ffeqoperators</name></decl></parameter>,
											<parameter><decl><type><name>bool</name></type> <name>old_check_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addFkRecurseReferencing</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>,
									<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentConstr</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>numfks</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>pkattnum</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>fkattnum</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>pfeqoperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ppeqoperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ffeqoperators</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>old_check_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CloneForeignKeyConstraints</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentRel</name></decl></parameter>,
									   <parameter><decl><type><name>Relation</name></type> <name>partitionRel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CloneFkReferenced</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parentRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partitionRel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CloneFkReferencing</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentRel</name></decl></parameter>,
							   <parameter><decl><type><name>Relation</name></type> <name>partRel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>createForeignKeyCheckTriggers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myRelOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>,
										  <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>,
										  <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>createForeignKeyActionTriggers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>,
										   <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>,
										   <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>tryAttachPartitionForeignKey</name><parameter_list>(<parameter><decl><type><name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>fk</name></decl></parameter>,
										 <parameter><decl><type><name>Oid</name></type> <name>partRelid</name></decl></parameter>,
										 <parameter><decl><type><name>Oid</name></type> <name>parentConstrOid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numfks</name></decl></parameter>,
										 <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>mapped_conkey</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>confkey</name></decl></parameter>,
										 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>conpfeqop</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecDropConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>,
								 <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepAlterColumnType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>,
								  <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
								  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ATColumnChangeRequiresRewrite</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAlterColumnType</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
										   <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RememberConstraintForRebuilding</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>conoid</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RememberIndexForRebuilding</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indoid</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPostAlterTypeCleanup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
								   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPostAlterTypeParse</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelId</name></decl></parameter>,
								 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>rewrite</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RebuildConstraintComment</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pass</name></decl></parameter>,
									 <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>domname</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TryReuseIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TryReuseForeignKey</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAlterColumnGenericOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
													 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>change_owner_fix_column_acls</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>,
										 <parameter><decl><type><name>Oid</name></type> <name>oldOwnerId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>change_owner_recurse_to_sequences</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>,
											  <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecClusterOn</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexName</name></decl></parameter>,
									 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecDropCluster</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepSetAccessMethod</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>amname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecSetAccessMethodNoStorage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newAccessMethod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ATPrepChangePersistence</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>toLogged</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepSetTableSpace</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tablespacename</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecSetTableSpace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newTableSpace</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecSetTableSpaceNoStorage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newTableSpace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecSetRelOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>defList</name></decl></parameter>,
								<parameter><decl><type><name>AlterTableType</name></type> <name>operation</name></decl></parameter>,
								<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>aoopt_changed</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>newam</name></decl></parameter>,
								<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecEnableDisableTrigger</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigname</name></decl></parameter>,
									   <parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_system</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecEnableDisableRule</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rulename</name></decl></parameter>,
									<parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATPrepAddInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDropInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>drop_parent_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refclassid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refobjid</name></decl></parameter>,
								   <parameter><decl><type><name>DependencyType</name></type> <name>deptype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAddOf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeName</name> <modifier>*</modifier></type><name>ofTypename</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecDropOf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ReplicaIdentityStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecGenericOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecEnableRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecDisableRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecForceNoForceRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_rls</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>index_copy_data</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name></type> <name>newrnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>storage_name</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RangeVarCallbackForDropRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>,
											<parameter><decl><type><name>Oid</name></type> <name>oldRelOid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RangeVarCallbackForAlterRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
											 <parameter><decl><type><name>Oid</name></type> <name>oldrelid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecExpandTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecExpandPartitionTablePrepare</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecExpandTableCTAS</name><parameter_list>(<parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>rootCmd</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATExecSetDistributedBy</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								   <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PartitionSpec</name> <modifier>*</modifier></type><name>transformPartitionSpec</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>partspec</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>strategy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ComputePartitionAttrs</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partParams</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>partattrs</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>partexprs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partopclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>strategy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateInheritance</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveInheritance</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAttachPartition</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
										   <parameter><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AttachPartitionEnsureIndexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>attachrel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>QueuePartitionConstraintValidation</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>scanrel</name></decl></parameter>,
											   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partConstraint</name></decl></parameter>,
											   <parameter><decl><type><name>bool</name></type> <name>validate_default</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CloneRowTriggersToPartition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecDetachPartition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>ATExecAttachPartitionIdx</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
											  <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validatePartitionedIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>partedIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partedTbl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>refuseDupeIndexAttach</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parentIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partIdx</name></decl></parameter>,
								  <parameter><decl><type><name>Relation</name></type> <name>partitionTbl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>GetParentedForeignKeyRefs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>partition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ATDetachCheckNoForeignKeyRefs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>partition</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>make_temp_table_name</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BackendId</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>prebuild_temp_table</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>tmpname</name></decl></parameter>, <parameter><decl><type><name>DistributedBy</name> <modifier>*</modifier></type><name>distro</name></decl></parameter>,
								<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>amname</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>isTmpTableAo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useExistingColumnAttributes</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prepare_AlterTableStmt_for_dispatch</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>strip_gpdb_part_commands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_rel_col_encodings</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stenc</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>withOptions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>get_rel_opts</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clear_rel_opts</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *		DefineRelation
 *				Creates a new relation.
 *
 * stmt carries parsetree information from an ordinary CREATE TABLE statement.
 * The other arguments are used to extend the behavior for other cases:
 * relkind: relkind to assign to the new relation
 * ownerId: if not InvalidOid, use this as the new relation's owner.
 * typaddress: if not null, it's set to the pg_type entry's address.
 * queryString: for error reporting
 *
 * Note that permissions checks are done against current user regardless of
 * ownerId.  A nonzero ownerId is used when someone is creating a relation
 * "on behalf of" someone else, so we still want to see that the current user
 * has permissions to do it.
 *
 * If successful, returns the address of the new relation.
 *
 * GPDB: If 'dispatch' is true (and we are running in QD), the statement is
 * also dispatched to the QE nodes. Otherwise it is the caller's
 * responsibility to dispatch.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineRelation</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ownerId</name></decl></parameter>,
			   <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>typaddress</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>dispatch</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useChangedOpts</name></decl></parameter>, <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>intoPolicy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>relname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>policy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tablespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>descriptor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inheritOids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>old_constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rawDefaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cookedDefaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>parentenc</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>reloptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>oldoptions</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>listptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partitioned</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>validnsps</name><index>[]</index></name> <init>= <expr><name>HEAP_RELOPT_NAMESPACES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ofTypeId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>parentLockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>accessMethodId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>schema</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cooked_constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldDispatch</name> <init>= <expr><name>dispatch</name> <operator>&amp;&amp;</operator>
								 <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator>
                                 <call><name>IsNormalProcessingMode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In QE mode, tableElts contain not only the normal ColumnDefs, but also
	 * pre-made CookedConstraints. Separate them into different lists.
	 */</comment>
	<expr_stmt><expr><name>schema</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cooked_constraints</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>listptr</argument>, <argument>stmt-&gt;tableElts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>listptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CookedConstraint</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cooked_constraints</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cooked_constraints</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>schema</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Truncate relname to appropriate length (probably a waste of time, as
	 * parser should have done this already).
	 */</comment>
	<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check consistency of arguments
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>!=</operator> <name>ONCOMMIT_NOOP</name>
		<operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON COMMIT can only be used on temporary tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In QD, the caller calls us with RELKIND_RELATION, and we turn it int
		 * REKIND_PARTITIONED_TABLE here. In QE, we received the modified
		 * CreateStmt from QD where relkind has already been set to RELKIND_PARTITIONED_TABLE
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <operator>(</operator><ternary><condition><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr> ?</condition><then> <expr><name>RELKIND_PARTITIONED_TABLE</name></expr> </then><else>: <expr><name>RELKIND_RELATION</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected relkind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>partitioned</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>partitioned</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Look up the namespace in which we are supposed to create the relation,
	 * check we have permission to create there, lock it against concurrent
	 * drop, and mark stmt-&gt;relation as RELPERSISTENCE_TEMP if a temporary
	 * namespace is selected.
	 */</comment>
	<expr_stmt><expr><name>namespaceId</name> <operator>=</operator>
		<call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Security check: disallow creating temp tables from security-restricted
	 * code.  This is needed because calling code might not expect untrusted
	 * tables to appear in pg_temp at the front of its search path.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name>
		<operator>&amp;&amp;</operator> <call><name>InSecurityRestrictedOperation</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create temporary table within security-restricted operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Determine the lockmode to use when scanning parents.  A self-exclusive
	 * lock is needed here.
	 *
	 * For regular inheritance, if two backends attempt to add children to the
	 * same parent simultaneously, and that parent has no pre-existing
	 * children, then both will attempt to update the parent's relhassubclass
	 * field, leading to a "tuple concurrently updated" error.  Also, this
	 * interlocks against a concurrent ANALYZE on the parent table, which
	 * might otherwise be attempting to clear the parent's relhassubclass
	 * field, if its previous children were recently dropped.
	 *
	 * If the child table is a partition, then we instead grab an exclusive
	 * lock on the parent because its partition descriptor will be changed by
	 * addition of the new partition.
	 */</comment>
	<expr_stmt><expr><name>parentLockmode</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>AccessExclusiveLock</name></expr> </then><else>:
					  <expr><name>ShareUpdateExclusiveLock</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Determine the list of OIDs of the parents. */</comment>
	<expr_stmt><expr><name>inheritOids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>listptr</argument>, <argument>stmt-&gt;inhRelations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>listptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentOid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>parentOid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>parentLockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reject duplications in the list of parents.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>, <argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" would be inherited from more than once"</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>inheritOids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>, <argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Select tablespace to use: an explicitly indicated one, or (in the case
	 * of a partitioned table) the parent's, if it has one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespacename</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Tablespace specified on the command line, or was passed down by
		 * dispatch.
		 */</comment>
		<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespacename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>partitioned</name> <operator>&amp;&amp;</operator> <name>tablespaceId</name> <operator>==</operator> <name>MyDatabaseTableSpace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify default tablespace for partitioned relations"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For partitions, when no other tablespace is specified, we default
		 * the tablespace to the parent partitioned table's.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <call><name>get_rel_tablespace</name><argument_list>(<argument><expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 
		 * MPP-8238 : inconsistent tablespaces between segments and master 
		 */</comment>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespacename</name></name> <operator>=</operator> <call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* still nothing? use the default */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <call><name>GetDefaultTablespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
											<argument><expr><name>partitioned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check permissions except when using database's default */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>tablespaceId</name> <operator>!=</operator> <name>MyDatabaseTableSpace</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_tablespace_aclcheck</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_TABLESPACE</name></expr></argument>,
						   <argument><expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* In all cases disallow placing user relations in pg_global */</comment>
	<if_stmt><if>if <condition>(<expr><name>tablespaceId</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only shared relations can be placed in pg_global tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Identify user ID that will own the table */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Greenplum: the accessMethod is necessary to extract, transform and
	 * validate the reloptions.
	 */</comment>

	<comment type="block">/*
	 * If the statement hasn't specified an access method, but we're defining
	 * a type of relation that needs one, use the default.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>accessMethodId</name> <operator>=</operator> <call><name>get_table_am_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * For partitioned tables, when no access method is specified, we
		 * default to the parent table's AM.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>accessMethodId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relam</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>accessMethodId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>accessMethodId</name> <operator>=</operator> <call><name>get_table_am_oid</name><argument_list>(<argument><expr><name>default_table_access_method</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			 <name>relkind</name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name> <operator>||</operator>
			 <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
			 <name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>accessMethodId</name> <operator>=</operator> <call><name>get_table_am_oid</name><argument_list>(<argument><expr><name>default_table_access_method</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* 
	 * GPDB: for partitioned tables, inherit reloptions from the parent. 
	 * Note this is applicable only if the parent has the same AM as the child.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentrelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> 		<name>parentrel</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * For partitioned children, when no reloptions is specified, we
		 * default to the parent table's reloptions.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentrelid</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>parentrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parentrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>accessMethodId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oldoptions</name> <operator>=</operator> <call><name>get_rel_opts</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>accessMethodId</name> <operator>==</operator> <name>AO_COLUMN_TABLE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>parentenc</name> <operator>=</operator> <call><name>rel_get_column_encodings</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Parse and validate reloptions, if any.
	 */</comment>
	<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <name>oldoptions</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>validnsps</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Greenplum: special case checks for reloptions that correspond to
	 * appendonly relations. This check can not be performed earlier because it
	 * is needed to know the access method.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>accessMethodId</name> <operator>==</operator> <name>AO_ROW_TABLE_AM_OID</name> <operator>||</operator>
			<name>accessMethodId</name> <operator>==</operator> <name>AO_COLUMN_TABLE_AM_OID</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Extract and process any WITH options supplied, otherwise use defaults
		 *
		 * The generated options will be added during heap_create_with_catalog
		 * for appendoptimized relations, so (view|heap)_reloptions should not
		 * be called yet.
		 */</comment>
		<decl_stmt><decl><type><name>StdRdOptions</name> <modifier>*</modifier></type><name>stdRdOptions</name> <init>= <expr><operator>(</operator><name>StdRdOptions</name> <operator>*</operator><operator>)</operator><call><name>default_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>,
																		<argument><expr><name>true</name></expr></argument>,
																		<argument><expr><name>RELOPT_KIND_APPENDOPTIMIZED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Validate the StdRdOptions parsed or error out */</comment>
		<expr_stmt><expr><call><name>validateAppendOnlyRelOptions</name><argument_list>(<argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>,
									 <argument><expr><name>gp_safefswritesize</name></expr></argument>,
									 <argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>compresslevel</name></name></expr></argument>,
									 <argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>,
									 <argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>,
									 <argument><expr><operator>(</operator><name>accessMethodId</name> <operator>==</operator> <name>AO_COLUMN_TABLE_AM_OID</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <call><name>transformAOStdRdOptions</name><argument_list>(<argument><expr><name>stdRdOptions</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>view_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ofTypeId</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>ofTypeId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ofTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ofTypeId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Look up inheritance ancestors and generate relation schema, including
	 * inherited attributes.  (Note that stmt-&gt;tableElts is destructively
	 * modified by MergeAttributes.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>schema</name> <operator>=</operator>
			<call><name>MergeAttributes</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>inheritOids</name></expr></argument>,
							<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
							<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>old_constraints</name></expr></argument>,
							<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>gp_style_alter_part</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * In QE mode, we already extracted all the constraints, inherited
		 * or not, from tableElts at the beginning of the function.
		 */</comment>
		<expr_stmt><expr><name>old_constraints</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Create a tuple descriptor from the relation schema.  Note that this
	 * deals with column names, types, and NOT NULL constraints, but not
	 * default values or CHECK constraints; we handle those below.
	 */</comment>
	<expr_stmt><expr><name>descriptor</name> <operator>=</operator> <call><name>BuildDescForRelation</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * now that we have the final list of attributes, interpret DISTRIBUTED BY
	 * column names into a GpPolicy
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>intoPolicy</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>policy</name> <operator>=</operator> <name>intoPolicy</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>policy</name> <operator>=</operator> <call><name>getPolicyForDistributedBy</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>distributedBy</name></name></expr></argument>, <argument><expr><name>descriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>partitioned</name> <operator>&amp;&amp;</operator> <call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PARTITION BY clause cannot be used with DISTRIBUTED REPLICATED clause"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find columns with default values and prepare for insertion of the
	 * defaults.  Pre-cooked (that is, inherited) defaults go into a list of
	 * CookedConstraint structs that we'll pass to heap_create_with_catalog,
	 * while raw defaults go into a list of RawColumnDefault structs that will
	 * be processed by AddRelationNewConstraints.  (We can't deal with raw
	 * expressions until we can do transformExpr.)
	 *
	 * We can set the atthasdef flags now in the tuple descriptor; this just
	 * saves StoreAttrDefault from having to do an immediate update of the
	 * pg_attribute rows.
	 */</comment>
	<expr_stmt><expr><name>rawDefaults</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cookedDefaults</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>listptr</argument>, <argument>schema</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>colDef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>listptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RawColumnDefault</name> <modifier>*</modifier></type><name>rawEnt</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>rawEnt</name> <operator>=</operator> <operator>(</operator><name>RawColumnDefault</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RawColumnDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>missingMode</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>generated</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>generated</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rawDefaults</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rawDefaults</name></expr></argument>, <argument><expr><name>rawEnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>cooked</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>cooked</name> <operator>=</operator> <operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CookedConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_DEFAULT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>conoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* until created */</comment>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>cooked_default</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* not used for defaults */</comment>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* ditto */</comment>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_no_inherit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cookedDefaults</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cookedDefaults</name></expr></argument>, <argument><expr><name>cooked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>generated</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>generated</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Analyze AOCS attribute encoding clauses.
	 *
	 * Ideally this could have happened even later confined in
	 * AddRelationAttributeEncodings(). However, since this function can
	 * legitimately error out, it is prefered to call it before updating the
	 * catalog in heap_create_with_catalog().
	 *
	 * For RELKIND_PARTITIONED_TABLE, we will create a list of encodings
	 * for the root partition to add to pg_attribute_encoding which includes
	 * explicitly specified column encodings and values picked from defaults
	 * We will also transform the stmt-&gt;attr_encodings to be passed down to
	 * create child partition create stmts which would only include explicitly
	 * specified column encodings from the current root partition
	 *
	 * This is done in dispatcher (and in utility mode). In QE, we receive
	 * the already-processed options from the QD.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
		 <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Note that we disallow encoding clauses for non-AOCO table
		 * besides only one exception: if we're creating a partition as
		 * part of a CREATE TABLE ... PARTITION BY ... command, ignore the
		 * ENCODING options instead. The parent table might be AOCS, while
		 * some of the partitions are not, or vice versa, so options can
		 * make sense for some parts of the partition hierarchy, even if
		 * it doesn't for this partition.
		 */</comment>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>attr_encodings</name></name> <operator>=</operator> <call><name>transformColumnEncoding</name><argument_list>(<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* Relation */</comment>, 
								<argument><expr><name>schema</name></expr></argument>,
								<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>attr_encodings</name></name></expr></argument>,
								<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
								<argument><expr><name>parentenc</name></expr></argument>,
								<argument><expr><name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>,
								<argument><expr><name>accessMethodId</name> <operator>!=</operator> <name>AO_COLUMN_TABLE_AM_OID</name>
										<operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> 
										<operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name></expr></argument> <comment type="block">/* errorOnEncodingClause */</comment>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>accessMethodId</name> <operator>!=</operator> <name>AO_COLUMN_TABLE_AM_OID</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>attr_encodings</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In executor mode, we received all the defaults and constraints
	 * in pre-cooked form from the QD, so forget about the lists we
	 * constructed just above, and use the old_constraints we received
	 * from the QD.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cooked_constraints</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>cookedDefaults</name></expr></argument>, <argument><expr><name>old_constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Store the deduced options back in the CreateStmt, for later dispatch.
	 *
	 * NOTE: We do this even if !shouldDispatch, because it means that the
	 * caller will dispatch the statement later, not that we won't need to
	 * dispatch at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>		<name>pg_class_desc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>		<name>pg_type_desc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>oldContext</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We use a RowExclusiveLock but hold it till end of transaction so
		 * that two DDL operations will not deadlock between QEs
		 */</comment>
		<expr_stmt><expr><name>pg_class_desc</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pg_type_desc</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class_desc</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* gonna update, so don't unlock */</comment>

		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relKind</name></name> <operator>=</operator> <name>relkind</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>ownerid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>ownerid</name></name> <operator>=</operator> <name>ownerId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_type_desc</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>ownerid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>shouldDispatch</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cdb_sync_oid_to_segments</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>valid_opts</name> <init>= <expr><operator>!</operator><name>useChangedOpts</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create the relation.  Inherited defaults and constraints are passed in
	 * for immediate handling --- since they don't need parsing, they can be
	 * stored immediately.
	 */</comment>
	<expr_stmt><expr><name>relationId</name> <operator>=</operator> <call><name>heap_create_with_catalog</name><argument_list>(<argument><expr><name>relname</name></expr></argument>,
										  <argument><expr><name>namespaceId</name></expr></argument>,
										  <argument><expr><name>tablespaceId</name></expr></argument>,
										  <argument><expr><name>InvalidOid</name></expr></argument>,
										  <argument><expr><name>InvalidOid</name></expr></argument>,
										  <argument><expr><name>ofTypeId</name></expr></argument>,
										  <argument><expr><name>ownerId</name></expr></argument>,
										  <argument><expr><name>accessMethodId</name></expr></argument>,
										  <argument><expr><name>descriptor</name></expr></argument>,
										  <argument><expr><name>cooked_constraints</name></expr></argument>,
										  <argument><expr><name>relkind</name></expr></argument>,
										  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
										  <argument><expr><name>tablespaceId</name><operator>==</operator><name>GLOBALTABLESPACE_OID</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oncommit</name></name></expr></argument>,
                                          <argument><expr><name>policy</name></expr></argument>,  <comment type="block">/*CDB*/</comment>
										  <argument><expr><name>reloptions</name></expr></argument>,
										  <argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>?</condition><then><expr><name>false</name></expr></then><else>:<expr><name>true</name></expr></else></ternary></expr></argument>,
										  <argument><expr><name>allowSystemTableMods</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>InvalidOid</name></expr></argument>,
										  <argument><expr><name>typaddress</name></expr></argument>,
										  <argument><expr><name>valid_opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must bump the command counter to make the newly-created relation
	 * tuple visible for opening.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the new relation and acquire exclusive lock on it.  This isn't
	 * really necessary for locking out other backends (since they can't see
	 * the new rel anyway until we commit), but it keeps the lock manager from
	 * complaining about deadlock risks.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is an append-only relation, create the auxliary tables necessary
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>NewRelationCreateAOAuxTables</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>buildAoBlkdir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now add any newly specified column default and generation expressions
	 * to the new relation.  These are passed to us in the form of raw
	 * parsetrees; we need to transform them to executable expression trees
	 * before they can be added. The most convenient way to do that is to
	 * apply the parser's transformExpr routine, but transformExpr doesn't
	 * work unless we have a pre-existing relation. So, the transformation has
	 * to be postponed to this final step of CREATE TABLE.
	 *
	 * This needs to be before processing the partitioning clauses because
	 * those could refer to generated columns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <name>rawDefaults</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newCookedDefaults</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newCookedDefaults</name> <operator>=</operator>
			<call><name>AddRelationNewConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rawDefaults</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cooked_constraints</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>cooked_constraints</name></expr></argument>, <argument><expr><name>newCookedDefaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator> <call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>part_attr_encodings</name> <init>=
			<expr><call><name>transformColumnEncoding</name><argument_list>(<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* Relation */</comment>,
									<argument><expr><name>schema</name></expr></argument>,
									<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>attr_encodings</name></name></expr></argument>,
									<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
									<argument><expr><name>parentenc</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>accessMethodId</name> <operator>!=</operator> <name>AO_COLUMN_TABLE_AM_OID</name>
									<operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name></expr></argument>
									<comment type="block">/* errorOnEncodingClause */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AddRelationAttributeEncodings</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>part_attr_encodings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>attr_encodings</name></name> <operator>&amp;&amp;</operator> <call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AddRelationAttributeEncodings</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>attr_encodings</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Make column generation expressions visible for use by partitioning.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process and store partition bound, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>bound</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentId</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call></expr></init></decl>,
					<decl><type ref="prev"/><name>defaultPartOid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>parent</name></decl>,
					<decl><type ref="prev"/><name>defaultRel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

		<comment type="block">/* Already have strong enough lock on the parent */</comment>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We are going to try to validate the partition bound specification
		 * against the partition key of parentRel, so it better have one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not partitioned"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The partition constraint of the default partition depends on the
		 * partition bounds of every other partition. It is possible that
		 * another backend might be about to execute a query on the default
		 * partition table, and that the query relies on previously cached
		 * default partition constraints. We must therefore take a table lock
		 * strong enough to prevent all queries on the default partition from
		 * proceeding until we commit and send out a shared-cache-inval notice
		 * that will make them update their index lists.
		 *
		 * Order of locking: The relation being added won't be visible to
		 * other backends until it is committed, hence here in
		 * DefineRelation() the order of locking the default partition and the
		 * relation being added does not matter. But at all other places we
		 * need to lock the default relation before we lock the relation being
		 * added or removed i.e. we should take the lock in same order at all
		 * the places such that lock parent, lock default partition and then
		 * lock the partition so as to avoid a deadlock.
		 */</comment>
		<expr_stmt><expr><name>defaultPartOid</name> <operator>=</operator>
			<call><name>get_default_oid_from_partdesc</name><argument_list>(<argument><expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defaultRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Transform the bound values */</comment>
		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add an RTE containing this relation, so that transformExpr called
		 * on partition bound expressions is able to report errors using a
		 * proper context.
		 */</comment>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bound</name> <operator>=</operator> <call><name>transformPartitionBound</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check first that the new partition's bound is valid and does not
		 * overlap with any of existing partitions of the parent.
		 */</comment>
		<expr_stmt><expr><call><name>check_new_partition_bound</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the default partition exists, its partition constraints will
		 * change after the addition of this new partition such that it won't
		 * allow any row that qualifies for this new partition. So, check that
		 * the existing data in the default partition satisfies the constraint
		 * as it will exist after adding this partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>check_default_partition_contents</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>defaultRel</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Keep the lock until commit. */</comment>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>defaultRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Update the pg_class entry. */</comment>
		<expr_stmt><expr><call><name>StorePartitionBound</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * GPDB inherits the ACLs from parent during creation.
		 */</comment>
		<expr_stmt><expr><call><name>CopyRelationAcls</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Store inheritance information for new rel. */</comment>
	<expr_stmt><expr><call><name>StoreCatalogInheritance</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>inheritOids</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process the partitioning specification (if any) and store the partition
	 * key information into the catalog.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partitioned</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>strategy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name><name>partattrs</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>partopclass</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>partcollation</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partexprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>partnatts</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name><operator>-&gt;</operator><name>partParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Protect fixed-size arrays here and in executor */</comment>
		<if_stmt><if>if <condition>(<expr><name>partnatts</name> <operator>&gt;</operator> <name>PARTITION_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot partition using more than %d columns"</literal></expr></argument>,
							<argument><expr><name>PARTITION_MAX_KEYS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We need to transform the raw parsetrees corresponding to partition
		 * expressions into executable expression trees.  Like column defaults
		 * and CHECK constraints, we could not have done the transformation
		 * earlier.
		 */</comment>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name> <operator>=</operator> <call><name>transformPartitionSpec</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ComputePartitionAttrs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name><operator>-&gt;</operator><name>partParams</name></name></expr></argument>,
							  <argument><expr><name>partattrs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>partexprs</name></expr></argument>, <argument><expr><name>partopclass</name></expr></argument>,
							  <argument><expr><name>partcollation</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>StorePartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partattrs</name></expr></argument>, <argument><expr><name>partexprs</name></expr></argument>,
						  <argument><expr><name>partopclass</name></expr></argument>, <argument><expr><name>partcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make it all visible */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're creating a partition, create now all the indexes, triggers,
	 * FKs defined in the parent.
	 *
	 * We can't do it earlier, because DefineIndex wants to know the partition
	 * key which we just stored.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentId</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>inheritOids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>parent</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>idxlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<comment type="block">/* Already have strong enough lock on the parent */</comment>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idxlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For each index in the parent table, create one in the partition
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>idxlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>idxRel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>idxstmt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create foreign partition of partitioned table \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table \"%s\" contains indexes that are unique."</literal></expr></argument>,
									   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>idxstmt</name> <operator>=</operator>
				<call><name>generateClonedIndexStmt</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>idxRel</name></expr></argument>,
										<argument><expr><name>attmap</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In QE, we cannot independently choose index names. We must use
			 * the same names as were chosen in the QD. The QD stashed the
			 * names in the CreateStmt-&gt;part_idx_oids/names lists, dig them
			 * up from there.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc_oid</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>lc_name</name></decl>;</decl_stmt>

				<macro><name>forboth</name><argument_list>(<argument>lc_oid</argument>, <argument>stmt-&gt;part_idx_oids</argument>,
						<argument>lc_name</argument>, <argument>stmt-&gt;part_idx_names</argument>)</argument_list></macro>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc_oid</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>idxstmt</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>idxstmt</name><operator>-&gt;</operator><name>idxname</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"did not receive index name from QD for index %s on partition %s"</literal></expr></argument>,
						 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>DefineIndex</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>idxstmt</name></expr></argument>,
						<argument><expr><name>InvalidOid</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>constraintOid</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						<argument><expr><name>true</name></expr></argument> <comment type="block">/* is_new_table */</comment> )</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>part_idx_oids</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>part_idx_oids</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>part_idx_names</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>part_idx_names</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>idxstmt</name><operator>-&gt;</operator><name>idxname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>idxlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there are any row-level triggers, clone them to the new
		 * partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CloneRowTriggersToPartition</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * And foreign keys too.  Note that because we're freshly creating the
		 * table, there is no need to verify these new constraints.
		 */</comment>
		<expr_stmt><expr><call><name>CloneForeignKeyConstraints</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now add any newly specified CHECK constraints to the new relation. Same
	 * as for defaults above, but these need to come after partitioning is set
	 * up.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newCookedDefaults</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newCookedDefaults</name> <operator>=</operator>
			<call><name>AddRelationNewConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cooked_constraints</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>cooked_constraints</name></expr></argument>, <argument><expr><name>newCookedDefaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Transfer any inherited CHECK constraints back to the statement, so
	 * that they are dispatched to QE nodes along with the statement
	 * itself. This way, the QE nodes don't need to repeat the processing
	 * above, which reduces the risk that they would interpret the defaults
	 * or constraints somehow differently.
	 *
	 * NOTE: We do this even if !shouldDispatch, because it means that the
	 * caller will dispatch the statement later, not that we won't need to
	 * dispatch at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <name>schema</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>listptr</argument>, <argument>cooked_constraints</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>cooked</name> <init>= <expr><operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>listptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * In PostgreSQL, CookedConstraint is not a regular struct, not
			 * "node", so MergeAttributes and friends that above created
			 * the CookedConstraints have not set the node tag. Set it now.
			 */</comment>
			<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_CookedConstraint</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name></expr></argument>, <argument><expr><name>cooked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* It is now safe to dispatch */</comment>
	<if_stmt><if>if <condition>(<expr><name>shouldDispatch</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Dispatch the statement tree to all primary and mirror segdbs.
		 * Doesn't wait for the QEs to finish execution.
		 *
		 * The OIDs are carried out-of-band.
		 */</comment>

		<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
									<argument><expr><name>DF_CANCEL_ON_ERROR</name> <operator>|</operator>
									<name>DF_NEED_TWO_PHASE</name> <operator>|</operator>
									<name>DF_WITH_SNAPSHOT</name></expr></argument>,
									<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"PARTITION"</literal></expr></argument>, <argument><expr><literal type="string">"ATTACH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Clean up.  We keep lock on new relation (although it shouldn't be
	 * visible to anyone else anyway, until commit).
	 */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Don't track internal namespaces for toast, bitmap, aoseg */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METATRACK_VALIDNAMESPACE</name><parameter_list>(<parameter><type><name>namespaceId</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(namespaceId != PG_TOAST_NAMESPACE &amp;&amp;	\
	 namespaceId != PG_BITMAPINDEX_NAMESPACE &amp;&amp; \
	 namespaceId != PG_AOSEGMENT_NAMESPACE )</cpp:value></cpp:define>

<comment type="block">/* check for valid namespace and valid relkind */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MetaTrackValidKindNsp</name><parameter_list>(<parameter><decl><type><name>Form_pg_class</name></type> <name>rd_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>nsp</name> <init>= <expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>PG_CATALOG_NAMESPACE</name> <operator>==</operator> <name>nsp</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * MPP-7773: don't track objects in system namespace
		 * if modifying system tables (eg during upgrade)  
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>allowSystemTableMods</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* MPP-7599: watch out for toast indexes */</comment>
	<return>return <expr><operator>(</operator><call><name>METATRACK_VALIDNAMESPACE</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <call><name>MetaTrackValidRelkind</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call>
			<comment type="block">/* MPP-7572: not valid if in any temporary namespace */</comment>
			<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Emit the right error or warning message for a "DROP" command issued on a
 * non-existent relation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropErrorMsgNonExistent</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>rightkind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dropmsgstrings</name></name> <modifier>*</modifier></type><name>rentry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>LookupNamespaceNoError</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"schema \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"schema \"%s\" does not exist, skipping"</literal></expr></argument>,
							<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>rentry</name> <operator>=</operator> <name>dropmsgstringarray</name></expr>;</init> <condition><expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>rentry</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>rightkind</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>nonexistent_code</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>nonexistent_msg</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>skipping_msg</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* Should be impossible */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Emit the right error message for a "DROP" command issued on a
 * relation of the wrong type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropErrorMsgWrongType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>wrongkind</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>rightkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dropmsgstrings</name></name> <modifier>*</modifier></type><name>rentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dropmsgstrings</name></name> <modifier>*</modifier></type><name>wentry</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>rentry</name> <operator>=</operator> <name>dropmsgstringarray</name></expr>;</init> <condition><expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>rentry</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>rightkind</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>wentry</name> <operator>=</operator> <name>dropmsgstringarray</name></expr>;</init> <condition><expr><name><name>wentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>wentry</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>wentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>wrongkind</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
	<comment type="block">/* wrongkind could be something we don't have in our table... */</comment>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><name><name>rentry</name><operator>-&gt;</operator><name>nota_msg</name></name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <ternary><condition><expr><operator>(</operator><name><name>wentry</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>wentry</name><operator>-&gt;</operator><name>drophint_msg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RemoveRelations
 *		Implements DROP TABLE, DROP INDEX, DROP SEQUENCE, DROP VIEW,
 *		DROP MATERIALIZED VIEW, DROP FOREIGN TABLE
 */</comment>
<function><type><name>void</name></type>
<name>RemoveRelations</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>drop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name>AccessExclusiveLock</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* DROP CONCURRENTLY uses a weaker lock, and has some restrictions */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>drop</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>PERFORM_DELETION_CONCURRENTLY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>drop</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>drop</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DROP INDEX CONCURRENTLY does not support dropping multiple objects"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>drop</name><operator>-&gt;</operator><name>behavior</name></name> <operator>==</operator> <name>DROP_CASCADE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DROP INDEX CONCURRENTLY does not support CASCADE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * First we identify all the relations, then we delete them in a single
	 * performMultipleDeletions() call.  This is to avoid unwanted DROP
	 * RESTRICT errors if one of the relations depends on another.
	 */</comment>

	<comment type="block">/* Determine required relkind */</comment>
	<switch>switch <condition>(<expr><name><name>drop</name><operator>-&gt;</operator><name>removeType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_SEQUENCE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_VIEW</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_MATVIEW</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized drop object type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>drop</name><operator>-&gt;</operator><name>removeType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>relkind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Lock and validate each relation; build a list of object addresses */</comment>
	<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>drop-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relOid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>obj</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>DropRelationCallbackState</name></name></type> <name>state</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * These next few steps are a great deal like relation_openrv, but we
		 * don't bother building a relcache entry since we don't need it.
		 *
		 * Check for shared-cache-inval messages before trying to access the
		 * relation.  This is needed to cover the case where the name
		 * identifies a rel that has been dropped and recreated since the
		 * start of our transaction: if we don't flush the old syscache entry,
		 * then we'll latch onto that entry and suffer an error later.
		 */</comment>
		<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Look up the appropriate relation using namespace search. */</comment>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>expected_relkind</name></name> <operator>=</operator> <name>relkind</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>heap_lockmode</name></name> <operator>=</operator> <ternary><condition><expr><name><name>drop</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then>
			<expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>AccessExclusiveLock</name></expr></else></ternary></expr>;</expr_stmt>
		<comment type="block">/* We must initialize these fields to show that no locks are held: */</comment>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>heapOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>partParentOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>relOid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>RVR_MISSING_OK</name></expr></argument>,
										  <argument><expr><name>RangeVarCallbackForDropRelation</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Not there? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DropErrorMsgNonExistent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relkind</name></expr></argument>, <argument><expr><name><name>drop</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we're told to drop a partitioned index, we must acquire lock on
		 * all the children of its parent partitioned table before proceeding.
		 * Otherwise we'd try to lock the child index partitions before their
		 * tables, leading to potential deadlock against other sessions that
		 * will lock those objects in the other order.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>actual_relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>heapOid</name></name></expr></argument>,
									   <argument><expr><name><name>state</name><operator>.</operator><name>heap_lockmode</name></name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* OK, we're ready to delete this one */</comment>
		<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name><name>drop</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>relid_set_new_relfilenode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationSetNewRelfilenode</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ao_aux_tables_safe_truncate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>aoseg_relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>aoblkdir_relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>aovisimap_relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aoseg_relid</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>aoblkdir_relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aovisimap_relid</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relid_set_new_relfilenode</name><argument_list>(<argument><expr><name>aoseg_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relid_set_new_relfilenode</name><argument_list>(<argument><expr><name>aoblkdir_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relid_set_new_relfilenode</name><argument_list>(<argument><expr><name>aovisimap_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset existing gp_fastsequence entries for the segrel to an initial entry.
	 * This mimics the state of the gp_fastsequence row when an empty AO/AOCS
	 * table is created.
	 */</comment>
	<expr_stmt><expr><call><name>RemoveFastSequenceEntry</name><argument_list>(<argument><expr><name>aoseg_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InsertInitialFastSequenceEntries</name><argument_list>(<argument><expr><name>aoseg_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Before acquiring a table lock, check whether we have sufficient rights.
 * In the case of DROP INDEX, also try to lock the table before the index.
 * Also, if the table to be dropped is a partition, we try to lock the parent
 * first.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForDropRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelOid</name></decl></parameter>,
								<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>DropRelationCallbackState</name></name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>expected_relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_partition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>heap_lockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>invalid_system_index</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>DropRelationCallbackState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>heap_lockmode</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>heap_lockmode</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we previously locked some other index's heap, and the name we're
	 * looking up no longer refers to that relation, release the now-useless
	 * lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relOid</name> <operator>!=</operator> <name>oldRelOid</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>, <argument><expr><name>heap_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Similarly, if we previously locked some other partition's heap, and the
	 * name we're looking up no longer refers to that relation, release the
	 * now-useless lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relOid</name> <operator>!=</operator> <name>oldRelOid</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Didn't find a relation, so no need for locking or permission checks. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* concurrently dropped, so nothing to do */</comment>
	<expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_partition</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relispartition</name></name></expr>;</expr_stmt>

	<comment type="block">/* Pass back some data to save lookups in RemoveRelations */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>actual_relkind</name></name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>actual_relpersistence</name></name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Both RELKIND_RELATION and RELKIND_PARTITIONED_TABLE are OBJECT_TABLE,
	 * but RemoveRelations() can only pass one relkind for a given relation.
	 * It chooses RELKIND_RELATION for both regular and partitioned tables.
	 * That means we must be careful before giving the wrong type error when
	 * the relation is RELKIND_PARTITIONED_TABLE.  An equivalent problem
	 * exists with indexes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expected_relkind</name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expected_relkind</name> <operator>=</operator> <name>RELKIND_INDEX</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>expected_relkind</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>expected_relkind</name></name> <operator>!=</operator> <name>expected_relkind</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DropErrorMsgWrongType</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>,
							  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>expected_relkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Allow DROP to either table owner or schema owner */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>pg_namespace_ownercheck</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>,
					   <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check the case of a system index that might have been invalidated by a
	 * failed concurrent process and allow its drop. For the time being, this
	 * only concerns indexes of toast relations that became invalid during a
	 * REINDEX CONCURRENTLY process.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>classform</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>locTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>indisvalid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>locTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>locTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>indexform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>locTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indisvalid</name> <operator>=</operator> <name><name>indexform</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>locTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark object as being an invalid index of system catalogs */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>indisvalid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>invalid_system_index</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* In the case of an invalid index, it is fine to bypass this check */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>invalid_system_index</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>classform</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In DROP INDEX, attempt to acquire lock on the parent table before
	 * locking the index.  index_drop() will need this anyway, and since
	 * regular queries lock tables before their indexes, we risk deadlock if
	 * we do it the other way around.  No error if we don't find a pg_index
	 * entry, though --- the relation may have been dropped.  Note that this
	 * code will execute for either plain or partitioned indexes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>expected_relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name>relOid</name> <operator>!=</operator> <name>oldRelOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>, <argument><expr><name>heap_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Similarly, if the relation is a partition, we must acquire lock on its
	 * parent before locking the partition.  That's because queries lock the
	 * parent before its partitions, so we risk deadlock if we do it the other
	 * way around.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_partition</name> <operator>&amp;&amp;</operator> <name>relOid</name> <operator>!=</operator> <name>oldRelOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name> <operator>=</operator> <call><name>get_partition_parent</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partParentOid</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecuteTruncate
 *		Executes a TRUNCATE command.
 *
 * This is a multi-relation truncate.  We first open and grab exclusive
 * lock on all relations involved, checking permissions and otherwise
 * verifying that the relation is OK for truncation.  In CASCADE mode,
 * relations having FK references to the targeted relations are automatically
 * added to the group; in RESTRICT mode, we check that all FK references are
 * internal to the group that's being truncated.  Finally all the relations
 * are truncated and reindexed.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteTruncate</name><parameter_list>(<parameter><decl><type><name>TruncateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relids_logged</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Open, exclusive-lock, and check all the explicitly-specified relations
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>recurse</name> <init>= <expr><name><name>rv</name><operator>-&gt;</operator><name>inh</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>myrelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name>AccessExclusiveLock</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>myrelid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RangeVarCallbackForTruncate</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* open the relation, we already hold a lock on it */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* don't throw error for "TRUNCATE foo, foo" */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * RangeVarGetRelidExtended() has done most checks with its callback,
		 * but other checks with the now-opened Relation remain.
		 */</comment>
		<expr_stmt><expr><call><name>truncate_check_activity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Log this relation only if needed for logical decoding */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>relids_logged</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* find_all_inheritors already got lock */</comment>
				<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * It is possible that the parent table has children that are
				 * temp tables of other backends.  We cannot safely access
				 * such tables (because of buffering issues), and the best
				 * thing to do is to silently ignore them.  Note that this
				 * check is the same as one of the checks done in
				 * truncate_check_activity() called below, still it is kept
				 * here for simplicity.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>truncate_check_rel</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>truncate_check_activity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Log this relation only if needed for logical decoding */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>relids_logged</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot truncate only a partitioned table"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword, or use TRUNCATE ONLY on the partitions directly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ExecuteTruncateGuts</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>, <argument><expr><name>relids_logged</name></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>restart_seqs</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And close the rels */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * ExecuteTruncateGuts
 *
 * Internal implementation of TRUNCATE.  This is called by the actual TRUNCATE
 * command (see above) as well as replication subscribers that execute a
 * replicated TRUNCATE action.
 *
 * explicit_rels is the list of Relations to truncate that the command
 * specified.  relids is the list of Oids corresponding to explicit_rels.
 * relids_logged is the list of Oids (a subset of relids) that require
 * WAL-logging.  This is all a bit redundant, but the existing callers have
 * this information handy in this form.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteTruncateGuts</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>explicit_rels</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relids</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relids_logged</name></decl></parameter>,
					<parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>restart_seqs</name></decl></parameter>, <parameter><decl><type><name>TruncateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>seq_relids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>logrelids</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check the explicitly-specified relations.
	 *
	 * In CASCADE mode, suck in all referencing relations as well.  This
	 * requires multiple iterations to find indirectly-dependent relations. At
	 * each phase, we need to exclusive-lock new rels before looking for their
	 * dependencies, else we might miss something.  Also, we check each rel as
	 * soon as we open it, to avoid a faux pas such as holding lock for a long
	 * time on a rel we have no permissions for.
	 */</comment>
	<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>explicit_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>behavior</name> <operator>==</operator> <name>DROP_CASCADE</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newrelids</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newrelids</name> <operator>=</operator> <call><name>heap_truncate_find_FKs</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newrelids</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* nothing else to add */</comment>

			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>newrelids</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"truncate cascades to table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>truncate_check_rel</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>truncate_check_activity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Log this relation only if needed for logical decoding */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>relids_logged</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* GPDB does not support all FK feature but keeps FK grammar recognition,
	 * which reduces migration manual workload from other databases.
	 * We do not want to reject relation truncate if the relation contains FK
	 * satisfied tuple, so skip heap_truncate_check_FKs function call.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	<comment type="block">/*
	 * Check foreign key references.  In CASCADE mode, this should be
	 * unnecessary since we just pulled in all the references; but as a
	 * cross-check, do it anyway if in an Assert-enabled build.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	heap_truncate_check_FKs(rels, false);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	if (behavior == DROP_RESTRICT)
		heap_truncate_check_FKs(rels, false);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If we are asked to restart sequences, find all the sequences, lock them
	 * (we need AccessExclusiveLock for ResetSequence), and check permissions.
	 * We want to do this early since it's pointless to do all the truncation
	 * work only to fail on sequence permissions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>restart_seqs</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>seqlist</name> <init>= <expr><call><name>getOwnedSequences</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>seqcell</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>seqcell</argument>, <argument>seqlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>seq_relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>seqcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>seq_rel</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>seq_rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* This check must match AlterSequence! */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_SEQUENCE</name></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>seq_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>seq_relids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>seq_relids</name></expr></argument>, <argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seq_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Prepare to catch AFTER triggers. */</comment>
	<expr_stmt><expr><call><name>AfterTriggerBeginQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To fire triggers, we'll need an EState as well as a ResultRelInfo for
	 * each relation.  We don't need to call ExecOpenIndices, though.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelInfos</name> <operator>=</operator> <operator>(</operator><name>ResultRelInfo</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>rels</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>,
						  <argument><expr><name>rel</name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* dummy rangetable index */</comment>
						  <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process all BEFORE STATEMENT TRUNCATE triggers before we begin
	 * truncating (this is because one of them might throw an error). Also, if
	 * we were to allow them to prevent statement execution, that would need
	 * to be handled here.
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecBSTruncateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * OK, truncate each table.
	 */</comment>
	<expr_stmt><expr><name>mySubid</name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Skip partitioned tables as there is nothing to do */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Normally, we need a transaction-safe truncation here.  However, if
		 * the table was either created in the current (sub)transaction or has
		 * a new relfilenode in the current (sub)transaction, then we can just
		 * truncate it in-place, because a rollback would cause the whole
		 * table or the current physical file to be thrown away anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_createSubid</name></name> <operator>==</operator> <name>mySubid</name> <operator>||</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_newRelfilenodeSubid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Immediate, non-rollbackable truncation is OK */</comment>
			<expr_stmt><expr><call><name>heap_truncate_one_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>heap_relid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>toast_relid</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * This effectively deletes all rows in the table, and may be done
			 * in a serializable transaction.  In that case we must record a
			 * rw-conflict in to this transaction from each transaction
			 * holding a predicate lock on the table.
			 */</comment>
			<expr_stmt><expr><call><name>CheckTableForSerializableConflictIn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Need the full transaction-safe pushups.
			 *
			 * Create a new empty storage file for the relation, and assign it
			 * as the relfilenode value. The old storage file is scheduled for
			 * deletion at commit.
			 */</comment>
			<expr_stmt><expr><call><name>RelationSetNewRelfilenode</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>heap_relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The same for the toast table, if any.
			 */</comment>
			<expr_stmt><expr><name>toast_relid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>toastrel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>,
													 <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>RelationSetNewRelfilenode</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>,
										  <argument><expr><name><name>toastrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * The same for the ao auxiliary tables, if any.
			 */</comment>
			<expr_stmt><expr><call><name>ao_aux_tables_safe_truncate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Reconstruct the indexes to match, and we're done.
			 */</comment>
			<expr_stmt><expr><call><name>reindex_relation</name><argument_list>(<argument><expr><name>heap_relid</name></expr></argument>, <argument><expr><name>REINDEX_REL_PROCESS_TOAST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>pgstat_count_truncate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name>stmt</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
									<argument><expr><name>DF_CANCEL_ON_ERROR</name> <operator>|</operator>
									<name>DF_WITH_SNAPSHOT</name> <operator>|</operator>
									<name>DF_NEED_TWO_PHASE</name></expr></argument>,
									<argument><expr><name>NIL</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* MPP-6929: metadata tracking */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rels</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
							   <argument><expr><literal type="string">"VACUUM"</literal></expr></argument>, <argument><expr><literal type="string">"TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
							   <argument><expr><literal type="string">"TRUNCATE"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Restart owned sequences if we were asked to.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>seq_relids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>seq_relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ResetSequence</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Write a WAL record to allow this set of actions to be logically
	 * decoded.
	 *
	 * Assemble an array of relids so we can write a single WAL record for the
	 * whole action.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_heap_truncate</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* should only get here if wal_level &gt;= logical */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogLogicalInfoActive</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>logrelids</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>relids_logged</argument>)</argument_list></macro>
			<expr_stmt><expr><name><name>logrelids</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>dbId</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nrelids</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>behavior</name> <operator>==</operator> <name>DROP_CASCADE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_TRUNCATE_CASCADE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>restart_seqs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>XLH_TRUNCATE_RESTART_SEQS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHeapTruncate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>logrelids</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>relids_logged</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogSetRecordFlags</name><argument_list>(<argument><expr><name>XLOG_INCLUDE_ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HEAP_ID</name></expr></argument>, <argument><expr><name>XLOG_HEAP_TRUNCATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process all AFTER STATEMENT TRUNCATE triggers.
	 */</comment>
	<expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <name>resultRelInfos</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecASTruncateTriggers</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelInfo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Handle queued AFTER triggers */</comment>
	<expr_stmt><expr><call><name>AfterTriggerEndQuery</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can clean up the EState now */</comment>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Close any rels opened by CASCADE (can't do this while EState still
	 * holds refs)
	 */</comment>
	<expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>list_difference_ptr</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name>explicit_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Check that a given relation is safe to truncate.  Subroutine for
 * ExecuteTruncate() and RangeVarCallbackForTruncate().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>truncate_check_rel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_class</name></type> <name>reltuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>reltuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Only allow truncate on regular tables and partitioned tables (although,
	 * the latter are only being included here for the following checks; no
	 * physical truncation will occur in their case.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>reltuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>reltuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>!</operator><name>IsBinaryUpgrade</name> <operator>||</operator> <operator>(</operator>
			<name><name>reltuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOSEGMENTS</name> <operator>&amp;&amp;</operator>
			<name><name>reltuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOBLOCKDIR</name> <operator>&amp;&amp;</operator>
			<name><name>reltuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOVISIMAP</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Permissions checks */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_TRUNCATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>reltuple</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>reltuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set of extra sanity checks to check if a given relation is safe to
 * truncate.  This is split with truncate_check_rel() as
 * RangeVarCallbackForTruncate() cannot open a Relation yet.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>truncate_check_activity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Don't allow truncate on temp tables of other backends ... their local
	 * buffer manager is not going to cope.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot truncate temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also check for active uses of the relation in the current transaction,
	 * including open scans and pending AFTER trigger events.
	 */</comment>
	<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="string">"TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * storage_name
 *	  returns the name corresponding to a typstorage/attstorage enum value
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>storage_name</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'p'</literal></expr>:</case>
			<return>return <expr><literal type="string">"PLAIN"</literal></expr>;</return>
		<case>case <expr><literal type="char">'m'</literal></expr>:</case>
			<return>return <expr><literal type="string">"MAIN"</literal></expr>;</return>
		<case>case <expr><literal type="char">'x'</literal></expr>:</case>
			<return>return <expr><literal type="string">"EXTENDED"</literal></expr>;</return>
		<case>case <expr><literal type="char">'e'</literal></expr>:</case>
			<return>return <expr><literal type="string">"EXTERNAL"</literal></expr>;</return>
		<default>default:</default>
			<return>return <expr><literal type="string">"???"</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*----------
 * MergeAttributes
 *		Returns new schema given initial schema and superclasses.
 *
 * Input arguments:
 * 'schema' is the column/attribute definition for the table. (It's a list
 *		of ColumnDef's.) It is destructively changed.
 * 'supers' is a list of OIDs of parent relations, already locked by caller.
 * 'relpersistence' is a persistence type of the table.
 * 'is_partition' tells if the table is a partition
 *
 * Output arguments:
 * 'supconstr' receives a list of constraints belonging to the parents,
 *		updated as necessary to be valid for the child.
 *
 * Return value:
 * Completed schema list.
 *
 * Notes:
 *	  The order in which the attributes are inherited is very important.
 *	  Intuitively, the inherited attributes should come first. If a table
 *	  inherits from multiple parents, the order of those attributes are
 *	  according to the order of the parents specified in CREATE TABLE.
 *
 *	  Here's an example:
 *
 *		create table person (name text, age int4, location point);
 *		create table emp (salary int4, manager text) inherits(person);
 *		create table student (gpa float8) inherits (person);
 *		create table stud_emp (percent int4) inherits (emp, student);
 *
 *	  The order of the attributes of stud_emp is:
 *
 *							person {1:name, 2:age, 3:location}
 *							/	 \
 *			   {6:gpa}	student   emp {4:salary, 5:manager}
 *							\	 /
 *						   stud_emp {7:percent}
 *
 *	   If the same attribute name appears multiple times, then it appears
 *	   in the result table in the proper location for its first appearance.
 *
 *	   Constraints (including NOT NULL constraints) for the child table
 *	   are the union of all relevant constraints, from both the child schema
 *	   and parent tables.
 *
 *	   The default value for a child column is defined as:
 *		(1) If the child schema specifies a default, that value is used.
 *		(2) If neither the child nor any parent specifies a default, then
 *			the column will not have a default.
 *		(3) If conflicting defaults are inherited from different parents
 *			(and not overridden by the child), an error is raised.
 *		(4) Otherwise the inherited default is used.
 *		Rule (3) is new in Postgres 7.1; in earlier releases you got a
 *		rather arbitrary choice of which parent default to use.
 *----------
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>MergeAttributes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>supers</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>is_partition</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>supconstr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>gp_style_alter_part</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inhSchema</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>constraints</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_bogus_defaults</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>child_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>Node</name></type> <name>bogus_marker</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* marks conflicting defaults */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>saved_schema</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check for and reject tables with too many columns. We perform this
	 * check relatively early for two reasons: (a) we don't run the risk of
	 * overflowing an AttrNumber in subsequent code (b) an O(n^2) algorithm is
	 * okay if we're processing &lt;= 1600 columns, but could take minutes to
	 * execute if the user attempts to create a table with hundreds of
	 * thousands of columns.
	 *
	 * Note that we also need to check that we do not exceed this figure after
	 * including columns from inherited relations.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MaxHeapAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tables can have at most %d columns"</literal></expr></argument>,
						<argument><expr><name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for duplicate names in the explicit list of attributes.
	 *
	 * Although we might consider merging such entries in the same way that we
	 * handle name conflicts for inherited attributes, it seems to make more
	 * sense to assume such conflicts are errors.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>schema</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>coldef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rest</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>entry</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_partition</name> <operator>&amp;&amp;</operator> <name><name>coldef</name><operator>-&gt;</operator><name>typeName</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Typed table column option that does not belong to a column from
			 * the type.  This works because the columns from the type come
			 * first in the list.  (We omit this check for partition column
			 * lists; those are processed separately below.)
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<while>while <condition>(<expr><name>rest</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>restdef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* need to save it in case we
											 * delete it */</comment>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>restdef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>coldef</name><operator>-&gt;</operator><name>is_from_type</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * merge the column options into the column from the type
					 */</comment>
					<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>cooked_default</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>constraints</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_from_type</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>schema</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * As two elements are merged and one is removed, we
					 * should never finish with an empty list.
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>schema</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" specified more than once"</literal></expr></argument>,
									<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>rest</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rest</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block>

	<comment type="block">/*
	 * In case of a partition, there are no new column definitions, only dummy
	 * ColumnDefs created for column constraints.  Set them aside for now and
	 * process them at the end.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_partition</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>saved_schema</name> <operator>=</operator> <name>schema</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>schema</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Scan the parents left-to-right, and merge their attributes to form a
	 * list of inherited attributes (inhSchema).  Also check to see if we need
	 * to inherit an OID column.
	 */</comment>
	<expr_stmt><expr><name>child_attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>supers</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parent</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>newattno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>parent_attno</name></decl>;</decl_stmt>

		<comment type="block">/* caller already got lock */</comment>
		<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for active uses of the parent partitioned table in the
		 * current transaction, such as being used in some manner by an
		 * enclosing command.
		 *
		 * GPDB-style ALTER TABLE ADD|SPLIT PARTITION can't meet this 
		 * upstream expectation on QD. As during alter, reference is 
		 * already held by alter command, and when we generate CREATE 
		 * STMT and execute them we have 2 reference instead on 1 here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_partition</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <operator>!</operator><name>gp_style_alter_part</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE .. PARTITION OF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We do not allow partitioned tables and partitions to participate in
		 * regular inheritance.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>is_partition</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from partitioned table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_partition</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from partition \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited relation \"%s\" is not a table or foreign table"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the parent is permanent, so must be all of its partitions.  Note
		 * that inheritance allows that case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_partition</name> <operator>&amp;&amp;</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
			<name>relpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create a temporary relation as partition of permanent relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Permanent rels cannot inherit from temporary ones */</comment>
		<if_stmt><if>if <condition>(<expr><name>relpersistence</name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
			<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><ternary><condition><expr><operator>!</operator><name>is_partition</name></expr>
							?</condition><then> <expr><literal type="string">"cannot inherit from temporary relation \"%s\""</literal></expr>
							</then><else>: <expr><literal type="string">"cannot create a permanent relation as partition of temporary relation \"%s\""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If existing rel is temp, it must belong to this session */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>relation</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><ternary><condition><expr><operator>!</operator><name>is_partition</name></expr>
							?</condition><then> <expr><literal type="string">"cannot inherit from temporary relation of another session"</literal></expr>
							</then><else>: <expr><literal type="string">"cannot create as partition of temporary relation of another session"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We should have an UNDER permission flag for this, but for now,
		 * demand that creator of a child table own the parent.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>constr</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * newattno[] will contain the child-table attribute numbers for the
		 * attributes of this parent table.  (They are not the same for
		 * parents after the first one, nor if we have dropped columns.)
		 */</comment>
		<expr_stmt><expr><name>newattno</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>parent_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>parent_attno</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition>
			 <incr><expr><name>parent_attno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
														<argument><expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>exist_attno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Ignore dropped columns in the parent.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* leave newattno entry as zero */</comment>

			<comment type="block">/*
			 * Does it conflict with some previously inherited column?
			 */</comment>
			<expr_stmt><expr><name>exist_attno</name> <operator>=</operator> <call><name>findAttrByName</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>, <argument><expr><name>inhSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>exist_attno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>defTypeId</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>deftypmod</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>defCollId</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Yes, try to merge the two column definitions. They must
				 * have the same type, typmod, and collation.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"merging multiple inherited definitions of column \"%s\""</literal></expr></argument>,
								<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>def</name> <operator>=</operator> <operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>inhSchema</name></expr></argument>, <argument><expr><name>exist_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>deftypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>defTypeId</name> <operator>!=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
					<name>deftypmod</name> <operator>!=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited column \"%s\" has a type conflict"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
									   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>defTypeId</name></expr></argument>,
																<argument><expr><name>deftypmod</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
																<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>defCollId</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>defTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>defCollId</name> <operator>!=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited column \"%s\" has a collation conflict"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" versus \"%s\""</literal></expr></argument>,
									   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>defCollId</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Copy storage parameter */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>!=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited column \"%s\" has a storage parameter conflict"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
									   <argument><expr><call><name>storage_name</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>storage_name</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>inhcount</name></name><operator>++</operator></expr>;</expr_stmt>
				<comment type="block">/* Merge of NOT NULL constraints = OR 'em together */</comment>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>|=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>;</expr_stmt>
				<comment type="block">/* Default and other constraints are handled below */</comment>
				<expr_stmt><expr><name><name>newattno</name><index>[<expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>exist_attno</name></expr>;</expr_stmt>

				<comment type="block">/* Check for GENERATED conflicts */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>generated</name></name> <operator>!=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited column \"%s\" has a generation conflict"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * No, create a new inherited column
				 */</comment>
				<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
													<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_from_type</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>generated</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>collClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>inhSchema</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>inhSchema</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newattno</name><index>[<expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>child_attno</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Copy default if any
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>this_default</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>attrdef</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<comment type="block">/* Find default in constraint structure */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>constr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>attrdef</name> <operator>=</operator> <name><name>constr</name><operator>-&gt;</operator><name>defval</name></name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adnum</name> <operator>==</operator> <name>parent_attno</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>this_default</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>this_default</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If default expr could contain any vars, we'd need to fix
				 * 'em, but it can't; so default is ready to apply to child.
				 *
				 * If we already had a default from some prior parent, check
				 * to see if they are the same.  If so, no problem; if not,
				 * mark the column as having a bogus default. Below, we will
				 * complain if the bogus default isn't overridden by the child
				 * schema.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>this_default</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name></expr></argument>, <argument><expr><name>this_default</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <operator>&amp;</operator><name>bogus_marker</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>have_bogus_defaults</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Now copy the CHECK constraints of this parent, adjusting attnos
		 * using the completed newattno[] map.  Identically named constraints
		 * are merged if possible, else we throw error.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>constr</name> <operator>&amp;&amp;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ConstrCheck</name> <modifier>*</modifier></type><name>check</name> <init>= <expr><name><name>constr</name><operator>-&gt;</operator><name>check</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccname</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

				<comment type="block">/* ignore if the constraint is non-inheritable */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccnoinherit</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* Adjust Vars to match new table's column numbering */</comment>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>map_variable_attnos</name><argument_list>(<argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name>newattno</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * For the moment we have to reject whole-row variables. We
				 * could convert them, if we knew the new table's rowtype OID,
				 * but that hasn't been assigned yet.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Constraint \"%s\" contains a whole-row reference to table \"%s\"."</literal></expr></argument>,
									   <argument><expr><name>name</name></expr></argument>,
									   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* check for duplicate */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MergeCheckConstraint</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* nope, this is a new one */</comment>
					<decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>cooked</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>cooked</name> <operator>=</operator> <operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CookedConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_CHECK</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>conoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* until created */</comment>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* not used for constraints */</comment>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_no_inherit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>constraints</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>, <argument><expr><name>cooked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Close the parent rel, but keep our lock on it until xact commit.
		 * That will prevent someone else from deleting or ALTERing the parent
		 * before the child is committed.
		 */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we had no inherited attributes, the result schema is just the
	 * explicitly declared columns.  Otherwise, we need to merge the declared
	 * columns into the inherited schema list.  Although, we never have any
	 * explicitly declared columns if the table is a partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>inhSchema</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>schema_attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>schema</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>newdef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><name><name>newdef</name><operator>-&gt;</operator><name>colname</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>exist_attno</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>schema_attno</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * Does it conflict with some previously inherited column?
			 */</comment>
			<expr_stmt><expr><name>exist_attno</name> <operator>=</operator> <call><name>findAttrByName</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>, <argument><expr><name>inhSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>exist_attno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>defTypeId</name></decl>,
							<decl><type ref="prev"/><name>newTypeId</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>deftypmod</name></decl>,
							<decl><type ref="prev"/><name>newtypmod</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>defcollid</name></decl>,
							<decl><type ref="prev"/><name>newcollid</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Partitions have only one parent and have no column
				 * definitions of their own, so conflict should never occur.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Yes, try to merge the two column definitions. They must
				 * have the same type, typmod, and collation.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>exist_attno</name> <operator>==</operator> <name>schema_attno</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"merging column \"%s\" with inherited definition"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"moving and merging column \"%s\" with inherited definition"</literal></expr></argument>, <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User-specified column moved to the position of the inherited column."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>def</name> <operator>=</operator> <operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>inhSchema</name></expr></argument>, <argument><expr><name>exist_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>deftypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>newdef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>defTypeId</name> <operator>!=</operator> <name>newTypeId</name> <operator>||</operator> <name>deftypmod</name> <operator>!=</operator> <name>newtypmod</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" has a type conflict"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
									   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>defTypeId</name></expr></argument>,
																<argument><expr><name>deftypmod</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>newTypeId</name></expr></argument>,
																<argument><expr><name>newtypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>defcollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>defTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>newcollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newdef</name></expr></argument>, <argument><expr><name>newTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>defcollid</name> <operator>!=</operator> <name>newcollid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" has a collation conflict"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" versus \"%s\""</literal></expr></argument>,
									   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>defcollid</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>newcollid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Identity is never inherited.  The new column can have an
				 * identity definition, so we always just take that one.
				 */</comment>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>identity</name></name> <operator>=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>identity</name></name></expr>;</expr_stmt>

				<comment type="block">/* Copy storage parameter */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>storage</name></name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>newdef</name><operator>-&gt;</operator><name>storage</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>!=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>storage</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" has a storage parameter conflict"</literal></expr></argument>,
									<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s versus %s"</literal></expr></argument>,
									   <argument><expr><call><name>storage_name</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>storage_name</name><argument_list>(<argument><expr><name><name>newdef</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Mark the column as locally defined */</comment>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* Merge of NOT NULL constraints = OR 'em together */</comment>
				<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>|=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
				<comment type="block">/* If new def has a default, override previous default */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>newdef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name><name>newdef</name><operator>-&gt;</operator><name>cooked_default</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * No, attach new column to result schema
				 */</comment>
				<expr_stmt><expr><name>inhSchema</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>inhSchema</name></expr></argument>, <argument><expr><name>newdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>schema</name> <operator>=</operator> <name>inhSchema</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check that we haven't exceeded the legal # of columns after merging
		 * in inherited columns.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MaxHeapAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tables can have at most %d columns"</literal></expr></argument>,
							<argument><expr><name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now that we have the column definition list for a partition, we can
	 * check whether the columns referenced in the column constraint specs
	 * actually exist.  Also, we merge NOT NULL and defaults into each
	 * corresponding column definition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_partition</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>saved_schema</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>restdef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>schema</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>coldef</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>restdef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>|=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Override the parent's default value for this column
					 * (coldef-&gt;cooked_default) with the partition's local
					 * definition (restdef-&gt;raw_default), if there's one. It
					 * should be physically impossible to get a cooked default
					 * in the local definition or a raw default in the
					 * inherited definition, but make sure they're nulls, for
					 * future-proofing.
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>restdef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>coldef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>restdef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>restdef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>coldef</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* complain for constraints on columns not in parent */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name><name>restdef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we found any conflicting parent default values, check to make sure
	 * they were overridden by the child.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>have_bogus_defaults</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>schema</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>==</operator> <operator>&amp;</operator><name>bogus_marker</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" inherits conflicting default values"</literal></expr></argument>,
								<argument><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To resolve the conflict, specify a default explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>supconstr</name> <operator>=</operator> <name>constraints</name></expr>;</expr_stmt>
	<return>return <expr><name>schema</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MergeCheckConstraint
 *		Try to merge an inherited CHECK constraint with previous ones
 *
 * If we inherit identically-named constraints from multiple parents, we must
 * merge them, or throw an error if they don't have identical definitions.
 *
 * constraints is a list of CookedConstraint structs for previous constraints.
 *
 * Returns true if merged (constraint is a duplicate), or false if it's
 * got a so-far-unique name, or throws error if conflict.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MergeCheckConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>constraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>ccon</name> <init>= <expr><operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ccon</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_CHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Non-matching names never conflict */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ccon</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>ccon</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* OK to merge */</comment>
			<expr_stmt><expr><name><name>ccon</name><operator>-&gt;</operator><name>inhcount</name></name><operator>++</operator></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"check constraint name \"%s\" appears multiple times but with different expressions"</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StoreCatalogInheritance
 *		Updates the system catalogs with proper inheritance information.
 *
 * supers is a list of the OIDs of the new relation's direct ancestors.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StoreCatalogInheritance</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>supers</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>child_is_partition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>seqNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>supers</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Store INHERITS information in pg_inherits using direct ancestors only.
	 * Also enter dependencies on the direct ancestors, and make sure they are
	 * marked with relhassubclass = true.
	 *
	 * (Once upon a time, both direct and indirect ancestors were found here
	 * and then entered into pg_ipl.  Since that catalog doesn't exist
	 * anymore, there's no need to look for indirect ancestors.)
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seqNumber</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>entry</argument>, <argument>supers</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>StoreCatalogInheritance1</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>seqNumber</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>,
								 <argument><expr><name>child_is_partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>seqNumber</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make catalog entries showing relationId as being an inheritance child
 * of parentOid.  inhRelation is the already-opened pg_inherits catalog.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StoreCatalogInheritance1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentOid</name></decl></parameter>,
						 <parameter><decl><type><name>int32</name></type> <name>seqNumber</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>inhRelation</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>child_is_partition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>childobject</name></decl>,
				<decl><type ref="prev"/><name>parentobject</name></decl>;</decl_stmt>

	<comment type="block">/* store the pg_inherits row */</comment>
	<expr_stmt><expr><call><name>StoreSingleInheritance</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>seqNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store a dependency too
	 */</comment>
	<expr_stmt><expr><name><name>parentobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parentobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>parentOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parentobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>childobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>childobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parentobject</name></expr></argument>,
					   <argument><expr><call><name>child_dependency_type</name><argument_list>(<argument><expr><name>child_is_partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Post creation hook of this inheritance. Since object_access_hook
	 * doesn't take multiple object identifiers, we relay oid of parent
	 * relation using auxiliary_id argument.
	 */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>,
								 <argument><expr><name>relationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the parent as having subclasses.
	 */</comment>
	<expr_stmt><expr><call><name>SetRelationHasSubclass</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Look for an existing schema entry with the given name.
 *
 * Returns the index (starting with 1) if attribute already exists in schema,
 * 0 if it doesn't.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>findAttrByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attributeName</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>schema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>s</argument>, <argument>schema</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetRelationHasSubclass
 *		Set the value of the relation's relhassubclass field in pg_class.
 *
 * NOTE: caller must be holding an appropriate lock on the relation.
 * ShareUpdateExclusiveLock is sufficient.
 *
 * NOTE: an important side-effect of this operation is that an SI invalidation
 * message is sent out to all backends --- including me --- causing plans
 * referencing the relation to be rebuilt with the new list of children.
 * This must happen even if we find that no change is needed in the pg_class
 * row.
 */</comment>
<function><type><name>void</name></type>
<name>SetRelationHasSubclass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>relhassubclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relationRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classtuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Fetch a modifiable copy of the tuple, modify it, update pg_class.
	 */</comment>
	<expr_stmt><expr><name>relationRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>classtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>classtuple</name><operator>-&gt;</operator><name>relhassubclass</name></name> <operator>!=</operator> <name>relhassubclass</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>classtuple</name><operator>-&gt;</operator><name>relhassubclass</name></name> <operator>=</operator> <name>relhassubclass</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no need to change tuple, but force relcache rebuild anyway */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		renameatt_check			- basic sanity checks before attribute rename
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>renameatt_check</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name> <init>= <expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>classform</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename column of typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Renaming the columns of sequences or toast tables doesn't actually
	 * break anything from the system's point of view, since internal
	 * references are by attnum.  But it doesn't seem right to allow users to
	 * change names that are hardcoded into the system, hence the following
	 * restriction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, composite type, index, or foreign table"</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * permissions checking.  only the owner of a class can change its schema.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>classform</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		renameatt_internal		- workhorse for renameatt
 *
 * Return value is the attribute number in the 'myrelid' relation.
 */</comment>
<function><type><specifier>static</specifier> <name>AttrNumber</name></type>
<name>renameatt_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldattname</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newattname</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>expected_parents</name></decl></parameter>,
				   <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>targetrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Grab an exclusive lock on the target table, which we will NOT release
	 * until end of transaction.
	 */</comment>
	<expr_stmt><expr><name>targetrelation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>renameatt_check</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recursing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if the 'recurse' flag is set then we are supposed to rename this
	 * attribute in all classes that inherit from 'relname' (as well as in
	 * 'relname').
	 *
	 * any permissions or problems with duplicate attributes will cause the
	 * whole transaction to abort, which is what we want -- all or nothing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_oids</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>child_numparents</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lo</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * we need the number of parents for each child so that the recursive
		 * calls to renameatt() can determine whether there are any parents
		 * outside the inheritance hierarchy being processed.
		 */</comment>
		<expr_stmt><expr><name>child_oids</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>child_numparents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * find_all_inheritors does the recursive search of the inheritance
		 * hierarchy, so all we have to do is process all of the relids in the
		 * list that it returns.
		 */</comment>
		<macro><name>forboth</name><argument_list>(<argument>lo</argument>, <argument>child_oids</argument>, <argument>li</argument>, <argument>child_numparents</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>numparents</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>childrelid</name> <operator>==</operator> <name>myrelid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* note we need not recurse again */</comment>
			<expr_stmt><expr><call><name>renameatt_internal</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>oldattname</name></expr></argument>, <argument><expr><name>newattname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>numparents</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If we are told not to recurse, there had better not be any child
		 * tables; else the rename would put them out of step.
		 *
		 * expected_parents will only be 0 if we are not already recursing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>expected_parents</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited column \"%s\" must be renamed in child tables too"</literal></expr></argument>,
							<argument><expr><name>oldattname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* rename attributes in typed tables of composite type */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_oids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>child_oids</name> <operator>=</operator> <call><name>find_typed_table_dependencies</name><argument_list>(<argument><expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
												   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lo</argument>, <argument>child_oids</argument>)</argument_list></macro>
			<expr_stmt><expr><call><name>renameatt_internal</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldattname</name></expr></argument>, <argument><expr><name>newattname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>atttup</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>oldattname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>oldattname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>oldattname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * if the attribute is inherited, forbid the renaming.  if this is a
	 * top-level call to renameatt(), then expected_parents will be 0, so the
	 * effect of this code will be to prohibit the renaming if the attribute
	 * is inherited at all.  if this is a recursive call to renameatt(),
	 * expected_parents will be the number of parents the current relation has
	 * within the inheritance hierarchy being processed, so we'll prohibit the
	 * renaming only if there are additional parents from elsewhere.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attform</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&gt;</operator> <name>expected_parents</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename inherited column \"%s\""</literal></expr></argument>,
						<argument><expr><name>oldattname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* new name should not already exist */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>check_for_column_name_collision</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>newattname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* apply the update */</comment>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>attform</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>newattname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>atttup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929, MPP-7600: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"RENAME COLUMN"</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* close rel but keep lock */</comment>

	<return>return <expr><name>attnum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform permissions and integrity checks before acquiring a relation lock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForRenameAttribute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldrelid</name></decl></parameter>,
								   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>form</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* concurrently dropped */</comment>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>renameatt_check</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>form</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		renameatt		- changes the name of an attribute in a relation
 *
 * The returned ObjectAddress is that of the renamed column.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>renameatt</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/* lock level taken here should match renameatt_internal */</comment>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr> ?</condition><then> <expr><name>RVR_MISSING_OK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
									 <argument><expr><name>RangeVarCallbackForRenameAttribute</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator>
		<call><name>renameatt_internal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>,	<comment type="block">/* old att name */</comment>
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>,	<comment type="block">/* new att name */</comment>
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <comment type="block">/* recursive? */</comment>
						   <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* recursing? */</comment>
						   <argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* expected inhcount */</comment>
						   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * same logic as renameatt_internal
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>rename_constraint_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>mytypid</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldconname</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newconname</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>expected_parents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>targetrelation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><operator>!</operator><name>myrelid</name> <operator>||</operator> <operator>!</operator><name>mytypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mytypid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>constraintOid</name> <operator>=</operator> <call><name>get_domain_constraint_oid</name><argument_list>(<argument><expr><name>mytypid</name></expr></argument>, <argument><expr><name>oldconname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>targetrelation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * don't tell it whether we're recursing; we allow changing typed
		 * tables here
		 */</comment>
		<expr_stmt><expr><call><name>renameatt_check</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>constraintOid</name> <operator>=</operator> <call><name>get_relation_constraint_oid</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>oldconname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>,
			 <argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>myrelid</name> <operator>&amp;&amp;</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_CHECK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>child_oids</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>child_numparents</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lo</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>child_oids</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>child_numparents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>forboth</name><argument_list>(<argument>lo</argument>, <argument>child_oids</argument>, <argument>li</argument>, <argument>child_numparents</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>numparents</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>childrelid</name> <operator>==</operator> <name>myrelid</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>rename_constraint_internal</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>oldconname</name></expr></argument>, <argument><expr><name>newconname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>numparents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>expected_parents</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited constraint \"%s\" must be renamed in child tables too"</literal></expr></argument>,
								<argument><expr><name>oldconname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>&gt;</operator> <name>expected_parents</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rename inherited constraint \"%s\""</literal></expr></argument>,
							<argument><expr><name>oldconname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>conindid</name></name>
		<operator>&amp;&amp;</operator> <operator>(</operator><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_PRIMARY</name>
			<operator>||</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_UNIQUE</name>
			<operator>||</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_EXCLUSION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* rename the index; this renames the constraint as well */</comment>
		<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conindid</name></name></expr></argument>, <argument><expr><name>newconname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RenameConstraintById</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>, <argument><expr><name>newconname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetrelation</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Invalidate relcache so as others can see the new constraint name.
		 */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* close rel but keep lock */</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ObjectAddress</name></type>
<name>RenameConstraint</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_DOMCONSTRAINT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>typid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>checkDomainOwner</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* lock level taken here should match rename_constraint_internal */</comment>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
										 <argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr> ?</condition><then> <expr><name>RVR_MISSING_OK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
										 <argument><expr><name>RangeVarCallbackForRenameAttribute</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
							<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return
		<expr><call><name>rename_constraint_internal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>,
								   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>,
								   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>,
								   <argument><expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>&amp;&amp;</operator>
									<name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name><operator>)</operator></expr></argument>,	<comment type="block">/* recursive? */</comment>
								   <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* recursing? */</comment>
								   <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* expected inhcount */</comment> )</argument_list></call></expr>;</return>

</block_content>}</block></function>

<comment type="block">/*
 * Execute ALTER TABLE/INDEX/SEQUENCE/VIEW/MATERIALIZED VIEW/FOREIGN TABLE
 * RENAME
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>RenameRelation</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_index</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_INDEX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>targetrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldrelname</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Grab an exclusive lock on the target table, index, sequence, view,
	 * materialized view, or foreign table, which we will NOT release until
	 * end of transaction.
	 *
	 * Lock level used here should match RenameRelationInternal, to avoid lock
	 * escalation.
	 */</comment>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
									 <argument><expr><ternary><condition><expr><name>is_index</name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>AccessExclusiveLock</name></expr></else></ternary></expr></argument>,
									 <argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr> ?</condition><then> <expr><name>RVR_MISSING_OK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
									 <argument><expr><name>RangeVarCallbackForAlterRelation</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Grab an exclusive lock on the target table, index, sequence
	 * or view, which we will NOT release until end of transaction.
	 */</comment>
	<expr_stmt><expr><name>targetrelation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldrelname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do the work */</comment>
	<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>is_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>GpRenameChildPartitions</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>oldrelname</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Close rel, but keep exclusive lock!
	 */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		RenameRelationInternal - change the name of a relation
 */</comment>
<function><type><name>void</name></type>
<name>RenameRelationInternal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myrelid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newrelname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>targetrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relrelation</name></decl>;</decl_stmt>	<comment type="block">/* for RELATION relation */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Grab a lock on the target relation, which we will NOT release until end
	 * of transaction.  We need at least a self-exclusive lock so that
	 * concurrent DDL doesn't overwrite the rename if they start updating
	 * while still seeing the old version.  The lock also guards against
	 * triggering relcache reloads in concurrent sessions, which might not
	 * handle this information changing under them.  For indexes, we can use a
	 * reduced lock level because RelationReloadIndexInfo() handles indexes
	 * specially.
	 */</comment>
	<expr_stmt><expr><name>targetrelation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><ternary><condition><expr><name>is_index</name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>AccessExclusiveLock</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find relation's pg_class tuple, and make sure newrelname isn't in use.
	 */</comment>
	<expr_stmt><expr><name>relrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name>newrelname</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists"</literal></expr></argument>,
						<argument><expr><name>newrelname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Update pg_class tuple with new relname.  (Scribbling on reltup is OK
	 * because it's a copy...)
	 */</comment>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>relform</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>newrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also rename the associated type, if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RenameTypeInternal</name><argument_list>(<argument><expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
						   <argument><expr><name>newrelname</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also rename the associated constraint, if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintId</name> <init>= <expr><call><name>get_index_constraint</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RenameConstraintById</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>, <argument><expr><name>newrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator>
		<comment type="block">/* MPP-7773: don't track objects in system namespace
		 * if modifying system tables (eg during upgrade)
		 */</comment>
		<operator>(</operator> <operator>!</operator> <operator>(</operator> <operator>(</operator><name>PG_CATALOG_NAMESPACE</name> <operator>==</operator> <name>namespaceId</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>allowSystemTableMods</name><operator>)</operator><operator>)</operator><operator>)</operator>
		<operator>&amp;&amp;</operator> <operator>(</operator>   <call><name>MetaTrackValidRelkind</name><argument_list>(<argument><expr><name><name>targetrelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <call><name>METATRACK_VALIDNAMESPACE</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call>
			   <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator>
				<operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><name>myrelid</name></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"RENAME"</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Close rel, but keep lock!
	 */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Disallow ALTER TABLE (and similar commands) when the current backend has
 * any open reference to the target table besides the one just acquired by
 * the calling command; this implies there's an open cursor or active plan.
 * We need this check because our lock doesn't protect us against stomping
 * on our own foot, only other people's feet!
 *
 * For ALTER TABLE, the only case known to cause serious trouble is ALTER
 * COLUMN TYPE, and some changes are obviously pretty benign, so this could
 * possibly be relaxed to only error out for certain types of alterations.
 * But the use-case for allowing any of these things is not obvious, so we
 * won't work hard at it for now.
 *
 * We also reject these commands if there are any pending AFTER trigger events
 * for the rel.  This is certainly necessary for the rewriting variants of
 * ALTER TABLE, because they don't preserve tuple TIDs and so the pending
 * events would try to fetch the wrong tuples.  It might be overly cautious
 * in other cases, but again it seems better to err on the side of paranoia.
 *
 * REINDEX calls this with "rel" referencing the index to be rebuilt; here
 * we are worried about active indexscans on the index.  The trigger-event
 * check can be skipped, since we are doing no damage to the parent table.
 *
 * The statement name (eg, "ALTER TABLE") is passed for use in error messages.
 */</comment>
<function><type><name>void</name></type>
<name>CheckTableNotInUse</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>expected_refcnt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>expected_refcnt</name> <operator>=</operator> <ternary><condition><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_isnailed</name></name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX For a bitmap index, since vacuum (or vacuum full) is currently done through
	 * reindex_index, the reference count could be 2 (or 3). We set it
	 * here until vacuum is done properly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>expected_refcnt</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<call><name>RelationIsBitmapIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expected_refcnt</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_refcnt</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_refcnt</name></name> <operator>!=</operator> <name>expected_refcnt</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_IN_USE</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: first %s is a SQL command, eg ALTER TABLE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot %s \"%s\" because it is being used by active queries in this session"</literal></expr></argument>,
						<argument><expr><name>stmt</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
		<call><name>AfterTriggerPendingOnRel</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_IN_USE</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: first %s is a SQL command, eg ALTER TABLE */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot %s \"%s\" because it has pending trigger events"</literal></expr></argument>,
						<argument><expr><name>stmt</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTableLookupRelation
 *		Look up, and lock, the OID for the relation named by an alter table
 *		statement.
 */</comment>
<function><type><name>Oid</name></type>
<name>AlterTableLookupRelation</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
									<argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr> ?</condition><then> <expr><name>RVR_MISSING_OK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
									<argument><expr><name>RangeVarCallbackForAlterRelation</name></expr></argument>,
									<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTable
 *		Execute ALTER TABLE, which can be a list of subcommands
 *
 * ALTER TABLE is performed in three phases:
 *		1. Examine subcommands and perform pre-transformation checking.
 *		2. Update system catalogs.
 *		3. Scan table(s) to check new constraints, and optionally recopy
 *		   the data into new table(s).
 * Phase 3 is not performed unless one or more of the subcommands requires
 * it.  The intention of this design is to allow multiple independent
 * updates of the table schema to be performed with only one pass over the
 * data.
 *
 * ATPrepCmd performs phase 1.  A "work queue" entry is created for
 * each table to be affected (there may be multiple affected tables if the
 * commands traverse a table inheritance hierarchy).  Also we do preliminary
 * validation of the subcommands, including parse transformation of those
 * expressions that need to be evaluated with respect to the old table
 * schema.
 *
 * ATRewriteCatalogs performs phase 2 for each affected table.  (Note that
 * phases 2 and 3 normally do no explicit recursion, since phase 1 already
 * did it --- although some subcommands have to recurse in phase 2 instead.)
 * Certain subcommands need to be performed before others to avoid
 * unnecessary conflicts; for example, DROP COLUMN should come before
 * ADD COLUMN.  Therefore phase 1 divides the subcommands into multiple
 * lists, one for each logical "pass" of phase 2.
 *
 * ATRewriteTables performs phase 3 for those tables that need it.
 *
 * Thanks to the magic of MVCC, an error anywhere along the way rolls back
 * the whole operation; we don't have to do anything special to clean up.
 *
 * The caller must lock the relation, with an appropriate lock level
 * for the subcommands requested, using AlterTableGetLockLevel(stmt-&gt;cmds)
 * or higher. We pass the lock level down
 * so that we can apply it recursively to inherited tables. Note that the
 * lock level we want as we recurse might well be higher than required for
 * that specific subcommand. So we pass down the overall lock requirement,
 * rather than reassess it at lower levels.
 */</comment>
<function><type><name>void</name></type>
<name>AlterTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<comment type="block">/* Caller is required to provide an adequate lock. */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * GPDB creates ALTER stmts and executes them internally as part of some
	 * partition related ALTER stmts, hence for such internal ALTER stmts
	 * can't meet this requirement.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_internal</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ATController</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If a transaction is in progress, kill any idle QE backends. They
		 * might be running with obsolete information in their relcaches. Any
		 * relcache invalidation events sent by the ALTER TABLE subcommands
		 * won't be sent to the other backend until the end of transaction, and
		 * we don't have any better way of invalidating them. The primary
		 * writer backends should be up-to-date, because we have used that to
		 * execute all the subcommands, so they should've created local
		 * invalidation events for themselves.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>DisconnectAndDestroyUnusedQEs</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>prepare_AlterTableStmt_for_dispatch</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
										<argument><expr><name>DF_CANCEL_ON_ERROR</name> <operator>|</operator>
										<name>DF_WITH_SNAPSHOT</name> <operator>|</operator>
										<name>DF_NEED_TWO_PHASE</name></expr></argument>,
										<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare an AlterTableStmt for dispatch.
 *
 * The GPDB partitioning subcommands are expanded and
 * immediately executed in ATExecCmd() phase. They are not included in the
 * working queues. By the time we dispatch the command, we have already
 * executed and dispatched those subcommands, so remove them from command
 * we'll dispatch now.
 *
 * GPDB_12_MERGE_FIXME: This is a bit bogus, because if you have multiple
 * ALTER TABLE subcommands in one command, the commands might be executed
 * in different order in the QEs than in the QD. I think it would be better
 * to expand the commands in the ATPrepCmd() phase, and included them in
 * the working queues for dispatching, instead of dispatching them
 * separately in the ATExecCmd() phase.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_AlterTableStmt_for_dispatch</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <call><name>strip_gpdb_part_commands</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt-&gt;wqueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>AT_NUM_PASSES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>strip_gpdb_part_commands</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>strip_gpdb_part_commands</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newcmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AT_PartAdd</name></expr>:</case>
			<case>case <expr><name>AT_PartDrop</name></expr>:</case>
			<case>case <expr><name>AT_PartAlter</name></expr>:</case>
			<case>case <expr><name>AT_PartSplit</name></expr>:</case>
			<case>case <expr><name>AT_PartRename</name></expr>:</case>
			<case>case <expr><name>AT_PartTruncate</name></expr>:</case>
			<case>case <expr><name>AT_PartExchange</name></expr>:</case>
			<case>case <expr><name>AT_PartSetTemplate</name></expr>:</case>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<return>return <expr><name>newcmds</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * Populate the column encoding option for each column in the relation. 
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>populate_rel_col_encodings</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stenc</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>withOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> 		<name>attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> 		<modifier>*</modifier></type><name>colDefs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> 	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Figure out the column definition list. */</comment>
	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> 	<name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnDef</name> 		<modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>makeColumnDef</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, 
								<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>colDefs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colDefs</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attr_encodings</name> <init>= <expr><call><name>transformColumnEncoding</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
							<argument><expr><name>colDefs</name></expr></argument> <comment type="block">/*column clauses*/</comment>,
							<argument><expr><name>stenc</name></expr></argument> <comment type="block">/*encoding clauses*/</comment>,
							<argument><expr><name>withOptions</name></expr></argument> <comment type="block">/*withOptions*/</comment>,
							<argument><expr><name>NULL</name></expr></argument> <comment type="block">/*parent encoding*/</comment>,
							<argument><expr><name>false</name></expr></argument> <comment type="block">/*explicitOnly*/</comment>,
							<argument><expr><name>false</name></expr></argument> <comment type="block">/*errorOnEncodingClause*/</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AddRelationAttributeEncodings</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attr_encodings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTableInternal
 *
 * ALTER TABLE with target specified by OID
 *
 * We do not reject if the relation is already open, because it's quite
 * likely that one or more layers of caller have it open.  That means it
 * is unsafe to use this entry point for alterations that could break
 * existing query plans.  On the assumption it's not used for such, we
 * don't have to reject pending AFTER triggers, either.
 *
 * It is also unsafe to use this function for any Alter Table subcommand that
 * requires rewriting the table or creating toast tables, because that requires
 * creating relfilenodes outside of a context that understands dispatch.
 * Commands that rewrite the table include: adding or altering columns, changing
 * the tablespace, etc.
 */</comment>
<function><type><name>void</name></type>
<name>AlterTableInternal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EventTriggerAlterTableRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ATController</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AlterTableGetLockLevel
 *
 * Sets the overall lock level required for the supplied list of subcommands.
 * Policy for doing this set according to needs of AlterTable(), see
 * comments there for overall explanation.
 *
 * Function is called before and after parsing, so it must give same
 * answer each time it is called. Some subcommands are transformed
 * into other subcommand types, so the transform must never be made to a
 * lower lock level than previously assigned. All transforms are noted below.
 *
 * Since this is called before we lock the table we cannot use table metadata
 * to influence the type of lock we acquire.
 *
 * There should be no lockmodes hardcoded into the subcommand functions. All
 * lockmode decisions for ALTER TABLE are made here only. The one exception is
 * ALTER TABLE RENAME which is treated as a different statement type T_RenameStmt
 * and does not travel through this section of code and cannot be combined with
 * any of the subcommands given here.
 *
 * Note that Hot Standby only knows about AccessExclusiveLocks on the master
 * so any changes that might affect SELECTs running on standbys need to use
 * AccessExclusiveLocks even if you think a lesser lock would do, unless you
 * have a solution for that also.
 *
 * Also note that pg_dump uses only an AccessShareLock, meaning that anything
 * that takes a lock less than AccessExclusiveLock can change object definitions
 * while pg_dump is running. Be careful to check that the appropriate data is
 * derived by pg_dump using an MVCC snapshot, rather than syscache lookups,
 * otherwise we might end up with an inconsistent dump that can't restore.
 */</comment>
<function><type><name>LOCKMODE</name></type>
<name>AlterTableGetLockLevel</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This only works if we read catalog tables using MVCC snapshots.
	 */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name>ShareUpdateExclusiveLock</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>cmd_lockmode</name> <init>= <expr><name>AccessExclusiveLock</name></expr></init></decl>;</decl_stmt> <comment type="block">/* default for compiler */</comment>

		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
		<block>{<block_content>
				<comment type="block">/*
				 * These subcommands rewrite the heap, so require full locks.
				 */</comment>
			<case>case <expr><name>AT_SetColumnEncoding</name></expr>:</case> <comment type="block">/* must rewrite heap */</comment>
			<case>case <expr><name>AT_AddColumn</name></expr>:</case>	<comment type="block">/* may rewrite heap, in some cases and visible
								 * to SELECT */</comment>
			<case>case <expr><name>AT_SetAccessMethod</name></expr>:</case>	<comment type="block">/* must rewrite heap */</comment>
			<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>	<comment type="block">/* must rewrite heap */</comment>
			<case>case <expr><name>AT_AlterColumnType</name></expr>:</case>	<comment type="block">/* must rewrite heap */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * These subcommands may require addition of toast tables. If
				 * we add a toast table to a table currently being scanned, we
				 * might miss data added to the new toast table by concurrent
				 * insert transactions.
				 */</comment>
			<case>case <expr><name>AT_SetStorage</name></expr>:</case> <comment type="block">/* may add toast tables, see
								 * ATRewriteCatalogs() */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Removing constraints can affect SELECTs that have been
				 * optimized assuming the constraint holds true. See also
				 * CloneFkReferenced.
				 */</comment>
			<case>case <expr><name>AT_DropConstraint</name></expr>:</case> <comment type="block">/* as DROP INDEX */</comment>
			<case>case <expr><name>AT_DropNotNull</name></expr>:</case>	<comment type="block">/* may change some SQL plans */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Subcommands that may be visible to concurrent SELECTs
				 */</comment>
			<case>case <expr><name>AT_DropColumn</name></expr>:</case> <comment type="block">/* change visible to SELECT */</comment>
			<case>case <expr><name>AT_AddColumnToView</name></expr>:</case>	<comment type="block">/* CREATE VIEW */</comment>
			<case>case <expr><name>AT_DropOids</name></expr>:</case>	<comment type="block">/* used to equiv to DropColumn */</comment>
			<case>case <expr><name>AT_EnableAlwaysRule</name></expr>:</case>	<comment type="block">/* may change SELECT rules */</comment>
			<case>case <expr><name>AT_EnableReplicaRule</name></expr>:</case>	<comment type="block">/* may change SELECT rules */</comment>
			<case>case <expr><name>AT_EnableRule</name></expr>:</case> <comment type="block">/* may change SELECT rules */</comment>
			<case>case <expr><name>AT_DisableRule</name></expr>:</case>	<comment type="block">/* may change SELECT rules */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Changing owner may remove implicit SELECT privileges
				 */</comment>
			<case>case <expr><name>AT_ChangeOwner</name></expr>:</case>	<comment type="block">/* change visible to SELECT */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Changing foreign table options may affect optimization.
				 */</comment>
			<case>case <expr><name>AT_GenericOptions</name></expr>:</case>
			<case>case <expr><name>AT_AlterColumnGenericOptions</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * These subcommands affect write operations only.
				 */</comment>
			<case>case <expr><name>AT_EnableTrig</name></expr>:</case>
			<case>case <expr><name>AT_EnableAlwaysTrig</name></expr>:</case>
			<case>case <expr><name>AT_EnableReplicaTrig</name></expr>:</case>
			<case>case <expr><name>AT_EnableTrigAll</name></expr>:</case>
			<case>case <expr><name>AT_EnableTrigUser</name></expr>:</case>
			<case>case <expr><name>AT_DisableTrig</name></expr>:</case>
			<case>case <expr><name>AT_DisableTrigAll</name></expr>:</case>
			<case>case <expr><name>AT_DisableTrigUser</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ShareRowExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * These subcommands affect write operations only. XXX
				 * Theoretically, these could be ShareRowExclusiveLock.
				 */</comment>
			<case>case <expr><name>AT_ColumnDefault</name></expr>:</case>
			<case>case <expr><name>AT_AlterConstraint</name></expr>:</case>
			<case>case <expr><name>AT_AddIndex</name></expr>:</case>	<comment type="block">/* from ADD CONSTRAINT */</comment>
			<case>case <expr><name>AT_AddIndexConstraint</name></expr>:</case>
			<case>case <expr><name>AT_ReplicaIdentity</name></expr>:</case>
			<case>case <expr><name>AT_SetNotNull</name></expr>:</case>
			<case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_ForceRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_NoForceRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_AddIdentity</name></expr>:</case>
			<case>case <expr><name>AT_DropIdentity</name></expr>:</case>
			<case>case <expr><name>AT_SetIdentity</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_AddConstraint</name></expr>:</case>
			<case>case <expr><name>AT_ProcessedConstraint</name></expr>:</case>	<comment type="block">/* becomes AT_AddConstraint */</comment>
			<case>case <expr><name>AT_AddConstraintRecurse</name></expr>:</case>	<comment type="block">/* becomes AT_AddConstraint */</comment>
			<case>case <expr><name>AT_ReAddConstraint</name></expr>:</case>	<comment type="block">/* becomes AT_AddConstraint */</comment>
			<case>case <expr><name>AT_ReAddDomainConstraint</name></expr>:</case>	<comment type="block">/* becomes AT_AddConstraint */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

					<switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>CONSTR_EXCLUSION</name></expr>:</case>
						<case>case <expr><name>CONSTR_PRIMARY</name></expr>:</case>
						<case>case <expr><name>CONSTR_UNIQUE</name></expr>:</case>

							<comment type="block">/*
							 * Cases essentially the same as CREATE INDEX. We
							 * could reduce the lock strength to ShareLock if
							 * we can work out how to allow concurrent catalog
							 * updates. XXX Might be set down to
							 * ShareRowExclusiveLock but requires further
							 * analysis.
							 */</comment>
							<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>

							<comment type="block">/*
							 * We add triggers to both tables when we add a
							 * Foreign Key, so the lock level must be at least
							 * as strong as CREATE TRIGGER.
							 */</comment>
							<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ShareRowExclusiveLock</name></expr>;</expr_stmt>
							<break>break;</break>

						<default>default:</default>
							<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
					</block_content>}</block></switch>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * These subcommands affect inheritance behaviour. Queries
				 * started before us will continue to see the old inheritance
				 * behaviour, while queries started after we commit will see
				 * new behaviour. No need to prevent reads or writes to the
				 * subtable while we hook it up though. Changing the TupDesc
				 * may be a problem, so keep highest lock.
				 */</comment>
			<case>case <expr><name>AT_AddInherit</name></expr>:</case>
			<case>case <expr><name>AT_DropInherit</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * These subcommands affect implicit row type conversion. They
				 * have affects similar to CREATE/DROP CAST on queries. don't
				 * provide for invalidating parse trees as a result of such
				 * changes, so we keep these at AccessExclusiveLock.
				 */</comment>
			<case>case <expr><name>AT_AddOf</name></expr>:</case>
			<case>case <expr><name>AT_DropOf</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Only used by CREATE OR REPLACE VIEW which must conflict
				 * with an SELECTs currently using the view.
				 */</comment>
			<case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * These subcommands affect general strategies for performance
				 * and maintenance, though don't change the semantic results
				 * from normal data reads and writes. Delaying an ALTER TABLE
				 * behind currently active writes only delays the point where
				 * the new strategy begins to take effect, so there is no
				 * benefit in waiting. In this case the minimum restriction
				 * applies: we don't currently allow concurrent catalog
				 * updates.
				 */</comment>
			<case>case <expr><name>AT_SetStatistics</name></expr>:</case>	<comment type="block">/* Uses MVCC in getTableAttrs() */</comment>
			<case>case <expr><name>AT_ClusterOn</name></expr>:</case>	<comment type="block">/* Uses MVCC in getIndexes() */</comment>
			<case>case <expr><name>AT_DropCluster</name></expr>:</case>	<comment type="block">/* Uses MVCC in getIndexes() */</comment>
			<case>case <expr><name>AT_SetOptions</name></expr>:</case> <comment type="block">/* Uses MVCC in getTableAttrs() */</comment>
			<case>case <expr><name>AT_ResetOptions</name></expr>:</case>	<comment type="block">/* Uses MVCC in getTableAttrs() */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_SetLogged</name></expr>:</case>
			<case>case <expr><name>AT_SetUnLogged</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_ValidateConstraint</name></expr>:</case> <comment type="block">/* Uses MVCC in getConstraints() */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * Rel options are more complex than first appears. Options
				 * are set here for tables, views and indexes; for historical
				 * reasons these can all be used with ALTER TABLE, so we can't
				 * decide between them using the basic grammar.
				 */</comment>
			<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>	<comment type="block">/* Uses MVCC in getIndexes() and
									 * getTables() */</comment>
			<case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>	<comment type="block">/* Uses MVCC in getIndexes() and
										 * getTables() */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <call><name>AlterTableGetRelOptionsLockLevel</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_AttachPartition</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_DetachPartition</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_CheckNotNull</name></expr>:</case>

				<comment type="block">/*
				 * This only examines the table's schema; but lock must be
				 * strong enough to prevent concurrent DROP NOT NULL.
				 */</comment>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/* GPDB additions */</comment>
			<case>case <expr><name>AT_ExpandTable</name></expr>:</case>
			<case>case <expr><name>AT_ExpandPartitionTablePrepare</name></expr>:</case>
			<case>case <expr><name>AT_SetDistributedBy</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * GPDB: For these commands lookup root partition to construct
				 * the appropriate stmt. Hence, AccessShareLock should be
				 * good. Stronger lock is mostly not required.
				 */</comment>
			<case>case <expr><name>AT_PartTruncate</name></expr>:</case>
			<case>case <expr><name>AT_PartAlter</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_PartAdd</name></expr>:</case>
			<case>case <expr><name>AT_PartDrop</name></expr>:</case>
			<case>case <expr><name>AT_PartSplit</name></expr>:</case>
			<case>case <expr><name>AT_PartRename</name></expr>:</case>
			<case>case <expr><name>AT_PartExchange</name></expr>:</case>
			<case>case <expr><name>AT_PartSetTemplate</name></expr>:</case>
				<expr_stmt><expr><name>cmd_lockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>			<comment type="block">/* oops */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter table type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Take the greatest lockmode from any subcommand
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cmd_lockmode</name> <operator>&gt;</operator> <name>lockmode</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>cmd_lockmode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>lockmode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ATController provides top level control over the phases.
 *
 * parsetree is passed in to allow it to be passed to event triggers
 * when requested.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATController</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
			 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cmds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>wqueue</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cdb_sync_oid_to_segments</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Phase 1: preliminary examination of commands, create work queue */</comment>
	<comment type="block">/*
	 * In QE, we receive an already-prepped work queue from the QD.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>parsetree</name> <operator>&amp;&amp;</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>wqueue</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wqueue</name> <operator>=</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>wqueue</name></name></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>wqueue</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * The old tuple descriptors are not dispatched, so fetch
			 * them here.
			 */</comment>
			<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopyConstr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>cmds</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Close the relation, but keep lock until commit */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Phase 2: update system catalogs */</comment>
	<expr_stmt><expr><call><name>ATRewriteCatalogs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wqueue</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Phase 3: scan/rewrite tables as needed */</comment>
	<expr_stmt><expr><call><name>ATRewriteTables</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wqueue</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In QD, include the work queue in the command for dispatching,
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name>parsetree</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>lockmode</name></name> <operator>=</operator> <name>lockmode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>wqueue</name></name> <operator>=</operator> <name>wqueue</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATPrepCmd
 *
 * Traffic cop for ALTER TABLE Phase 1 operations, including simple
 * recursion and permission checks.
 *
 * Caller must have acquired appropriate lock type on relation already.
 * This lock should be held until commit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepCmd</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pass</name> <init>= <expr><name>AT_PASS_UNSET</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Find or create work queue entry for this table */</comment>
	<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the original subcommand for each table.  This avoids conflicts
	 * when different child tables need to make different parse
	 * transformations (for example, the same column may have different column
	 * numbers in different children).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do permissions checking, recursion to child tables if needed, and any
	 * additional phase-1 processing needed.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AT_AddColumn</name></expr>:</case>		<comment type="block">/* ADD COLUMN */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								<argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_COMPOSITE_TYPE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATPrepAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>,
							<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Recursion occurs during execution phase */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_COL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddColumnToView</name></expr>:</case>	<comment type="block">/* add column via CREATE OR REPLACE VIEW */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_VIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATPrepAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>,
							<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Recursion occurs during execution phase */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_COL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetColumnEncoding</name></expr>:</case> <comment type="block">/* ALTER COLUMN SET ENCODING */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,<argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ColumnDefault</name></expr>:</case>	<comment type="block">/* ALTER COLUMN DEFAULT */</comment>

			<comment type="block">/*
			 * We allow defaults on views so that INSERT into a view can have
			 * default-ish behavior.  This works because the rewriter
			 * substitutes default values into INSERTs before it expands
			 * rules.
			 */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <ternary><condition><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr> ?</condition><then> <expr><name>AT_PASS_ADD_CONSTR</name></expr> </then><else>: <expr><name>AT_PASS_DROP</name></expr></else></ternary></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIdentity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_CONSTR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropIdentity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetIdentity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_COL_ATTRS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropNotNull</name></expr>:</case>	<comment type="block">/* ALTER COLUMN DROP NOT NULL */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATPrepDropNotNull</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetNotNull</name></expr>:</case>		<comment type="block">/* ALTER COLUMN SET NOT NULL */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Need command-specific recursion decision */</comment>
			<expr_stmt><expr><call><name>ATPrepSetNotNull</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_COL_ATTRS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_CheckNotNull</name></expr>:</case>	<comment type="block">/* check column is already marked NOT NULL */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_COL_ATTRS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetStatistics</name></expr>:</case>	<comment type="block">/* ALTER COLUMN SET STATISTICS */</comment>
			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Performs own permission checks */</comment>
			<expr_stmt><expr><call><name>ATPrepSetStatistics</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetOptions</name></expr>:</case>		<comment type="block">/* ALTER COLUMN SET ( options ) */</comment>
		<case>case <expr><name>AT_ResetOptions</name></expr>:</case>	<comment type="block">/* ALTER COLUMN RESET ( options ) */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetStorage</name></expr>:</case>		<comment type="block">/* ALTER COLUMN SET STORAGE */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropColumn</name></expr>:</case>		<comment type="block">/* DROP COLUMN */</comment>
		<case>case <expr><name>AT_DropColumnRecurse</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								<argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_COMPOSITE_TYPE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATPrepDropColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Recursion occurs during execution phase */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIndex</name></expr>:</case>		<comment type="block">/* ADD INDEX */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddConstraint</name></expr>:</case>	<comment type="block">/* ADD CONSTRAINT */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Recursion occurs during execution phase */</comment>
			<comment type="block">/* No command-specific prep needed except saving recurse flag */</comment>
			<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddConstraintRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_CONSTR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddConstraintRecurse</name></expr>:</case> <comment type="block">/* ADD check CONSTRAINT internal */</comment>
			<comment type="block">/* Parent/Base CHECK constraints apply to child/part tables here.
			 * No need for ATPartitionCheck
			 */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_CONSTR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIndexConstraint</name></expr>:</case> <comment type="block">/* ADD CONSTRAINT USING INDEX */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ADD_CONSTR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropConstraint</name></expr>:</case> <comment type="block">/* DROP CONSTRAINT */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATCheckPartitionsNotInUse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Recursion occurs during execution phase */</comment>
			<comment type="block">/* No command-specific prep needed except saving recurse flag */</comment>
			<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_DropConstraintRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AlterColumnType</name></expr>:</case>	<comment type="block">/* ALTER COLUMN TYPE */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								<argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_COMPOSITE_TYPE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Performs own recursion */</comment>
			<expr_stmt><expr><call><name>ATPrepAlterColumnType</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>recursing</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_ALTER_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AlterColumnGenericOptions</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ChangeOwner</name></expr>:</case>	<comment type="block">/* ALTER OWNER */</comment>
			<comment type="block">/* GPDB: we have historically been performing recurse by default for partition tables. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ClusterOn</name></expr>:</case>		<comment type="block">/* CLUSTER ON */</comment>
		<case>case <expr><name>AT_DropCluster</name></expr>:</case>	<comment type="block">/* SET WITHOUT CLUSTER */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* These commands never recurse */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetLogged</name></expr>:</case>		<comment type="block">/* SET LOGGED */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name> <operator>=</operator> <call><name>ATPrepChangePersistence</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* force rewrite if necessary; see comment in ATRewriteTables */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_ALTER_PERSISTENCE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newrelpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetUnLogged</name></expr>:</case>	<comment type="block">/* SET UNLOGGED */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name> <operator>=</operator> <call><name>ATPrepChangePersistence</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* force rewrite if necessary; see comment in ATRewriteTables */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_ALTER_PERSISTENCE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newrelpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropOids</name></expr>:</case>		<comment type="block">/* SET WITHOUT OIDS */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_DROP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetAccessMethod</name></expr>:</case>	<comment type="block">/* SET ACCESS METHOD */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* check if another access method change was already requested */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newAccessMethod</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have multiple SET ACCESS METHOD subcommands"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ATPrepSetAccessMethod</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>	<comment type="block">/* does not matter; no work in Phase 2 */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>	<comment type="block">/* SET TABLESPACE */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name> <operator>|</operator>
								<name>ATT_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			 * GPDB: This command never recurses in upstream Postgres, however,
			 * it recurses in Greenplum.
			 */</comment>
			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATPrepSetTableSpace</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>	<comment type="block">/* doesn't actually matter */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>	<comment type="block">/* SET (...) */</comment>
		<case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>	<comment type="block">/* RESET (...) */</comment>
		<case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>	<comment type="block">/* reset them all, then set just these */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* GPDB: recurse when setting reloptions of root partition w/o 'ONLY' keyword. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetDistributedBy</name></expr>:</case>	<comment type="block">/* SET DISTRIBUTED BY */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>( <expr><operator>!</operator><name>recursing</name></expr> )</condition> <comment type="block">/* MPP-5772, MPP-5784 */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DistributedBy</name> <modifier>*</modifier></type><name>ldistro</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>policy</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* The distributeby clause is the second element of cmd-&gt;def */</comment>
				<expr_stmt><expr><name>ldistro</name> <operator>=</operator> <operator>(</operator><name>DistributedBy</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ldistro</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>ldistro</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>

					<expr_stmt><expr><name>policy</name> <operator>=</operator>  <call><name>getPolicyForDistributedBy</name><argument_list>(<argument><expr><name>ldistro</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* can't set the distribution policy of interior table */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can't set the distribution policy of \"%s\""</literal></expr></argument>,
									   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Distribution policy can not be set for an interior branch."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GpPolicyEqual</name><argument_list>(<argument><expr><name>policy</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Reject leaf of partitioned tables if new policy is different of parent table*/</comment>
						<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* We can only set policy of child table to the same with parent table */</comment>
							<decl_stmt><decl><type><name>Oid</name></type> <name>parent_oid</name> <init>= <expr><call><name>get_partition_parent</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<comment type="block">/* Use AccessShareLock to allow set distributed in parallel */</comment>
							<decl_stmt><decl><type><name>Relation</name></type> <name>parent_rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GpPolicyEqualByName</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>policy</name></expr></argument>,
													 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can't set the distribution policy of \"%s\""</literal></expr></argument>,
											<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Distribution policy of a partition can only be the same as its parent's."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
							<name>ldistro</name> <operator>&amp;&amp;</operator> <name><name>ldistro</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_REPLICATED</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can't set the distribution policy of a partition table to REPLICATED"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recurse</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Don't allow ALTER TABLE ONLY on a partitioned table */</comment>
							<if_stmt><if>if <condition>(<expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can't set the distribution policy of \"%s\" ONLY"</literal></expr></argument>,
												<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Distribution policy can be set for an entire partitioned table, not for one of its leaf parts or an interior branch."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ExpandTable</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator>
					<name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>==</operator> <call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot expand table \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"table has already been expanded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot expand leaf or interior partition \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Root/leaf/interior partitions need to have same numsegments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Call ALTER TABLE EXPAND TABLE on the root table instead"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_ExpandPartitionTablePrepare</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator>
					<name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>==</operator> <call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipped, table \"%s\" has already been expanded partiton prepare"</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>	<comment type="block">/* We do nothing here */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot expand partition table prepare \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"only root partition can be expanded partition prepare"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GpPolicyIsPartitioned</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot expand partition table prepare \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"only hash/randomly table can be expanded partition prepare"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_AddInherit</name></expr>:</case>		<comment type="block">/* INHERIT */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<expr_stmt><expr><call><name>ATPrepAddInherit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropInherit</name></expr>:</case>	<comment type="block">/* NO INHERIT */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AlterConstraint</name></expr>:</case>	<comment type="block">/* ALTER CONSTRAINT */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ValidateConstraint</name></expr>:</case> <comment type="block">/* VALIDATE CONSTRAINT */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Recursion occurs during execution phase */</comment>
			<comment type="block">/* No command-specific prep needed except saving recurse flag */</comment>
			<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ValidateConstraintRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ReplicaIdentity</name></expr>:</case>	<comment type="block">/* REPLICA IDENTITY ... */</comment>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<comment type="block">/* This command never recurses */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_EnableTrig</name></expr>:</case>		<comment type="block">/* ENABLE TRIGGER variants */</comment>
		<case>case <expr><name>AT_EnableAlwaysTrig</name></expr>:</case>
		<case>case <expr><name>AT_EnableReplicaTrig</name></expr>:</case>
		<case>case <expr><name>AT_EnableTrigAll</name></expr>:</case>
		<case>case <expr><name>AT_EnableTrigUser</name></expr>:</case>
		<case>case <expr><name>AT_DisableTrig</name></expr>:</case>	<comment type="block">/* DISABLE TRIGGER variants */</comment>
		<case>case <expr><name>AT_DisableTrigAll</name></expr>:</case>
		<case>case <expr><name>AT_DisableTrigUser</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableRule</name></expr>:</case>		<comment type="block">/* ENABLE/DISABLE RULE variants */</comment>
		<case>case <expr><name>AT_EnableAlwaysRule</name></expr>:</case>
		<case>case <expr><name>AT_EnableReplicaRule</name></expr>:</case>
		<case>case <expr><name>AT_DisableRule</name></expr>:</case>
		<case>case <expr><name>AT_AddOf</name></expr>:</case>			<comment type="block">/* OF */</comment>
		<case>case <expr><name>AT_DropOf</name></expr>:</case>			<comment type="block">/* NOT OF */</comment>
		<case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
		<case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
		<case>case <expr><name>AT_ForceRowSecurity</name></expr>:</case>
		<case>case <expr><name>AT_NoForceRowSecurity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* These commands never recurse */</comment>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_GenericOptions</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AttachPartition</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DetachPartition</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_PartAdd</name></expr>:</case>
		<case>case <expr><name>AT_PartDrop</name></expr>:</case>
		<case>case <expr><name>AT_PartAlter</name></expr>:</case>
		<case>case <expr><name>AT_PartSplit</name></expr>:</case>
		<case>case <expr><name>AT_PartRename</name></expr>:</case>
		<case>case <expr><name>AT_PartTruncate</name></expr>:</case>
		<case>case <expr><name>AT_PartExchange</name></expr>:</case>
		<case>case <expr><name>AT_PartSetTemplate</name></expr>:</case>
			<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No command-specific prep needed */</comment>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_MISC</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>				<comment type="block">/* oops */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter table type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>AT_PASS_UNSET</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pass</name> <operator>&gt;</operator> <name>AT_PASS_UNSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add the subcommand to the appropriate list for phase 2 */</comment>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATRewriteCatalogs
 *
 * Traffic cop for ALTER TABLE Phase 2 operations.  Subcommands are
 * dispatched in a "safe" execution order (designed to avoid unnecessary
 * conflicts).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATRewriteCatalogs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ltab</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We process all the tables "in parallel", one pass at a time.  This is
	 * needed because we may have to propagate work from one table to another
	 * (specifically, ALTER TYPE on a foreign key's PK has to dispatch the
	 * re-adding of the foreign key constraint to the other table).  Work can
	 * only be propagated into later passes, however.
	 */</comment>
	<for>for <control>(<init><expr><name>pass</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pass</name> <operator>&lt;</operator> <name>AT_NUM_PASSES</name></expr>;</condition> <incr><expr><name>pass</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Go through each table that needs to be processed */</comment>
		<macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subcmds</name> <init>= <expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>subcmds</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Appropriate lock was obtained by phase 1, needn't get it again
			 */</comment>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>subcmds</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>ATExecCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
						  <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * After the ALTER TYPE pass, do cleanup work (this is not done in
			 * ATExecAlterColumnType since it should be done only once if
			 * multiple columns of a table are altered).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <name>AT_PASS_ALTER_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATPostAlterTypeCleanup</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<comment type="block">/* Check to see if a toast table must be added. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the table is source table of ATTACH PARTITION command, we did
		 * not modify anything about it that will change its toasting
		 * requirement, so no need to check.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			  <name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
			<name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AlterTableCreateToastTable</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * ATExecCmd: dispatch a subcommand to appropriate execution routine
 *
 * NOTE: we need to use a pointer to Relation here since the relation
 * address may be changed by ATPExecPartSplit(). This is different
 * behavior from Postgres upstream.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecCmd</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
		  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AT_AddColumn</name></expr>:</case>		<comment type="block">/* ADD COLUMN */</comment>
		<case>case <expr><name>AT_AddColumnToView</name></expr>:</case>	<comment type="block">/* add column via CREATE OR REPLACE VIEW */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddColumnRecurse</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetColumnEncoding</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecSetColumnEncoding</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ColumnDefault</name></expr>:</case>	<comment type="block">/* ALTER COLUMN DEFAULT */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecColumnDefault</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIdentity</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddIdentity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetIdentity</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetIdentity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropIdentity</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropIdentity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropNotNull</name></expr>:</case>	<comment type="block">/* ALTER COLUMN DROP NOT NULL */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropNotNull</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetNotNull</name></expr>:</case>		<comment type="block">/* ALTER COLUMN SET NOT NULL */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetNotNull</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_CheckNotNull</name></expr>:</case>	<comment type="block">/* check column is already marked NOT NULL */</comment>
			<expr_stmt><expr><call><name>ATExecCheckNotNull</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetStatistics</name></expr>:</case>	<comment type="block">/* ALTER COLUMN SET STATISTICS */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetStatistics</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetOptions</name></expr>:</case>		<comment type="block">/* ALTER COLUMN SET ( options ) */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ResetOptions</name></expr>:</case>	<comment type="block">/* ALTER COLUMN RESET ( options ) */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetStorage</name></expr>:</case>		<comment type="block">/* ALTER COLUMN SET STORAGE */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecSetStorage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropColumn</name></expr>:</case>		<comment type="block">/* DROP COLUMN */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									   <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropColumnRecurse</name></expr>:</case>	<comment type="block">/* DROP COLUMN with recursion */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									   <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIndex</name></expr>:</case>		<comment type="block">/* ADD INDEX */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddIndex</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									 <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ReAddIndex</name></expr>:</case>		<comment type="block">/* ADD INDEX */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddIndex</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddConstraint</name></expr>:</case>	<comment type="block">/* ADD CONSTRAINT */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator>
				<call><name>ATExecAddConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddConstraintRecurse</name></expr>:</case>	<comment type="block">/* ADD CONSTRAINT with recursion */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator>
				<call><name>ATExecAddConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ReAddConstraint</name></expr>:</case>	<comment type="block">/* Re-add pre-existing check constraint */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator>
				<call><name>ATExecAddConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ReAddDomainConstraint</name></expr>:</case>	<comment type="block">/* Re-add pre-existing domain check
										 * constraint */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator>
				<call><name>AlterDomainAddConstraint</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterDomainStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>typeName</name></expr></argument>,
										 <argument><expr><operator>(</operator><operator>(</operator><name>AlterDomainStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>def</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ReAddComment</name></expr>:</case>	<comment type="block">/* Re-add existing comment */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>CommentObject</name><argument_list>(<argument><expr><operator>(</operator><name>CommentStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddIndexConstraint</name></expr>:</case> <comment type="block">/* ADD CONSTRAINT USING INDEX */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddIndexConstraint</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
											   <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AlterConstraint</name></expr>:</case>	<comment type="block">/* ALTER CONSTRAINT */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAlterConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ValidateConstraint</name></expr>:</case> <comment type="block">/* VALIDATE CONSTRAINT */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecValidateConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ValidateConstraintRecurse</name></expr>:</case>	<comment type="block">/* VALIDATE CONSTRAINT with
											 * recursion */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecValidateConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropConstraint</name></expr>:</case> <comment type="block">/* DROP CONSTRAINT */</comment>
			<expr_stmt><expr><call><name>ATExecDropConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropConstraintRecurse</name></expr>:</case>	<comment type="block">/* DROP CONSTRAINT with recursion */</comment>
			<expr_stmt><expr><call><name>ATExecDropConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AlterColumnType</name></expr>:</case>	<comment type="block">/* ALTER COLUMN TYPE */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAlterColumnType</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AlterColumnGenericOptions</name></expr>:</case>	<comment type="block">/* ALTER COLUMN OPTIONS */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator>
				<call><name>ATExecAlterColumnGenericOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
												<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ChangeOwner</name></expr>:</case>	<comment type="block">/* ALTER OWNER */</comment>
			<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>newowner</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ClusterOn</name></expr>:</case>		<comment type="block">/* CLUSTER ON */</comment>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecClusterOn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropCluster</name></expr>:</case>	<comment type="block">/* SET WITHOUT CLUSTER */</comment>
			<expr_stmt><expr><call><name>ATExecDropCluster</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetLogged</name></expr>:</case>		<comment type="block">/* SET LOGGED */</comment>
		<case>case <expr><name>AT_SetUnLogged</name></expr>:</case>	<comment type="block">/* SET UNLOGGED */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_DropOids</name></expr>:</case>		<comment type="block">/* SET WITHOUT OIDS */</comment>
			<comment type="block">/* nothing to do here, oid columns don't exist anymore */</comment>
			<break>break;</break>
		<case>case <expr><name>AT_SetAccessMethod</name></expr>:</case>	<comment type="block">/* SET ACCESS METHOD */</comment>
			<comment type="block">/* Set reloptions if specified any. Otherwise handled specially in Phase 3. */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>aoopt_changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* If we are changing access method, simply remove all the existing ones. */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newAccessMethod</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>clear_rel_opts</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>ATExecSetRelOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aoopt_changed</name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newAccessMethod</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* make reloptions change visiable */</comment>

				<comment type="block">/* 
				 * When user sets the same access method as the existing one, the
				 * rewrite flag won't be set. But it's possible that the storage
				 * option changed, in which case we'll still have to rewrite.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>aoopt_changed</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_ALTER_RELOPTS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* If we are changing AM to AOCO, add pg_attribute_encoding entries for each column. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>newAccessMethod</name></name> <operator>==</operator> <name>AO_COLUMN_TABLE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content> 
				<expr_stmt><expr><call><name>populate_rel_col_encodings</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name><operator>*</operator><operator>)</operator><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Only do this when it's a valid AM change and just for partitioned tables, 
			 * for which this is just a catalog change. Other relation types which have
			 * storage are handled by Phase 3.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newAccessMethod</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATExecSetAccessMethodNoStorage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newAccessMethod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>	<comment type="block">/* SET TABLESPACE */</comment>

			<comment type="block">/*
			 * Only do this for partitioned tables and indexes, for which this
			 * is just a catalog change.  Other relation types which have
			 * storage are handled by Phase 3.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
				<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATExecSetTableSpaceNoStorage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>	<comment type="block">/* SET (...) */</comment>
		<case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>	<comment type="block">/* RESET (...) */</comment>
		<case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>	<comment type="block">/* replace entire option list */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> 		<name>aoopt_changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ATExecSetRelOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aoopt_changed</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Will rewrite table if there's a change to the AO reloptions. */</comment>
				<if_stmt><if>if <condition>(<expr><name>aoopt_changed</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_ALTER_RELOPTS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>AT_EnableTrig</name></expr>:</case>		<comment type="block">/* ENABLE TRIGGER name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									   <argument><expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableAlwaysTrig</name></expr>:</case>	<comment type="block">/* ENABLE ALWAYS TRIGGER name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									   <argument><expr><name>TRIGGER_FIRES_ALWAYS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableReplicaTrig</name></expr>:</case>	<comment type="block">/* ENABLE REPLICA TRIGGER name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									   <argument><expr><name>TRIGGER_FIRES_ON_REPLICA</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DisableTrig</name></expr>:</case>	<comment type="block">/* DISABLE TRIGGER name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									   <argument><expr><name>TRIGGER_DISABLED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableTrigAll</name></expr>:</case>	<comment type="block">/* ENABLE TRIGGER ALL */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DisableTrigAll</name></expr>:</case> <comment type="block">/* DISABLE TRIGGER ALL */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>TRIGGER_DISABLED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableTrigUser</name></expr>:</case> <comment type="block">/* ENABLE TRIGGER USER */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DisableTrigUser</name></expr>:</case>	<comment type="block">/* DISABLE TRIGGER USER */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>TRIGGER_DISABLED</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_EnableRule</name></expr>:</case>		<comment type="block">/* ENABLE RULE name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									<argument><expr><name>RULE_FIRES_ON_ORIGIN</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableAlwaysRule</name></expr>:</case>	<comment type="block">/* ENABLE ALWAYS RULE name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									<argument><expr><name>RULE_FIRES_ALWAYS</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableReplicaRule</name></expr>:</case>	<comment type="block">/* ENABLE REPLICA RULE name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									<argument><expr><name>RULE_FIRES_ON_REPLICA</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DisableRule</name></expr>:</case>	<comment type="block">/* DISABLE RULE name */</comment>
			<expr_stmt><expr><call><name>ATExecEnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									<argument><expr><name>RULE_DISABLED</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_AddInherit</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddInherit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropInherit</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecDropInherit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AddOf</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATExecAddOf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>TypeName</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DropOf</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecDropOf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ReplicaIdentity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecReplicaIdentity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>ReplicaIdentityStmt</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecEnableRowSecurity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecDisableRowSecurity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ForceRowSecurity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecForceNoForceRowSecurity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_NoForceRowSecurity</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecForceNoForceRowSecurity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_GenericOptions</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecGenericOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_SetDistributedBy</name></expr>:</case>	<comment type="block">/* SET DISTRIBUTED BY */</comment>
			<expr_stmt><expr><call><name>ATExecSetDistributedBy</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ExpandTable</name></expr>:</case>	<comment type="block">/* EXPAND TABLE */</comment>
			<expr_stmt><expr><call><name>ATExecExpandTable</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_ExpandPartitionTablePrepare</name></expr>:</case>	<comment type="block">/* EXPAND PARTITION PREPARE */</comment>
			<expr_stmt><expr><call><name>ATExecExpandPartitionTablePrepare</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AttachPartition</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATExecAttachPartition</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATExecAttachPartitionIdx</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
										 <argument><expr><operator>(</operator><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_DetachPartition</name></expr>:</case>
			<comment type="block">/* ATPrepCmd ensures it must be a table */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATExecDetachPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>				<comment type="block">/* oops */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter table type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_PartAdd</name></expr>:</case>
		<case>case <expr><name>AT_PartDrop</name></expr>:</case>
		<case>case <expr><name>AT_PartAlter</name></expr>:</case>
		<case>case <expr><name>AT_PartSplit</name></expr>:</case>
		<case>case <expr><name>AT_PartRename</name></expr>:</case>
		<case>case <expr><name>AT_PartTruncate</name></expr>:</case>
		<case>case <expr><name>AT_PartExchange</name></expr>:</case>
		<case>case <expr><name>AT_PartSetTemplate</name></expr>:</case>
			<expr_stmt><expr><call><name>ATExecGPPartCmds</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Report the subcommand to interested event triggers.
	 */</comment>
	<expr_stmt><expr><call><name>EventTriggerCollectAlterTableSubcmd</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cmd</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Bump the command counter to ensure the next subcommand in the sequence
	 * can see the changes so far
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATRewriteTables: ALTER TABLE phase 3
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATRewriteTables</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ltab</name></decl>;</decl_stmt>

	<comment type="block">/* Go through each table that needs to be checked or rewritten */</comment>
	<macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Relations without storage may be ignored here */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RELKIND_HAS_STORAGE</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we change column data types or add/remove OIDs, the operation
		 * has to be propagated to tables that use this table's rowtype as a
		 * column type.  tab-&gt;newvals will also be non-NULL in the case where
		 * we're adding a column with a default.  We choose to forbid that
		 * case as well, since composite types might eventually support
		 * defaults.
		 *
		 * (Eventually we'll probably need to check for composite type
		 * dependencies even when we're just scanning the table without a
		 * rewrite, but at the moment a composite type does not enforce any
		 * constraints, so it's not necessary/appropriate to enforce them just
		 * during ALTER.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * 'OldHeap' can be an AO or external table, but kept the upstream variable name
		 * to minimize the diff.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>OldHeap</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hasIndexes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> 		<name>oldTableSpace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>oldRelPersistence</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>oldAm</name></decl>;</decl_stmt>

		<comment type="block">/* We will lock the table iff we decide to actually rewrite it */</comment>
		<expr_stmt><expr><name>OldHeap</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldTableSpace</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldRelPersistence</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldAm</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr>;</expr_stmt>

		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexIds</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>indexIds</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hasIndexes</name> <operator>=</operator> <operator>(</operator><name>indexIds</name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * There are two cases where we will rewrite the table, for these cases
		 * run the necessary sanity checks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We don't support rewriting of system catalogs; there are too
			 * many corner cases and too little benefit.  In particular this
			 * is certainly not going to work for mapped catalogs.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rewrite system relation \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>RelationIsUsedAsCatalogTable</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rewrite table \"%s\" used as a catalog table"</literal></expr></argument>,
					   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Don't allow rewrite on temp tables of other backends ... their
			 * local buffer manager is not going to cope.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rewrite temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * GPDB_12_MERGE_FIXME: This is a AM specific optimization, currently
		 * exposted out of the AM handler.  The add-column optimization should
		 * ideally be implemented within the table AM.
		 *
		 * A counterargument can be made that this optimization is very
		 * specific to column-oriented table AM.  Should the table AM API be
		 * generalised to fit it?
		 *
		 * If table AM API needs to be changed, we can imagine a few options
		 * to implement the add-column optimization.
		 *
		 * (1) definfe a new interface on the lines of
		 * table_relation_copy_for_cluster.  It would require traslating the
		 * state currently maintained in AlteredTableInfo for per-row
		 * expression and constraint evaluation and passed as arguments to the
		 * new interface.
		 *
		 * (2) Define a new interface to scan the underlying table one block
		 * at a time, where block is a append-optimized varblock.  And another
		 * interface to scan tuples within the block.  After evaluating the
		 * expressions and constraints on this tuple, new slot is constructed,
		 * as is currently done.  A new interface is needed to insert this
		 * slot into specific block and finish the block being inserted into,
		 * when there are no more tuples in the scanned block.  Let's
		 * illustrate this with pseudocode:
		 *
		 * TableScanDesc sdesc = table_begin_block_scan();
		 * Block block;
		 * 
		 * // table AM API doesn't provide an insert descriptor
		 * TableInsertDesc idesc = table_begin_block_insert();
		 *
		 * while (block = table_getnext_block(sdesc))
		 * {
		 *     table_insert_begin_block(idesc, block);
		 *     while (slot = table_getnextslot_in_block(block))
		 *     {
		 *         // evaluate expressions and constraints for tab-&gt;newvals
		 *         newslot = ExecEvalExpr();
		 *         tuple_insert_in_block(idesc, block, newslot);
		 *     }
		 *     table_insert_end_block(idesc);
		 * }
		 *
		 * table_end_block_insert(idesc);
		 *
		 * table_end_blcok_scan(sdesc);
		 *
		 *
		 * Ideally, ALTER TABLE ADD COLUMN should not be exposed to any code
		 * specific to table AM.  Descide the best option to achieve this
		 * goal.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&amp;</operator> <name>AT_REWRITE_NEW_COLUMNS_ONLY_AOCS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ATAocsWriteNewColumns</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/*
		 * We only need to rewrite the table if at least one column needs to
		 * be recomputed, we are adding/removing the OID column, or we are
		 * changing its persistence or access method.
		 *
		 * There are two reasons for requiring a rewrite when changing
		 * persistence: on one hand, we need to ensure that the buffers
		 * belonging to each of the two relations are marked with or without
		 * BM_PERMANENT properly.  On the other hand, since rewriting creates
		 * and assigns a new relfilenode, we automatically create or drop an
		 * init fork for the relation as appropriate.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Build a temporary relation and copy data */</comment>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>OIDNewHeap</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>NewAccessMethod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>NewTableSpace</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name>persistence</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>relfrozenxid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>OldHeap</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We don't support rewriting of system catalogs; there are too
			 * many corner cases and too little benefit.  In particular this
			 * is certainly not going to work for mapped catalogs.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rewrite system relation \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>RelationIsUsedAsCatalogTable</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rewrite table \"%s\" used as a catalog table"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Don't allow rewrite on temp tables of other backends ... their
			 * local buffer manager is not going to cope.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rewrite temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Select destination tablespace (same as original unless user
			 * requested a change)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>NewTableSpace</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>NewTableSpace</name> <operator>=</operator> <name>oldTableSpace</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Select destination access method (same as original unless user
			 * requested a change)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newAccessMethod</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>NewAccessMethod</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>newAccessMethod</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>NewAccessMethod</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Select persistence of transient table (same as original unless
			 * user requested a change)
			 */</comment>
			<expr_stmt><expr><name>persistence</name> <operator>=</operator> <ternary><condition><expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name></expr> ?</condition><then>
				<expr><name><name>tab</name><operator>-&gt;</operator><name>newrelpersistence</name></name></expr> </then><else>: <expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Fire off an Event Trigger now, before actually rewriting the
			 * table.
			 *
			 * We don't support Event Trigger for nested commands anywhere,
			 * here included, and parsetree is given NULL when coming from
			 * AlterTableInternal.
			 *
			 * And fire it only once.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>parsetree</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EventTriggerTableRewrite</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
										 <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
										 <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Create transient table that will receive the modified data.
			 *
			 * Ensure it is marked correctly as logged or unlogged.  We have
			 * to do this here so that buffers for the new relfilenode will
			 * have the right persistence set, and at the same time ensure
			 * that the original filenode's buffers will get read in with the
			 * correct setting (i.e. the original one).  Otherwise a rollback
			 * after the rewrite would possibly result with buffers for the
			 * original filenode having the wrong persistence setting.
			 *
			 * NB: This relies on swap_relation_files() also swapping the
			 * persistence. That wouldn't work for pg_class, but that can't be
			 * unlogged anyway.
			 */</comment>
			<expr_stmt><expr><name>OIDNewHeap</name> <operator>=</operator> <call><name>make_new_heap</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NewTableSpace</name></expr></argument>, <argument><expr><name>NewAccessMethod</name></expr></argument>,
									   <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>new_crsds</name></name></expr></argument>, <argument><expr><name>persistence</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
									   <argument><expr><name>hasIndexes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Copy the heap data into the new table with the desired
			 * modifications, and test the current data within the table
			 * against new constraints generated by ALTER TABLE commands.
			 */</comment>
			<expr_stmt><expr><call><name>ATRewriteTable</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Swap the physical files of the old and new heaps, then rebuild
			 * indexes and discard the old heap.  We can use RecentXmin for
			 * the table's new relfrozenxid because we rewrote all the tuples
			 * in ATRewriteTable, so no older Xid remains in the table.  Also,
			 * we never try to swap toast tables by content, since we have no
			 * interest in letting this code work on system catalogs.
			 *
			 * MPP-17516 - The 'swap_stats' argument dictates whether the
			 * relpages and reltuples of the fake relfile should be copied
			 * over to our original pg_class tuple. We do not want to do this
			 * in the case of ALTER TABLE rewrites as the temp relfile will
			 * not have correct stats.
			 *
			 * GPDB: Since pg_class.relfrozenxid doesn't mean anything for
			 * AO/AOCO tables, and should not be set, pass in
			 * InvalidTransactionId instead of RecentXmin.
			 */</comment>

			<comment type="block">/*
			 * Example workflow of changing access method from a
			 * Heap table (Oid:a) to an AO table:
			 * - Create transient AO table (Oid:b) and its AO aux tables in
			 * 	 make_new_heap
			 * - Copy table data into the transient table
			 * - Swap Oids in the pg_appendonly entry so that newly generated
			 * 	 aux tables are mapped to Oid a in ATAOEntries
			 * - Swap attributes in pg_class entry between the two tables
			 * 	 (such as relfilenode, relam, ...)
			 * - Now dropping the transient table will use the heap AM and
			 *   delete the original heap relation file.
			 */</comment>

			<if_stmt><if>if <condition>(<expr><name>NewAccessMethod</name> <operator>==</operator> <name>AO_ROW_TABLE_AM_OID</name> <operator>||</operator> <name>NewAccessMethod</name> <operator>==</operator> <name>AO_COLUMN_TABLE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>relfrozenxid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>relfrozenxid</name> <operator>=</operator> <name>RecentXmin</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>finish_heap_swap</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument> <comment type="block">/* swap_stats */</comment>,
							 <argument><expr><name>true</name></expr></argument>,
							 <argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>relfrozenxid</name></expr></argument>,
							 <argument><expr><call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call></expr></argument>,
							 <argument><expr><name>persistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If required, test the current data within the table against new
			 * constraints generated by ALTER TABLE commands, but don't
			 * rebuild data.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>tab</name><operator>-&gt;</operator><name>verify_new_notnull</name></name> <operator>||</operator>
				<name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATRewriteTable</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If we had SET TABLESPACE but no reason to reconstruct tuples,
			 * just do a block-by-block copy.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Foreign key constraints are checked in a final pass, since (a) it's
	 * generally best to examine each one separately, and (b) it's at least
	 * theoretically possible that we have changed both relations of the
	 * foreign key, and we'd better have finished both rewrites before we try
	 * to read the tables.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcon</name></decl>;</decl_stmt>

		<comment type="block">/* Relations without storage may be ignored here too */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RELKIND_HAS_STORAGE</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lcon</argument>, <argument>tab-&gt;constraints</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcon</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>qual</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>refrel</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Long since locked, no need for another */</comment>
					<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>refrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>refrelid</name></name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>validateForeignKeyConstraint</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>refrel</name></expr></argument>,
											 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>refindid</name></name></expr></argument>,
											 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>conid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * No need to mark the constraint row as validated, we did
				 * that when we inserted the row earlier.
				 */</comment>

				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>refrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * A helper for ATAocsWriteNewColumns(). It scans an existing column for
 * varblock headers. Write one new segfile each for new columns.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATAocsWriteSegFileNewColumns</name><parameter_list>(
		<parameter><decl><type><name>AOCSAddColumnDesc</name></type> <name>idesc</name></decl></parameter>, <parameter><decl><type><name>AOCSHeaderScanDesc</name></type> <name>sdesc</name></decl></parameter>,
		<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>idesc</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>expectedFRN</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* expected firstRowNum of the next varblock */</comment>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Start index in values and isnull array for newly added columns. */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>newcol</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>-</operator> <name><name>idesc</name><operator>-&gt;</operator><name>num_newcols</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Loop over each varblock in an appendonly segno. */</comment>
	<while>while <condition>(<expr><call><name>aocs_get_nextheader</name><argument_list>(<argument><expr><name>sdesc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sdesc</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>current</name><operator>.</operator><name>hasFirstRowNum</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>expectedFRN</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Initialize expected firstRowNum for each appendonly
				 * segment.  Initializing it to 1 may not always be
				 * good.  E.g. if the first insert into an appendonly
				 * segment is aborted.  A subsequent successful insert
				 * creates the first varblock having firstRowNum
				 * greater than 1.
				 */</comment>
				<expr_stmt><expr><name>expectedFRN</name> <operator>=</operator> <name><name>sdesc</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>current</name><operator>.</operator><name>firstRowNum</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>aocs_addcol_setfirstrownum</name><argument_list>(<argument><expr><name>idesc</name></expr></argument>, <argument><expr><name>expectedFRN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expectedFRN</name> <operator>&lt;=</operator> <name><name>sdesc</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>current</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>expectedFRN</name> <operator>&lt;</operator> <name><name>sdesc</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>current</name><operator>.</operator><name>firstRowNum</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_storage_headers</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
						   <argument><expr><literal type="string">"hole in %s: exp FRN: "</literal> <name>INT64_FORMAT</name> <literal type="string">", actual FRN: "</literal>
						   <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>sdesc</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>segmentFileName</name></name></expr></argument>,
						   <argument><expr><name>expectedFRN</name></expr></argument>, <argument><expr><name><name>sdesc</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>current</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/*
					 * We encountered a break in sequence of row
					 * numbers (hole), replicate it in the new
					 * segfiles.
					 */</comment>
					<expr_stmt><expr><call><name>aocs_addcol_endblock</name><argument_list>(
							<argument><expr><name>idesc</name></expr></argument>, <argument><expr><name><name>sdesc</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>current</name><operator>.</operator><name>firstRowNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sdesc</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>current</name><operator>.</operator><name>rowCount</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
			<block>{<block_content>
				<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>tab-&gt;newvals</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>values</name><index>[<expr><name><name>newval</name><operator>-&gt;</operator><name>attnum</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
							<call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name><name>newval</name><operator>-&gt;</operator><name>exprstate</name></name></expr></argument>,
													  <argument><expr><name>econtext</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name><name>isnull</name><index>[<expr><name><name>newval</name><operator>-&gt;</operator><name>attnum</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/*
					 * Ensure that NOT NULL constraint for the newly
					 * added columns is not being violated.  This
					 * covers the case when explicit "CHECK()"
					 * constraint is not specified but only "NOT NULL"
					 * is specified in the new column's definition.
					 */</comment>
					<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>newval</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator>	<name><name>isnull</name><index>[<expr><name><name>newval</name><operator>-&gt;</operator><name>attnum</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NOT_NULL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" contains null values"</literal></expr></argument>,
										<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>tab-&gt;constraints</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<switch>switch<condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
							<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>qualstate</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
										<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
										 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"check constraint \"%s\" is violated by some row"</literal></expr></argument>,
											<argument><expr><name><name>con</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<break>break;</break>
						<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
							<comment type="block">/* Nothing to do */</comment>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unrecognized constraint type: %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></switch>
				</block_content>}</block>
				<expr_stmt><expr><call><name>aocs_addcol_insert_datum</name><argument_list>(<argument><expr><name>idesc</name></expr></argument>, <argument><expr><name>values</name><operator>+</operator><name>newcol</name></expr></argument>, <argument><expr><name>isnull</name><operator>+</operator><name>newcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name>expectedFRN</name> <operator>=</operator> <name><name>sdesc</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>current</name><operator>.</operator><name>firstRowNum</name></name> <operator>+</operator>
					<name><name>sdesc</name><operator>-&gt;</operator><name>ao_read</name><operator>.</operator><name>current</name><operator>.</operator><name>rowCount</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Choose the column that has the smallest segfile size so as to
 * minimize disk I/O in subsequent varblock header scan. The natts arg
 * includes only existing columns and not the ones being added. Once
 * we find a segfile with nonzero tuplecount and find the column with
 * the smallest eof to return, we continue the loop but skip over all
 * segfiles except for those in AOSEG_STATE_AWAITING_DROP state which
 * we need to append to our drop list.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>column_to_scan</name><parameter_list>(<parameter><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>segInfos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nseg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>aocsrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>scancol</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>segi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOCSVPInfoEntry</name> <modifier>*</modifier></type><name>vpe</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>min_eof</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>segi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>segi</name> <operator>&lt;</operator> <name>nseg</name></expr>;</condition> <incr><expr><operator>++</operator><name>segi</name></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Don't use a AOSEG_STATE_AWAITING_DROP segfile. That seems
		 * like a bad idea in general, but there's one particular problem:
		 * the 'vpinfo' of a dropped segfile might be missing information
		 * for columns that were added later.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>segInfos</name><index>[<expr><name>segi</name></expr>]</index></name><operator>-&gt;</operator><name>state</name> <operator>==</operator> <name>AOSEG_STATE_AWAITING_DROP</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Skip over appendonly segments with no tuples (caused by VACUUM)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>segInfos</name><index>[<expr><name>segi</name></expr>]</index></name><operator>-&gt;</operator><name>total_tupcount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>scancol</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>vpe</name> <operator>=</operator> <call><name>getAOCSVPEntry</name><argument_list>(<argument><expr><name><name>segInfos</name><index>[<expr><name>segi</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>vpe</name><operator>-&gt;</operator><name>eof</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>min_eof</name> <operator>||</operator> <name><name>vpe</name><operator>-&gt;</operator><name>eof</name></name> <operator>&lt;</operator> <name>min_eof</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>min_eof</name> <operator>=</operator> <name><name>vpe</name><operator>-&gt;</operator><name>eof</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>scancol</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>scancol</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATAocsWriteNewColumns</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOCSFileSegInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>segInfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOCSHeaderScanDesc</name></type> <name>sdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOCSAddColumnDesc</name></type> <name>idesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt> <comment type="block">/* Relation being altered */</comment>
	<decl_stmt><decl><type><name>int32</name></type> <name>nseg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>segi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>basepath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>scancol</name></decl>;</decl_stmt> <comment type="block">/* chosen column number to scan from */</comment>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>addcols</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;constraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
				<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>qualstate</name></name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
				<comment type="block">/* Nothing to do here */</comment>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;newvals</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>exprstate</name></name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>newval</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
     * There might be AWAITING_DROP segments occupying spaces for failing
     * to drop at VACUUM in the case of cleaning up happened concurrently
     * with earlier readers which was accessing the dead segment files.
     *
     * We used to call AppendOptimizedRecycleDeadSegments() (current name is
     * ao_vacuum_rel_recycle_dead_segments) to recycle those segfiles to save
     * spaces in this scenario. But it didn't do corresponding index tuples
     * cleanup for unknown reason.
     *
     * After optimizing VACUUM AO strategy, we did refactor for
     * AppendOptimizedRecycleDeadSegments() a little bit and combine
     * dead segfiles cleanup with corresponding indexes cleanup together.
     * While it seems to be impossible to pass index vacuuming parameter in
     * this scenario, so we removed AppendOptimizedRecycleDeadSegments() out
     * of this function and dedicated it to be called only in VACUUM scenario.
     *
     * We are supposed to be fine without recycling spaces here, or find
     * another way to fix it if that does become a real problem.
     */</comment>

	<expr_stmt><expr><name>segInfos</name> <operator>=</operator> <call><name>GetAllAOCSFileSegInfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nseg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>basepath</name> <operator>=</operator> <call><name>relpathbackend</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nseg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>aocs_addcol_emptyvpe</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>segInfos</name></expr></argument>, <argument><expr><name>nseg</name></expr></argument>,
							 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>scancol</name> <operator>=</operator> <call><name>column_to_scan</name><argument_list>(<argument><expr><name>segInfos</name></expr></argument>, <argument><expr><name>nseg</name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_storage_headers</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"using column %d of relation %s for alter table scan"</literal></expr></argument>,
		   <argument><expr><name>scancol</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Continue only if a non-empty existing segfile was found above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name>scancol</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize expression context for evaluating values and
		 * constraints of the newly added columns.
		 */</comment>
		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * The slot's data will be populated for each newly added
		 * column by ExecEvalExpr().
		 */</comment>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Mark all attributes including newly added columns as valid.
		 * Used for per tuple constraint evaluation.
		 */</comment>
		<expr_stmt><expr><call><name>ExecStoreAllNullTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sdesc</name> <operator>=</operator> <call><name>aocs_begin_headerscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>scancol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>addcols</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name> <operator>-</operator> <name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<comment type="block">/*
		 * Protect against potential negative number here.
		 * Note that natts is not decremented to reflect dropped columns,
		 * so this should be safe
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>addcols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idesc</name> <operator>=</operator> <call><name>aocs_addcol_init</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>addcols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Loop over all appendonly segments */</comment>
		<for>for <control>(<init><expr><name>segi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>segi</name> <operator>&lt;</operator> <name>nseg</name></expr>;</condition> <incr><expr><operator>++</operator><name>segi</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>segInfos</name><index>[<expr><name>segi</name></expr>]</index></name><operator>-&gt;</operator><name>total_tupcount</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
				<name><name>segInfos</name><index>[<expr><name>segi</name></expr>]</index></name><operator>-&gt;</operator><name>state</name> <operator>==</operator> <name>AOSEG_STATE_AWAITING_DROP</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * VACUUM may cause appendonly segments with eof=0.
				 * We only need to add new rows in pg_aocsseg_* in
				 * this case for each newly added column.  This is
				 * accomplished by aocs_addcol_emptyvpe() above.
				 *
				 * Compaction leaves redundant segments in
				 * AOSEG_STATE_AWAITING_DROP.  We skip over them too.
				 */</comment>
				<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_storage_headers</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
					   <argument><expr><literal type="string">"Skipping over empty segno %d relation %s"</literal></expr></argument>,
					   <argument><expr><name><name>segInfos</name><index>[<expr><name>segi</name></expr>]</index></name><operator>-&gt;</operator><name>segno</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/*
			 * Open aocs segfile for chosen column for current
			 * appendonly segment.
			 */</comment>
			<expr_stmt><expr><call><name>aocs_headerscan_opensegfile</name><argument_list>(<argument><expr><name>sdesc</name></expr></argument>, <argument><expr><name><name>segInfos</name><index>[<expr><name>segi</name></expr>]</index></name></expr></argument>, <argument><expr><name>basepath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Create new segfiles for new columns for current
			 * appendonly segment.
			 */</comment>
			<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>backend</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>aocs_addcol_newsegfile</name><argument_list>(<argument><expr><name>idesc</name></expr></argument>, <argument><expr><name><name>segInfos</name><index>[<expr><name>segi</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name>basepath</name></expr></argument>, <argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ATAocsWriteSegFileNewColumns</name><argument_list>(<argument><expr><name>idesc</name></expr></argument>, <argument><expr><name>sdesc</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>aocs_end_headerscan</name><argument_list>(<argument><expr><name>sdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>aocs_addcol_finish</name><argument_list>(<argument><expr><name>idesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATRewriteTable: scan or rewrite one table
 *
 * OIDNewHeap is InvalidOid if we don't need to rewrite
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATRewriteTable</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>oldrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>newrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>oldTupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>newTupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needscan</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>notnull_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>mycid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ti_options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>partqualstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Open the relation(s).  We have surely already locked the existing
	 * table.
	 */</comment>
	<expr_stmt><expr><name>oldrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldTupDesc</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newTupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* includes all mods */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newrel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Prepare a BulkInsertState and options for table_tuple_insert. Because
	 * we're building a new heap, we can skip WAL-logging and fsync it to disk
	 * at the end instead (unless WAL-logging is required for archiving or
	 * streaming replication). The FSM is empty too, so don't bother using it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>mycid</name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bistate</name> <operator>=</operator> <call><name>GetBulkInsertState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ti_options</name> <operator>=</operator> <name>TABLE_INSERT_SKIP_FSM</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogIsNeeded</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ti_options</name> <operator>|=</operator> <name>TABLE_INSERT_SKIP_WAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* keep compiler quiet about using these uninitialized */</comment>
		<expr_stmt><expr><name>mycid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>bistate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ti_options</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Generate the constraint and default execution states
	 */</comment>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build the needed expression execution states */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;constraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
				<expr_stmt><expr><name>needscan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>qualstate</name></name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
				<comment type="block">/* Nothing to do here */</comment>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/* Build expression execution states for partition check quals */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>needscan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>partqualstate</name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;newvals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>ex</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* expr already planned */</comment>
		<expr_stmt><expr><name><name>ex</name><operator>-&gt;</operator><name>exprstate</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>ex</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>notnull_attrs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newrel</name> <operator>||</operator> <name><name>tab</name><operator>-&gt;</operator><name>verify_new_notnull</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we are rebuilding the tuples OR if we added any new but not
		 * verified NOT NULL constraints, check all not-null constraints. This
		 * is a bit of overkill but it minimizes risk of bugs, and
		 * heap_attisnull is a pretty cheap test anyway.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>notnull_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>notnull_attrs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>notnull_attrs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>needscan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newrel</name> <operator>||</operator> <name>needscan</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dropped_attrs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rewriting table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"verifying table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * All predicate locks on the tuples or pages are about to be made
			 * invalid, because we move tuples around.  Promote them to
			 * relation locks.
			 */</comment>
			<expr_stmt><expr><call><name>TransferPredicateLocksToHeapRelation</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create necessary tuple slots. When rewriting, two slots are needed,
		 * otherwise one suffices. In the case where one slot suffices, we
		 * need to use the new tuple descriptor, otherwise some constraints
		 * can't be evaluated.  Note that even when the tuple layout is the
		 * same and no rewrite is required, the tupDescs might not be
		 * (consider ADD COLUMN without a default).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newrel</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>oldTupDesc</name></expr></argument>,
											   <argument><expr><call><name>table_slot_callbacks</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>,
											   <argument><expr><call><name>table_slot_callbacks</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>oldslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>,
											   <argument><expr><call><name>table_slot_callbacks</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newslot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Any attributes that are dropped according to the new tuple
		 * descriptor can be set to NULL. We precompute the list of dropped
		 * attributes to avoid needing to do so in the per-tuple loop.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dropped_attrs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>dropped_attrs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Scan through the rows, generating a new row if needed and then
		 * checking all the constraints.
		 */</comment>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>newrel</name> <operator>&amp;&amp;</operator> <name><name>newrel</name><operator>-&gt;</operator><name>rd_tableam</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>table_dml_init</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Switch to per-tuple memory context and reset it for each tuple
		 * produced, so we don't leak memory.
		 */</comment>
		<expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>table_scan_getnextslot</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>insertslot</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Extract data from old tuple */</comment>
				<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>oldslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>newslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* copy attributes */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newslot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>oldslot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>oldslot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newslot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name><name>oldslot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>oldslot</name><operator>-&gt;</operator><name>tts_nvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Set dropped attributes to null in new tuple */</comment>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>dropped_attrs</argument>)</argument_list></macro>
					<expr_stmt><expr><name><name>newslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Process supplied expressions to replace selected columns.
				 *
				 * First, evaluate expressions whose inputs come from the old
				 * tuple.
				 */</comment>
				<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>oldslot</name></expr>;</expr_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;newvals</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>ex</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>ex</name><operator>-&gt;</operator><name>is_generated</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>newslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name><name>ex</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>
						<operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>ex</name><operator>-&gt;</operator><name>exprstate</name></name></expr></argument>,
									   <argument><expr><name>econtext</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>newslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name><name>ex</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>newslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Now, evaluate any expressions whose inputs come from the
				 * new tuple.  We assume these columns won't reference each
				 * other, so that there's no ordering dependency.
				 */</comment>
				<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>newslot</name></expr>;</expr_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;newvals</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>ex</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ex</name><operator>-&gt;</operator><name>is_generated</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>newslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name><name>ex</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>
						<operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name><name>ex</name><operator>-&gt;</operator><name>exprstate</name></name></expr></argument>,
									   <argument><expr><name>econtext</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>newslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name><name>ex</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/*
				 * Constraints might reference the tableoid column, so
				 * initialize t_tableOid before evaluating them.
				 */</comment>
				<expr_stmt><expr><name><name>newslot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>insertslot</name> <operator>=</operator> <name>newslot</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * If there's no rewrite, old and new table are guaranteed to
				 * have the same AM, so we can just use the old slot to verify
				 * new constraints etc.
				 */</comment>
				<expr_stmt><expr><name>insertslot</name> <operator>=</operator> <name>oldslot</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Now check any constraints on the possibly-changed tuple */</comment>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>insertslot</name></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>notnull_attrs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>attn</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>slot_attisnull</name><argument_list>(<argument><expr><name>insertslot</name></expr></argument>, <argument><expr><name>attn</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>newTupDesc</name></expr></argument>, <argument><expr><name>attn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NOT_NULL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" contains null values"</literal></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errtablecol</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name>attn</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tab-&gt;constraints</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>qualstate</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"check constraint \"%s\" is violated by some row"</literal></expr></argument>,
											<argument><expr><name><name>con</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>
					<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
						<comment type="block">/* Nothing to do here */</comment>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name>partqualstate</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name>partqualstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>validate_default</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated partition constraint for default partition would be violated by some row"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition constraint is violated by some row"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Write the tuple out to the new relation */</comment>
			<if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>table_tuple_insert</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>insertslot</name></expr></argument>, <argument><expr><name>mycid</name></expr></argument>,
								   <argument><expr><name>ti_options</name></expr></argument>, <argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>oldslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newslot</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>newslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>oldrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newrel</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FreeBulkInsertState</name><argument_list>(<argument><expr><name>bistate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_finish_bulk_insert</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>ti_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATGetQueueEntry: find or create an entry in the ALTER TABLE work queue
 */</comment>
<function><type><specifier>static</specifier> <name>AlteredTableInfo</name> <modifier>*</modifier></type>
<name>ATGetQueueEntry</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ltab</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>ltab</argument>, <argument>*wqueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>tab</name> <operator>=</operator> <operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>tab</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Not there, so add it.  Note that we make a copy of the relation's
	 * existing descriptor before anything interesting can happen to it.
	 */</comment>
	<expr_stmt><expr><name>tab</name> <operator>=</operator> <operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AlteredTableInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopyConstr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newAccessMethod</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>new_crsds</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newrelpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>chgPersistence</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>wqueue</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tab</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ATSimplePermissions
 *
 * - Ensure that it is a relation (or possibly a view)
 * - Ensure this user is the owner
 * - Ensure that it is not a system table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATSimplePermissions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>allowed_targets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>actual_target</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_VIEW</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_MATVIEW</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_PARTITIONED_INDEX</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_COMPOSITE_TYPE</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_COMPOSITE_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_FOREIGN_TABLE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RELKIND_AOSEGMENTS</name></expr>:</case>
		<case>case <expr><name>RELKIND_AOBLOCKDIR</name></expr>:</case>
		<case>case <expr><name>RELKIND_AOVISIMAP</name></expr>:</case>
			<comment type="block">/*
			 * Allow ALTER TABLE operations in standard alone mode on
			 * AO segment tables.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <name>ATT_TABLE</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><name>actual_target</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Wrong target type? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>actual_target</name> <operator>&amp;</operator> <name>allowed_targets</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATWrongRelkindError</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>allowed_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Permissions checks */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATWrongRelkindError
 *
 * Throw an error when a relation has been determined to be of the wrong
 * type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATWrongRelkindError</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>allowed_targets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>allowed_targets</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ATT_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or view"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_VIEW</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, or index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or materialized view"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, materialized view, or index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, materialized view, or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_COMPOSITE_TYPE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, composite type, or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_MATVIEW</name> <operator>|</operator> <name>ATT_INDEX</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, materialized view, index, or foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_VIEW</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a view"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ATT_FOREIGN_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a foreign table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* shouldn't get here, add all necessary cases above */</comment>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is of the wrong type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATSimpleRecursion
 *
 * Simple table recursion sufficient for most ALTER TABLE operations.
 * All direct and indirect children are processed in an unspecified order.
 * Note that if a child inherits from the original table via multiple
 * inheritance paths, it will be visited just once.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATSimpleRecursion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Propagate to children if desired.  Only plain tables and foreign tables
	 * have children, so no need to search for other relkinds.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recurse</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		 <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
		 <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * find_all_inheritors does the recursive search of the inheritance
		 * hierarchy, so all we have to do is process all of the relids in the
		 * list that it returns.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>childrelid</name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* find_all_inheritors already got lock */</comment>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * GPDB: for now we disallow setting reloptions of the entire partition
			 * hierarchy, if some child tables have different access method than the
			 * root. We check it here so that we can print pretty error message.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_SetRelOptions</name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_ReplaceRelOptions</name><operator>)</operator> 
					<operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter reloptions for \"%s\" because one of the "</literal>
						        <literal type="string">"child tables \"%s\" has different access method"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Alter tables individually or change the child's AM to be same as parent."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain list of partitions of the given table, locking them all at the given
 * lockmode and ensuring that they all pass CheckTableNotInUse.
 *
 * This function is a no-op if the given relation is not a partitioned table;
 * in particular, nothing is done if it's a legacy inheritance parent.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATCheckPartitionsNotInUse</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inh</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>inh</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* first element is the parent rel; must ignore it */</comment>
		<macro><name>for_each_cell</name><argument_list>(<argument>cell</argument>, <argument>lnext(list_head(inh))</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>

			<comment type="block">/* find_all_inheritors already got lock */</comment>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ATTypedTableRecursion
 *
 * Propagate ALTER TYPE operations to the typed tables of that type.
 * Also check the RESTRICT/CASCADE behavior.  Given CASCADE, also permit
 * recursion to inheritance children of the typed tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATTypedTableRecursion</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
					  <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_typed_table_dependencies</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
											 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * find_composite_type_dependencies
 *
 * Check to see if the type "typeOid" is being used as a column in some table
 * (possibly nested several levels deep in composite types, arrays, etc!).
 * Eventually, we'd like to propagate the check or rewrite operation
 * into such tables, but for now, just error out if we find any.
 *
 * Caller should provide either the associated relation of a rowtype,
 * or a type name (not both) for use in the error message, if any.
 *
 * Note that "typeOid" is not necessarily a composite type; it could also be
 * another container type such as an array or range, or a domain over one of
 * these things.  The name of this function is therefore somewhat historical,
 * but it's not worth changing.
 *
 * We assume that functions and views depending on the type are not reasons
 * to reject the ALTER.  (How safe is this really?)
 */</comment>
<function><type><name>void</name></type>
<name>find_composite_type_dependencies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>origRelation</name></decl></parameter>,
								 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>origTypeName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>depRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>depScan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>depTup</name></decl>;</decl_stmt>

	<comment type="block">/* since this function recurses, it could be driven to stack overflow */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We scan pg_depend to find those things that depend on the given type.
	 * (We assume we can ignore refobjsubid for a type.)
	 */</comment>
	<expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>depScan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>pg_depend</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

		<comment type="block">/* Check for directly dependent types */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>classid</name></name> <operator>==</operator> <name>TypeRelationId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This must be an array, domain, or range containing the given
			 * type, so recursively check for uses of this type.  Note that
			 * any error message will mention the original type not the
			 * container; this is intentional.
			 */</comment>
			<expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>,
											 <argument><expr><name>origRelation</name></expr></argument>, <argument><expr><name>origTypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Else, ignore dependees that aren't user columns of relations */</comment>
		<comment type="block">/* (we assume system columns are never of interesting types) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>classid</name></name> <operator>!=</operator> <name>RelationRelationId</name> <operator>||</operator>
			<name><name>pg_depend</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>pg_depend</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>origTypeName</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type \"%s\" because column \"%s.%s\" uses it"</literal></expr></argument>,
								<argument><expr><name>origTypeName</name></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>origRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type \"%s\" because column \"%s.%s\" uses it"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>origRelation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>origRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter foreign table \"%s\" because column \"%s.%s\" uses its row type"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>origRelation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter table \"%s\" because column \"%s.%s\" uses its row type"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>origRelation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * A view or composite type itself isn't a problem, but we must
			 * recursively check for indirect dependencies via its rowtype.
			 */</comment>
			<expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
											 <argument><expr><name>origRelation</name></expr></argument>, <argument><expr><name>origTypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>depScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * find_typed_table_dependencies
 *
 * Check to see if a composite type is being used as the type of a
 * typed table.  Abort if any are found and behavior is RESTRICT.
 * Else return the list of tables.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>find_typed_table_dependencies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>, <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>classRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_class_reloftype</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>behavior</name> <operator>==</operator> <name>DROP_RESTRICT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type \"%s\" because it is the type of a typed table"</literal></expr></argument>,
							<argument><expr><name>typeName</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER ... CASCADE to alter the typed tables too."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>classform</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * check_of_type
 *
 * Check whether a type is suitable for CREATE TABLE OF/ALTER TABLE OF.  If it
 * isn't suitable, throw an error.  Currently, we require that the type
 * originated with CREATE TYPE AS.  We could support any row type, but doing so
 * would require handling a number of extra corner cases in the DDL commands.
 * (Also, allowing domain-over-composite would open up a can of worms about
 * whether and how the domain's constraints should apply to derived tables.)
 */</comment>
<function><type><name>void</name></type>
<name>check_of_type</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>typetuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typ</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typeOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>typ</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>typeRelation</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typeRelation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typeOk</name> <operator>=</operator> <operator>(</operator><name><name>typeRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Close the parent rel, but keep our AccessShareLock on it until xact
		 * commit.  That will prevent someone else from deleting or ALTERing
		 * the type before the typed table creation/conversion commits.
		 */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>typeRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>typeOk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is not a composite type"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ALTER TABLE ADD COLUMN
 *
 * Adds an additional attribute to a relation making the assumption that
 * CHECK, NOT NULL, and FOREIGN KEY constraints will be removed from the
 * AT_AddColumn AlterTableCmd by parse_utilcmd.c and added as independent
 * AlterTableCmd's.
 *
 * ADD COLUMN cannot use the normal ALTER TABLE recursion mechanism, because we
 * have to decide at runtime whether to recurse or not depending on whether we
 * actually add a column or merely merge with an existing column.  (We can't
 * check this in a static pre-pass because it won't handle multiple inheritance
 * situations correctly.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepAddColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>is_view</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add column to typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATTypedTableRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>recurse</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_view</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddColumnRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a column to a table.  The return value is the address of the
 * new column in the parent relation.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				<parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>colDef</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>myrelid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pgclass</name></decl>,
				<decl><type ref="prev"/><name>attrdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_pg_attribute</name></type> <name>attribute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newattnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>tform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>defval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
 	<decl_stmt><decl><type><name>List</name><modifier>*</modifier></type> <name>enc</name></decl>;</decl_stmt>

	<comment type="block">/* At top level, permission check was done in ATPrepCmd, else do it */</comment>
	<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add column to a partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attrdesc</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Are we adding the column to a recursion child?  If so, check whether to
	 * merge with an existing definition for the column.  If we do merge, we
	 * must not recurse.  Children will already have the column, and recursing
	 * into them would mess up attinhcount.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<comment type="block">/* Does child already have a column by this name? */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>childatt</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>ctypeId</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>ctypmod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>ccollid</name></decl>;</decl_stmt>

			<comment type="block">/* Child column must match on type, typmod, and collation */</comment>
			<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ctypeId</name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
				<name>ctypmod</name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different type for column \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>ccollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>colDef</name></expr></argument>, <argument><expr><name>ctypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ccollid</name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different collation for column \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" versus \"%s\""</literal></expr></argument>,
								   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name>ccollid</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>get_collation_name</name><argument_list>(<argument><expr><name><name>childatt</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Bump the existing child att's inhcount */</comment>
			<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Inform the user about the merge */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"merging definition of column \"%s\" for child \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>pgclass</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cannot add identity column if table has children, because identity does
	 * not inherit.  (Adding column and identity separately will work.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name> <operator>&amp;&amp;</operator>
		<name>recurse</name> <operator>&amp;&amp;</operator>
		<call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot recursively add identity column to table that has child tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* skip if the name already exists and if_not_exists is true */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_for_column_name_collision</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Determine the new attribute's number */</comment>
	<expr_stmt><expr><name>newattnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relnatts</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newattnum</name> <operator>&gt;</operator> <name>MaxHeapAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tables can have at most %d columns"</literal></expr></argument>,
						<argument><expr><name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typeOid</name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>collOid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>colDef</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure datatype is legal for a column */</comment>
	<expr_stmt><expr><call><name>CheckAttributeType</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name>collOid</name></expr></argument>,
					   <argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* construct new attribute's pg_attribute entry */</comment>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attrelid</name></name> <operator>=</operator> <name>myrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>attribute</name><operator>.</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>atttypid</name></name> <operator>=</operator> <name>typeOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attstattarget</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newattnum</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attlen</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>atttypmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attnum</name></name> <operator>=</operator> <name>newattnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attbyval</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attndims</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>arrayBounds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attstorage</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attalign</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attnotnull</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>atthasdef</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>atthasmissing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attidentity</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attgenerated</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>generated</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attisdropped</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attislocal</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>is_local</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attinhcount</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>inhcount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attribute</name><operator>.</operator><name>attcollation</name></name> <operator>=</operator> <name>collOid</name></expr>;</expr_stmt>
	<comment type="block">/* attribute.attacl is handled by InsertPgAttributeTuple */</comment>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InsertPgAttributeTuple</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attribute</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrdesc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update pg_class tuple as appropriate
	 */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relnatts</name> <operator>=</operator> <name>newattnum</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Post creation hook for new attribute */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>newattnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make the attribute's catalog entry visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store the DEFAULT, if any, in the catalogs
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>raw_default</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawColumnDefault</name> <modifier>*</modifier></type><name>rawEnt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rawEnt</name> <operator>=</operator> <operator>(</operator><name>RawColumnDefault</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RawColumnDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name><name>attribute</name><operator>.</operator><name>attnum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>raw_default</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>hasCookedMissingVal</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>hasCookedMissingVal</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>missingVal</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>missingVal</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>missingIsNull</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>missingIsNull</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Attempt to skip a complete table rewrite by storing the specified
		 * DEFAULT value outside of the heap.  This may be disabled inside
		 * AddRelationNewConstraints if the optimization cannot be applied.
		 *
		 * In GPDB, AddRelationNewConstraints will also set rawEnt-&gt;missingVal/IsNull
		 */</comment>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>missingMode</name></name> <operator>=</operator> <operator>(</operator><operator>!</operator><name><name>colDef</name><operator>-&gt;</operator><name>generated</name></name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>generated</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>generated</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * This function is intended for CREATE TABLE, so it processes a
		 * _list_ of defaults, but we just do one.
		 */</comment>
		<expr_stmt><expr><call><name>AddRelationNewConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rawEnt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* copy back the cooked attmissingval for dispatch */</comment>
		<expr_stmt><expr><name><name>colDef</name><operator>-&gt;</operator><name>hasCookedMissingVal</name></name> <operator>=</operator> <name><name>rawEnt</name><operator>-&gt;</operator><name>hasCookedMissingVal</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>colDef</name><operator>-&gt;</operator><name>missingVal</name></name> <operator>=</operator> <name><name>rawEnt</name><operator>-&gt;</operator><name>missingVal</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>colDef</name><operator>-&gt;</operator><name>missingIsNull</name></name> <operator>=</operator> <name><name>rawEnt</name><operator>-&gt;</operator><name>missingIsNull</name></name></expr>;</expr_stmt>

		<comment type="block">/* Make the additional catalog changes visible */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Did the request for a missing value work? If not we'll have to do a
		 * rewrite
		 */</comment>
		<comment type="block">/*
		 * GPDB_12_MERGE_FIXME: This optimization to avoid rewriting a table
		 * is based on the assumption that at the time of reading tuples from
		 * this table, it is possible to determine if the tuple does not
		 * contain the value for the new column being added.  In that case,
		 * the missing value would be replaced with the default value from
		 * pg_attrdef catalog table.
		 *
		 * The optimization cannot be applied to appendoptimized row-oriented
		 * tables because the number of attributes is not recorded on disk.
		 * MemTuples only record the tuple length followed by the tuple data.
		 * This information is not sufficient to determine if the tuple
		 * contains a missing column.
		 *
		 * A possible solution involves recoding the number of attributes for
		 * each tuple or for each varblock, so that this optimization can be
		 * applied on similar lines as heap_getattr.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rawEnt</name><operator>-&gt;</operator><name>missingMode</name></name> <operator>||</operator> <call><name>RelationIsAoRows</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_DEFAULT_VAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Tell Phase 3 to fill in the default expression, if there is one.
	 *
	 * If there is no default, Phase 3 doesn't have to do anything, because
	 * that effectively means that the default is NULL.  The heap tuple access
	 * routines always check for attnum &gt; # of attributes in tuple, and return
	 * NULL if so, so without any modification of the tuple data we will get
	 * the effect of NULL values in the new column.
	 *
	 * An exception occurs when the new column is of a domain type: the domain
	 * might have a NOT NULL constraint, or a check constraint that indirectly
	 * rejects nulls.  If there are any domain constraints then we construct
	 * an explicit NULL default value that will be passed through
	 * CoerceToDomain processing.  (This is a tad inefficient, since it causes
	 * rewriting the table which we really don't have to do, but the present
	 * design of domain processing doesn't offer any simple way of checking
	 * the constraints more directly.)
	 *
	 * Note: we use build_column_default, and not just the cooked default
	 * returned by AddRelationNewConstraints, so that the right thing happens
	 * when a datatype's default applies.
	 *
	 * We skip this step completely for views and foreign tables.  For a view,
	 * we can only get here from CREATE OR REPLACE VIEW, which historically
	 * doesn't set up defaults, not even for domain-typed columns.  And in any
	 * case we mustn't invoke Phase 3 on a view or foreign table, since they
	 * have no storage.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name>
		<operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <name><name>attribute</name><operator>.</operator><name>attnum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For an identity column, we can't use build_column_default(),
		 * because the sequence ownership isn't set yet.  So do it manually.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>identity</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NextValueExpr</name> <modifier>*</modifier></type><name>nve</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>nve</name><operator>-&gt;</operator><name>seqid</name></name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>identitySequence</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nve</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name>typeOid</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>defval</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>nve</name></expr>;</expr_stmt>

			<comment type="block">/* must do a rewrite for identity columns */</comment>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_DEFAULT_VAL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>defval</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>.</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>defval</name> <operator>&amp;&amp;</operator> <call><name>DomainHasConstraints</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>baseTypeId</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>baseTypeMod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>baseTypeColl</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>baseTypeMod</name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>baseTypeId</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseTypeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>baseTypeColl</name> <operator>=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name>baseTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>defval</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>baseTypeId</name></expr></argument>, <argument><expr><name>baseTypeMod</name></expr></argument>, <argument><expr><name>baseTypeColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>defval</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
													<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>defval</name></expr></argument>,
													<argument><expr><name>baseTypeId</name></expr></argument>,
													<argument><expr><name>typeOid</name></expr></argument>,
													<argument><expr><name>typmod</name></expr></argument>,
													<argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
													<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
													<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>defval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to coerce base type to domain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Handling of default NULL for AO/CO tables.
		 *
		 * Currently memtuples cannot deal with the scenario where the number of
		 * attributes in the tuple data don't match the attnum. We will generate an
		 * explicit NULL default value and force a rewrite of the table below.
		 *
		 * At one point there were plans to restructure memtuples so that this
		 * rewrite did not have to occur. An optimization was added to
		 * column-oriented tables to avoid the rewrite, but it does not apply to
		 * row-oriented tables. Eventually it would be nice to remove this
		 * workaround; see GitHub issue
		 *     https://github.com/greenplum-db/gpdb/issues/3756
		 *
		 * GPDB_12_MERGE_FIXME: we used to do this only if no default was given,
		 * but starting with PostgreSQL v11, a table doesn't need to be rewritten
		 * even if a non-NULL default is used. That caused an assertion failure in
		 * the 'uao_ddl/alter_ao_table_constraint_column' test. To make that go
		 * away, always force full rewrite on AO_ROW and AO_COLUMN tables. We
		 * should be smarter..
		 */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>defval</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>defval</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_DEFAULT_VAL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>defval</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>

			<comment type="block">/* If QE, AlteredTableInfo streamed from QD already contains newvals */</comment>
			<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>newval</name> <operator>=</operator> <operator>(</operator><name>NewColumnValue</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewColumnValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name><name>attribute</name><operator>.</operator><name>attnum</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><name>defval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>is_generated</name></name> <operator>=</operator> <operator>(</operator><name><name>colDef</name><operator>-&gt;</operator><name>generated</name></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * tab is null if this is called by "create or replace view" which
				 * can't have any default value.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>DomainHasConstraints</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_DEFAULT_VAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>attribute</name><operator>.</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atthasmissing</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the new column is NOT NULL, and there is no missing value,
			 * tell Phase 3 it needs to check for NULLs.
			 */</comment>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>verify_new_notnull</name></name> <operator>|=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add needed dependency entries for the new column.
	 */</comment>
	<expr_stmt><expr><call><name>add_column_datatype_dependency</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>newattnum</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>.</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_column_collation_dependency</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>newattnum</name></expr></argument>, <argument><expr><name><name>attribute</name><operator>.</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * Process the encoding clauses.
	 *
	 * For AO/CO tables, always store an encoding clause. If no encoding
	 * clause was provided, store the default encoding clause.
	 * If there's an encoding clause for non AO/CO tables, we'll throw an error 
	 * in the function (indicated by errorOnEncodingClause == true).
	 */</comment>
	<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>transformColumnEncoding</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>colDef</name></expr></argument>)</argument_list></call></expr></argument>, 
					<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* COLUMN ENCODING clauses is only for CREATE TABLE */</comment>, 
					<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* withOptions */</comment>,
					<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* parent encodings */</comment>,
					<argument><expr><name>false</name></expr></argument> <comment type="block">/* explicitOnly */</comment>,
					<argument><expr><operator>!</operator><call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument> <comment type="block">/* errorOnEncodingClause */</comment>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* 
	 * Store the encoding clause for AO/CO tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AddRelationAttributeEncodings</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"ADD COLUMN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Propagate to children as appropriate.  Unlike most other ALTER
	 * routines, we have to do this one level of recursion at a time; we can't
	 * use find_all_inheritors to do it in one pass.
	 */</comment>
	<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are told not to recurse, there had better not be any child
	 * tables; else the addition would put them out of step.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>children</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column must be added to child tables too"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Children should see column as singly inherited */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>colDef</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>colDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>colDef</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>colDef</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Leave a flag on tables in the partition hierarchy that can benefit from the
	 * optimization for columnar tables.
	 * We have to do it while processing the root partition because that's the
	 * only level where the `ADD COLUMN` subcommands are populated.
	 *
	 * QD will dispatch wqueue and the QE will get all the info
	 * to perform the column optimized rewrite.
	 * So, we only need to execute this block on QD.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator> <name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>	<name>aocs_write_new_columns_only</name></decl>;</decl_stmt>
		<comment type="block">/*
		 * ADD COLUMN for CO can be optimized only if it is the
		 * only subcommand being performed.
		 */</comment>
		<expr_stmt><expr><name>aocs_write_new_columns_only</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>AT_NUM_PASSES</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>AT_PASS_ADD_COL</name> <operator>&amp;&amp;</operator> <name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>aocs_write_new_columns_only</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>aocs_write_new_columns_only</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We have acquired lockmode on the root and first-level partitions
			 * already. This leaves the deeper subpartitions unlocked, but no
			 * operations can drop (or alter) those relations without locking
			 * through the root. But we still lock them to meet the upstream 
			 * expecation in relation_open that all callers should have acquired
			 * a lock on the table except in bootstrap mode.

			 * Note that find_all_inheritors() also includes the root partition 
			 * in the returned list.
			 */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>all_inheritors</name> <init>= <expr><call><name>find_all_inheritors</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>all_inheritors</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type> <name>r</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>childtab</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>childtab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>childtab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_NEW_COLUMNS_ONLY_AOCS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>childtab</name></decl>;</decl_stmt>

		<comment type="block">/* find_inheritance_children already got lock */</comment>
		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Find or create work queue entry for this table */</comment>
		<expr_stmt><expr><name>childtab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Recurse to child; return value is ignored */</comment>
		<expr_stmt><expr><call><name>ATExecAddColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childtab</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>,
						<argument><expr><name>colDef</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
						<argument><expr><name>if_not_exists</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>newattnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If a new or renamed column will collide with the name of an existing
 * column and if_not_exists is false then error out, else do nothing.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_for_column_name_collision</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>if_not_exists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * this test is deliberately not attisdropped-aware, since if one tries to
	 * add a column matching a dropped column name, it's gonna fail anyway.
	 */</comment>
	<expr_stmt><expr><name>attTuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>,
							   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We throw a different error message for conflicts with system column
	 * names, since they are normally not shown and the user might otherwise
	 * be confused about the reason for the conflict.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column name \"%s\" conflicts with a system column name"</literal></expr></argument>,
						<argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>if_not_exists</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" already exists, skipping"</literal></expr></argument>,
							<argument><expr><name>colname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" already exists"</literal></expr></argument>,
						<argument><expr><name>colname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Install a column's dependency on its datatype.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_column_datatype_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Install a column's dependency on its collation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_column_collation_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

	<comment type="block">/* We know the default collation is pinned, so don't bother recording it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>collid</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>CollationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>collid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ... ALTER COLUMN a SET ENCODING (...)
 *
 * Update pg_attribute_encoding with the given encoding options.
 * Normally this will need a table rewrite, except when
 * (1) the table is a partitioned one,
 * or
 * (2) the encoding option isn't really changed (they are the same as the given ones).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecSetColumnEncoding</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>new_crsd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_updated</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newAccessMethod</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>newAccessMethod</name></name> <operator>!=</operator> <name>AO_COLUMN_TABLE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER COLUMN SET ENCODING operation is only applicable to AOCO tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"New access method for \"%s\" is not AOCO"</literal></expr></argument>,
						  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>AO_COLUMN_TABLE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
			<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER COLUMN SET ENCODING operation is only applicable to AOCO tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an AOCO table"</literal></expr></argument>,
					  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tab</name><operator>-&gt;</operator><name>new_crsds</name></name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* first iteration */</comment>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>new_crsds</name></name> <operator>=</operator> <call><name>rel_get_column_encodings</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>new_crsd</name> <operator>=</operator> <operator>(</operator><name>ColumnReferenceStorageDirective</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_updated</name> <operator>=</operator> <call><name>updateEncodingList</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>new_crsds</name></name></expr></argument>, <argument><expr><name>new_crsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_updated</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>=</operator> <name>AT_REWRITE_COLUMN_REWRITE</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UpdateAttributeEncodings</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>new_crsds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="line">//cannot reach here</comment>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN DROP NOT NULL
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepDropNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the parent is a partitioned table, like check constraints, we do not
	 * support removing the NOT NULL while partitions exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partdesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot remove constraint from only the partitioned table when partitions exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the address of the modified column.  If the column was already
 * nullable, InvalidObjectAddress is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDropNotNull</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attr_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * lookup the attribute
	 */</comment>
	<expr_stmt><expr><name>attr_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

	<comment type="block">/* Prevent them from altering a system attribute */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is an identity column"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the attribute is not in a primary key
	 *
	 * Note: we'll throw error even if the pkey index is not valid.
	 */</comment>

	<comment type="block">/* Loop over all indexes on the relation */</comment>
	<expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If the index is not a primary key, skip the check */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Loop over each attribute in the primary key and see if it
			 * matches the to-be-altered attribute
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is in a primary key"</literal></expr></argument>,
									<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If rel is partition, shouldn't drop NOT NULL if parent has the same */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentId</name> <init>= <expr><call><name>get_partition_parent</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>parent</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>parent_attnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>parent_attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>parent_attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attnotnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is marked NOT NULL in parent table"</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Okay, actually perform the catalog change ... if needed
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
							<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN DROP NOT NULL"</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET NOT NULL
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepSetNotNull</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we're already recursing, there's nothing to do; the topmost
	 * invocation of ATSimpleRecursion already visited all children.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we have ALTER TABLE ONLY ... SET NOT NULL on a partitioned table,
	 * apply ALTER TABLE ... CHECK NOT NULL to every child.  Otherwise, use
	 * normal recursion logic.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>recurse</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>newcmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_CheckNotNull</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>newcmd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATSimpleRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the address of the modified column.  If the column was already NOT
 * NULL, InvalidObjectAddress is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetNotNull</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attr_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * lookup the attribute
	 */</comment>
	<expr_stmt><expr><name>attr_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnum</name></expr>;</expr_stmt>

	<comment type="block">/* Prevent them from altering a system attribute */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Okay, actually perform the catalog change ... if needed
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnotnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnotnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Ordinarily phase 3 must ensure that no NULLs exist in columns that
		 * are set NOT NULL; however, if we can find a constraint which proves
		 * this then we can skip that.  We needn't bother looking if we've
		 * already found that we must verify some other NOT NULL constraint.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tab</name><operator>-&gt;</operator><name>verify_new_notnull</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>NotNullImpliedByRelConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Tell Phase 3 it needs to test the constraint */</comment>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>verify_new_notnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
							<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN SET NOT NULL"</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN CHECK NOT NULL
 *
 * This doesn't exist in the grammar, but we generate AT_CheckNotNull
 * commands against the partitions of a partitioned table if the user
 * writes ALTER TABLE ONLY ... SET NOT NULL on the partitioned table,
 * or tries to create a primary key on it (which internally creates
 * AT_SetNotNull on the partitioned table).   Such a command doesn't
 * allow us to actually modify any partition, but we want to let it
 * go through if the partitions are already properly marked.
 *
 * In future, this might need to adjust the child table's state, likely
 * by incrementing an inheritance count for the attnotnull constraint.
 * For now we need only check for the presence of the flag.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecCheckNotNull</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnotnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint must be added to child tables too"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Column \"%s\" of relation \"%s\" is not already NOT NULL."</literal></expr></argument>,
						   <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * NotNullImpliedByRelConstraints
 *		Does rel's existing constraints imply NOT NULL for the given attribute?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NotNullImpliedByRelConstraints</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nnulltest</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>nnulltest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>,
									  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
									  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
									  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nnulltest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * argisrow = false is correct even for a composite column, because
	 * attnotnull does not represent a SQL-spec IS NOT NULL test in such a
	 * case, just IS DISTINCT FROM NULL.
	 */</comment>
	<expr_stmt><expr><name><name>nnulltest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nnulltest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ConstraintImpliedByRelConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>nnulltest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"existing constraints on column \"%s\".\"%s\" are sufficient to prove that it does not contain nulls"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET/DROP DEFAULT
 *
 * Return the address of the affected column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecColumnDefault</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
					<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newDefault</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * get the number of the attribute
	 */</comment>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prevent them from altering a system attribute */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attidentity</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is an identity column"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>newDefault</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TABLE ... ALTER COLUMN ... DROP IDENTITY instead."</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attgenerated</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is a generated column"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Remove any old default for the column.  We use RESTRICT here for
	 * safety, but at present we do not expect anything to depend on the
	 * default.
	 *
	 * We treat removing the existing default as an internal operation when it
	 * is preparatory to adding a new default, but as a user-initiated
	 * operation when the user asked for a drop.
	 */</comment>
	<expr_stmt><expr><call><name>RemoveAttrDefault</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>newDefault</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>newDefault</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* SET DEFAULT */</comment>
		<decl_stmt><decl><type><name>RawColumnDefault</name> <modifier>*</modifier></type><name>rawEnt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rawEnt</name> <operator>=</operator> <operator>(</operator><name>RawColumnDefault</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RawColumnDefault</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name>newDefault</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>missingMode</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawEnt</name><operator>-&gt;</operator><name>generated</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * This function is intended for CREATE TABLE, so it processes a
		 * _list_ of defaults, but we just do one.
		 */</comment>
		<expr_stmt><expr><call><name>AddRelationNewConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rawEnt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN DEFAULT"</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN ADD IDENTITY
 *
 * Return the address of the affected column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>cdef</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

	<comment type="block">/* Can't alter a system attribute */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Creating a column as identity implies NOT NULL, so adding the identity
	 * to an existing column that is not NOT NULL would create a state that
	 * cannot be reproduced without contortions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attTup</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" must be declared NOT NULL before identity can be added"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is already an identity column"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" already has a default value"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <name><name>cdef</name><operator>-&gt;</operator><name>identity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET { GENERATED or sequence options }
 *
 * Return the address of the affected column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>generatedEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>castNode(List, def)</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"generated"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>generatedEl</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>generatedEl</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>,
				 <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Even if there is nothing to change here, we run all the checks.  There
	 * will be a subsequent ALTER SEQUENCE that relies on everything being
	 * there.
	 */</comment>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is not an identity column"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>generatedEl</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <call><name>defGetInt32</name><argument_list>(<argument><expr><name>generatedEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
								  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
							<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN DROP IDENTITY
 *
 * Return the address of the affected column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDropIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>seqid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>seqaddress</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is not an identity column"</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" is not an identity column, skipping"</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* drop the internal sequence */</comment>
	<expr_stmt><expr><name>seqid</name> <operator>=</operator> <call><name>getOwnedSequence</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deleteDependencyRecordsForClass</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>seqid</name></expr></argument>,
									<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqaddress</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqaddress</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>seqid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqaddress</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqaddress</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>PERFORM_DELETION_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET STATISTICS
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepSetStatistics</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>colNum</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We do our own permission checking because (a) we want to allow SET
	 * STATISTICS on indexes (for expressional index columns), and (b) we want
	 * to allow SET STATISTICS on system catalogs without requiring
	 * allowSystemTableMods to be turned on.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, materialized view, index, or foreign table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We allow referencing columns by numbers only for indexes, since table
	 * column numbers could contain gaps if columns are later dropped.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>colName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot refer to non-index column by number"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Permissions checks */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return value is the address of the modified column
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetStatistics</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>colNum</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>newtarget</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attrtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>, <argument><expr><name>Integer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newtarget</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Limit target to a sane range
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newtarget</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statistics target %d is too low"</literal></expr></argument>,
						<argument><expr><name>newtarget</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>newtarget</name> <operator>&gt;</operator> <literal type="number">10000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newtarget</name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lowering statistics target to %d"</literal></expr></argument>,
						<argument><expr><name>newtarget</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>colName</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttNum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column number %d of relation \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>colNum</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>attrtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter statistics on included column \"%s\" of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter statistics on non-expression column \"%s\" of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Alter statistics on table column instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <name>newtarget</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN SET STATISTICS"</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return value is the address of the modified column
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>isReset</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>,
				<decl><type ref="prev"/><name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attrtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>,
				<decl><type ref="prev"/><name>newOptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attrtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Generate new proposed attoptions (text array) */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_attribute_attoptions</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newOptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>datum</name></expr></else></ternary></expr></argument>,
									 <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>isReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Validate new options */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>attribute_reloptions</name><argument_list>(<argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build new tuple. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newOptions</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_attribute_attoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newOptions</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_attribute_attoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_attribute_attoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update system catalog. */</comment>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ALTER COLUMN SET STORAGE
 *
 * Return value is the address of the modified column
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecSetStorage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newValue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>storagemode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>newstorage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attrtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>storagemode</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>storagemode</name></expr></argument>, <argument><expr><literal type="string">"plain"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>storagemode</name></expr></argument>, <argument><expr><literal type="string">"external"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>storagemode</name></expr></argument>, <argument><expr><literal type="string">"extended"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>storagemode</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid storage type \"%s\""</literal></expr></argument>,
						<argument><expr><name>storagemode</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newstorage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attrtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * safety check: do not allow toasted storage modes unless column datatype
	 * is TOAST-aware.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newstorage</name> <operator>==</operator> <literal type="char">'p'</literal> <operator>||</operator> <call><name>TypeIsToastable</name><argument_list>(<argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <name>newstorage</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column data type %s can only have storage PLAIN"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>attrtuple</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN SET STORAGE"</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ALTER TABLE DROP COLUMN
 *
 * DROP COLUMN cannot use the normal ALTER TABLE recursion mechanism,
 * because we have to decide at runtime whether to recurse or not depending
 * on whether attinhcount goes to zero or not.  (We can't check this in a
 * static pre-pass because it won't handle multiple inheritance situations
 * correctly.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepDropColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				 <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop column from typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATTypedTableRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_DropColumnRecurse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Drops column 'colName' from relation 'rel' and returns the address of the
 * dropped column.  The column is also dropped (or marked as no longer
 * inherited from relation) from the relation's inheritance children, if any.
 *
 * In the recursive invocations for inheritance child relations, instead of
 * dropping the column directly (if to be dropped at all), its object address
 * is added to 'addrs', which must be non-NULL in such invocations.  All
 * columns are dropped at the same time after all the children have been
 * checked recursively.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDropColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
				 <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
				 <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>addrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>targetatt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_expr</name></decl>;</decl_stmt>

	<comment type="block">/* At top level, permission check was done in ATPrepCmd, else do it */</comment>
	<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize addrs on the first invocation */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>recursing</name> <operator>||</operator> <name>addrs</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>addrs</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * get the number of the attribute
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist, skipping"</literal></expr></argument>,
							<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>targetatt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>targetatt</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

	<comment type="block">/* Can't drop a system attribute */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Don't drop inherited columns */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>targetatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop inherited column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Don't drop columns used in the partition key */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>has_partition_attrs</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
							<argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>is_expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_expr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop column named in partition key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop column referenced in partition key expression"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsPartitioned</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ia</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>ia</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ia</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>ia</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>ia</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl>;</decl_stmt>

				<comment type="block">/* force a random distribution */</comment>
				<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>policy</name> <operator>=</operator> <call><name>GpPolicyCopy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * replace policy first in catalog and then assign to
				 * rd_cdbpolicy to make sure we have intended policy in relcache
				 * even with relcache invalidation. Otherwise rd_cdbpolicy can
				 * become invalid soon after assignment.
				 */</comment>
				<expr_stmt><expr><call><name>GpPolicyReplace</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>=</operator> <name>policy</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
				    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dropping a column that is part of the distribution policy forces a NULL distribution policy"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Propagate to children as appropriate.  Unlike most other ALTER
	 * routines, we have to do this one level of recursion at a time; we can't
	 * use find_all_inheritors to do it in one pass.
	 */</comment>
	<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>children</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>attr_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * In case of a partitioned table, the column must be dropped from the
		 * partitions as well.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop column from only the partitioned table when partitions exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attr_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>childatt</name></decl>;</decl_stmt>

			<comment type="block">/* find_inheritance_children already got lock */</comment>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute \"%s\" of relation %u"</literal></expr></argument>,
					 <argument><expr><name>colName</name></expr></argument>, <argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>childatt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u has non-inherited attribute \"%s\""</literal></expr></argument>,
					 <argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If the child column has other definition sources, just
				 * decrement its inheritance count; if not or if this is part
				 * of a partition configuration, recurse to delete it.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>childatt</name><operator>-&gt;</operator><name>attislocal</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Time to delete this child column, too */</comment>
					<expr_stmt><expr><call><name>ATExecDropColumn</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>colName</name></expr></argument>,
									 <argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Child column must survive my deletion */</comment>
					<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>--</operator></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Make update visible */</comment>
					<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * If we were told to drop ONLY in this table (no recursion),
				 * we need to mark the inheritors' attributes as locally
				 * defined rather than inherited.
				 */</comment>
				<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Make update visible */</comment>
				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add object to delete */</comment>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recursion has ended, drop everything that was collected */</comment>
		<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>addrs</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"DROP COLUMN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>object</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ADD INDEX
 *
 * There is no such command in the grammar, but parse_utilcmd.c converts
 * UNIQUE and PRIMARY KEY constraints into AT_AddIndex subcommands.  This lets
 * us schedule creation of the index at the appropriate time during ALTER.
 *
 * Return value is the address of the new index.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddIndex</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
			   <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_rebuild</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>check_rights</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skip_build</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>quiet</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The IndexStmt has already been through transformIndexStmt */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>transformed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* suppress schema rights check when rebuilding existing index */</comment>
	<expr_stmt><expr><name>check_rights</name> <operator>=</operator> <operator>!</operator><name>is_rebuild</name></expr>;</expr_stmt>
	<comment type="block">/* skip index build if phase 3 will do it or we're reusing an old one */</comment>
	<expr_stmt><expr><name>skip_build</name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* suppress notices when rebuilding existing index */</comment>
	<expr_stmt><expr><name>quiet</name> <operator>=</operator> <name>is_rebuild</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>DefineIndex</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>stmt</name></expr></argument>,
						  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no predefined OID */</comment>
						  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no parent index */</comment>
						  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no parent constraint */</comment>
						  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* is_alter_table */</comment>
						  <argument><expr><name>check_rights</name></expr></argument>,
						  <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* check_not_in_use - we did it already */</comment>
						  <argument><expr><name>skip_build</name></expr></argument>,
						  <argument><expr><name>quiet</name></expr></argument>,
						  <argument><expr><name>false</name></expr></argument> <comment type="block">/* not a new table */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If TryReuseIndex() stashed a relfilenode for us, we used it for the new
	 * index instead of building from scratch.  The DROP of the old edition of
	 * this index will have scheduled the storage for deletion at commit, so
	 * cancel that pending deletion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldNode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>irel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>RelationPreserveStorage</name><argument_list>(<argument><expr><name><name>irel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"ADD INDEX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ADD CONSTRAINT USING INDEX
 *
 * Returns the address of the new constraint.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddIndexConstraint</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						 <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>index_oid</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>indexOid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indexName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>constraintName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>constraintType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits16</name></type>		<name>flags</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>isconstraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Doing this on partitioned tables is not a simple feature to implement,
	 * so let's punt for now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER TABLE / ADD CONSTRAINT USING INDEX is not supported on partitioned tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* this should have been checked at parse time */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index \"%s\" is not unique"</literal></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Determine name to assign to constraint.  We require a constraint to
	 * have the same name as the underlying index; therefore, use the index's
	 * existing name as the default constraint name, and if the user
	 * explicitly gives some other name for the constraint, rename the index
	 * to match.
	 */</comment>
	<expr_stmt><expr><name>constraintName</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>idxname</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>constraintName</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>constraintName</name> <operator>=</operator> <name>indexName</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index \"%s\" to \"%s\""</literal></expr></argument>,
						<argument><expr><name>indexName</name></expr></argument>, <argument><expr><name>constraintName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>, <argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Extra checks needed if making primary key */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_check_primary_key</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Note we currently don't support EXCLUSION constraints here */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>constraintType</name> <operator>=</operator> <name>CONSTRAINT_PRIMARY</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>constraintType</name> <operator>=</operator> <name>CONSTRAINT_UNIQUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Create the catalog entries for the constraint */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>INDEX_CONSTR_CREATE_UPDATE_INDEX</name> <operator>|</operator>
		<name>INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS</name> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>initdeferred</name></name></expr> ?</condition><then> <expr><name>INDEX_CONSTR_CREATE_INIT_DEFERRED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>deferrable</name></name></expr> ?</condition><then> <expr><name>INDEX_CONSTR_CREATE_DEFERRABLE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
		<operator>(</operator><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>primary</name></name></expr> ?</condition><then> <expr><name>INDEX_CONSTR_CREATE_MARK_AS_PRIMARY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>index_constraint_create</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
									  <argument><expr><name>index_oid</name></expr></argument>,
									  <argument><expr><name>InvalidOid</name></expr></argument>,
									  <argument><expr><name>indexInfo</name></expr></argument>,
									  <argument><expr><name>constraintName</name></expr></argument>,
									  <argument><expr><name>constraintType</name></expr></argument>,
									  <argument><expr><name>flags</name></expr></argument>,
									  <argument><expr><name>allowSystemTableMods</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* is_internal */</comment>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ADD CONSTRAINT
 *
 * Return value is the address of the new constraint; if no constraint was
 * added, InvalidObjectAddress is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					<parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>newConstraint</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_readd</name></decl></parameter>,
					<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>newConstraint</name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Currently, we only expect to see CONSTR_CHECK and CONSTR_FOREIGN nodes
	 * arriving here (see the preprocessing done in parse_utilcmd.c).  Use a
	 * switch anyway to make it easier to add more code later.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>newConstraint</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
			<expr_stmt><expr><name>address</name> <operator>=</operator>
				<call><name>ATAddCheckConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
									 <argument><expr><name>newConstraint</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>is_readd</name></expr></argument>,
									 <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>

			<comment type="block">/*
			 * Assign or validate constraint name
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>newConstraint</name><operator>-&gt;</operator><name>conname</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>ConstraintNameIsUsed</name><argument_list>(<argument><expr><name>CONSTRAINT_RELATION</name></expr></argument>,
										 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name><name>newConstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" for relation \"%s\" already exists"</literal></expr></argument>,
									<argument><expr><name><name>newConstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>newConstraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator>
					<call><name>ChooseConstraintName</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>ChooseForeignKeyConstraintNameAddition</name><argument_list>(<argument><expr><name><name>newConstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><literal type="string">"fkey"</literal></expr></argument>,
										 <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>ATAddForeignKeyConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
												<argument><expr><name>newConstraint</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
												<argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>newConstraint</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"ADD CONSTRAINT"</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate the column-name portion of the constraint name for a new foreign
 * key given the list of column names that reference the referenced
 * table.  This will be passed to ChooseConstraintName along with the parent
 * table name and the "fkey" suffix.
 *
 * We know that less than NAMEDATALEN characters will actually be used, so we
 * can truncate the result once we've generated that many.
 *
 * XXX see also ChooseExtendedStatisticNameAddition and
 * ChooseIndexNameAddition.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ChooseForeignKeyConstraintNameAddition</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colnames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>NAMEDATALEN</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>buflen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>colnames</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>buflen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* insert _ between names */</comment>

		<comment type="block">/*
		 * At this point we have buflen &lt;= NAMEDATALEN.  name should be less
		 * than NAMEDATALEN already, but use strlcpy for paranoia.
		 */</comment>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>buflen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buflen</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a check constraint to a single table and its children.  Returns the
 * address of the constraint added to the parent relation, if one gets added,
 * or InvalidObjectAddress otherwise.
 *
 * Subroutine for ATExecAddConstraint.
 *
 * We must recurse to child tables during execution, rather than using
 * ALTER TABLE's normal prep-time recursion.  The reason is that all the
 * constraints *must* be given the same name, else they won't be seen as
 * related later.  If the user didn't explicitly specify a name, then
 * AddRelationNewConstraints would normally assign different names to the
 * child constraints.  To fix that, we must capture the name assigned at
 * the parent table and pass that down.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATAddCheckConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					 <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>is_readd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newcons</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcon</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* At top level, permission check was done in ATPrepCmd, else do it */</comment>
	<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Call AddRelationNewConstraints to do the work, making sure it works on
	 * a copy of the Constraint so transformExpr can't modify the original. It
	 * returns a list of cooked constraints.
	 *
	 * If the constraint ends up getting merged with a pre-existing one, it's
	 * omitted from the returned list, which is what we want: we do not need
	 * to do any validation work.  That can only happen at child tables,
	 * though, since we disallow merging at the top level.
	 */</comment>
	<expr_stmt><expr><name>newcons</name> <operator>=</operator> <call><name>AddRelationNewConstraints</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>constr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>recursing</name> <operator>|</operator> <name>is_readd</name></expr></argument>,	<comment type="block">/* allow_merge */</comment>
										<argument><expr><operator>!</operator><name>recursing</name></expr></argument>, <comment type="block">/* is_local */</comment>
										<argument><expr><name>is_readd</name></expr></argument>,	<comment type="block">/* is_internal */</comment>
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* queryString not available
												 * here */</comment>

	<comment type="block">/* we don't expect more than one constraint here */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>newcons</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add each to-be-validated constraint to Phase 3's queue */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lcon</argument>, <argument>newcons</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>ccon</name> <init>= <expr><operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcon</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ccon</name><operator>-&gt;</operator><name>skip_validation</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>newcon</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newcon</name> <operator>=</operator> <operator>(</operator><name>NewConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>ccon</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name><name>ccon</name><operator>-&gt;</operator><name>contype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name><name>ccon</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>newcon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Save the actually assigned name if it was defaulted */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <name><name>ccon</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name><name>ccon</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* At this point we must have a locked-down name to use */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>conname</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Advance command counter in case same table is visited multiple times */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the constraint got merged with an existing constraint, we're done.
	 * We mustn't recurse to child tables in this case, because they've
	 * already got the constraint, and visiting them again would lead to an
	 * incorrect value for coninhcount.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newcons</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>address</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If adding a NO INHERIT constraint, no need to find our children.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>is_no_inherit</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>address</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Propagate to children as appropriate.  Unlike most other ALTER
	 * routines, we have to do this one level of recursion at a time; we can't
	 * use find_all_inheritors to do it in one pass.
	 */</comment>
	<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are told not to recurse, there had better not be any child tables;
	 * else the addition would put them out of step.
	 * Check if ONLY was specified with ALTER TABLE.  If so, allow the
	 * constraint creation only if there are no children currently.  Error out
	 * otherwise.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name>children</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint must be added to child tables too"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>childtab</name></decl>;</decl_stmt>

		<comment type="block">/* find_inheritance_children already got lock */</comment>
		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Find or create work queue entry for this table */</comment>
		<expr_stmt><expr><name>childtab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Recurse to child */</comment>
		<expr_stmt><expr><call><name>ATAddCheckConstraint</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childtab</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>,
							 <argument><expr><name>constr</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>is_readd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a foreign-key constraint to a single table; return the new constraint's
 * address.
 *
 * Subroutine for ATExecAddConstraint.  Must already hold exclusive
 * lock on the rel, and have done appropriate validity checks for it.
 * We do permissions checks here, however.
 *
 * When the referenced or referencing tables (or both) are partitioned,
 * multiple pg_constraint rows are required -- one for each partitioned table
 * and each partition on each side (fortunately, not one for every combination
 * thereof).  We also need action triggers on each leaf partition on the
 * referenced side, and check triggers on each leaf partition on the
 * referencing side.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATAddForeignKeyConstraint</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentConstr</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pkrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name><name>pkattnum</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name><name>fkattnum</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>pktypoid</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>fktypoid</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>opclasses</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>pfeqoperators</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>ppeqoperators</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>ffeqoperators</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numfks</name></decl>,
				<decl><type ref="prev"/><name>numpks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>old_check_ok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>old_pfeqop_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_conpfeqop</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Grab ShareRowExclusiveLock on the pk table, so that someone doesn't
	 * delete rows out from under us.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_pktable_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pkrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_pktable_oid</name></name></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>pkrel</name> <operator>=</operator> <call><name>table_openrv</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>pktable</name></name></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * GPDB: Schema-qualify the primary key table for the statement dispatch
	 * that will happen later. The QE nodes are not guaranteed to have the
	 * same search_path as the QD (e.g. CREATE SCHEMA command with schema
	 * elements creating relations).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>pktable</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator>
			<call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Validity checks (permission checks wait till we have the column
	 * numbers)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use ONLY for foreign key on partitioned table \"%s\" referencing relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fkconstraint</name><operator>-&gt;</operator><name>initially_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add NOT VALID foreign key on partitioned table \"%s\" referencing relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This feature is not yet supported on partitioned tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"referenced relation \"%s\" is not a table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * References from permanent or unlogged tables to temp tables, and from
	 * permanent tables to unlogged tables, are disallowed because the
	 * referenced data can vanish out from under us.  References from temp
	 * tables to any other table type are also disallowed, because other
	 * backends might need to run the RI triggers on the perm table, but they
	 * can't reliably see tuples in the local buffers of other backends.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELPERSISTENCE_PERMANENT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraints on permanent tables may reference only permanent tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELPERSISTENCE_UNLOGGED</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_PERMANENT</name>
				<operator>&amp;&amp;</operator> <name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraints on unlogged tables may reference only permanent or unlogged tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELPERSISTENCE_TEMP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraints on temporary tables may reference only temporary tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pkrel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name> <operator>||</operator> <operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraints on temporary tables must involve temporary tables of this session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Look up the referencing attributes to make sure they exist, and record
	 * their attnums and type OIDs.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>pkattnum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pkattnum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>fkattnum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fkattnum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>pktypoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pktypoid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>fktypoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fktypoid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>opclasses</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>opclasses</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>pfeqoperators</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pfeqoperators</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ppeqoperators</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ppeqoperators</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ffeqoperators</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ffeqoperators</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numfks</name> <operator>=</operator> <call><name>transformColumnNameList</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>,
									 <argument><expr><name>fkattnum</name></expr></argument>, <argument><expr><name>fktypoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the attribute list for the referenced table was omitted, lookup the
	 * definition of the primary key and use it.  Otherwise, validate the
	 * supplied attribute list.  In either case, discover the index OID and
	 * index opclasses, and the attnums and type OIDs of the attributes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>pk_attrs</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>numpks</name> <operator>=</operator> <call><name>transformFkeyGetPrimaryKey</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexOid</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>fkconstraint</name><operator>-&gt;</operator><name>pk_attrs</name></name></expr></argument>,
											<argument><expr><name>pkattnum</name></expr></argument>, <argument><expr><name>pktypoid</name></expr></argument>,
											<argument><expr><name>opclasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>numpks</name> <operator>=</operator> <call><name>transformColumnNameList</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>pk_attrs</name></name></expr></argument>,
										 <argument><expr><name>pkattnum</name></expr></argument>, <argument><expr><name>pktypoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Look for an index matching the column list */</comment>
		<expr_stmt><expr><name>indexOid</name> <operator>=</operator> <call><name>transformFkeyCheckAttrs</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>numpks</name></expr></argument>, <argument><expr><name>pkattnum</name></expr></argument>,
										   <argument><expr><name>opclasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Now we can check permissions.
	 */</comment>
	<expr_stmt><expr><call><name>checkFkeyPermissions</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>pkattnum</name></expr></argument>, <argument><expr><name>numpks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check some things for generated columns.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>attgenerated</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fkattnum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attgenerated</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attgenerated</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Check restrictions on UPDATE/DELETE actions, per SQL standard
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_SETNULL</name> <operator>||</operator>
				<name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_SETDEFAULT</name> <operator>||</operator>
				<name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_CASCADE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid %s action for foreign key constraint containing generated column"</literal></expr></argument>,
								<argument><expr><literal type="string">"ON UPDATE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_SETNULL</name> <operator>||</operator>
				<name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_SETDEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid %s action for foreign key constraint containing generated column"</literal></expr></argument>,
								<argument><expr><literal type="string">"ON DELETE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Look up the equality operators to use in the constraint.
	 *
	 * Note that we have to be careful about the difference between the actual
	 * PK column type and the opclass' declared input type, which might be
	 * only binary-compatible with it.  The declared opcintype is the right
	 * thing to probe pg_amop with.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numfks</name> <operator>!=</operator> <name>numpks</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FOREIGN_KEY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of referencing and referenced columns for foreign key disagree"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On the strength of a previous constraint, we might avoid scanning
	 * tables to validate this one.  See below.
	 */</comment>
	<expr_stmt><expr><name>old_check_ok</name> <operator>=</operator> <operator>(</operator><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_conpfeqop</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>old_check_ok</name> <operator>||</operator> <name>numfks</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>old_conpfeqop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numpks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pktype</name> <init>= <expr><name><name>pktypoid</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>fktype</name> <init>= <expr><name><name>fktypoid</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>fktyped</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>cla_ht</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>cla_tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>amid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opcintype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pfeqop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ppeqop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ffeqop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>eqstrategy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pfeqop_right</name></decl>;</decl_stmt>

		<comment type="block">/* We need several fields out of the pg_opclass entry */</comment>
		<expr_stmt><expr><name>cla_ht</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>cla_ht</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>cla_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>cla_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>amid</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcmethod</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcfamily</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>opcintype</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcintype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>cla_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check it's a btree; currently this can never fail since no other
		 * index AMs support unique indexes.  If we ever did have other types
		 * of unique indexes, we'd need a way to determine which operator
		 * strategy number is equality.  (Is it reasonable to insist that
		 * every such index AM use btree's number for equality?)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>amid</name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only b-tree indexes are supported for foreign keys"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>eqstrategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * There had better be a primary equality operator for the index.
		 * We'll use it for PK = PK comparisons.
		 */</comment>
		<expr_stmt><expr><name>ppeqop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>,
									 <argument><expr><name>eqstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ppeqop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
				 <argument><expr><name>eqstrategy</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Are there equality operators that take exactly the FK type? Assume
		 * we should look through any domain here.
		 */</comment>
		<expr_stmt><expr><name>fktyped</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>fktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pfeqop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>fktyped</name></expr></argument>,
									 <argument><expr><name>eqstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pfeqop</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pfeqop_right</name> <operator>=</operator> <name>fktyped</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ffeqop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>fktyped</name></expr></argument>, <argument><expr><name>fktyped</name></expr></argument>,
										 <argument><expr><name>eqstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* keep compiler quiet */</comment>
			<expr_stmt><expr><name>pfeqop_right</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ffeqop</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pfeqop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>ffeqop</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Otherwise, look for an implicit cast from the FK type to the
			 * opcintype, and if found, use the primary equality operator.
			 * This is a bit tricky because opcintype might be a polymorphic
			 * type such as ANYARRAY or ANYENUM; so what we have to test is
			 * whether the two actual column types can be concurrently cast to
			 * that type.  (Otherwise, we'd fail to reject combinations such
			 * as int[] and point[].)
			 */</comment>
			<decl_stmt><decl><type><name>Oid</name></type>			<name><name>input_typeids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name><name>target_typeids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>input_typeids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pktype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>input_typeids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>fktype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>target_typeids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>target_typeids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>input_typeids</name></expr></argument>, <argument><expr><name>target_typeids</name></expr></argument>,
								<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>pfeqop</name> <operator>=</operator> <name>ffeqop</name> <operator>=</operator> <name>ppeqop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pfeqop_right</name> <operator>=</operator> <name>opcintype</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pfeqop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>ffeqop</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key constraint \"%s\" cannot be implemented"</literal></expr></argument>,
							<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key columns \"%s\" and \"%s\" "</literal>
							   <literal type="string">"are of incompatible types: %s and %s."</literal></expr></argument>,
							   <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>pk_attrs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>fktype</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>pktype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>old_check_ok</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When a pfeqop changes, revalidate the constraint.  We could
			 * permit intra-opfamily changes, but that adds subtle complexity
			 * without any concrete benefit for core types.  We need not
			 * assess ppeqop or ffeqop, which RI_Initial_Check() does not use.
			 */</comment>
			<expr_stmt><expr><name>old_check_ok</name> <operator>=</operator> <operator>(</operator><name>pfeqop</name> <operator>==</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>old_pfeqop_item</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_pfeqop_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>old_pfeqop_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>old_check_ok</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>old_fktype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>new_fktype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>old_pathtype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>new_pathtype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>old_castfunc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>new_castfunc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name></name></expr></argument>,
												   <argument><expr><name><name>fkattnum</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Identify coercion pathways from each of the old and new FK-side
			 * column types to the right (foreign) operand type of the pfeqop.
			 * We may assume that pg_constraint.conkey is not changing.
			 */</comment>
			<expr_stmt><expr><name>old_fktype</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_fktype</name> <operator>=</operator> <name>fktype</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>old_pathtype</name> <operator>=</operator> <call><name>findFkeyCast</name><argument_list>(<argument><expr><name>pfeqop_right</name></expr></argument>, <argument><expr><name>old_fktype</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>old_castfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_pathtype</name> <operator>=</operator> <call><name>findFkeyCast</name><argument_list>(<argument><expr><name>pfeqop_right</name></expr></argument>, <argument><expr><name>new_fktype</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>new_castfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Upon a change to the cast from the FK column to its pfeqop
			 * operand, revalidate the constraint.  For this evaluation, a
			 * binary coercion cast is equivalent to no cast at all.  While
			 * type implementors should design implicit casts with an eye
			 * toward consistency of operations like equality, we cannot
			 * assume here that they have done so.
			 *
			 * A function with a polymorphic argument could change behavior
			 * arbitrarily in response to get_fn_expr_argtype().  Therefore,
			 * when the cast destination is polymorphic, we only avoid
			 * revalidation if the input type has not changed at all.  Given
			 * just the core data types and operator classes, this requirement
			 * prevents no would-be optimizations.
			 *
			 * If the cast converts from a base type to a domain thereon, then
			 * that domain type must be the opcintype of the unique index.
			 * Necessarily, the primary key column must then be of the domain
			 * type.  Since the constraint was previously valid, all values on
			 * the foreign side necessarily exist on the primary side and in
			 * turn conform to the domain.  Consequently, we need not treat
			 * domains specially here.
			 *
			 * Since we require that all collations share the same notion of
			 * equality (which they do, because texteq reduces to bitwise
			 * equality), we don't compare collation here.
			 *
			 * We need not directly consider the PK type.  It's necessarily
			 * binary coercible to the opcintype of the unique index column,
			 * and ri_triggers.c will only deal with PK datums in terms of
			 * that opcintype.  Changing the opcintype also changes pfeqop.
			 */</comment>
			<expr_stmt><expr><name>old_check_ok</name> <operator>=</operator> <operator>(</operator><name>new_pathtype</name> <operator>==</operator> <name>old_pathtype</name> <operator>&amp;&amp;</operator>
							<name>new_castfunc</name> <operator>==</operator> <name>old_castfunc</name> <operator>&amp;&amp;</operator>
							<operator>(</operator><operator>!</operator><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>pfeqop_right</name></expr></argument>)</argument_list></call> <operator>||</operator>
							 <name>new_fktype</name> <operator>==</operator> <name>old_fktype</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>pfeqoperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pfeqop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ppeqoperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ppeqop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ffeqoperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ffeqop</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Create all the constraint and trigger objects, recursing to partitions
	 * as necessary.  First handle the referenced side.
	 */</comment>
	<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>addFkRecurseReferenced</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pkrel</name></expr></argument>,
									 <argument><expr><name>indexOid</name></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no parent constraint */</comment>
									 <argument><expr><name>numfks</name></expr></argument>,
									 <argument><expr><name>pkattnum</name></expr></argument>,
									 <argument><expr><name>fkattnum</name></expr></argument>,
									 <argument><expr><name>pfeqoperators</name></expr></argument>,
									 <argument><expr><name>ppeqoperators</name></expr></argument>,
									 <argument><expr><name>ffeqoperators</name></expr></argument>,
									 <argument><expr><name>old_check_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now handle the referencing side. */</comment>
	<expr_stmt><expr><call><name>addFkRecurseReferencing</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pkrel</name></expr></argument>,
							<argument><expr><name>indexOid</name></expr></argument>,
							<argument><expr><name><name>address</name><operator>.</operator><name>objectId</name></name></expr></argument>,
							<argument><expr><name>numfks</name></expr></argument>,
							<argument><expr><name>pkattnum</name></expr></argument>,
							<argument><expr><name>fkattnum</name></expr></argument>,
							<argument><expr><name>pfeqoperators</name></expr></argument>,
							<argument><expr><name>ppeqoperators</name></expr></argument>,
							<argument><expr><name>ffeqoperators</name></expr></argument>,
							<argument><expr><name>old_check_ok</name></expr></argument>,
							<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Done.  Close pk table, but keep lock until we've committed.
	 */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * addFkRecurseReferenced
 *		subroutine for ATAddForeignKeyConstraint; recurses on the referenced
 *		side of the constraint
 *
 * Create pg_constraint rows for the referenced side of the constraint,
 * referencing the parent of the referencing side; also create action triggers
 * on leaf partitions.  If the table is partitioned, recurse to handle each
 * partition.
 *
 * wqueue is the ALTER TABLE work queue; can be NULL when not running as part
 * of an ALTER TABLE sequence.
 * fkconstraint is the constraint being added.
 * rel is the root referencing relation.
 * pkrel is the referenced relation; might be a partition, if recursing.
 * indexOid is the OID of the index (on pkrel) implementing this constraint.
 * parentConstr is the OID of a parent constraint; InvalidOid if this is a
 * top-level constraint.
 * numfks is the number of columns in the foreign key
 * pkattnum is the attnum array of referenced attributes.
 * fkattnum is the attnum array of referencing attributes.
 * pf/pp/ffeqoperators are OID array of operators between columns.
 * old_check_ok signals that this constraint replaces an existing one that
 * was already validated (thus this one doesn't need validation).
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>addFkRecurseReferenced</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					   <parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentConstr</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>numfks</name></decl></parameter>,
					   <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>pkattnum</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>fkattnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>pfeqoperators</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ppeqoperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ffeqoperators</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>old_check_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>constrOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>conname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>conislocal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>coninhcount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>connoinherit</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Verify relkind for each referenced partition.  At the top level, this
	 * is redundant with a previous check, but we need it when recursing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"referenced relation \"%s\" is not a table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Caller supplies us with a constraint name; however, it may be used in
	 * this partition, so come up with a different one in that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ConstraintNameIsUsed</name><argument_list>(<argument><expr><name>CONSTRAINT_RELATION</name></expr></argument>,
							 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>conname</name> <operator>=</operator> <call><name>ChooseConstraintName</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>ChooseForeignKeyConstraintNameAddition</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><literal type="string">"fkey"</literal></expr></argument>,
									   <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>conname</name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentConstr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>conislocal</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>coninhcount</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>connoinherit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>conislocal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>coninhcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * always inherit for partitioned tables, never for legacy inheritance
		 */</comment>
		<expr_stmt><expr><name>connoinherit</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Record the FK constraint in pg_constraint.
	 */</comment>
	<expr_stmt><expr><name>constrOid</name> <operator>=</operator> <call><name>CreateConstraintEntry</name><argument_list>(<argument><expr><name>conname</name></expr></argument>,
									  <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>CONSTRAINT_FOREIGN</name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initially_valid</name></name></expr></argument>,
									  <argument><expr><name>parentConstr</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>fkattnum</name></expr></argument>,
									  <argument><expr><name>numfks</name></expr></argument>,
									  <argument><expr><name>numfks</name></expr></argument>,
									  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* not a domain constraint */</comment>
									  <argument><expr><name>indexOid</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>pkattnum</name></expr></argument>,
									  <argument><expr><name>pfeqoperators</name></expr></argument>,
									  <argument><expr><name>ppeqoperators</name></expr></argument>,
									  <argument><expr><name>ffeqoperators</name></expr></argument>,
									  <argument><expr><name>numfks</name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_matchtype</name></name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* no exclusion constraint */</comment>
									  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* no check constraint */</comment>
									  <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>conislocal</name></expr></argument>,	<comment type="block">/* islocal */</comment>
									  <argument><expr><name>coninhcount</name></expr></argument>,	<comment type="block">/* inhcount */</comment>
									  <argument><expr><name>connoinherit</name></expr></argument>, <comment type="block">/* conNoInherit */</comment>
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* is_internal */</comment>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the child constraint as part of the parent constraint; it must not
	 * be dropped on its own.  (This constraint is deleted when the partition
	 * is detached, but a special check needs to occur that the partition
	 * contains no referenced values.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentConstr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>referenced</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>referenced</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>parentConstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* make new constraint visible, in case we add more */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the referenced table is a plain relation, create the action triggers
	 * that enforce the constraint.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>createForeignKeyActionTriggers</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>fkconstraint</name></expr></argument>,
									   <argument><expr><name>constrOid</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the referenced table is partitioned, recurse on ourselves to handle
	 * each partition.  We need one pg_constraint row created for each
	 * partition in addition to the pg_constraint row for the parent table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>pd</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pd</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>partRel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>mapped_pkattnum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>partIndexId</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>partRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Map the attribute numbers in the referenced side of the FK
			 * definition to match the partition's column layout.
			 */</comment>
			<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>convert_tuples_by_name_map_if_req</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>mapped_pkattnum</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numfks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numfks</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>mapped_pkattnum</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>map</name><index>[<expr><name><name>pkattnum</name><index>[<expr><name>j</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>mapped_pkattnum</name> <operator>=</operator> <name>pkattnum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* do the deed */</comment>
			<expr_stmt><expr><name>partIndexId</name> <operator>=</operator> <call><name>index_get_partition</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partIndexId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index for %u not found in partition %s"</literal></expr></argument>,
					 <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>addFkRecurseReferenced</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>partRel</name></expr></argument>,
								   <argument><expr><name>partIndexId</name></expr></argument>, <argument><expr><name>constrOid</name></expr></argument>, <argument><expr><name>numfks</name></expr></argument>,
								   <argument><expr><name>mapped_pkattnum</name></expr></argument>, <argument><expr><name>fkattnum</name></expr></argument>,
								   <argument><expr><name>pfeqoperators</name></expr></argument>, <argument><expr><name>ppeqoperators</name></expr></argument>, <argument><expr><name>ffeqoperators</name></expr></argument>,
								   <argument><expr><name>old_check_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Done -- clean up (but keep the lock) */</comment>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mapped_pkattnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * addFkRecurseReferencing
 *		subroutine for ATAddForeignKeyConstraint and CloneFkReferencing
 *
 * If the referencing relation is a plain relation, create the necessary check
 * triggers that implement the constraint, and set up for Phase 3 constraint
 * verification.  If the referencing relation is a partitioned table, then
 * we create a pg_constraint row for it and recurse on this routine for each
 * partition.
 *
 * We assume that the referenced relation is locked against concurrent
 * deletions.  If it's a partitioned relation, every partition must be so
 * locked.
 *
 * wqueue is the ALTER TABLE work queue; can be NULL when not running as part
 * of an ALTER TABLE sequence.
 * fkconstraint is the constraint being added.
 * rel is the referencing relation; might be a partition, if recursing.
 * pkrel is the root referenced relation.
 * indexOid is the OID of the index (on pkrel) implementing this constraint.
 * parentConstr is the OID of the parent constraint (there is always one).
 * numfks is the number of columns in the foreign key
 * pkattnum is the attnum array of referenced attributes.
 * fkattnum is the attnum array of referencing attributes.
 * pf/pp/ffeqoperators are OID array of operators between columns.
 * old_check_ok signals that this constraint replaces an existing one that
 *		was already validated (thus this one doesn't need validation).
 * lockmode is the lockmode to acquire on partitions when recursing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addFkRecurseReferencing</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						<parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentConstr</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>numfks</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>pkattnum</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>fkattnum</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>pfeqoperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ppeqoperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ffeqoperators</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>old_check_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentConstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the referencing relation is a plain table, add the check triggers to
	 * it and, if necessary, schedule it to be checked in Phase 3.
	 *
	 * If the relation is partitioned, drill down to do it to its partitions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>createForeignKeyCheckTriggers</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>fkconstraint</name></expr></argument>,
									  <argument><expr><name>parentConstr</name></expr></argument>,
									  <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Tell Phase 3 to check that the constraint is satisfied by existing
		 * rows. We can skip this during table creation, when requested
		 * explicitly by specifying NOT VALID in an ADD FOREIGN KEY command,
		 * and when we're recreating a constraint following a SET DATA TYPE
		 * operation that did not impugn its validity.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>wqueue</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>old_check_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fkconstraint</name><operator>-&gt;</operator><name>skip_validation</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>newcon</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>newcon</name> <operator>=</operator> <operator>(</operator><name>NewConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>get_constraint_name</name><argument_list>(<argument><expr><name>parentConstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_FOREIGN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refrelid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>refindid</name></name> <operator>=</operator> <name>indexOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>conid</name></name> <operator>=</operator> <name>parentConstr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcon</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fkconstraint</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>newcon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>pd</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Recurse to take appropriate action on each partition; either we
		 * find an existing constraint to reparent to ours, or we create a new
		 * one.
		 */</comment>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pd</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>partitionId</name> <init>= <expr><name><name>pd</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>partition</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>partitionId</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partFKs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name><name>mapped_fkattnum</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>attached</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>conname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>constrOid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>,
						<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>partition</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numfks</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>mapped_fkattnum</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>attmap</name><index>[<expr><name><name>fkattnum</name><index>[<expr><name>j</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

			<comment type="block">/* Check whether an existing constraint can be repurposed */</comment>
			<expr_stmt><expr><name>partFKs</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>RelationGetFKeyList</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attached</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>partFKs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>fk</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>fk</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>ForeignKeyCacheInfo</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>tryAttachPartitionForeignKey</name><argument_list>(<argument><expr><name>fk</name></expr></argument>,
												 <argument><expr><name>partitionId</name></expr></argument>,
												 <argument><expr><name>parentConstr</name></expr></argument>,
												 <argument><expr><name>numfks</name></expr></argument>,
												 <argument><expr><name>mapped_fkattnum</name></expr></argument>,
												 <argument><expr><name>pkattnum</name></expr></argument>,
												 <argument><expr><name>pfeqoperators</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>attached</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>attached</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>partition</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * No luck finding a good constraint to reuse; create our own.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ConstraintNameIsUsed</name><argument_list>(<argument><expr><name>CONSTRAINT_RELATION</name></expr></argument>,
									 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>conname</name> <operator>=</operator> <call><name>ChooseConstraintName</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><call><name>ChooseForeignKeyConstraintNameAddition</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><literal type="string">"fkey"</literal></expr></argument>,
											   <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>conname</name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>constrOid</name> <operator>=</operator>
				<call><name>CreateConstraintEntry</name><argument_list>(<argument><expr><name>conname</name></expr></argument>,
									  <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>CONSTRAINT_FOREIGN</name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initially_valid</name></name></expr></argument>,
									  <argument><expr><name>parentConstr</name></expr></argument>,
									  <argument><expr><name>partitionId</name></expr></argument>,
									  <argument><expr><name>mapped_fkattnum</name></expr></argument>,
									  <argument><expr><name>numfks</name></expr></argument>,
									  <argument><expr><name>numfks</name></expr></argument>,
									  <argument><expr><name>InvalidOid</name></expr></argument>,
									  <argument><expr><name>indexOid</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>pkattnum</name></expr></argument>,
									  <argument><expr><name>pfeqoperators</name></expr></argument>,
									  <argument><expr><name>ppeqoperators</name></expr></argument>,
									  <argument><expr><name>ffeqoperators</name></expr></argument>,
									  <argument><expr><name>numfks</name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name></expr></argument>,
									  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_matchtype</name></name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Give this constraint partition-type dependencies on the parent
			 * constraint as well as the table.
			 */</comment>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>referenced</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>parentConstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_PARTITION_PRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>referenced</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_PARTITION_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Make all this visible before recursing */</comment>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* call ourselves to finalize the creation and we're done */</comment>
			<expr_stmt><expr><call><name>addFkRecurseReferencing</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name>partition</name></expr></argument>, <argument><expr><name>pkrel</name></expr></argument>,
									<argument><expr><name>indexOid</name></expr></argument>,
									<argument><expr><name>constrOid</name></expr></argument>,
									<argument><expr><name>numfks</name></expr></argument>,
									<argument><expr><name>pkattnum</name></expr></argument>,
									<argument><expr><name>mapped_fkattnum</name></expr></argument>,
									<argument><expr><name>pfeqoperators</name></expr></argument>,
									<argument><expr><name>ppeqoperators</name></expr></argument>,
									<argument><expr><name>ffeqoperators</name></expr></argument>,
									<argument><expr><name>old_check_ok</name></expr></argument>,
									<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>partition</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CloneForeignKeyConstraints
 *		Clone foreign keys from a partitioned table to a newly acquired
 *		partition.
 *
 * partitionRel is a partition of parentRel, so we can be certain that it has
 * the same columns with the same datatypes.  The columns may be in different
 * order, though.
 *
 * wqueue must be passed to set up phase 3 constraint checking, unless the
 * referencing-side partition is known to be empty (such as in CREATE TABLE /
 * PARTITION OF).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CloneForeignKeyConstraints</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentRel</name></decl></parameter>,
						   <parameter><decl><type><name>Relation</name></type> <name>partitionRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* This only works for declarative partitioning */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parentRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clone constraints for which the parent is on the referenced side.
	 */</comment>
	<expr_stmt><expr><call><name>CloneFkReferenced</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>, <argument><expr><name>partitionRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now clone constraints where the parent is on the referencing side.
	 */</comment>
	<expr_stmt><expr><call><name>CloneFkReferencing</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>parentRel</name></expr></argument>, <argument><expr><name>partitionRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CloneFkReferenced
 *		Subroutine for CloneForeignKeyConstraints
 *
 * Find all the FKs that have the parent relation on the referenced side;
 * clone those constraints to the given partition.  This is to be called
 * when the partition is being created or attached.
 *
 * This recurses to partitions, if the relation being attached is partitioned.
 * Recursion is done by calling addFkRecurseReferenced.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CloneFkReferenced</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parentRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partitionRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_constraint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clone</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Search for any constraints where this partition is in the referenced
	 * side.  However, we must ignore any constraint whose parent constraint
	 * is also going to be cloned, to avoid duplicates.  So do it in two
	 * steps: first construct the list of constraints to clone, then go over
	 * that list cloning those whose parents are not in the list.  (We must
	 * not rely on the parent being seen first, since the catalog scan could
	 * return children first.)
	 */</comment>
	<expr_stmt><expr><name>pg_constraint</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_confrelid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_contype</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_CHAREQ</name></expr></argument>, <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>CONSTRAINT_FOREIGN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* This is a seqscan, as we don't have a usable index ... */</comment>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constrForm</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Only try to clone the top-level constraint; skip child ones. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>constrForm</name><operator>-&gt;</operator><name>conparentid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>clone</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partitionRel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>clone</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constrOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constrForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>fkRel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>partIndexId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numfks</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name><name>conkey</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name><name>mapped_confkey</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name><name>confkey</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>conpfeqop</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>conppeqop</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>conffeqop</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>constrForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Because we're only expanding the key space at the referenced side,
		 * we don't need to prevent any operation in the referencing table, so
		 * AccessShareLock suffices (assumes that dropping the constraint
		 * acquires AEL).
		 */</comment>
		<expr_stmt><expr><name>fkRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>indexOid</name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>conindid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DeconstructFkConstraintRow</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>numfks</name></expr></argument>,
								   <argument><expr><name>conkey</name></expr></argument>,
								   <argument><expr><name>confkey</name></expr></argument>,
								   <argument><expr><name>conpfeqop</name></expr></argument>,
								   <argument><expr><name>conppeqop</name></expr></argument>,
								   <argument><expr><name>conffeqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>mapped_confkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>attmap</name><index>[<expr><name><name>confkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><name>fkconstraint</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* for now this is all we need */</comment>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>confupdtype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>confdeltype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>condeferrable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>condeferred</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initially_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_matchtype</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>confmatchtype</name></name></expr>;</expr_stmt>

		<comment type="block">/* set up colnames that are used to generate the constraint name */</comment>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>fkRel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name><name>conkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>,
											 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Add the new foreign key constraint pointing to the new partition.
		 * Because this new partition appears in the referenced side of the
		 * constraint, we don't need to set up for Phase 3 check.
		 */</comment>
		<expr_stmt><expr><name>partIndexId</name> <operator>=</operator> <call><name>index_get_partition</name><argument_list>(<argument><expr><name>partitionRel</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partIndexId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index for %u not found in partition %s"</literal></expr></argument>,
				 <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partitionRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>addFkRecurseReferenced</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>fkconstraint</name></expr></argument>,
							   <argument><expr><name>fkRel</name></expr></argument>,
							   <argument><expr><name>partitionRel</name></expr></argument>,
							   <argument><expr><name>partIndexId</name></expr></argument>,
							   <argument><expr><name>constrOid</name></expr></argument>,
							   <argument><expr><name>numfks</name></expr></argument>,
							   <argument><expr><name>mapped_confkey</name></expr></argument>,
							   <argument><expr><name>conkey</name></expr></argument>,
							   <argument><expr><name>conpfeqop</name></expr></argument>,
							   <argument><expr><name>conppeqop</name></expr></argument>,
							   <argument><expr><name>conffeqop</name></expr></argument>,
							   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>fkRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * CloneFkReferencing
 *		Subroutine for CloneForeignKeyConstraints
 *
 * For each FK constraint of the parent relation in the given list, find an
 * equivalent constraint in its partition relation that can be reparented;
 * if one cannot be found, create a new constraint in the partition as its
 * child.
 *
 * If wqueue is given, it is used to set up phase-3 verification for each
 * cloned constraint; if omitted, we assume that such verification is not
 * needed (example: the partition is being created anew).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CloneFkReferencing</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partFKs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clone</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/* obtain a list of constraints that we need to clone */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>RelationGetFKeyList(parentRel)</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>fk</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>clone</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Silently do nothing if there's nothing to do.  In particular, this
	 * avoids throwing a spurious error for foreign tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>clone</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>partRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The constraint key may differ, if the columns in the partition are
	 * different.  This map is used to convert them.
	 */</comment>
	<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>partFKs</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>RelationGetFKeyList</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>clone</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentConstrOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constrForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>pkrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numfks</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name><name>conkey</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name><name>mapped_conkey</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name><name>confkey</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>conpfeqop</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>conppeqop</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>conffeqop</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>attached</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constrOid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>,
					<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>parentConstrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>,
				 <argument><expr><name>parentConstrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>constrForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Don't clone constraints whose parents are being cloned */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conparentid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Need to prevent concurrent deletions.  If pkrel is a partitioned
		 * relation, that means to lock all partitions.
		 */</comment>
		<expr_stmt><expr><name>pkrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>, <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pkrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>ShareRowExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>DeconstructFkConstraintRow</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numfks</name></expr></argument>, <argument><expr><name>conkey</name></expr></argument>, <argument><expr><name>confkey</name></expr></argument>,
								   <argument><expr><name>conpfeqop</name></expr></argument>, <argument><expr><name>conppeqop</name></expr></argument>, <argument><expr><name>conffeqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>mapped_conkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>attmap</name><index>[<expr><name><name>conkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/*
		 * Before creating a new constraint, see whether any existing FKs are
		 * fit for the purpose.  If one is, attach the parent constraint to
		 * it, and don't clone anything.  This way we avoid the expensive
		 * verification step and don't end up with a duplicate FK, and we
		 * don't need to recurse to partitions for this constraint.
		 */</comment>
		<expr_stmt><expr><name>attached</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>partFKs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>fk</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>ForeignKeyCacheInfo</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>tryAttachPartitionForeignKey</name><argument_list>(<argument><expr><name>fk</name></expr></argument>,
											 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>parentConstrOid</name></expr></argument>,
											 <argument><expr><name>numfks</name></expr></argument>,
											 <argument><expr><name>mapped_conkey</name></expr></argument>,
											 <argument><expr><name>confkey</name></expr></argument>,
											 <argument><expr><name>conpfeqop</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>attached</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>attached</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* No dice.  Set up to create our own constraint */</comment>
		<expr_stmt><expr><name>fkconstraint</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ConstraintNameIsUsed</name><argument_list>(<argument><expr><name>CONSTRAINT_RELATION</name></expr></argument>,
								 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator>
				<call><name>ChooseConstraintName</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>ChooseForeignKeyConstraintNameAddition</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><literal type="string">"fkey"</literal></expr></argument>,
									 <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>confupdtype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>confdeltype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>condeferrable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>condeferred</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_matchtype</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>confmatchtype</name></name></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name><name>mapped_conkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_attrs</name></name></expr></argument>,
											 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>indexOid</name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>conindid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>constrOid</name> <operator>=</operator>
			<call><name>CreateConstraintEntry</name><argument_list>(<argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>,
								  <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>connamespace</name></name></expr></argument>,
								  <argument><expr><name>CONSTRAINT_FOREIGN</name></expr></argument>,
								  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr></argument>,
								  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr></argument>,
								  <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>convalidated</name></name></expr></argument>,
								  <argument><expr><name>parentConstrOid</name></expr></argument>,
								  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>mapped_conkey</name></expr></argument>,
								  <argument><expr><name>numfks</name></expr></argument>,
								  <argument><expr><name>numfks</name></expr></argument>,
								  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* not a domain constraint */</comment>
								  <argument><expr><name>indexOid</name></expr></argument>,
								  <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>,	<comment type="block">/* same foreign rel */</comment>
								  <argument><expr><name>confkey</name></expr></argument>,
								  <argument><expr><name>conpfeqop</name></expr></argument>,
								  <argument><expr><name>conppeqop</name></expr></argument>,
								  <argument><expr><name>conffeqop</name></expr></argument>,
								  <argument><expr><name>numfks</name></expr></argument>,
								  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name></expr></argument>,
								  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name></expr></argument>,
								  <argument><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_matchtype</name></name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* islocal */</comment>
								  <argument><expr><literal type="number">1</literal></expr></argument>,	<comment type="block">/* inhcount */</comment>
								  <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* conNoInherit */</comment>
								  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up partition dependencies for the new constraint */</comment>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>referenced</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>parentConstrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_PARTITION_PRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>referenced</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_PARTITION_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Done with the cloned constraint's tuple */</comment>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make all this visible before recursing */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>addFkRecurseReferencing</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>,
								<argument><expr><name>fkconstraint</name></expr></argument>,
								<argument><expr><name>partRel</name></expr></argument>,
								<argument><expr><name>pkrel</name></expr></argument>,
								<argument><expr><name>indexOid</name></expr></argument>,
								<argument><expr><name>constrOid</name></expr></argument>,
								<argument><expr><name>numfks</name></expr></argument>,
								<argument><expr><name>confkey</name></expr></argument>,
								<argument><expr><name>mapped_conkey</name></expr></argument>,
								<argument><expr><name>conpfeqop</name></expr></argument>,
								<argument><expr><name>conppeqop</name></expr></argument>,
								<argument><expr><name>conffeqop</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>,	<comment type="block">/* no old check exists */</comment>
								<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * When the parent of a partition receives [the referencing side of] a foreign
 * key, we must propagate that foreign key to the partition.  However, the
 * partition might already have an equivalent foreign key; this routine
 * compares the given ForeignKeyCacheInfo (in the partition) to the FK defined
 * by the other parameters.  If they are equivalent, create the link between
 * the two constraints and return true.
 *
 * If the given FK does not match the one defined by rest of the params,
 * return false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tryAttachPartitionForeignKey</name><parameter_list>(<parameter><decl><type><name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>fk</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>partRelid</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>parentConstrOid</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>numfks</name></decl></parameter>,
							 <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>mapped_conkey</name></decl></parameter>,
							 <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>confkey</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>conpfeqop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>parentConstrTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>parentConstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>partcontup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>partConstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>trigrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>trigtup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>parentConstrTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parentConstrOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>parentConstrTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name>parentConstrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>parentConstr</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>parentConstrTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do some quick &amp; easy initial checks.  If any of these fail, we cannot
	 * use this constraint.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fk</name><operator>-&gt;</operator><name>confrelid</name></name> <operator>!=</operator> <name><name>parentConstr</name><operator>-&gt;</operator><name>confrelid</name></name> <operator>||</operator> <name><name>fk</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>!=</operator> <name>numfks</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>parentConstrTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fk</name><operator>-&gt;</operator><name>conkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>mapped_conkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
			<name><name>fk</name><operator>-&gt;</operator><name>confkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>confkey</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator>
			<name><name>fk</name><operator>-&gt;</operator><name>conpfeqop</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>conpfeqop</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>parentConstrTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Looks good so far; do some more extensive checks.  Presumably the check
	 * for 'convalidated' could be dropped, since we don't really care about
	 * that, but let's be careful for now.
	 */</comment>
	<expr_stmt><expr><name>partcontup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>partcontup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>partConstr</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>partcontup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>partConstr</name><operator>-&gt;</operator><name>conparentid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><name><name>partConstr</name><operator>-&gt;</operator><name>convalidated</name></name> <operator>||</operator>
		<name><name>partConstr</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>!=</operator> <name><name>parentConstr</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>||</operator>
		<name><name>partConstr</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>!=</operator> <name><name>parentConstr</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>||</operator>
		<name><name>partConstr</name><operator>-&gt;</operator><name>confupdtype</name></name> <operator>!=</operator> <name><name>parentConstr</name><operator>-&gt;</operator><name>confupdtype</name></name> <operator>||</operator>
		<name><name>partConstr</name><operator>-&gt;</operator><name>confdeltype</name></name> <operator>!=</operator> <name><name>parentConstr</name><operator>-&gt;</operator><name>confdeltype</name></name> <operator>||</operator>
		<name><name>partConstr</name><operator>-&gt;</operator><name>confmatchtype</name></name> <operator>!=</operator> <name><name>parentConstr</name><operator>-&gt;</operator><name>confmatchtype</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>parentConstrTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>partcontup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>partcontup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>parentConstrTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Looks good!  Attach this constraint.  The action triggers in the new
	 * partition become redundant -- the parent table already has equivalent
	 * ones, and those will be able to reach the partition.  Remove the ones
	 * in the partition.  We identify them because they have our constraint
	 * OID, as well as being on the referenced rel.
	 */</comment>
	<expr_stmt><expr><name>trigrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_tgconstraint</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>trigrel</name></expr></argument>, <argument><expr><name>TriggerConstraintIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>trigtup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>trgform</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>trigtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>trigger</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>trgform</name><operator>-&gt;</operator><name>tgconstrrelid</name></name> <operator>!=</operator> <name><name>fk</name><operator>-&gt;</operator><name>conrelid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trgform</name><operator>-&gt;</operator><name>tgrelid</name></name> <operator>!=</operator> <name><name>fk</name><operator>-&gt;</operator><name>confrelid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The constraint is originally set up to contain this trigger as an
		 * implementation object, so there's a dependency record that links
		 * the two; however, since the trigger is no longer needed, we remove
		 * the dependency link in order to be able to drop the trigger while
		 * keeping the constraint intact.
		 */</comment>
		<expr_stmt><expr><call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>,
								   <argument><expr><name><name>trgform</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* make dependency deletion visible to performDeletion */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>trigger</name></expr></argument>, <argument><expr><name>TriggerRelationId</name></expr></argument>,
						 <argument><expr><name><name>trgform</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trigger</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* make trigger drop visible, in case the loop iterates */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>trigrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>, <argument><expr><name>parentConstrOid</name></expr></argument>, <argument><expr><name>partRelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ALTER TABLE ALTER CONSTRAINT
 *
 * Update the attributes of a constraint.
 *
 * Currently only works for Foreign Key constraints.
 * Foreign keys do not inherit, so we purposely ignore the
 * recursion bit here, but we keep the API the same for when
 * other constraint types are supported.
 *
 * If the constraint is modified, returns its address; otherwise, return
 * InvalidObjectAddress.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAlterConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>cmdcon</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>contuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>currcon</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cmdcon</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find and check the target constraint
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_contypid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>cmdcon</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There can be at most one matching row */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>contuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name><name>cmdcon</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>currcon</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>contuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>currcon</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" is not a foreign key constraint"</literal></expr></argument>,
						<argument><expr><name><name>cmdcon</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>currcon</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>!=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>||</operator>
		<name><name>currcon</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>!=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copyTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tgtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>copy_con</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>otherrelids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>tgkey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Now update the catalog, while we have the door open.
		 */</comment>
		<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>contuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>copy_con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>,
								  <argument><expr><name><name>currcon</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we need to update the multiple entries in pg_trigger that
		 * implement the constraint.
		 */</comment>
		<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tgkey</name></expr></argument>,
					<argument><expr><name>Anum_pg_trigger_tgconstraint</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>currcon</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerConstraintIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tgkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tgtuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>tgform</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tgtuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>copy_tg</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Remember OIDs of other relation(s) involved in FK constraint.
			 * (Note: it's likely that we could skip forcing a relcache inval
			 * for other rels that don't have a trigger whose properties
			 * change, but let's be conservative.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tgform</name><operator>-&gt;</operator><name>tgrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>otherrelids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>otherrelids</name></expr></argument>,
													 <argument><expr><name><name>tgform</name><operator>-&gt;</operator><name>tgrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Update deferrability of RI_FKey_noaction_del,
			 * RI_FKey_noaction_upd, RI_FKey_check_ins and RI_FKey_check_upd
			 * triggers, but not others; see createForeignKeyActionTriggers
			 * and CreateFKCheckTrigger.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tgform</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>!=</operator> <name>F_RI_FKEY_NOACTION_DEL</name> <operator>&amp;&amp;</operator>
				<name><name>tgform</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>!=</operator> <name>F_RI_FKEY_NOACTION_UPD</name> <operator>&amp;&amp;</operator>
				<name><name>tgform</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>!=</operator> <name>F_RI_FKEY_CHECK_INS</name> <operator>&amp;&amp;</operator>
				<name><name>tgform</name><operator>-&gt;</operator><name>tgfoid</name></name> <operator>!=</operator> <name>F_RI_FKEY_CHECK_UPD</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tgtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>copy_tg</name> <operator>=</operator> <operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>copy_tg</name><operator>-&gt;</operator><name>tgdeferrable</name></name> <operator>=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>copy_tg</name><operator>-&gt;</operator><name>tginitdeferred</name></name> <operator>=</operator> <name><name>cmdcon</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name><name>currcon</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Invalidate relcache so that others see the new attributes.  We must
		 * inval both the named rel and any others having relevant triggers.
		 * (At present there should always be exactly one other rel, but
		 * there's no need to hard-wire such an assumption here.)
		 */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>otherrelids</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name><name>currcon</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE VALIDATE CONSTRAINT
 *
 * XXX The reason we handle recursion here rather than at Phase 1 is because
 * there's no good way to skip recursing when handling foreign keys: there is
 * no need to lock children in that case, yet we wouldn't be able to avoid
 * doing so at that level.
 *
 * Return value is the address of the validated constraint.  If the constraint
 * was already validated, InvalidObjectAddress is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecValidateConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find and check the target constraint
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_contypid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>constrName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There can be at most one matching row */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_FOREIGN</name> <operator>&amp;&amp;</operator>
		<name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" is not a foreign key or check constraint"</literal></expr></argument>,
						<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>convalidated</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copyTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>copy_con</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>refrel</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Triggers are already in place on both tables, so a concurrent
			 * write that alters the result here is not possible. Normally we
			 * can run a query here to do the validation, which would only
			 * require AccessShareLock. In some cases, it is possible that we
			 * might need to fire triggers to perform the check, so we take a
			 * lock at RowShareLock level just in case.
			 */</comment>
			<expr_stmt><expr><name>refrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>validateForeignKeyConstraint</name><argument_list>(<argument><expr><name>constrName</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>refrel</name></expr></argument>,
										 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>conindid</name></name></expr></argument>,
										 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>refrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We disallow creating invalid foreign keys to or from
			 * partitioned tables, so ignoring the recursion bit is okay.
			 */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If we're recursing, the parent has already done this, so skip
			 * it.  Also, if the constraint is a NO INHERIT constraint, we
			 * shouldn't try to look for it in the children.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * For CHECK constraints, we must ensure that we only mark the
			 * constraint as validated on the parent if it's already validated
			 * on the children.
			 *
			 * We recurse before validating on the parent, to reduce risk of
			 * deadlocks.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>childoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>childoid</name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If we are told not to recurse, there had better not be any
				 * child tables, because we can't mark the constraint on the
				 * parent valid unless it is valid for all child tables.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint must be validated on child tables too"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* find_all_inheritors already got lock */</comment>
				<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>childoid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ATExecValidateConstraint</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>constrName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>validateCheckConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Invalidate relcache so that others see the new validated
			 * constraint.
			 */</comment>
			<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now update the catalog, while we have the door open.
		 */</comment>
		<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>copy_con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>convalidated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>address</name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* already validated */</comment>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformColumnNameList - transform list of column names
 *
 * Lookup each name and return its attnum and type OID
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>transformColumnNameList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colList</name></decl></parameter>,
						<parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>atttypids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>colList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>atttuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" referenced in foreign key constraint does not exist"</literal></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;=</operator> <name>INDEX_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have more than %d keys in a foreign key"</literal></expr></argument>,
							<argument><expr><name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>attnums</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atttypids</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attnum</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>attnum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformFkeyGetPrimaryKey -
 *
 *	Look up the names, attnums, and types of the primary key attributes
 *	for the pkrel.  Also return the index OID and index opclasses of the
 *	index supporting the primary key.
 *
 *	All parameters except pkrel are output parameters.  Also, the function
 *	return value is the number of attributes in the primary key.
 *
 *	Used when the column list in the REFERENCES specification is omitted.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>transformFkeyGetPrimaryKey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>indexOid</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>attnamelist</name></decl></parameter>,
						   <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>atttypids</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opclasses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>indclassDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the list of index OIDs for the table from the relcache, and look up
	 * each one in the pg_index syscache until we find one marked primary key
	 * (hopefully there isn't more than one such).  Insist it's valid, too.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>indexOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indisprimary</name></name> <operator>&amp;&amp;</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Refuse to use a deferrable primary key.  This is per SQL spec,
			 * and there would be a lot of interesting semantic problems if we
			 * tried to allow it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexStruct</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use a deferrable primary key for referenced table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>indexOid</name> <operator>=</operator> <name>indexoid</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that we found it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no primary key for referenced table \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Must get indclass the hard way */</comment>
	<expr_stmt><expr><name>indclassDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>,
									<argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclassDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now build the list of PK attributes from the indkey definition (we
	 * assume a primary key cannot have expressional elements)
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>attnamelist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>pkattno</name> <init>= <expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pkattno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atttypids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>attnumTypeId</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>pkattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>attnamelist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>attnamelist</name></expr></argument>,
							   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>attnumAttName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>, <argument><expr><name>pkattno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformFkeyCheckAttrs -
 *
 *	Make sure that the attributes of a referenced table belong to a unique
 *	(or primary key) constraint.  Return the OID of the index supporting
 *	the constraint, as well as the opclasses associated with the index
 *	columns.
 */</comment>
<function><type><name>Oid</name></type>
<name>transformFkeyCheckAttrs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>numattrs</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opclasses</name></decl></parameter>)</parameter_list> <comment type="block">/* output parameter */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_deferrable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reject duplicate appearances of columns in the referenced-columns list.
	 * Such a case is forbidden by the SQL standard, and even if we thought it
	 * useful to allow it, there would be ambiguity about how to match the
	 * list to unique indexes (in particular, it'd be unclear which index
	 * opclass goes with which FK column).
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>attnums</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FOREIGN_KEY</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key referenced-columns list must not contain duplicates"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Get the list of index OIDs for the table from the relcache, and look up
	 * each one in the pg_index syscache, and match unique indexes to the list
	 * of attnums we are given.
	 */</comment>
	<expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indexoid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Must have the right number of columns; must be unique and not a
		 * partial index; forget it if there are any expressions, too. Invalid
		 * indexes are out as well.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indnkeyatts</name></name> <operator>==</operator> <name>numattrs</name> <operator>&amp;&amp;</operator>
			<name><name>indexStruct</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>&amp;&amp;</operator>
			<name><name>indexStruct</name><operator>-&gt;</operator><name>indisvalid</name></name> <operator>&amp;&amp;</operator>
			<call><name>heap_attisnull</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>, <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>heap_attisnull</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>, <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>indclassDatum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>

			<comment type="block">/* Must get indclass the hard way */</comment>
			<expr_stmt><expr><name>indclassDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>,
											<argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclassDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The given attnum list may match the index columns in any order.
			 * Check for a match, and extract the appropriate opclasses while
			 * we're at it.
			 *
			 * We know that attnums[] is duplicate-free per the test at the
			 * start of this function, and we checked above that the number of
			 * index columns agrees, so if we find a match for each attnums[]
			 * entry then we must have a one-to-one match in some order.
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Refuse to use a deferrable unique/primary key.  This is per SQL
			 * spec, and there would be a lot of interesting semantic problems
			 * if we tried to allow it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>indexStruct</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Remember that we found an otherwise matching index, so that
				 * we can generate a more appropriate error message.
				 */</comment>
				<expr_stmt><expr><name>found_deferrable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>found_deferrable</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use a deferrable unique constraint for referenced table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FOREIGN_KEY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no unique constraint matching given keys for referenced table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>indexoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findFkeyCast -
 *
 *	Wrapper around find_coercion_pathway() for ATAddForeignKeyConstraint().
 *	Caller has equal regard for binary coercibility and for an exact match.
*/</comment>
<function><type><specifier>static</specifier> <name>CoercionPathType</name></type>
<name>findFkeyCast</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sourceTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetTypeId</name> <operator>==</operator> <name>sourceTypeId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>COERCION_PATH_RELABELTYPE</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>funcid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>targetTypeId</name></expr></argument>, <argument><expr><name>sourceTypeId</name></expr></argument>,
									<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>COERCION_PATH_NONE</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* A previously-relied-upon cast is now gone. */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find cast from %u to %u"</literal></expr></argument>,
				 <argument><expr><name>sourceTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Permissions checks on the referenced table for ADD FOREIGN KEY
 *
 * Note: we have already checked that the user owns the referencing table,
 * else we'd have failed much earlier; no additional checks are needed for it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkFkeyPermissions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Okay if we have relation-level REFERENCES permission */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>roleid</name></expr></argument>,
								  <argument><expr><name>ACL_REFERENCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>==</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Else we must have REFERENCES on each column */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ACL_REFERENCES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Scan the existing rows in a table to verify they meet a proposed
 * CHECK constraint.
 *
 * The caller must have opened and locked the relation appropriately.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validateCheckConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>constrtup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>conbin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>origexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>exprstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constrForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * VALIDATE CONSTRAINT is a no-op for foreign tables and partitioned
	 * tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>constrForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>constrtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX this tuple doesn't really come from a syscache, but this doesn't
	 * matter to SysCacheGetAttr, because it only wants to be able to fetch
	 * the tupdesc
	 */</comment>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>constrtup</name></expr></argument>, <argument><expr><name>Anum_pg_constraint_conbin</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conbin for constraint %u"</literal></expr></argument>,
			 <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>conbin</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>origexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>conbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>exprstate</name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name>origexpr</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to per-tuple memory context and reset it for each tuple
	 * produced, so we don't leak memory.
	 */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>table_scan_getnextslot</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name>exprstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"check constraint \"%s\" is violated by some row"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Scan the existing rows in a table to verify they meet a proposed FK
 * constraint.
 *
 * Caller must have opened and locked both relations appropriately.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validateForeignKeyConstraint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>,
							 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							 <parameter><decl><type><name>Relation</name></type> <name>pkrel</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>pkindOid</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Trigger</name></type>		<name>trig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>perTupCxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"validating foreign key constraint \"%s\""</literal></expr></argument>, <argument><expr><name>conname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Greenplum Database: Ignore foreign keys for now, with a warning. */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_FEATURE_NOT_YET</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build a trigger call structure; we'll need it either way.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trig</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgname</name></name> <operator>=</operator> <name>conname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgenabled</name></name> <operator>=</operator> <name>TRIGGER_FIRES_ON_ORIGIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgisinternal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgconstrrelid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgconstrindid</name></name> <operator>=</operator> <name>pkindOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgconstraint</name></name> <operator>=</operator> <name>constraintOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgdeferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tginitdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* we needn't fill in remaining fields */</comment>

	<comment type="block">/*
	 * See if we can do it with a single LEFT JOIN query.  A false result
	 * indicates we must proceed with the fire-the-trigger method.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RI_Initial_Check</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trig</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pkrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Scan through each tuple, calling RI_FKey_check_ins (insert trigger) as
	 * if that tuple had just been inserted.  If any of those fail, it should
	 * ereport(ERROR) and that's that.
	 */</comment>
	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>perTupCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									  <argument><expr><literal type="string">"validateForeignKeyConstraint"</literal></expr></argument>,
									  <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>perTupCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>table_scan_getnextslot</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>TriggerData</name></type> <name>trigdata</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make a call to the trigger function
		 *
		 * No parameters are passed, but we do set a context
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SizeForFunctionCallInfo</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We assume RI_FKey_check_ins won't look at flinfo...
		 */</comment>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_TriggerData</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_event</name></name> <operator>=</operator> <name>TRIGGER_EVENT_INSERT</name> <operator>|</operator> <name>TRIGGER_EVENT_ROW</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_relation</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_trigtuple</name></name> <operator>=</operator> <call><name>ExecFetchSlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_trigslot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_newtuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_newslot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigdata</name><operator>.</operator><name>tg_trigger</name></name> <operator>=</operator> <operator>&amp;</operator><name>trig</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>trigdata</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>RI_FKey_check_ins</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>perTupCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>perTupCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateFKCheckTrigger</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myRelOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>on_insert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>fk_trigger</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: for a self-referential FK (referencing and referenced tables are
	 * the same), it is important that the ON UPDATE action fires before the
	 * CHECK action, since both triggers will fire on the same row during an
	 * UPDATE event; otherwise the CHECK trigger will be checking a non-final
	 * state of the row.  Triggers fire in name order, so we ensure this by
	 * using names like "RI_ConstraintTrigger_a_NNNN" for the action triggers
	 * and "RI_ConstraintTrigger_c_NNNN" for the check triggers.
	 */</comment>
	<expr_stmt><expr><name>fk_trigger</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>trigname</name></name> <operator>=</operator> <literal type="string">"RI_ConstraintTrigger_c"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>;</expr_stmt>

	<comment type="block">/* Either ON INSERT or ON UPDATE */</comment>
	<if_stmt><if>if <condition>(<expr><name>on_insert</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_check_ins"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_INSERT</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_check_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_UPDATE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>transitionRels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>constrrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><name>fk_trigger</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>myRelOid</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
						 <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make changes-so-far visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * createForeignKeyActionTriggers
 *		Create the referenced-side "action" triggers that implement a foreign
 *		key.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>createForeignKeyActionTriggers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>fk_trigger</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Special for Greenplum Database: Ignore foreign keys for now, with warning
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"referential integrity (FOREIGN KEY) constraints are not supported in Greenplum Database, will not be enforced"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build and execute a CREATE CONSTRAINT TRIGGER statement for the ON
	 * DELETE action on the referenced table.
	 */</comment>
	<expr_stmt><expr><name>fk_trigger</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>trigname</name></name> <operator>=</operator> <literal type="string">"RI_ConstraintTrigger_a"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_DELETE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>transitionRels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>constrrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FKCONSTR_ACTION_NOACTION</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_noaction_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_RESTRICT</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_restrict_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_CASCADE</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_cascade_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_SETNULL</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_setnull_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_SETDEFAULT</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_setdefault_del"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized FK action type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><name>fk_trigger</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>constraintOid</name></expr></argument>,
						 <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make changes-so-far visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build and execute a CREATE CONSTRAINT TRIGGER statement for the ON
	 * UPDATE action on the referenced table.
	 */</comment>
	<expr_stmt><expr><name>fk_trigger</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>trigname</name></name> <operator>=</operator> <literal type="string">"RI_ConstraintTrigger_a"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_UPDATE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>transitionRels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>constrrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FKCONSTR_ACTION_NOACTION</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_noaction_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_RESTRICT</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_restrict_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_CASCADE</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_cascade_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_SETNULL</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_setnull_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FKCONSTR_ACTION_SETDEFAULT</name></expr>:</case>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"RI_FKey_setdefault_upd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized FK action type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><name><name>fk_trigger</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><name>fk_trigger</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>constraintOid</name></expr></argument>,
						 <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * createForeignKeyCheckTriggers
 *		Create the referencing-side "check" triggers that implement a foreign
 *		key.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>createForeignKeyCheckTriggers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>myRelOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelOid</name></decl></parameter>,
							  <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CreateFKCheckTrigger</name><argument_list>(<argument><expr><name>myRelOid</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
						 <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CreateFKCheckTrigger</name><argument_list>(<argument><expr><name>myRelOid</name></expr></argument>, <argument><expr><name>refRelOid</name></expr></argument>, <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
						 <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE DROP CONSTRAINT
 *
 * Like DROP COLUMN, we can't use the normal ALTER TABLE recursion mechanism.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecDropConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constrName</name></decl></parameter>,
					 <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_no_inherit_constraint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>contype</name></decl>;</decl_stmt>

	<comment type="block">/* At top level, permission check was done in ATPrepCmd, else do it */</comment>
	<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find and drop the target constraint
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_contypid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>constrName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There can be at most one matching row */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>conobj</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Don't drop inherited constraints */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop inherited constraint \"%s\" of relation \"%s\""</literal></expr></argument>,
							<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>is_no_inherit_constraint</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>contype</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a foreign-key constraint, we'd better lock the referenced
		 * table and check that that's not in use, just as we've already done
		 * for the constrained table (else we might, eg, be dropping a trigger
		 * that has unfired events).  But we can/must skip that in the
		 * self-referential case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>contype</name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name> <operator>&amp;&amp;</operator>
			<name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>frel</name></decl>;</decl_stmt>

			<comment type="block">/* Must match lock taken by RemoveTriggerById: */</comment>
			<expr_stmt><expr><name>frel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>frel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>frel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If it's a foreign-key constraint, we'd better lock the referenced
		 * table and check that that's not in use, just as we've already done
		 * for the constrained table (else we might, eg, be dropping a trigger
		 * that has unfired events).  But we can/must skip that in the
		 * self-referential case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name> <operator>&amp;&amp;</operator>
			<name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>frel</name></decl>;</decl_stmt>

			<comment type="block">/* Must match lock taken by RemoveTriggerById: */</comment>
			<expr_stmt><expr><name>frel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>frel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>frel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Perform the actual constraint deletion
		 */</comment>
		<expr_stmt><expr><name><name>conobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ConstraintRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conobj</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist, skipping"</literal></expr></argument>,
							<argument><expr><name>constrName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For partitioned tables, non-CHECK inherited constraints are dropped via
	 * the dependency mechanism, so we're done here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>contype</name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Propagate to children as appropriate.  Unlike most other ALTER
	 * routines, we have to do this one level of recursion at a time; we can't
	 * use find_all_inheritors to do it in one pass.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_no_inherit_constraint</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>children</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * For a partitioned table, if partitions exist and we are told not to
	 * recurse, it's a user error.  It doesn't make sense to have a constraint
	 * be defined only on the parent, especially if it's a partitioned table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<name>children</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot remove constraint from only the partitioned table when partitions exist"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not specify the ONLY keyword."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copy_tuple</name></decl>;</decl_stmt>

		<comment type="block">/* find_inheritance_children already got lock */</comment>
		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_constraint_contypid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_constraint_conname</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
					<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>constrName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* There can be at most one matching row */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>constrName</name></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>copy_tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Right now only CHECK constraints can be inherited */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inherited constraint is not a CHECK constraint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u has non-inherited constraint \"%s\""</literal></expr></argument>,
				 <argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>constrName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the child constraint has other definition sources, just
			 * decrement its inheritance count; if not, recurse to delete it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>conislocal</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Time to delete this child constraint, too */</comment>
				<expr_stmt><expr><call><name>ATExecDropConstraint</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>constrName</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Child constraint must survive my deletion */</comment>
				<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copy_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Make update visible */</comment>
				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If we were told to drop ONLY in this table (no recursion), we
			 * need to mark the inheritors' constraints as locally defined
			 * rather than inherited.
			 */</comment>
			<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copy_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Make update visible */</comment>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"DROP CONSTRAINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER COLUMN TYPE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepAlterColumnType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>,
					  <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
					  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colName</name> <init>= <expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typeName</name> <init>= <expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>transform</name> <init>= <expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>targettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>targettypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>targetcollid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>new_opclass</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>old_opclass</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>old_opfamily</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>new_opfamily</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_expr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter column type of typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* lookup the attribute so we can check inheritance status */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

	<comment type="block">/* Can't alter a system attribute */</comment>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Don't alter inherited columns */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter inherited column \"%s\""</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Don't alter columns used in the partition key */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>has_partition_attrs</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
							<argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>is_expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_expr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of column named in partition key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of column referenced in partition key expression"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Look up the target type */</comment>
	<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targettypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And the collation */</comment>
	<expr_stmt><expr><name>targetcollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure datatype is legal for a column */</comment>
	<expr_stmt><expr><call><name>CheckAttributeType</name><argument_list>(<argument><expr><name>colName</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>targetcollid</name></expr></argument>,
					   <argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the column is part of the distribution key, look up the new operator
	 * class
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>policy</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>attnum</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* found it! */</comment>
				<expr_stmt><expr><name>old_opclass</name> <operator>=</operator> <name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>old_opclass</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_opfamily</name> <operator>=</operator> <call><name>get_opclass_family</name><argument_list>(<argument><expr><name>old_opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>new_opclass</name> <operator>=</operator> <call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>HASH_AM_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>new_opclass</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>new_opfamily</name> <operator>=</operator> <call><name>get_opclass_family</name><argument_list>(<argument><expr><name>new_opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>new_opclass</name> <operator>!=</operator> <name>old_opclass</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>new_opclass</name></name> <operator>=</operator> <name>new_opclass</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>new_opfamily</name> <operator>!=</operator> <name>old_opfamily</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>dist_opfamily_changed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * The new datatype doesn't have a default operator class.
				 * We'll have to turn the table randomly distributed.
				 */</comment>
				<expr_stmt><expr><name>new_opfamily</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>new_opclass</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>dist_opfamily_changed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Distribution key cannot be changed in a non-compatible way. Unless the
	 * table is completely empty.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator>
		<call><name>GpPolicyIsPartitioned</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>tab</name><operator>-&gt;</operator><name>dist_opfamily_changed</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>relContainsTuples</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>relContainsTuples</name> <operator>=</operator> <call><name>cdbRelMaxSegSize</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>relContainsTuples</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>ia</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>ia</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>ia</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>ia</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of a column used in "</literal>
									<literal type="string">"a distribution policy"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		<name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Set up an expression to transform the old data value to the new
		 * type. If a USING option was given, use the expression as
		 * transformed by transformAlterTableStmt, else just take the old
		 * value and try to coerce it.  We do this first so that type
		 * incompatibility can be detected before we waste effort, and because
		 * we need the expression to be parsed against the original table row
		 * type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transform</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>transform</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
										 <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
										 <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
										 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>transform</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										  <argument><expr><name>transform</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>transform</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>targettypmod</name></expr></argument>,
										  <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
										  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
										  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>transform</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* error text depends on whether USING was specified or not */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"result of USING clause for column \"%s\""</literal>
								<literal type="string">" cannot be cast automatically to type %s"</literal></expr></argument>,
								<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to add an explicit cast."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" cannot be cast automatically to type %s"</literal></expr></argument>,
								<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				<comment type="block">/* translator: USING is SQL, don't translate it */</comment>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to specify \"USING %s::%s\"."</literal></expr></argument>,
								 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>,
														  <argument><expr><name>targettypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Fix collations after all else */</comment>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>transform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Plan the expr now so we can accurately assess the need to rewrite. */</comment>
		<expr_stmt><expr><name>transform</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>transform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add a work queue item to make ATRewriteTable update the column
		 * contents.
		 */</comment>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <operator>(</operator><name>NewColumnValue</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewColumnValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>transform</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>is_generated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ATColumnChangeRequiresRewrite</name><argument_list>(<argument><expr><name>transform</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_COLUMN_REWRITE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the column is part of the distribution key, and the new opclass is not
		 * in the same family as the old one, we'll need to rewrite the table because
		 * the distribution changes. (Unless the new datatype is not hashable, in
		 * which case we're going to drop it from the distribution key, and make
		 * the table randomly distributed.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>old_opfamily</name> <operator>!=</operator> <name>new_opfamily</name> <operator>&amp;&amp;</operator> <name>new_opfamily</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_COLUMN_REWRITE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>transform</name> <operator>&amp;&amp;</operator>
			 <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
			 <call><name>rel_is_external_table</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Just to give a better error message than "foo is not a table" */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify a USING expression when altering an external table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>transform</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator>
		<name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For composite types, do this check now.  Tables will check it later
		 * when the table is being rewritten.
		 */</comment>
		<expr_stmt><expr><call><name>find_composite_type_dependencies</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recurse manually by queueing a new command for each child, if
	 * necessary. We cannot apply ATSimpleRecursion here because we need to
	 * remap attribute numbers in the USING expression, if any.
	 *
	 * If we are told not to recurse, there had better not be any child
	 * tables; else the alter would put them out of step.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * find_all_inheritors does the recursive search of the inheritance
		 * hierarchy, so all we have to do is process all of the relids in the
		 * list that it returns.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>child</argument>, <argument>children</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>childrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>childrelid</name> <operator>==</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* find_all_inheritors already got lock */</comment>
			<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>childrelid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Remap the attribute numbers.  If no USING expression was
			 * specified, there is no need for this step.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

				<comment type="block">/* create a copy to scribble on */</comment>
				<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>cooked_default</name> <operator>=</operator>
					<call><name>map_variable_attnos</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name></expr></argument>,
										<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>attmap</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"USING expression contains a whole-row table reference."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ATPrepCmd</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>recursing</name> <operator>&amp;&amp;</operator>
			 <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type of inherited column \"%s\" must be changed in child tables too"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATTypedTableRecursion</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * When the data type of a column is changed, a rewrite might not be required
 * if the new type is sufficiently identical to the old one, and the USING
 * clause isn't trying to insert some other value.  It's safe to skip the
 * rewrite in these cases:
 *
 * - the old type is binary coercible to the new type
 * - the new type is an unconstrained domain over the old type
 * - {NEW,OLD} or {OLD,NEW} is {timestamptz,timestamp} and the timezone is UTC
 *
 * In the case of a constrained domain, we could get by with scanning the
 * table and checking the constraint rather than actually rewriting it, but we
 * don't currently try to do that.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ATColumnChangeRequiresRewrite</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* only one varno, so no need to check that */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name>varattno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>DomainHasConstraints</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>funcid</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>F_TIMESTAMPTZ_TIMESTAMP</name></expr>:</case>
				<case>case <expr><name>F_TIMESTAMP_TIMESTAMPTZ</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>TimestampTimestampTzRequiresRewrite</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER COLUMN .. SET DATA TYPE
 *
 * Return the address of the modified column.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAlterColumnType</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colName</name> <init>= <expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typeName</name> <init>= <expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heapTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attTup</name></decl>,
				<decl><type ref="prev"/><name>attOldTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>tform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>targettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>targettypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>targetcollid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>defaultexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>depRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>depTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Clear all the missing values if we're rewriting the table, since this
	 * renders them pointless.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>newrel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationClearMissing</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* make sure we don't conflict with later attribute modifications */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>attrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up the target column */</comment>
	<expr_stmt><expr><name>heapTup</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attOldTup</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>oldDesc</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for multiple ALTER TYPE on same column --- can't cope */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>attOldTup</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
		<name><name>attTup</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name><name>attOldTup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of column \"%s\" twice"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Look up the target type (should not fail, since prep found it) */</comment>
	<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targettypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>targettype</name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
	<comment type="block">/* And the collation */</comment>
	<expr_stmt><expr><name>targetcollid</name> <operator>=</operator> <call><name>GetColumnDefCollation</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is a default expression for the column, get it and ensure we
	 * can coerce it to the new datatype.  (We must do this before changing
	 * the column type, because build_column_default itself will try to
	 * coerce, and will not issue the error message we want if it fails.)
	 *
	 * We remove any implicit coercion steps at the top level of the old
	 * default expression; this has been agreed to satisfy the principle of
	 * least surprise.  (The conversion to the new column type should act like
	 * it started from what the user sees as the stored expression, and the
	 * implicit coercions aren't going to be shown.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>defaultexpr</name> <operator>=</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>defaultexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>defaultexpr</name> <operator>=</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><name>defaultexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>defaultexpr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no UNKNOWN params */</comment>
											<argument><expr><name>defaultexpr</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>defaultexpr</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>targettype</name></expr></argument>, <argument><expr><name>targettypmod</name></expr></argument>,
											<argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
											<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
											<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>defaultexpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"generation expression for column \"%s\" cannot be cast automatically to type %s"</literal></expr></argument>,
								<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"default for column \"%s\" cannot be cast automatically to type %s"</literal></expr></argument>,
								<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>defaultexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Find everything that depends on the column (constraints, indexes, etc),
	 * and record enough information to let us recreate the objects.
	 *
	 * The actual recreation does not happen here, but only after we have
	 * performed all the individual ALTER TYPE operations.  We have to save
	 * the info before executing ALTER TYPE, though, else the deparser will
	 * get confused.
	 */</comment>
	<expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>foundDep</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>foundObject</name></decl>;</decl_stmt>

		<comment type="block">/* We don't expect any PIN dependencies on columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_PIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot alter type of a pinned column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>foundObject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>classid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>objid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>objsubid</name></name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><call><name>getObjectClass</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>OCLASS_CLASS</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name>relKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
						<name>relKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>RememberIndexForRebuilding</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * This must be a SERIAL column's sequence.  We need
						 * not do anything to it.
						 */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
							 <name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
							 <call><name>get_attgenerated</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Changing the type of a column that is used by a
						 * generated column is not allowed by SQL standard. It
						 * might be doable with some thinking and effort.
						 */</comment>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of a column used by a generated column"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Column \"%s\" is used by generated column \"%s\"."</literal></expr></argument>,
										   <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Not expecting any other direct dependencies... */</comment>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected object depending on column: %s"</literal></expr></argument>,
							 <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>OCLASS_CONSTRAINT</name></expr>:</case>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>RememberConstraintForRebuilding</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OCLASS_REWRITE</name></expr>:</case>
				<comment type="block">/* XXX someday see if we can cope with revising views */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of a column used by a view or rule"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s depends on column \"%s\""</literal></expr></argument>,
								   <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OCLASS_TRIGGER</name></expr>:</case>

				<comment type="block">/*
				 * A trigger can depend on a column because the column is
				 * specified as an update target, or because the column is
				 * used in the trigger's WHEN condition.  The first case would
				 * not require any extra work, but the second case would
				 * require updating the WHEN expression, which will take a
				 * significant amount of new code.  Since we can't easily tell
				 * which case applies, we punt for both.  FIXME someday.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of a column used in a trigger definition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s depends on column \"%s\""</literal></expr></argument>,
								   <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OCLASS_POLICY</name></expr>:</case>

				<comment type="block">/*
				 * A policy can depend on a column because the column is
				 * specified in the policy's USING or WITH CHECK qual
				 * expressions.  It might be possible to rewrite and recheck
				 * the policy expression, but punt for now.  It's certainly
				 * easy enough to remove and recreate the policy; still, FIXME
				 * someday.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter type of a column used in a policy definition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s depends on column \"%s\""</literal></expr></argument>,
								   <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OCLASS_DEFAULT</name></expr>:</case>

				<comment type="block">/*
				 * Ignore the column's default expression, since we will fix
				 * it below.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>defaultexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OCLASS_STATISTIC_EXT</name></expr>:</case>

				<comment type="block">/*
				 * Give the extended-stats machinery a chance to fix anything
				 * that this column type change would break.
				 */</comment>
				<expr_stmt><expr><call><name>UpdateStatisticsForTypeChange</name><argument_list>(<argument><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name></expr></argument>,
											  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
											  <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>OCLASS_PROC</name></expr>:</case>
			<case>case <expr><name>OCLASS_TYPE</name></expr>:</case>
			<case>case <expr><name>OCLASS_CAST</name></expr>:</case>
			<case>case <expr><name>OCLASS_COLLATION</name></expr>:</case>
			<case>case <expr><name>OCLASS_CONVERSION</name></expr>:</case>
			<case>case <expr><name>OCLASS_LANGUAGE</name></expr>:</case>
			<case>case <expr><name>OCLASS_LARGEOBJECT</name></expr>:</case>
			<case>case <expr><name>OCLASS_OPERATOR</name></expr>:</case>
			<case>case <expr><name>OCLASS_OPCLASS</name></expr>:</case>
			<case>case <expr><name>OCLASS_OPFAMILY</name></expr>:</case>
			<case>case <expr><name>OCLASS_AM</name></expr>:</case>
			<case>case <expr><name>OCLASS_AMOP</name></expr>:</case>
			<case>case <expr><name>OCLASS_AMPROC</name></expr>:</case>
			<case>case <expr><name>OCLASS_SCHEMA</name></expr>:</case>
			<case>case <expr><name>OCLASS_TSPARSER</name></expr>:</case>
			<case>case <expr><name>OCLASS_TSDICT</name></expr>:</case>
			<case>case <expr><name>OCLASS_TSTEMPLATE</name></expr>:</case>
			<case>case <expr><name>OCLASS_TSCONFIG</name></expr>:</case>
			<case>case <expr><name>OCLASS_ROLE</name></expr>:</case>
			<case>case <expr><name>OCLASS_DATABASE</name></expr>:</case>
			<case>case <expr><name>OCLASS_TBLSPACE</name></expr>:</case>
			<case>case <expr><name>OCLASS_FDW</name></expr>:</case>
			<case>case <expr><name>OCLASS_FOREIGN_SERVER</name></expr>:</case>
			<case>case <expr><name>OCLASS_USER_MAPPING</name></expr>:</case>
			<case>case <expr><name>OCLASS_DEFACL</name></expr>:</case>
			<case>case <expr><name>OCLASS_EXTENSION</name></expr>:</case>
			<case>case <expr><name>OCLASS_EVENT_TRIGGER</name></expr>:</case>
			<case>case <expr><name>OCLASS_PUBLICATION</name></expr>:</case>
			<case>case <expr><name>OCLASS_PUBLICATION_REL</name></expr>:</case>
			<case>case <expr><name>OCLASS_SUBSCRIPTION</name></expr>:</case>
			<case>case <expr><name>OCLASS_TRANSFORM</name></expr>:</case>
			<case>case <expr><name>OCLASS_EXTPROTOCOL</name></expr>:</case>

				<comment type="block">/*
				 * We don't expect any of these sorts of objects to depend on
				 * a column.
				 */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected object depending on column: %s"</literal></expr></argument>,
					 <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * There's intentionally no default: case here; we want the
				 * compiler to warn if a new OCLASS hasn't been handled above.
				 */</comment>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now scan for dependencies of this column on other things.  The only
	 * thing we should find is the dependency on the column datatype, which we
	 * want to remove, possibly a collation dependency, and dependencies on
	 * other columns if it is a generated column.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_classid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_objid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_objsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>foundDep</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>foundObject</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>foundObject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>refclassid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>foundObject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>refobjid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>foundObject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name><name>foundDep</name><operator>-&gt;</operator><name>refobjsubid</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name> <operator>!=</operator> <name>DEPENDENCY_NORMAL</name> <operator>&amp;&amp;</operator>
			<name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name> <operator>!=</operator> <name>DEPENDENCY_AUTO</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found unexpected dependency type '%c'"</literal></expr></argument>,
				 <argument><expr><name><name>foundDep</name><operator>-&gt;</operator><name>deptype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>foundDep</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>==</operator> <name>TypeRelationId</name> <operator>&amp;&amp;</operator>
			  <name><name>foundDep</name><operator>-&gt;</operator><name>refobjid</name></name> <operator>==</operator> <name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name><name>foundDep</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>==</operator> <name>CollationRelationId</name> <operator>&amp;&amp;</operator>
			  <name><name>foundDep</name><operator>-&gt;</operator><name>refobjid</name></name> <operator>==</operator> <name><name>attTup</name><operator>-&gt;</operator><name>attcollation</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name><name>foundDep</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>==</operator> <name>RelationRelationId</name> <operator>&amp;&amp;</operator>
			  <name><name>foundDep</name><operator>-&gt;</operator><name>refobjid</name></name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			  <name><name>foundDep</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>
			)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found unexpected dependency for column: %s"</literal></expr></argument>,
				 <argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>foundObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>depTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Here we go --- change the recorded column type and collation.  (Note
	 * heapTup is a copy of the syscache entry, so okay to scribble on.) First
	 * fix up the missing value if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attTup</name><operator>-&gt;</operator><name>atthasmissing</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>missingval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>missingNull</name></decl>;</decl_stmt>

		<comment type="block">/* if rewrite is true the missing value should already be cleared */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get the missing value datum */</comment>
		<expr_stmt><expr><name>missingval</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>,
								  <argument><expr><name>Anum_pg_attribute_attmissingval</name></expr></argument>,
								  <argument><expr><name><name>attrelation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>missingNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if it's a null array there is nothing to do */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missingNull</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Get the datum out of the array and repack it in a new array
			 * built with the new type data. We assume that since the table
			 * doesn't need rewriting, the actual Datum doesn't need to be
			 * changed, only the array metadata.
			 */</comment>

			<decl_stmt><decl><type><name>int</name></type>			<name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name><name>valuesAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name><name>nullsAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name><name>replacesAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newTup</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>valuesAtt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>valuesAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nullsAtt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nullsAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replacesAtt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replacesAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>missingval</name> <operator>=</operator> <call><name>array_get_element</name><argument_list>(<argument><expr><name>missingval</name></expr></argument>,
										   <argument><expr><literal type="number">1</literal></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>one</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>,
										   <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>,
										   <argument><expr><name><name>attTup</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>missingval</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(
										 <argument><expr><call><name>construct_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name>missingval</name></expr></argument>,
														 <argument><expr><literal type="number">1</literal></expr></argument>,
														 <argument><expr><name>targettype</name></expr></argument>,
														 <argument><expr><name><name>tform</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
														 <argument><expr><name><name>tform</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
														 <argument><expr><name><name>tform</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>valuesAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>missingval</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>replacesAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nullsAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>newTup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>valuesAtt</name></expr></argument>, <argument><expr><name>nullsAtt</name></expr></argument>, <argument><expr><name>replacesAtt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>heapTup</name> <operator>=</operator> <name>newTup</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>attTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>=</operator> <name>targettype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <name>targettypmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>=</operator> <name>targetcollid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attndims</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>typeName</name><operator>-&gt;</operator><name>arrayBounds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attlen</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attalign</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attTup</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <name><name>tform</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>heapTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update gp_distribution_policy */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>dist_opfamily_changed</name></name> <operator>||</operator> <name><name>tab</name><operator>-&gt;</operator><name>new_opclass</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>newpolicy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>dist_opfamily_changed</name></name> <operator>&amp;&amp;</operator> <name><name>tab</name><operator>-&gt;</operator><name>new_opclass</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The column was part of the distribution key, but the new datatype
			 * is not hashable. Make it randomly distributed.
			 *
			 * XXX: Perhaps a NOTICE would be in order? Or an ERROR?
			 */</comment>
			<expr_stmt><expr><name>newpolicy</name> <operator>=</operator> <call><name>createRandomPartitionedPolicy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>newpolicy</name> <operator>=</operator> <call><name>GpPolicyCopy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newpolicy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>newpolicy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>newpolicy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>new_opclass</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>GpPolicyReplace</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newpolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Install dependencies on new datatype and collation */</comment>
	<expr_stmt><expr><call><name>add_column_datatype_dependency</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_column_collation_dependency</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>targetcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Drop any pg_statistic entry for the column, since it's now wrong type
	 */</comment>
	<expr_stmt><expr><call><name>RemoveStatistics</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the default, if present, by brute force --- remove and re-add
	 * the default.  Probably unsafe to take shortcuts, since the new version
	 * may well have additional dependencies.  (It's okay to do this now,
	 * rather than after other ALTER TYPE commands, since the default won't
	 * depend on other column types.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>defaultexpr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Must make new row visible since it will be updated again */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We use RESTRICT here for safety, but at present we do not expect
		 * anything to depend on the default.
		 */</comment>
		<expr_stmt><expr><call><name>RemoveAttrDefault</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
						  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>StoreAttrDefault</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>defaultexpr</name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* missing val stuff */</comment>
						 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cleanup */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>heapTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN TYPE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATExecAlterColumnType: remember that a constraint needs
 * to be rebuilt (which we might already know).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RememberConstraintForRebuilding</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>conoid</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This de-duplication check is critical for two independent reasons: we
	 * mustn't try to recreate the same constraint twice, and if a constraint
	 * depends on more than one column whose type is to be altered, we must
	 * capture its definition string before applying any of the column type
	 * changes.  ruleutils.c will get confused if we ask again later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintOids</name></name></expr></argument>, <argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* OK, capture the constraint's existing definition string */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>defstring</name> <init>= <expr><call><name>pg_get_constraintdef_command</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintOids</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintOids</name></name></expr></argument>,
												 <argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintDefs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedConstraintDefs</name></name></expr></argument>,
											 <argument><expr><name>defstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATExecAlterColumnType: remember that an index needs
 * to be rebuilt (which we might already know).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RememberIndexForRebuilding</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indoid</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This de-duplication check is critical for two independent reasons: we
	 * mustn't try to recreate the same index twice, and if an index depends
	 * on more than one column whose type is to be altered, we must capture
	 * its definition string before applying any of the column type changes.
	 * ruleutils.c will get confused if we ask again later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexOids</name></name></expr></argument>, <argument><expr><name>indoid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Before adding it as an index-to-rebuild, we'd better see if it
		 * belongs to a constraint, and if so rebuild the constraint instead.
		 * Typically this check fails, because constraint indexes normally
		 * have only dependencies on their constraint.  But it's possible for
		 * such an index to also have direct dependencies on table columns,
		 * for example with a partial exclusion constraint.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>conoid</name> <init>= <expr><call><name>get_index_constraint</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RememberConstraintForRebuilding</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* OK, capture the index's existing definition string */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>defstring</name> <init>= <expr><call><name>pg_get_indexdef_string</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexOids</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexOids</name></name></expr></argument>,
												<argument><expr><name>indoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexDefs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>changedIndexDefs</name></name></expr></argument>,
											<argument><expr><name>defstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cleanup after we've finished all the ALTER TYPE operations for a
 * particular relation.  We have to drop and recreate all the indexes
 * and constraints that depend on the altered columns.  We do the
 * actual dropping here, but re-creation is managed by adding work
 * queue entries to do those steps later.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPostAlterTypeCleanup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objects</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>def_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>oid_item</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Collect all the constraints and indexes to drop so we can process them
	 * in a single call.  That way we don't have to worry about dependencies
	 * among them.
	 */</comment>
	<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Re-parse the index and constraint definitions, and attach them to the
	 * appropriate work queue entries.  We do this before dropping because in
	 * the case of a FOREIGN KEY constraint, we might not yet have exclusive
	 * lock on the table the constraint is attached to, and we need to get
	 * that before reparsing/dropping.
	 *
	 * We can't rely on the output of deparsing to tell us which relation to
	 * operate on, because concurrent activity might have made the name
	 * resolve differently.  Instead, we've got to use the OID of the
	 * constraint or index we're processing to figure out which relation to
	 * operate on.
	 */</comment>
	<macro><name>forboth</name><argument_list>(<argument>oid_item</argument>, <argument>tab-&gt;changedConstraintOids</argument>,
			<argument>def_item</argument>, <argument>tab-&gt;changedConstraintDefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>oldId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>oid_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>confrelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>contype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>conislocal</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>conrelid</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* must be a domain constraint */</comment>
			<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>get_typ_typrelid</name><argument_list>(<argument><expr><call><name>getBaseType</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>contypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not identify relation associated with constraint %u"</literal></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>confrelid</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>contype</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>conislocal</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>conislocal</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>contype</name> <operator>==</operator> <name>CONSTRAINT_PRIMARY</name> <operator>||</operator> <name>contype</name> <operator>==</operator> <name>CONSTRAINT_UNIQUE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Currently, GPDB doesn't support alter type on primary key and unique
			 * constraint column. Because it requires drop - recreate logic.
			 * The drop currently only performs on master which lead error when
			 * recreating index (since recreate index will dispatch to segments and
			 * there still old constraint index exists)
			 * Related issue: https://github.com/greenplum-db/gpdb/issues/10561.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter column with primary key or unique constraint"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"DROP the constraint first, and recreate it after the ALTER"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the constraint is inherited (only), we don't want to inject a
		 * new definition here; it'll get recreated when ATAddCheckConstraint
		 * recurses from adding the parent table's constraint.  But we had to
		 * carry the info this far so that we can drop the constraint below.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conislocal</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * When rebuilding an FK constraint that references the table we're
		 * modifying, we might not yet have any lock on the FK's table, so get
		 * one now.  We'll need AccessExclusiveLock for the DROP CONSTRAINT
		 * step, so there's no value in asking for anything weaker.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>!=</operator> <name><name>tab</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator> <name>contype</name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ATPostAlterTypeParse</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>confrelid</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>def_item</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<macro><name>forboth</name><argument_list>(<argument>oid_item</argument>, <argument>tab-&gt;changedIndexOids</argument>,
			<argument>def_item</argument>, <argument>tab-&gt;changedIndexDefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>oldId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>oid_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ATPostAlterTypeParse</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>def_item</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * It should be okay to use DROP_RESTRICT here, since nothing else should
	 * be depending on these objects.
	 */</comment>
	<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>PERFORM_DELETION_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The objects will get recreated during subsequent passes over the work
	 * queue.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Parse the previously-saved definition string for a constraint or index
 * against the newly-established column data type(s), and queue up the
 * resulting command parsetrees for execution.
 *
 * This might fail if, for example, you have a WHERE clause that uses an
 * operator that's not available for the new column type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPostAlterTypeParse</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refRelId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rewrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>raw_parsetree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querytree_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>list_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In the QE, don't add items to the work queues. They were already
	 * added in the QD, and we don't want to do them twice.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We expect that we will get only ALTER TABLE and CREATE INDEX
	 * statements. Hence, there is no need to pass them through
	 * parse_analyze() or the rewriter, but instead we need to pass them
	 * through parse_utilcmd.c to make them ready for execution.
	 */</comment>
	<expr_stmt><expr><name>raw_parsetree_list</name> <operator>=</operator> <call><name>raw_parser</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>list_item</argument>, <argument>raw_parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawStmt</name>    <modifier>*</modifier></type><name>rs</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>, <argument><expr><name>list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><name><name>rs</name><operator>-&gt;</operator><name>stmt</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>,
									 <argument><expr><call><name>transformIndexStmt</name><argument_list>(<argument><expr><name>oldRelId</name></expr></argument>,
														<argument><expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
														<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>,
										 <argument><expr><call><name>transformAlterTableStmt</name><argument_list>(<argument><expr><name>oldRelId</name></expr></argument>,
																 <argument><expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
																 <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>querytree_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>querytree_list</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Caller should already have acquired whatever lock we need. */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>oldRelId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Attach each generated command to the proper place in the work queue.
	 * Note this could result in creation of entirely new work-queue entries.
	 *
	 * Also note that we have to tweak the command subtypes, because it turns
	 * out that re-creation of indexes and constraints has to act a bit
	 * differently from initial creation.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>list_item</argument>, <argument>querytree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>stm</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stm</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>stm</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>newcmd</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rewrite</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>TryReuseIndex</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>reset_default_tblspc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* keep the index's comment */</comment>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>idxcomment</name></name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>newcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddIndex</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_INDEX</name></expr>]</index></name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_INDEX</name></expr>]</index></name></expr></argument>, <argument><expr><name>newcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stm</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stm</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>stmt-&gt;cmds</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AddIndex</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>indstmt</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>indoid</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>indstmt</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>indoid</name> <operator>=</operator> <call><name>get_constraint_index</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rewrite</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>TryReuseIndex</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>, <argument><expr><name>indstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* keep any comment on the index */</comment>
					<expr_stmt><expr><name><name>indstmt</name><operator>-&gt;</operator><name>idxcomment</name></name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name>indoid</name></expr></argument>,
													 <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>indstmt</name><operator>-&gt;</operator><name>reset_default_tblspc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddIndex</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_INDEX</name></expr>]</index></name> <operator>=</operator>
						<call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_INDEX</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* recreate any comment on the constraint */</comment>
					<expr_stmt><expr><call><name>RebuildConstraintComment</name><argument_list>(<argument><expr><name>tab</name></expr></argument>,
											 <argument><expr><name>AT_PASS_OLD_INDEX</name></expr></argument>,
											 <argument><expr><name>oldId</name></expr></argument>,
											 <argument><expr><name>rel</name></expr></argument>,
											 <argument><expr><name>NIL</name></expr></argument>,
											 <argument><expr><name><name>indstmt</name><operator>-&gt;</operator><name>idxname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AddConstraint</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>old_pktable_oid</name></name> <operator>=</operator> <name>refRelId</name></expr>;</expr_stmt>
					<comment type="block">/* rewriting neither side of a FK */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name> <operator>&amp;&amp;</operator>
						<operator>!</operator><name>rewrite</name> <operator>&amp;&amp;</operator> <name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>TryReuseForeignKey</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>reset_default_tblspc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddConstraint</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name> <operator>=</operator>
						<call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* recreate any comment on the constraint */</comment>
					<expr_stmt><expr><call><name>RebuildConstraintComment</name><argument_list>(<argument><expr><name>tab</name></expr></argument>,
											 <argument><expr><name>AT_PASS_OLD_CONSTR</name></expr></argument>,
											 <argument><expr><name>oldId</name></expr></argument>,
											 <argument><expr><name>rel</name></expr></argument>,
											 <argument><expr><name>NIL</name></expr></argument>,
											 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_SetNotNull</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * The parser will create AT_SetNotNull subcommands for
					 * columns of PRIMARY KEY indexes/constraints, but we need
					 * not do anything with them here, because the columns'
					 * NOT NULL marks will already have been propagated into
					 * the new table definition.
					 */</comment>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected statement subtype: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stm</name></expr></argument>, <argument><expr><name>AlterDomainStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterDomainStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>AlterDomainStmt</name> <operator>*</operator><operator>)</operator> <name>stm</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <literal type="char">'C'</literal></expr>)</condition>	<comment type="block">/* ADD CONSTRAINT */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddDomainConstraint</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name> <operator>=</operator>
					<call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_OLD_CONSTR</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* recreate any comment on the constraint */</comment>
				<expr_stmt><expr><call><name>RebuildConstraintComment</name><argument_list>(<argument><expr><name>tab</name></expr></argument>,
										 <argument><expr><name>AT_PASS_OLD_CONSTR</name></expr></argument>,
										 <argument><expr><name>oldId</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>,
										 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected statement subtype: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected statement type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>stm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATPostAlterTypeParse() to recreate any existing comment
 * for a table or domain constraint that is being rebuilt.
 *
 * objid is the OID of the constraint.
 * Pass "rel" for a table constraint, or "domname" (domain's qualified name
 * as a string list) for a domain constraint.
 * (We could dig that info, as well as the conname, out of the pg_constraint
 * entry; but callers already have them so might as well pass them.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RebuildConstraintComment</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>,
						 <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>domname</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>comment_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>newcmd</name></decl>;</decl_stmt>

	<comment type="block">/* Look for comment for object wanted, and leave if none */</comment>
	<expr_stmt><expr><name>comment_str</name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name>objid</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>comment_str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Build CommentStmt node, copying all input data for safety */</comment>
	<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CommentStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rel</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_TABCONSTRAINT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
			<call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_DOMCONSTRAINT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
			<call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>domname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>comment</name></name> <operator>=</operator> <name>comment_str</name></expr>;</expr_stmt>

	<comment type="block">/* Append it to list of commands */</comment>
	<expr_stmt><expr><name>newcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ReAddComment</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cmd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>pass</name></expr>]</index></name></expr></argument>, <argument><expr><name>newcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATPostAlterTypeParse().  Calls out to CheckIndexCompatible()
 * for the real analysis, then mutates the IndexStmt based on that verdict.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TryReuseIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>CheckIndexCompatible</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>,
							 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>,
							 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>,
							 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>irel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If it's a partitioned index, there is no storage to share. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>irel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldNode</name></name> <operator>=</operator> <name><name>irel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>irel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine for ATPostAlterTypeParse().
 *
 * Stash the old P-F equality operator into the Constraint node, for possible
 * use by ATAddForeignKeyConstraint() in determining whether revalidation of
 * this constraint can be skipped.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TryReuseForeignKey</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldId</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>adatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>rawarr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>old_conpfeqop</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* already prepared this node */</comment>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>adatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>,
							 <argument><expr><name>Anum_pg_constraint_conpfeqop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conpfeqop for constraint %u"</literal></expr></argument>, <argument><expr><name>oldId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>adatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* ensure not toasted */</comment>
	<expr_stmt><expr><name>numkeys</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
	<comment type="block">/* test follows the one in ri_FetchConstraintInfo() */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OIDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"conpfeqop is not a 1-D Oid array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rawarr</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* stash a List of the operator Oids in our Constraint node */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>old_conpfeqop</name></name> <operator>=</operator> <call><name>lcons_oid</name><argument_list>(<argument><expr><name><name>rawarr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>old_conpfeqop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER COLUMN .. OPTIONS ( ... )
 *
 * Returns the address of the modified column
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAlterColumnGenericOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
								<parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>ftrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignDataWrapper</name> <modifier>*</modifier></type><name>fdw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_foreign_table</name></type> <name>fttableform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>atttableform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidObjectAddress</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* First, determine FDW validator associated to the foreign table. */</comment>
	<expr_stmt><expr><name>ftrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNTABLEREL</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>fttableform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_foreign_table</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>fttableform</name><operator>-&gt;</operator><name>ftserver</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fdw</name> <operator>=</operator> <call><name>GetForeignDataWrapper</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prevent them from altering a system attribute */</comment>
	<expr_stmt><expr><name>atttableform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>atttableform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter system column \"%s\""</literal></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<comment type="block">/* Initialize buffers for new tuple values */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract the current options */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>,
							<argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_attribute_attfdwoptions</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Transform the options */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>transformGenericOptions</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>,
									<argument><expr><name>datum</name></expr></argument>,
									<argument><expr><name>options</name></expr></argument>,
									<argument><expr><name><name>fdw</name><operator>-&gt;</operator><name>fdwvalidator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_attribute_attfdwoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_attribute_attfdwoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_attribute_attfdwoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Everything looks good - update the tuple */</comment>

	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>atttableform</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSubSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE OWNER
 *
 * recursing is true if we are recursing from a table to its indexes,
 * sequences, or toast table.  We don't allow the ownership of those things to
 * be changed separately from the parent table.  Also, we can skip permission
 * checks (this is necessary not just an optimization, else we'd fail to
 * handle toast tables properly).
 *
 * recursing is also true if ALTER TYPE OWNER is calling us to fix up a
 * free-standing composite type.
 */</comment>
<function><type><name>void</name></type>
<name>ATExecChangeOwner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>target_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>class_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>tuple_class</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get exclusive lock till end of transaction on the target table. Use
	 * relation_open so that we can work on indexes and sequences.
	 */</comment>
	<expr_stmt><expr><name>target_rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get its pg_class tuple, too */</comment>
	<expr_stmt><expr><name>class_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tuple_class</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can we change the ownership of this tuple? */</comment>
	<switch>switch <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
		<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<comment type="block">/* ok to change owner */</comment>
			<break>break;</break>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Because ALTER INDEX OWNER used to be allowed, and in fact
				 * is generated by old versions of pg_dump, we give a warning
				 * and do nothing rather than erroring out.  Also, to avoid
				 * unnecessary chatter while restoring those old dumps, say
				 * nothing at all if the command would be a no-op anyway.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name> <operator>!=</operator> <name>newOwnerId</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change owner of index \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Change the ownership of the index's table, instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* quick hack to exit via the no-op path */</comment>
				<expr_stmt><expr><name>newOwnerId</name> <operator>=</operator> <name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change owner of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Change the ownership of the index's table, instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name> <operator>&amp;&amp;</operator>
				<name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name> <operator>!=</operator> <name>newOwnerId</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* if it's an owned sequence, disallow changing it by itself */</comment>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>tableId</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>colId</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>sequenceIsOwned</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colId</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>sequenceIsOwned</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change owner of sequence \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Sequence \"%s\" is linked to table \"%s\"."</literal></expr></argument>,
									   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_COMPOSITE_TYPE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a composite type"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TYPE instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
		<case>case <expr><name>RELKIND_AOSEGMENTS</name></expr>:</case>
		<case>case <expr><name>RELKIND_AOBLOCKDIR</name></expr>:</case>
		<case>case <expr><name>RELKIND_AOVISIMAP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, sequence, or foreign table"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If the new owner is the same as the existing owner, consider the
	 * command to have succeeded.  This is for dump restoration purposes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name> <operator>!=</operator> <name>newOwnerId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>newAcl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>

		<comment type="block">/* skip permission checks when recursing to index or toast table */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursing</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Superusers can always do it */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceOid</name> <init>= <expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

				<comment type="block">/* Otherwise, must be owner of the existing object */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>target_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Must be able to become new owner */</comment>
				<expr_stmt><expr><call><name>check_is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* New owner must have CREATE privilege on namespace */</comment>
				<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceOid</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>,
												  <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
								   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_class_relowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_class_relowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Determine the modified ACL for the new owner.  This is only
		 * necessary when the ACL is non-null.
		 */</comment>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><name>Anum_pg_class_relacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newAcl</name> <operator>=</operator> <call><name>aclnewowner</name><argument_list>(<argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_class_relacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_class_relacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>newAcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We must similarly update any per-column ACLs to reflect the new
		 * owner; for neatness reasons that's split out as a subroutine.
		 */</comment>
		<expr_stmt><expr><call><name>change_owner_fix_column_acls</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>,
									 <argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
									 <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update owner dependency reference, if any.  A composite type has
		 * none, because it's tracked for the pg_type entry instead of here;
		 * indexes and TOAST tables don't have their own entries either.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>&amp;&amp;</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_TOASTVALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>changeDependencyOnOwner</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>,
									<argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Also change the ownership of the table's row type, if it has one
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AlterTypeOwnerInternal</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we are operating on a table or materialized view, also change
		 * the ownership of any indexes and sequences that belong to the
		 * relation, as well as its toast table (if it has one).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
			<name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name> <operator>||</operator>
			<call><name>IsAppendonlyMetadataRelkind</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>index_oid_list</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

			<comment type="block">/* Find all the indexes belonging to this relation */</comment>
			<expr_stmt><expr><name>index_oid_list</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>target_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* For each index, recursively change its ownership */</comment>
			<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>index_oid_list</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>index_oid_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If it has a toast table, recurse to change its ownership */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tuple_class</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name><name>tuple_class</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>target_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>segrelid</name></decl>, <decl><type ref="prev"/><name>blkdirrelid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>visimap_relid</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>segrelid</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>blkdirrelid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>visimap_relid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If it has an AO segment table, recurse to change its
			 * ownership */</comment>
			<if_stmt><if>if <condition>(<expr><name>segrelid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name>segrelid</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* If it has an AO block directory table, recurse to change its
			 * ownership */</comment>
			<if_stmt><if>if <condition>(<expr><name>blkdirrelid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* If it has an AO visimap table, recurse to change its
			 * ownership */</comment>
			<if_stmt><if>if <condition>(<expr><name>visimap_relid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name>visimap_relid</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If it has dependent sequences, recurse to change them too */</comment>
		<expr_stmt><expr><call><name>change_owner_recurse_to_sequences</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>target_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name>tuple_class</name></expr></argument>)</argument_list></call></expr>
			)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><name>relationOid</name></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"OWNER"</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * change_owner_fix_column_acls
 *
 * Helper function for ATExecChangeOwner.  Scan the columns of the table
 * and fix any non-null column ACLs to reflect the new owner.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>change_owner_fix_column_acls</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldOwnerId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attributeTuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>attRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>, <argument><expr><name>AttributeRelidNumIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attributeTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>newAcl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>,
								<argument><expr><name>Anum_pg_attribute_attacl</name></expr></argument>,
								<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Null ACLs do not require changes */</comment>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newAcl</name> <operator>=</operator> <call><name>aclnewowner</name><argument_list>(<argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>oldOwnerId</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_attribute_attacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_attribute_attacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>newAcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>,
									 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * change_owner_recurse_to_sequences
 *
 * Helper function for ATExecChangeOwner.  Examines pg_depend searching
 * for sequences that are dependent on serial columns, and changes their
 * ownership.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>change_owner_recurse_to_sequences</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>depRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * SERIAL sequences are those having an auto dependency on one of the
	 * table's columns (we don't care *which* column, exactly).
	 */</comment>
	<expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we leave refobjsubid unspecified */</comment>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>depForm</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>seqRel</name></decl>;</decl_stmt>

		<comment type="block">/* skip dependencies other than auto dependencies on columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>depForm</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<name><name>depForm</name><operator>-&gt;</operator><name>classid</name></name> <operator>!=</operator> <name>RelationRelationId</name> <operator>||</operator>
			<name><name>depForm</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>!</operator><operator>(</operator><name><name>depForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_AUTO</name> <operator>||</operator> <name><name>depForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_INTERNAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Use relation_open just in case it's an index */</comment>
		<expr_stmt><expr><name>seqRel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>depForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* skip non-sequence relations */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relkind</name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No need to keep the lock */</comment>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We don't need to close the sequence while we alter it. */</comment>
		<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name><name>depForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now we can close it.  Keep the lock till end of transaction. */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE CLUSTER ON
 *
 * The only thing we have to do is to change the indisclustered bits.
 *
 * Return the address of the new clustering index.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecClusterOn</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexName</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>indexOid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" for table \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>indexName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isBtree</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>oldIndex</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>isBtree</name> <operator>=</operator> <name><name>oldIndex</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BTREE_AM_OID</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>oldIndex</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isBtree</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cluster append-optimized table \"%s\""</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Append-optimized tables can only be clustered against a B-tree index"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/* Check index is valid to cluster on */</comment>
	<expr_stmt><expr><call><name>check_index_is_clusterable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And do the work */</comment>
	<expr_stmt><expr><call><name>mark_index_clustered</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"CLUSTER ON"</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>,
					 <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE SET WITHOUT CLUSTER
 *
 * We have to find any indexes on the table that have indisclustered bit
 * set and turn it off.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecDropCluster</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>mark_index_clustered</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"SET WITHOUT CLUSTER"</literal></expr></argument>
				)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Preparation phase for SET ACCESS METHOD
 *
 * Check that access method exists.  If it is the same as the table's current
 * access method, it is a no-op.  Otherwise, a table rewrite is necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepSetAccessMethod</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>amname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>amoid</name></decl>;</decl_stmt>

	<comment type="block">/* Check that the table access method exists */</comment>
	<expr_stmt><expr><name>amoid</name> <operator>=</operator> <call><name>get_table_am_oid</name><argument_list>(<argument><expr><name>amname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>amoid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Save info for Phase 3 to do the real work */</comment>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>rewrite</name></name> <operator>|=</operator> <name>AT_REWRITE_ACCESS_METHOD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newAccessMethod</name></name> <operator>=</operator> <name>amoid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE SET TABLESPACE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepSetTableSpace</name><parameter_list>(<parameter><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tablespacename</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tablespaceId</name></decl>;</decl_stmt>

	<comment type="block">/* Check that the tablespace exists */</comment>
	<expr_stmt><expr><name>tablespaceId</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check permissions except when moving to database's default */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>tablespaceId</name> <operator>!=</operator> <name>MyDatabaseTableSpace</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_tablespace_aclcheck</name><argument_list>(<argument><expr><name>tablespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_TABLESPACE</name></expr></argument>, <argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Save info for Phase 3 to do the real work */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have multiple SET TABLESPACE subcommands"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>newTableSpace</name></name> <operator>=</operator> <name>tablespaceId</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set, reset, or replace reloptions.
 *
 * GPDB specific arguments: 
 * 	aoopt_changed: whether any AO storage options have been changed in this function.
 * 	newam: the new AM if we will change the table AM. It's InvalidOid if no change is needed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecSetRelOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>defList</name></decl></parameter>, <parameter><decl><type><name>AlterTableType</name></type> <name>operation</name></decl></parameter>,
					<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>aoopt_changed</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newam</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pgclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>newOptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>validnsps</name><index>[]</index></name> <init>= <expr><name>HEAP_RELOPT_NAMESPACES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> 		<name>tableam</name></decl>;</decl_stmt>

	<comment type="block">/* Get the new table AM if applicable. Otherwise get the one from the reltion. */</comment>
	<expr_stmt><expr><name>tableam</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newam</name> <operator>!=</operator> <name>InvalidOid</name><operator>)</operator></expr> ?</condition><then> <expr><name>newam</name></expr> </then><else>: <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>defList</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>operation</name> <operator>!=</operator> <name>AT_ReplaceRelOptions</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><name>pgclass</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch heap tuple */</comment>
	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>AT_ReplaceRelOptions</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we're supposed to replace the reloptions list, we just 
		 * pretend there were none before.
		 */</comment>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Get the old reloptions */</comment>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>defList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>defList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Autovacuum on user tables is not enabled in Greenplum.  Move on
			 * with a warning.  The decision to not error out is in favor of
			 * DDL compatibility with external BI tools.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"autovacuum"</literal></expr></argument>,
							   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"autovaccum"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_FEATURE_NOT_YET</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"autovacuum is not supported in Greenplum"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Generate new proposed reloptions (text array) */</comment>
	<expr_stmt><expr><name>newOptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>datum</name></expr></else></ternary></expr></argument>,
									 <argument><expr><name>defList</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>validnsps</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									 <argument><expr><name>operation</name> <operator>==</operator> <name>AT_ResetRelOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Validate */</comment>
	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
		<case>case <expr><name>RELKIND_AOSEGMENTS</name></expr>:</case>
		<case>case <expr><name>RELKIND_AOBLOCKDIR</name></expr>:</case>
		<case>case <expr><name>RELKIND_AOVISIMAP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IsAccessMethodAO</name><argument_list>(<argument><expr><name>tableam</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>StdRdOptions</name> <modifier>*</modifier></type><name>stdRdOptions</name> <init>= <expr><operator>(</operator><name>StdRdOptions</name> <operator>*</operator><operator>)</operator> <call><name>default_reloptions</name><argument_list>(<argument><expr><name>newOptions</name></expr></argument>,
																				 <argument><expr><name>true</name></expr></argument>,
																				 <argument><expr><name>RELOPT_KIND_APPENDOPTIMIZED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>validateAppendOnlyRelOptions</name><argument_list>(<argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>,
											 <argument><expr><name>gp_safefswritesize</name></expr></argument>,
											 <argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>compresslevel</name></name></expr></argument>,
											 <argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>,
											 <argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>,
											 <argument><expr><name>tableam</name> <operator>==</operator> <name>AO_COLUMN_TABLE_AM_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* If reloptions will be changed, indicate so. */</comment>
				<if_stmt><if>if <condition>(<expr><name>aoopt_changed</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>aoopt_changed</name> <operator>=</operator> <operator>!</operator><call><name>relOptionsEquals</name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><name>newOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>, <argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>view_reloptions</name><argument_list>(<argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>index_reloptions</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_indam</name><operator>-&gt;</operator><name>amoptions</name></name></expr></argument>, <argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, index, or TOAST table"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Special-case validation of view options */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>view_query</name> <init>= <expr><call><name>get_view_query</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>view_options</name> <init>= <expr><call><name>untransformRelOptions</name><argument_list>(<argument><expr><name>newOptions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>check_option</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>view_options</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"check_option"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>check_option</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If the check option is specified, look to see if the view is
		 * actually auto-updatable or not.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>check_option</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>view_updatable_error</name> <init>=
			<expr><call><name>view_query_is_auto_updatable</name><argument_list>(<argument><expr><name>view_query</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>view_updatable_error</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WITH CHECK OPTION is supported only on automatically updatable views"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>view_updatable_error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * All we need do here is update the pg_class row; the new options will be
	 * propagated into relcaches during post-commit cache inval.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>newOptions</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newOptions</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* repeat the whole exercise for the toast table, if there's one */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>toastrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>toastid</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>toastrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>toastid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fetch heap tuple */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>toastid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>toastid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>AT_ReplaceRelOptions</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we're supposed to replace the reloptions list, we just
			 * pretend there were none before.
			 */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Get the old reloptions */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>newOptions</name> <operator>=</operator> <call><name>transformRelOptions</name><argument_list>(<argument><expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name>datum</name></expr></else></ternary></expr></argument>,
										 <argument><expr><name>defList</name></expr></argument>, <argument><expr><literal type="string">"toast"</literal></expr></argument>, <argument><expr><name>validnsps</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										 <argument><expr><name>operation</name> <operator>==</operator> <name>AT_ResetRelOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_reloptions</name><argument_list>(<argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>, <argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>newOptions</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newOptions</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
									 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgclass</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>,
						   <argument><expr><ternary><condition><expr><name>operation</name> <operator>==</operator> <name>AT_ResetRelOptions</name></expr> ?</condition><then> <expr><literal type="string">"RESET"</literal></expr> </then><else>: <expr><literal type="string">"SET"</literal></expr></else></ternary></expr></argument>
				)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute ALTER TABLE SET TABLESPACE for cases where there is no tuple
 * rewriting to be done, so we just want to copy the data as fast as possible.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecSetTableSpace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newTableSpace</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldTableSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>reltoastrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relaosegrelid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relaoblkdirrelid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relaoblkdiridxid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>         <name>relaovisimaprelid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>         <name>relaovisimapidxid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relbmrelid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relbmidxid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>newrelfilenode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>newrnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>rd_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>reltoastidxids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Need lock here in case we are recursing to toast table or index
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No work if no change in tablespace.
	 */</comment>
	<expr_stmt><expr><name>oldTableSpace</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newTableSpace</name> <operator>==</operator> <name>oldTableSpace</name> <operator>||</operator>
		<operator>(</operator><name>newTableSpace</name> <operator>==</operator> <name>MyDatabaseTableSpace</name> <operator>&amp;&amp;</operator> <name>oldTableSpace</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
								  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We cannot support moving mapped relations into different tablespaces.
	 * (In particular this eliminates all shared catalogs.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsMapped</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move system relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Can't move a non-shared relation into pg_global */</comment>
	<if_stmt><if>if <condition>(<expr><name>newTableSpace</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only shared relations can be placed in pg_global tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't allow moving temp tables of other backends ... their local buffer
	 * manager is not going to cope.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>reltoastrelid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
	<comment type="block">/* Fetch the list of indexes on toast relation if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>reltoastrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>toastRel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>reltoastrelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>reltoastidxids</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>toastRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>toastRel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get the ao sub objects */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>GetAppendOnlyEntryAuxOids</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>relaosegrelid</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>relaoblkdirrelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relaoblkdiridxid</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>relaovisimaprelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relaovisimapidxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the bitmap sub objects */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsBitmapIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>GetBitmapIndexAuxOids</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relbmrelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relbmidxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get a modifiable copy of the relation's pg_class row */</comment>
	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>tableOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rd_rel</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Relfilenodes are not unique in databases across tablespaces, so we need
	 * to allocate a new one in the new tablespace.
	 */</comment>
	<expr_stmt><expr><name>newrelfilenode</name> <operator>=</operator> <call><name>GetNewRelFileNode</name><argument_list>(<argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open old and new relation */</comment>
	<expr_stmt><expr><name>newrnode</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrnode</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <name>newrelfilenode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrnode</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <name>newTableSpace</name></expr>;</expr_stmt>

	<comment type="block">/* hand off to AM to actually create the new filenode and copy the data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>index_copy_data</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>newrnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
			   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name> <operator>||</operator>
			   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_AOSEGMENTS</name> <operator>||</operator>
			   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_AOBLOCKDIR</name> <operator>||</operator>
			   <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_AOVISIMAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_relation_copy_data</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newrnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Update the pg_class row.
	 *
	 * NB: This wouldn't work if ATExecSetTableSpace() were allowed to be
	 * executed on pg_class or its indexes (the above copy wouldn't contain
	 * the updated pg_class entry), but that's forbidden above.
	 */</comment>
	<expr_stmt><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newTableSpace</name> <operator>==</operator> <name>MyDatabaseTableSpace</name><operator>)</operator></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>newTableSpace</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>newrelfilenode</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"SET TABLESPACE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure the reltablespace change is visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Move associated toast relation and/or indexes, too */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>reltoastrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><name>reltoastrelid</name></expr></argument>, <argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>reltoastidxids</argument>)</argument_list></macro>
		<expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Move associated ao subobjects */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relaosegrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><name>relaosegrelid</name></expr></argument>, <argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relaoblkdirrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><name>relaoblkdirrelid</name></expr></argument>, <argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relaoblkdiridxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><name>relaoblkdiridxid</name></expr></argument>, <argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relaovisimaprelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><name>relaovisimaprelid</name></expr></argument>, <argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relaovisimapidxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><name>relaovisimapidxid</name></expr></argument>, <argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* 
	 * MPP-7996 - bitmap index subobjects w/Alter Table Set tablespace
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relbmrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>relaosegrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><name>relbmrelid</name></expr></argument>, <argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relbmidxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATExecSetTableSpace</name><argument_list>(<argument><expr><name>relbmidxid</name></expr></argument>, <argument><expr><name>newTableSpace</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>reltoastidxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Special handling of ALTER TABLE SET ACCESS METHOD for relations with no
 * storage that have an interest in preserving AM.
 *
 * Since these relations have no storage the access method can be updated with a
 * simple metadata only operation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecSetAccessMethodNoStorage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newAccessMethod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldrelam</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Shouldn't be called on relations having storage; these are processed in
	 * phase 3.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RELKIND_HAS_STORAGE</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pull the record for this relation and update it */</comment>
	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldrelam</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relam</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relam</name> <operator>=</operator> <name>newAccessMethod</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Record dependency on AM.  This is only required for relations
	 * that have no physical storage.
	 */</comment>
	<expr_stmt><expr><call><name>changeDependencyFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>AccessMethodRelationId</name></expr></argument>, <argument><expr><name>oldrelam</name></expr></argument>,
			<argument><expr><name>newAccessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove the pg_attribute_encoding entries when we are changing the AOCO table to some other AM.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldrelam</name> <operator>==</operator> <name>AO_COLUMN_TABLE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RemoveAttributeEncodingsByRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Make sure the relam change is visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Special handling of ALTER TABLE SET TABLESPACE for relations with no
 * storage that have an interest in preserving tablespace.
 *
 * Since these have no storage the tablespace can be updated with a simple
 * metadata only operation to update the tablespace.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecSetTableSpaceNoStorage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newTableSpace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldTableSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>rd_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Shouldn't be called on relations having storage; these are processed in
	 * phase 3.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RELKIND_HAS_STORAGE</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't allow a non-shared relation in pg_global */</comment>
	<if_stmt><if>if <condition>(<expr><name>newTableSpace</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only shared relations can be placed in pg_global tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No work if no change in tablespace.
	 */</comment>
	<expr_stmt><expr><name>oldTableSpace</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newTableSpace</name> <operator>==</operator> <name>oldTableSpace</name> <operator>||</operator>
		<operator>(</operator><name>newTableSpace</name> <operator>==</operator> <name>MyDatabaseTableSpace</name> <operator>&amp;&amp;</operator> <name>oldTableSpace</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>reloid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get a modifiable copy of the relation's pg_class row */</comment>
	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rd_rel</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update the pg_class row */</comment>
	<expr_stmt><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newTableSpace</name> <operator>==</operator> <name>MyDatabaseTableSpace</name><operator>)</operator></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>newTableSpace</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>reloid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure the reltablespace change is visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Alter Table ALL ... SET TABLESPACE
 *
 * Allows a user to move all objects of some type in a given tablespace in the
 * current database to another tablespace.  Objects can be chosen based on the
 * owner of the object also, to allow users to move only their objects.
 * The user must have CREATE rights on the new tablespace, as usual.   The main
 * permissions handling is done by the lower-level table move function.
 *
 * All to-be-moved objects are locked first. If NOWAIT is specified and the
 * lock can't be acquired then we ereport(ERROR).
 */</comment>
<function><type><name>Oid</name></type>
<name>AlterTableMoveAll</name><parameter_list>(<parameter><decl><type><name>AlterTableMoveAllStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>orig_tablespaceoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>new_tablespaceoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>role_oids</name> <init>= <expr><call><name>roleSpecsToIds</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Ensure we were not asked to move something we can't */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>!=</operator> <name>OBJECT_TABLE</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>!=</operator> <name>OBJECT_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>!=</operator> <name>OBJECT_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only tables, indexes, and materialized views exist in tablespaces"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the orig and new tablespace OIDs */</comment>
	<expr_stmt><expr><name>orig_tablespaceoid</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>orig_tablespacename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_tablespaceoid</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>new_tablespacename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can't move shared relations in to or out of pg_global */</comment>
	<comment type="block">/* This is also checked by ATExecSetTableSpace, but nice to stop earlier */</comment>
	<if_stmt><if>if <condition>(<expr><name>orig_tablespaceoid</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name> <operator>||</operator>
		<name>new_tablespaceoid</name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move relations in to or out of pg_global tablespace"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Must have CREATE rights on the new tablespace, unless it is the
	 * database default tablespace (which all users implicitly have CREATE
	 * rights on).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>new_tablespaceoid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>new_tablespaceoid</name> <operator>!=</operator> <name>MyDatabaseTableSpace</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_tablespace_aclcheck</name><argument_list>(<argument><expr><name>new_tablespaceoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_TABLESPACE</name></expr></argument>,
						   <argument><expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>new_tablespaceoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now that the checks are done, check if we should set either to
	 * InvalidOid because it is our database's default tablespace.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>orig_tablespaceoid</name> <operator>==</operator> <name>MyDatabaseTableSpace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>orig_tablespaceoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>new_tablespaceoid</name> <operator>==</operator> <name>MyDatabaseTableSpace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>new_tablespaceoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* no-op */</comment>
	<if_stmt><if>if <condition>(<expr><name>orig_tablespaceoid</name> <operator>==</operator> <name>new_tablespaceoid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>new_tablespaceoid</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Walk the list of objects in the tablespace and move them. This will
	 * only find objects in our database, of course.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_class_reltablespace</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>orig_tablespaceoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relForm</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relOid</name> <init>= <expr><name><name>relForm</name><operator>-&gt;</operator><name>oid</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Do not move objects in pg_catalog as part of this, if an admin
		 * really wishes to do so, they can issue the individual ALTER
		 * commands directly.
		 *
		 * Also, explicitly avoid any shared tables, temp tables, or TOAST
		 * (TOAST will be moved with the main table).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsCatalogNamespace</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name><name>relForm</name><operator>-&gt;</operator><name>relisshared</name></name> <operator>||</operator>
			<call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>IsToastNamespace</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Only move the object type requested */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>&amp;&amp;</operator>
			 <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
			 <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_INDEX</name> <operator>&amp;&amp;</operator>
			 <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
			 <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_MATVIEW</name> <operator>&amp;&amp;</operator>
			 <name><name>relForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Check if we are only moving objects owned by certain roles */</comment>
		<if_stmt><if>if <condition>(<expr><name>role_oids</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>role_oids</name></expr></argument>, <argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Handle permissions-checking here since we are locking the tables
		 * and also to avoid doing a bunch of work only to fail part-way. Note
		 * that permissions will also be checked by AlterTableInternal().
		 *
		 * Caller must be considered an owner on the table to move it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>nowait</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>ConditionalLockRelationOid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_IN_USE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aborting because lock on relation \"%s.%s\" is not available"</literal></expr></argument>,
							<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Add to our list of objects to move */</comment>
		<expr_stmt><expr><name>relations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relations</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>relations</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_DATA_FOUND</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no matching relations in tablespace \"%s\" found"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><name>orig_tablespaceoid</name> <operator>==</operator> <name>InvalidOid</name></expr> ?</condition><then> <expr><literal type="string">"(database default)"</literal></expr> </then><else>:
						<expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>orig_tablespaceoid</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Everything is locked, loop through and move all of the relations. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_SetTableSpace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>new_tablespacename</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* OID is set by AlterTableInternal */</comment>
		<expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
									<argument><expr><name>DF_CANCEL_ON_ERROR</name><operator>|</operator>
									<name>DF_WITH_SNAPSHOT</name><operator>|</operator>
									<name>DF_NEED_TWO_PHASE</name></expr></argument>,
									<argument><expr><name>NIL</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>new_tablespaceoid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>index_copy_data</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name></type> <name>newrnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>dstrel</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SMgrImpl</name></type> <name>smgr_which</name> <init>= <expr><ternary><condition><expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>SMGR_AO</name></expr> </then><else>: <expr><name>SMGR_MD</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>dstrel</name> <operator>=</operator> <call><name>smgropen</name><argument_list>(<argument><expr><name>newrnode</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_backend</name></name></expr></argument>, <argument><expr><name>smgr_which</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					  
	<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we copy the file directly without looking at the shared buffers,
	 * we'd better first flush out any pages of the source relation that are
	 * in shared buffers.  We assume no new changes will be made while we are
	 * holding exclusive lock on the rel.
	 */</comment>
	<expr_stmt><expr><call><name>FlushRelationBuffers</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create and copy all forks of the relation, and schedule unlinking of
	 * old physical files.
	 *
	 * NOTE: any conflict in relfilenode value will be caught in
	 * RelationCreateStorage().
	 */</comment>
	<expr_stmt><expr><call><name>RelationCreateStorage</name><argument_list>(<argument><expr><name>newrnode</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>, <argument><expr><name>smgr_which</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy main fork */</comment>
	<expr_stmt><expr><call><name>RelationCopyStorage</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>dstrel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>,
						<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy those extra forks that exist */</comment>
	<for>for <control>(<init><decl><type><name>ForkNumber</name></type> <name>forkNum</name> <init>= <expr><name>MAIN_FORKNUM</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</init>
		 <condition><expr><name>forkNum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forkNum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>smgrexists</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>smgrcreate</name><argument_list>(<argument><expr><name>dstrel</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * WAL log creation if the relation is persistent, or this is the
			 * init fork of an unlogged relation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name> <operator>||</operator>
				<operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name> <operator>&amp;&amp;</operator>
				 <name>forkNum</name> <operator>==</operator> <name>INIT_FORKNUM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>log_smgrcreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newrnode</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>, <argument><expr><name>smgr_which</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>RelationCopyStorage</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>dstrel</name></expr></argument>, <argument><expr><name>forkNum</name></expr></argument>,
								<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* drop old relation, and close new one */</comment>
	<expr_stmt><expr><call><name>RelationDropStorage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>dstrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ENABLE/DISABLE TRIGGER
 *
 * We just pass this off to trigger.c.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecEnableDisableTrigger</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigname</name></decl></parameter>,
						   <parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_system</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnableDisableTrigger</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>trigname</name></expr></argument>, <argument><expr><name>fires_when</name></expr></argument>, <argument><expr><name>skip_system</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>subtype</name></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name>fires_when</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr>:</case>
				<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"ENABLE TRIGGER"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>TRIGGER_FIRES_ALWAYS</name></expr>:</case>
				<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"ENABLE ALWAYS TRIGGER"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>TRIGGER_FIRES_ON_REPLICA</name></expr>:</case>
				<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"ENABLE REPLICA TRIGGER"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>TRIGGER_DISABLED</name></expr>:</case>
				<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"DISBLE TRIGGER"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"unknown trigger mode"</literal></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, 
						   <argument><expr><name>subtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ENABLE/DISABLE RULE
 *
 * We just pass this off to rewriteDefine.c.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecEnableDisableRule</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rulename</name></decl></parameter>,
						<parameter><decl><type><name>char</name></type> <name>fires_when</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnableDisableRule</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rulename</name></expr></argument>, <argument><expr><name>fires_when</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE INHERIT
 *
 * Add a parent to the child's parents. This verifies that all the columns and
 * check constraints of the parent appear in the child and that they have the
 * same data types and expressions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATPrepAddInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change inheritance of typed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change inheritance of a partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change inheritance of partitioned table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the address of the new parent relation.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>parent_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigger_name</name></decl>;</decl_stmt>

	<comment type="block">/* 1. Replicated table cannot inherit a parent */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>&amp;&amp;</operator>
		<name><name>child_rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_REPLICATED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Replicated table cannot inherit a parent"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * A self-exclusive lock is needed here.  See the similar case in
	 * MergeAttributes() for a full explanation.
	 */</comment>
	<expr_stmt><expr><name>parent_rel</name> <operator>=</operator> <call><name>table_openrv</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 2. Replicated table cannot be inherited */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>&amp;&amp;</operator>
		<name><name>parent_rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_REPLICATED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Replicated table cannot be inherited"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Must be owner of both parent and child -- child was checked by
	 * ATSimplePermissions call in ATPrepCmd
	 */</comment>
	<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Permanent rels cannot inherit from temporary ones */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from temporary relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* If parent rel is temp, it must belong to this session */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from temporary relation of another session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Ditto for the child */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>child_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>child_rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit to temporary relation of another session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prevent partitioned tables from becoming inheritance parents */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from partitioned table \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Likewise for partitions */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot inherit from a partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Prevent circularity by seeing if proposed parent inherits from child.
	 * (In particular, this disallows making a rel inherit from itself.)
	 *
	 * This is not completely bulletproof because of race conditions: in
	 * multi-level inheritance trees, someone else could concurrently be
	 * making another inheritance link that closes the loop but does not join
	 * either of the rels we have locked.  Preventing that seems to require
	 * exclusive locks on the entire inheritance tree, which is a cure worse
	 * than the disease.  find_all_inheritors() will cope with circularity
	 * anyway, so don't sweat it too much.
	 *
	 * We use weakest lock we can on child's children, namely AccessShareLock.
	 */</comment>
	<expr_stmt><expr><name>children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>children</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"circular inheritance not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is already a child of \"%s\"."</literal></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If child_rel has row-level triggers with transition tables, we
	 * currently don't allow it to become an inheritance child.  See also
	 * prohibitions in ATExecAttachPartition() and CreateTrigger().
	 */</comment>
	<expr_stmt><expr><name>trigger_name</name> <operator>=</operator> <call><name>FindTriggerIncompatibleWithInheritance</name><argument_list>(<argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>trigger_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" prevents table \"%s\" from becoming an inheritance child"</literal></expr></argument>,
						<argument><expr><name>trigger_name</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ROW triggers with transition tables are not supported in inheritance hierarchies."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OK to create inheritance */</comment>
	<expr_stmt><expr><call><name>CreateInheritance</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
					 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* keep our lock on the parent relation until commit */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateInheritance
 *		Catalog manipulation portion of creating inheritance between a child
 *		table and a parent table.
 *
 * Common to ATExecAddInherit() and ATExecAttachPartition().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateInheritance</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalogRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>inheritsTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>inhseqno</name></decl>;</decl_stmt>

	<comment type="block">/* Note: get RowExclusiveLock because we will write pg_inherits below. */</comment>
	<expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for duplicates in the list of parents, and determine the highest
	 * inhseqno already present; we'll use the next one for the new parent.
	 * Also, if proposed child is a partition, it cannot already be
	 * inheriting.
	 *
	 * Note: we do not reject the case where the child already inherits from
	 * the parent indirectly; CREATE TABLE doesn't reject comparable cases.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
				<argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* inhseqno sequences start at 1 */</comment>
	<expr_stmt><expr><name>inhseqno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>inheritsTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_inherits</name></type> <name>inh</name> <init>= <expr><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>inheritsTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>inh</name><operator>-&gt;</operator><name>inhparent</name></name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" would be inherited from more than once"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>inh</name><operator>-&gt;</operator><name>inhseqno</name></name> <operator>&gt;</operator> <name>inhseqno</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inhseqno</name> <operator>=</operator> <name><name>inh</name><operator>-&gt;</operator><name>inhseqno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Match up the columns and bump attinhcount and attislocal */</comment>
	<expr_stmt><expr><call><name>MergeAttributesIntoExisting</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Match up the constraints and bump coninhcount as needed */</comment>
	<expr_stmt><expr><call><name>MergeConstraintsIntoExisting</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * OK, it looks valid.  Make the catalog entries that show inheritance.
	 */</comment>
	<expr_stmt><expr><call><name>StoreCatalogInheritance1</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>inhseqno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>catalogRelation</name></expr></argument>,
							 <argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator>
							 <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now we're done with pg_inherits */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain the source-text form of the constraint expression for a check
 * constraint, given its pg_constraint tuple
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>decompile_conbin</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>contup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>expr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>contup</name></expr></argument>, <argument><expr><name>Anum_pg_constraint_conbin</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conbin for constraint %u"</literal></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>pg_get_expr</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>,
							   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine whether two check constraints are functionally equivalent
 *
 * The test we apply is to see whether they reverse-compile to the same
 * source string.  This insulates us from issues like whether attributes
 * have the same physical column numbers in parent and child relations.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>constraints_equivalent</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>acon</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>bcon</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>acon</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>!=</operator> <name><name>bcon</name><operator>-&gt;</operator><name>condeferrable</name></name> <operator>||</operator>
		<name><name>acon</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>!=</operator> <name><name>bcon</name><operator>-&gt;</operator><name>condeferred</name></name> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><call><name>decompile_conbin</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><call><name>decompile_conbin</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check columns in child table match up with columns in parent, and increment
 * their attinhcount.
 *
 * Called by CreateInheritance
 *
 * Currently all parent columns must be found in child. Missing columns are an
 * error.  One day we might consider creating new columns like CREATE TABLE
 * does.  However, that is widely unpopular --- in the common use case of
 * partitioned tables it's a foot-gun.
 *
 * The data type must match exactly. If the parent column is NOT NULL then
 * the child must be as well. Defaults are not compared, however.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MergeAttributesIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>parent_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>parent_natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>child_is_partition</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>attrrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_natts</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<comment type="block">/* If parent_rel is a partitioned table, child_rel must be a partition */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>child_is_partition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>parent_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>parent_attno</name> <operator>&lt;=</operator> <name>parent_natts</name></expr>;</condition> <incr><expr><name>parent_attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
													<argument><expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped columns in the parent. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Find same column in child (matching on column name). */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopyAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Check they are same type, typmod, and collation */</comment>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>childatt</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
				<name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different type for column \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>!=</operator> <name><name>childatt</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_COLLATION_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different collation for column \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Check child doesn't discard NOT NULL property.  (Other
			 * constraints are checked elsewhere.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>childatt</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" in child table must be marked NOT NULL"</literal></expr></argument>,
								<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * OK, bump the child column's inheritance count.  (If we fail
			 * later on, this change will just roll back.)
			 */</comment>
			<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * In case of partitions, we must enforce that value of attislocal
			 * is same in all partitions. (Note: there are only inherited
			 * attributes in partitions)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>child_is_partition</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childatt</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>childatt</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table is missing column \"%s\""</literal></expr></argument>,
							<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check constraints in child table match up with constraints in parent,
 * and increment their coninhcount.
 *
 * Constraints that are marked ONLY in the parent are ignored.
 *
 * Called by CreateInheritance
 *
 * Currently all constraints in parent must be present in the child. One day we
 * may consider adding new constraints like CREATE TABLE does.
 *
 * XXX This is O(N^2) which may be an issue with tables with hundreds of
 * constraints. As long as tables have more like 10 constraints it shouldn't be
 * a problem though. Even 100 constraints ought not be the end of the world.
 *
 * XXX See MergeWithExistingConstraint too if you change this code.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MergeConstraintsIntoExisting</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalog_relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tuple_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>parent_scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>parent_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>parent_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>child_is_partition</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>catalog_relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple_desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If parent_rel is a partitioned table, child_rel must be a partition */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>child_is_partition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Outer loop scans through the parent's constraint definitions */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent_key</name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent_scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>parent_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>parent_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>parent_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>parent_con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>parent_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>child_scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>child_key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>child_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parent_con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* if the parent's constraint is marked NO INHERIT, it's not inherited */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parent_con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Search for a child constraint matching this one */</comment>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>child_key</name></expr></argument>,
					<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>child_scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>child_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>child_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>child_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>child_con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>child_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>child_copy</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>child_con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>parent_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>child_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>constraints_equivalent</name><argument_list>(<argument><expr><name>parent_tuple</name></expr></argument>, <argument><expr><name>child_tuple</name></expr></argument>, <argument><expr><name>tuple_desc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table \"%s\" has different definition for check constraint \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>parent_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* If the child constraint is "no inherit" then cannot merge */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>child_con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" conflicts with non-inherited constraint on child table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>child_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If the child constraint is "not valid" then cannot merge with a
			 * valid parent constraint
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parent_con</name><operator>-&gt;</operator><name>convalidated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>child_con</name><operator>-&gt;</operator><name>convalidated</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" conflicts with NOT VALID constraint on child table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>child_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * OK, bump the child constraint's inheritance count.  (If we fail
			 * later on, this change will just roll back.)
			 */</comment>
			<expr_stmt><expr><name>child_copy</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>child_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>child_con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>child_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>child_con</name><operator>-&gt;</operator><name>coninhcount</name></name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * In case of partitions, an inherited constraint must be
			 * inherited only once since it cannot have multiple parents and
			 * it is never considered local.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>child_is_partition</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>child_con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>child_con</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>child_copy</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>child_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>child_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>child_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child table is missing constraint \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>parent_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>parent_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>catalog_relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE NO INHERIT
 *
 * Return value is the address of the relation that is no longer parent.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDropInherit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>parent_rel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change inheritance of a partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * AccessShareLock on the parent is probably enough, seeing that DROP
	 * TABLE doesn't lock parent tables at all.  We need some lock since we'll
	 * be inspecting the parent's schema.
	 */</comment>
	<expr_stmt><expr><name>parent_rel</name> <operator>=</operator> <call><name>table_openrv</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't bother to check ownership of the parent table --- ownership of
	 * the child is presumed enough rights.
	 */</comment>

	<comment type="block">/* Off to RemoveInheritance() where most of the work happens */</comment>
	<expr_stmt><expr><call><name>RemoveInheritance</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
					 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* keep our lock on the parent relation until commit */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <call><name>MetaTrackValidKindNsp</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ALTER"</literal></expr></argument>, <argument><expr><literal type="string">"NO INHERIT"</literal></expr></argument>
		)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RemoveInheritance
 *
 * Drop a parent from the child's parents. This just adjusts the attinhcount
 * and attislocal of the columns and removes the pg_inherit and pg_depend
 * entries.
 *
 * If attinhcount goes to 0 then attislocal gets set to true. If it goes back
 * up attislocal stays true, which means if a child is ever removed from a
 * parent then its columns will never be automatically dropped which may
 * surprise. But at least we'll never surprise by dropping columns someone
 * isn't expecting to be dropped which would actually mean data loss.
 *
 * coninhcount and conislocal for inherited constraints are adjusted in
 * exactly the same way.
 *
 * Common to ATExecDropInherit() and ATExecDetachPartition().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveInheritance</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>child_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalogRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attributeTuple</name></decl>,
				<decl><type ref="prev"/><name>constraintTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>connames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>child_is_partition</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If parent_rel is a partitioned table, child_rel must be a partition */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>child_is_partition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>DeleteInheritsTuple</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>child_is_partition</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" is not a partition of relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" is not a parent of relation \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Search through child columns looking for ones matching parent rel
	 */</comment>
	<expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>AttributeRelidNumIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attributeTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore if dropped or not inherited */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExistsAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Decrement inhcount and possibly set islocal to true */</comment>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copyTuple</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>copy_att</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>copy_att</name><operator>-&gt;</operator><name>attinhcount</name></name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>copy_att</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>copy_att</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Likewise, find inherited check constraints and disinherit them. To do
	 * this, we first need a list of the names of the parent's check
	 * constraints.  (We cheat a bit by only checking for name matches,
	 * assuming that the expressions will match.)
	 */</comment>
	<expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>connames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>constraintTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>constraintTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>connames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connames</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now scan the child's constraints */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>constraintTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>constraintTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>match</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>connames</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Decrement inhcount and possibly set islocal to true */</comment>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>copyTuple</name> <init>= <expr><call><name>heap_copytuple</name><argument_list>(<argument><expr><name>constraintTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>copy_con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>copy_con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation %u has non-inherited constraint \"%s\""</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>copy_con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>coninhcount</name></name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>copy_con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>copy_con</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>copyTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>drop_parent_dependency</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>child_dependency_type</name><argument_list>(<argument><expr><name>child_is_partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Post alter hook of this inherits. Since object_access_hook doesn't take
	 * multiple object identifiers, we relay oid of parent relation using
	 * auxiliary_id argument.
	 */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>,
								 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Drop the dependency created by StoreCatalogInheritance1 (CREATE TABLE
 * INHERITS/ALTER TABLE INHERIT -- refclassid will be RelationRelationId) or
 * heap_create_with_catalog (CREATE TABLE OF/ALTER TABLE OF -- refclassid will
 * be TypeRelationId).  There's no convenient way to do this, so go trawling
 * through pg_depend.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>drop_parent_dependency</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refclassid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refobjid</name></decl></parameter>,
					   <parameter><decl><type><name>DependencyType</name></type> <name>deptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalogRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>depTuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_classid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_objid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_objsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>DependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>depTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>dep</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dep</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>==</operator> <name>refclassid</name> <operator>&amp;&amp;</operator>
			<name><name>dep</name><operator>-&gt;</operator><name>refobjid</name></name> <operator>==</operator> <name>refobjid</name> <operator>&amp;&amp;</operator>
			<name><name>dep</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>dep</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>deptype</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>depTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update the pg_attribute entries of dropped columns in given relation,
 * as if they were of type int4.
 *
 * This is used by ALTER TABLE SET DISTRIBUTED BY, which swaps the
 * relation file with a newly constructed temp table. The temp table is
 * constructed with int4 columns standing in for the dropped columns,
 * and this function is used to update the original table's definition
 * to match that.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>change_dropped_col_datatypes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalogRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Loop through all dropped columns.
	 */</comment>
	<expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>AttributeRelidNumIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>copyTuple</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>att</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&lt;=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>copyTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>att</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attndims</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>copyTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build:
 *
 * CREATE TABLE pg_temp_&lt;NNNN&gt; AS SELECT * FROM rel
 *   DISTRIBUTED BY dist_clause
 */</comment>
<function><type><specifier>static</specifier> <name>QueryDesc</name> <modifier>*</modifier></type>
<name>build_ctas_with_dist</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>DistributedBy</name> <modifier>*</modifier></type><name>dist_clause</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>storage_opts</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier><modifier>*</modifier></type><name>tmprv</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>useExistingColumnAttributes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>from_tbl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rewritten</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>tmprel</name> <init>= <expr><call><name>make_temp_table_name</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pre_built</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IntoClause</name>	<modifier>*</modifier></type><name>into</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnRef</name> 		   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>c</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Use a dummy NULL::int4 column to stand in for any dropped columns. */</comment>
			<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>from_tbl</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>from_tbl</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	   <comment type="block">/* MPP-5300: turn off inheritance -
								* Otherwise, the data from the child
								* tables is added to the parent!
								*/</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>from_tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pre_built</name> <operator>=</operator> <call><name>prebuild_temp_table</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tmprel</name></expr></argument>, <argument><expr><name>dist_clause</name></expr></argument>,
									<argument><expr><call><name>get_am_name</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>storage_opts</name></expr></argument>,
									<argument><expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>useExistingColumnAttributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pre_built</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>InsertStmt</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>InsertStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>tmprel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>selectStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>s</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>i</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>tblspc</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>q_list</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p_list</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>ctas</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>into</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IntoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>into</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>tmprel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>into</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <call><name>get_am_name</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>into</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>storage_opts</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>into</name><operator>-&gt;</operator><name>tableSpaceName</name></name> <operator>=</operator> <call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>tblspc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>into</name><operator>-&gt;</operator><name>distributedBy</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>dist_clause</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>RelationIsAoRows</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In order to avoid being affected by the GUC of gp_default_storage_options,
			 * we should re-build storage options from original table.
			 *
			 * The reason is that when we use the default parameters to create a table,
			 * the configuration will not be written to pg_class.reloptions, and then if
			 * gp_default_storage_options is modified, the newly created table will be
			 * inconsistent with the original table.
			 */</comment>
			<expr_stmt><expr><name><name>into</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>build_ao_rel_storage_opts</name><argument_list>(<argument><expr><name><name>into</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>=</operator> <name>into</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>rawstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>s</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>q_list</name> <operator>=</operator> <call><name>pg_analyze_and_rewrite</name><argument_list>(<argument><expr><name>rawstmt</name></expr></argument>, <argument><expr><name>synthetic_sql</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p_list</name> <operator>=</operator> <call><name>pg_plan_queries</name><argument_list>(<argument><expr><name>q_list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>, <argument><expr><name>p_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ctas</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>CreateTableAsStmt</name></expr></argument>, <argument><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>ctas</name><operator>-&gt;</operator><name>query</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>tmprv</name> <operator>=</operator> <name>tmprel</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pre_built</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>rawstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>parse_analyze</name><argument_list>(<argument><expr><name>rawstmt</name></expr></argument>, <argument><expr><name>synthetic_sql</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>q</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>n</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>AcquireRewriteLocks</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Rewrite through rule system */</comment>
	<expr_stmt><expr><name>rewritten</name> <operator>=</operator> <call><name>QueryRewrite</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We don't expect more or less than one result query */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>rewritten</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>rewritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>||</operator> <name><name>q</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* plan the query */</comment>
	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>planner</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>intoClause</name></name> <operator>=</operator> <name>into</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update snapshot command ID to ensure this query sees results of any
	 * previously executed queries.
	 */</comment>
	<expr_stmt><expr><call><name>PushCopiedSnapshot</name><argument_list>(<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UpdateActiveSnapshotCommandId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create dest receiver for COPY OUT */</comment>
	<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestIntoRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a QueryDesc requesting no output */</comment>
	<expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>,
								<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
								<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>GP_INSTRUMENT_OPTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>queryDesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GPDB: Convenience function to get reloptions for a given relation.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>get_rel_opts</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>newOptions</name> <init>= <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get the old reloptions */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>optsTuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>optsTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>optsTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newOptions</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>optsTuple</name></expr></argument>,
								 <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* take a copy since we're using it after ReleaseSysCache() */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newOptions</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>newOptions</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>optsTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newOptions</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GPDB: Convenience function to clear the pg_class.reloptions field for a given relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_rel_opts</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>           <name><name>val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>            <name><name>null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>            <name><name>repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> 	<name>classrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> 	<name>tup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>classrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>val</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>null</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repl</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>classrel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>val</name></expr></argument>, <argument><expr><name>null</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>classrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>classrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RangeVar</name> <modifier>*</modifier></type>
<name>make_temp_table_name</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BackendId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tmpname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>tmprel</name></decl>;</decl_stmt>

	<comment type="block">/* temporary enough */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpname</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"pg_temp_%u_%i"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmprel</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>tmpname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure the temp relation has the same persistence setting with the
	 * original relation.
	 */</comment>
	<expr_stmt><expr><name><name>tmprel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>

	<return>return <expr><name>tmprel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If the table has dropped columns, we must create the table and
 * drop the columns before we can dispatch the select statement.
 * Return true if we do it, false if we do not. If we return false,
 * there are no dropped columns and we can do a SELECT INTO later.
 * If we need to do it, but fail, issue an error. (See make_type.)
 *
 * Specifically for build_ctas_with_dist.
 *
 * Note that the caller should guarantee that isTmpTableAo has
 * a value that matches 'opts'.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prebuild_temp_table</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>tmpname</name></decl></parameter>, <parameter><decl><type><name>DistributedBy</name> <modifier>*</modifier></type><name>distro</name></decl></parameter>,
					<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>amname</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>isTmpTableAo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useExistingColumnAttributes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>need_rebuild</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* 
	 * We cannot CTAS and do per column compression for AO_COLUMN tables so we need
	 * to CREATE and then INSERT.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>need_rebuild</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_rebuild</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>need_rebuild</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the new table is an AO table with indexes, always use
	 * Create Table + Insert Into. During Create Table phase,
	 * we determine whether to create the block directory
	 * depending on whether the original table has indexes. It is
	 * important to create the block directory to support the reindex
	 * later. See MPP-9545 for more info.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isTmpTableAo</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>need_rebuild</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_rebuild</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>cs</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><name>None_Receiver</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>col_encs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>relKind</name></name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <name>amname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>distributedBy</name></name> <operator>=</operator> <name>distro</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>tmpname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>ownerid</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>tablespacename</name></name> <operator>=</operator> <call><name>get_tablespace_name</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>buildAoBlkdir</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>gp_style_alter_part</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isTmpTableAo</name> <operator>&amp;&amp;</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>buildAoBlkdir</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>opts</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationIsAoRows</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			* In order to avoid being affected by the GUC of gp_default_storage_options,
			* we should re-build storage options from original table.
			*
			* The reason is that when we use the default parameters to create a table,
			* the configuration will not be written to pg_class.reloptions, and then if
			* gp_default_storage_options is modified, the newly created table will be
			* inconsistent with the original table.
			*/</comment>
			<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>build_ao_rel_storage_opts</name><argument_list>(<argument><expr><name><name>cs</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>useExistingColumnAttributes</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>col_encs</name> <operator>=</operator> <call><name>RelationGetUntransformedAttributeOptions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>tname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Use dummy int4 columns to stand in for dropped columns.
				 * We cannot easily reconstruct the original layout, because
				 * we don't know what the original datatype was, and it might
				 * not even exist anymore. This means that the temp table is
				 * not binary-compatible with the old table. We will fix that
				 * by updating the catalogs of the original table, to match
				 * the temp table we build here, before swapping the relation
				 * files.
				 */</comment>
				<expr_stmt><expr><name>tname</name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>Type</name></type> <name>typ</name> <init>= <expr><call><name>typeidType</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>typnamespace</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typ</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>typnamespace</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>typnamespace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>arno</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>typstr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type> <name>ndims</name> <init>= <expr><name><name>att</name><operator>-&gt;</operator><name>attndims</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>tname</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not lookup namespace %d"</literal></expr></argument>, <argument><expr><name>typnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>typstr</name> <operator>=</operator> <call><name>typeTypeName</name><argument_list>(<argument><expr><name>typ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tname</name><operator>-&gt;</operator><name>names</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>typstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tname</name><operator>-&gt;</operator><name>typemod</name></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * If this is a built in array type, like _int4, then reduce
				 * the array dimensions by 1. This is an annoying postgres
				 * hack which I wish would go away.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>typstr</name> <operator>&amp;&amp;</operator> <name><name>typstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <name>ndims</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>ndims</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<for>for <control>(<init><expr><name>arno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>arno</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>arno</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<comment type="block">/* bound of -1 are fine because this has no effect on data */</comment>
					<expr_stmt><expr><name><name>tname</name><operator>-&gt;</operator><name>arrayBounds</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>tname</name><operator>-&gt;</operator><name>arrayBounds</name></name></expr></argument>,
												 <argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Per column encoding settings */</comment>
			<if_stmt><if>if <condition>(<expr><name>col_encs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name><name>col_encs</name><index>[<expr><name>attno</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>tname</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <name>tname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cs</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cs</name><operator>-&gt;</operator><name>tableElts</name></name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<decl_stmt><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>rawstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RawStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawstmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>parse_analyze</name><argument_list>(<argument><expr><name>rawstmt</name></expr></argument>, <argument><expr><name>synthetic_sql</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* No planning needed, just make a wrapper PlannedStmt */</comment>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>q</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>rawstmt</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>rawstmt</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>,
					   <argument><expr><name>synthetic_sql</name></expr></argument>,
					   <argument><expr><name>PROCESS_UTILITY_SUBCOMMAND</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>,
					   <argument><expr><name>dest</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>need_rebuild</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Build a human readable tag for what we're doing */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>make_distro_str</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>lwith</name></decl></parameter>, <parameter><decl><type><name>DistributedBy</name> <modifier>*</modifier></type><name>ldistro</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>distro_str</name> <init>= <expr><literal type="string">"SET WITH DISTRIBUTED BY"</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lwith</name> <operator>&amp;&amp;</operator> <name>ldistro</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>distro_str</name> <operator>=</operator> <literal type="string">"SET WITH DISTRIBUTED BY"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lwith</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>distro_str</name> <operator>=</operator> <literal type="string">"SET WITH"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>ldistro</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>distro_str</name> <operator>=</operator> <literal type="string">"SET DISTRIBUTED BY"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>distro_str</name></expr></argument>)</argument_list></call></expr>;</return> <comment type="block">/* don't return a stack address */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a new DISTRIBUTED BY clause is compatible with existing indexes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkPolicyCompatibleWithIndexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>pol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexoidlist</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>pol</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pol</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Loop over all indexes on the relation */</comment>
	<macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indisprimary</name></name> <operator>||</operator>
			<name><name>indexStruct</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>||</operator>
			<name><name>indexStruct</name><operator>-&gt;</operator><name>indisexclusion</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int2vector</name> <modifier>*</modifier></type><name>indkey</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>exclops</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>indkey</name> <operator>=</operator> <operator>&amp;</operator><name><name>indexStruct</name><operator>-&gt;</operator><name>indkey</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>,
									<argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indisexclusion</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_constr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>conrec</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintId</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elems</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nElems</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * For an exclusion constraint, we need to extract the operator OIDs
				 * from pg_constraint
				 */</comment>
				<expr_stmt><expr><name>constraintId</name> <operator>=</operator> <call><name>get_index_constraint</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>constraintId</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find pg_constraint entry for index %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>ht_constr</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>,
											<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_constr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>,
						 <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>conrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>ht_constr</name></expr></argument>,
										<argument><expr><name>Anum_pg_constraint_conexclop</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conexclop for constraint %u"</literal></expr></argument>,
						 <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>elems</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>exclops</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nElems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nElems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>exclops</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>index_check_policy_compatible_context</name></type> <name>ctx</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>for_alter_dist_policy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>is_constraint</name></name> <operator>=</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>;</expr_stmt> <comment type="block">/* unknown */</comment>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>is_unique</name></name> <operator>=</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indisunique</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>is_primarykey</name></name> <operator>=</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>constraint_name</name></name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>index_check_policy_compatible</name><argument_list>(<argument><expr><name>pol</name></expr></argument>,
												 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name><name>indkey</name><operator>-&gt;</operator><name>values</name></name></expr></argument>,
												 <argument><expr><name><name>indclass</name><operator>-&gt;</operator><name>values</name></name></expr></argument>,
												 <argument><expr><name>exclops</name></expr></argument>,
												 <argument><expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr></argument>,
												 <argument><expr><name>true</name></expr></argument>, <comment type="block">/* report_error */</comment>
												 <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>exclops</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>exclops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE EXPAND TABLE
 *
 * Update a table's "numsegments" value to current cluster size, and move
 * data as needed to the new segments.
 *
 * There are currently only one way we can perform EXPAND TABLE:
 *
 * 1. Create a whole new relation file, with the new 'numsegments', copy all
 *    the data to the new reltion file, and swap it in place of the old one.
 *    This is called the "CTAS method", because it uses a CREATE TABLE AS
 *    command internally to create the new physical relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecExpandTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlteredTableInfo</name>	<modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name>		<modifier>*</modifier></type><name>rootCmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>		<name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>					<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpPolicy</name>			<modifier>*</modifier></type><name>newPolicy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpPolicy</name>			<modifier>*</modifier></type><name>policy</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"EXPAND not supported in utility mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Permissions checks */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_TABLE</name></expr></argument>,
					   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Can't ALTER TABLE SET system catalogs */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
			<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newPolicy</name> <operator>=</operator> <call><name>GpPolicyCopy</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><operator>*</operator><name>wqueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rootCmd</name> <operator>=</operator> <operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>subcmds</name><index>[<expr><name>AT_PASS_MISC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Nothing to do on a partitioned table. But we better recurse to the
		 * child partitions.
		 */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>rel_is_external_table</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExtTableEntry</name> <modifier>*</modifier></type><name>ext</name> <init>= <expr><call><name>GetExtTableEntry</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ext</name><operator>-&gt;</operator><name>iswritable</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Skip expanding readable external table, since data is not
				 * located inside gpdb
				 */</comment>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Skip expanding foreign table, since data is not located inside gpdb */</comment>
			<return>return;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ATExecExpandTableCTAS</name><argument_list>(<argument><expr><name>rootCmd</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Update numsegments to cluster size */</comment>
	<expr_stmt><expr><name><name>newPolicy</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GpPolicyReplace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>newPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE xxx EXPAND PARTITION PREPARE
 *
 * Update a partition table's "numsegments" value to current cluster size,
 * change policy type of leaf partitions to randomly,
 * the policy type of root and interior partitions are the same as before.
 *
 * For external(foreign) tables, only writable external tables have distribution
 * policy. So for writable external leaf partitions, expansion is finished during
 * prepare stage (the following functon) by simply updating numsegments field
 * in policy. For other external(foreign) tables, just ignore them.
 *
 * After we expand partition prepare from 2 segments to 3 segments, 
 * possible distribution policies of partition table:
 * a) original policy type is randomly:
 *    new policy type of all root/interior/leaf partitions are randomly on 3 segments
 * b) original policy type is hashed:
 *    new policy type of root/interior partitions are hashed on 3 segments
 *    and new policy type of leaf partitions are randomly on 3 segments
 *
 * @param rel the parent or leaf of partition table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecExpandPartitionTablePrepare</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>       <name>new_numsegments</name> <init>= <expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>       <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsRandomPartitioned</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GpPolicy</name>	 <modifier>*</modifier></type><name>new_policy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * we only change numsegments for root/interior/leaf partitions distributed randomly
		 * and root/interior partitions distributed by hash, and change the numsegments of policy to
		 * current cluster size
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_policy</name> <operator>=</operator> <call><name>GpPolicyCopy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_policy</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name>new_numsegments</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>GpPolicyReplace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>new_policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We should make the policy between on-disk catalog and on-memory relation cache consistently */</comment>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>=</operator> <name>new_policy</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For external|foreign leaves, only writable external
			 * table has policy entry and need to be handled.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>rel_is_external_table</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExtTableEntry</name> <modifier>*</modifier></type><name>ext</name> <init>= <expr><call><name>GetExtTableEntry</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ext</name><operator>-&gt;</operator><name>iswritable</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>GpPolicy</name>	 <modifier>*</modifier></type><name>new_policy</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

					<comment type="block">/* Just modify the numsegments for external writable leaves */</comment>
					<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>new_policy</name> <operator>=</operator> <call><name>GpPolicyCopy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>new_policy</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name>new_numsegments</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>GpPolicyReplace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>new_policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* We should make the policy between on-disk catalog and on-memory relation cache consistently */</comment>
					<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>=</operator> <name>new_policy</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>GpPolicy</name>	 <modifier>*</modifier></type><name>new_policy</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

			<comment type="block">/* we change policy type to randomly for regular leaf partitions distributed by hash */</comment>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_policy</name> <operator>=</operator> <call><name>createRandomPartitionedPolicy</name><argument_list>(<argument><expr><name>new_numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>GpPolicyReplace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>new_policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* We should make the policy between on-disk catalog and on-memory relation cache consistently */</comment>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>=</operator> <name>new_policy</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecExpandTableCTAS</name><parameter_list>(<parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>rootCmd</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>			<modifier>*</modifier></type><name>tmprv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>					<name>tmprelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>					<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*--
	 * a) Ensure that the proposed policy is sensible
	 * b) Create a temporary table and reorganise data according to our desired
	 *    distribution policy. To do this, we build a Query node which express
	 *    the query:
	 *    CREATE TABLE tmp_tab_nam AS SELECT * FROM cur_table DISTRIBUTED BY (policy)
	 * c) Execute the query across all nodes
	 * d) Update our parse tree to include the details of the newly created
	 *    table
	 * e) Update the ownership of the temporary table
	 * f) Swap the relfilenodes of the existing table and the temporary table
	 * g) Update the policy on the QD to reflect the underlying data
	 * h) Drop the temporary table -- and with it, the old copy of the data
	 *--
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AutoStatsCmdType</name></type>	<name>cmdType</name> <init>= <expr><name>AUTOSTATS_CMDTYPE_SENTINEL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DistributedBy</name>		<modifier>*</modifier></type><name>distby</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QueryDesc</name>			<modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>					<name>relationOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> 				<name>saveOptimizerGucValue</name></decl>;</decl_stmt><empty_stmt>;</empty_stmt>

		<comment type="block">/* Step (a) */</comment>
		<comment type="block">/*
		 * Force the use of Postgres query optimizer, since Pivotal Optimizer (GPORCA) will not
		 * redistribute the tuples if the current and required distributions
		 * are both RANDOM even when reorganize is set to "true"
		 */</comment>
		<expr_stmt><expr><name>saveOptimizerGucValue</name> <operator>=</operator> <name>optimizer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>optimizer</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Step (b) - build CTAS */</comment>
		<expr_stmt><expr><name>distby</name> <operator>=</operator> <call><name>make_distributedby_for_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>distby</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>build_ctas_with_dist</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>distby</name></expr></argument>,
						<argument><expr><call><name>untransformRelOptions</name><argument_list>(<argument><expr><call><name>get_rel_opts</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>tmprv</name></expr></argument>,
						<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We need to update our snapshot here to make sure we see all
		 * committed work. We have an exclusive lock on the table so no one
		 * will be able to access the table now.
		 */</comment>
		<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Step (c) - run on all nodes */</comment>
		<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>QueryDispatchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name><operator>-&gt;</operator><name>useChangedAOOpts</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>query_mem</name></name> <operator>=</operator>
				<call><name>ResourceManagerGetQueryMemoryLimit</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>autostats_get_cmdtype</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmdType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>rDestroy</name></name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>auto_stats</name><argument_list>(<argument><expr><name>cmdType</name></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Restore the old snapshot */</comment>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>optimizer</name> <operator>=</operator> <name>saveOptimizerGucValue</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* see the effects of the command */</comment>

		<comment type="block">/*
		 * Step (d) - tell the seg nodes about the temporary relation.
		 */</comment>
		<comment type="block">/*
		 * Store the dispatch info in the command so that it gets sent to the QEs.
		 * We add one to it, so that '0' isn't a valid value. Makes it easier
		 * to sanity check that it's set in the QEs.
		 */</comment>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>backendId</name></name> <operator>=</operator> <name>MyBackendId</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>backendId</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"did not receive backend ID info from QD for EXPAND TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tmprv</name> <operator>=</operator> <call><name>make_temp_table_name</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>backendId</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot perform EXPAND TABLE in utility mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Step (e) - Correct ownership on temporary table:
	 *   necessary so that the toast tables/indices have the correct
	 *   owner after we swap them.
	 *
	 * Note: ATExecChangeOwner does NOT dispatch, so this does not
	 * belong in the dispatch block above (MPP-9663).
	 */</comment>
	<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>tmprv</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* see the effects of the command */</comment>

	<comment type="block">/*
	 * Update pg_attribute for dropped columns. The temp table we built
	 * uses int4 to stand in for any dropped columns, so we need to update
	 * the original table's definition to match the new contents.
	 */</comment>
	<expr_stmt><expr><call><name>change_dropped_col_datatypes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Step (f) - swap relfilenodes and MORE !!!
	 */</comment>
	<expr_stmt><expr><name>tmprelid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>tmprv</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>swap_relation_files</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>tmprelid</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>, <comment type="block">/* target_is_pg_class */</comment>
						<argument><expr><name>false</name></expr></argument>, <comment type="block">/* swap_toast_by_content */</comment>
						<argument><expr><name>false</name></expr></argument>, <comment type="block">/* swap_stats */</comment>
						<argument><expr><name>true</name></expr></argument>,
						<argument><expr><name>RecentXmin</name></expr></argument>,
						<argument><expr><call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make changes from swapping relation files visible before updating
	 * options below or else we get an already updated tuple error.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now, reindex */</comment>
	<expr_stmt><expr><call><name>reindex_relation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Step (h) Drop the table */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>tmprelid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE SET DISTRIBUTED BY
 *
 * set distribution policy for rel
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecSetDistributedBy</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> 	   <modifier>*</modifier></type><name>lprime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> 	   <modifier>*</modifier></type><name>lwith</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedBy</name> <modifier>*</modifier></type><name>ldistro</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cols</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>policy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>tmprv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tmprelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tarrelid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>rand_pol</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>rep_pol</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>force_reorg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_reorg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>change_policy</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 				<name>save_optimizer_replicated_table_insert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>					<name>relationOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AutoStatsCmdType</name></type> 	<name>cmdType</name> <init>= <expr><name>AUTOSTATS_CMDTYPE_SENTINEL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Can't ALTER TABLE SET system catalogs */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
			<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lprime</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>

	<comment type="block">/* 
	 * First element is the WITH clause, second element is the actual
	 * distribution clause.
	 */</comment>
	<expr_stmt><expr><name>lwith</name>   <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name>lprime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ldistro</name> <operator>=</operator> <operator>(</operator><name>DistributedBy</name> <operator>*</operator><operator>)</operator><call><name>lsecond</name><argument_list>(<argument><expr><name>lprime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SET DISTRIBUTED BY not supported in utility mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/*
	 * SET DISTRIBUTED BY only change the distribution policy, but should not
	 * change numsegments, keep the old value.
	 */</comment>
	<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name>ldistro</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ldistro</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name>numsegments</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* we only support partitioned/replicated tables */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsEntry</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s not supported on non-distributed tables"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><name>ldistro</name></expr> ?</condition><then> <expr><literal type="string">"SET DISTRIBUTED BY"</literal></expr> </then><else>: <expr><literal type="string">"SET WITH"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lwith</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>reorg_str</name> <init>= <expr><literal type="string">"reorganize"</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>nlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>lwith</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify more than one option in WITH clause"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>lwith</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>reorg_str</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>def</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>force_reorg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"TRUE"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>force_reorg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"FALSE"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>force_reorg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid REORGANIZE option"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Valid REORGANIZE options are \"true\" or \"false\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option \"%s\" not supported"</literal></expr></argument>,
								<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>lwith</name> <operator>=</operator> <name>nlist</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* External tables cannot really be re-organized. Error out if we are instructed to do so.*/</comment>
		<if_stmt><if>if <condition>(<expr><name>force_reorg</name> <operator>&amp;&amp;</operator> <call><name>rel_is_external_table</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reorganize external table \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ldistro</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>change_policy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ldistro</name> <operator>&amp;&amp;</operator> <name><name>ldistro</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name> <operator>&amp;&amp;</operator> <name><name>ldistro</name><operator>-&gt;</operator><name>keyCols</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>hasPrimaryKey</name> <init>= <expr><call><name>relationHasPrimaryKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>hasUniqueIndex</name> <init>= <expr><call><name>relationHasUniqueIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>rand_pol</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>hasPrimaryKey</name> <operator>||</operator> <name>hasUniqueIndex</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set to DISTRIBUTED RANDOMLY because relation has %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>hasPrimaryKey</name></expr> ?</condition><then> <expr><literal type="string">"primary Key"</literal></expr> </then><else>: <expr><literal type="string">"unique index"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Drop the %s first."</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>hasPrimaryKey</name></expr> ?</condition><then> <expr><literal type="string">"primary key"</literal></expr> </then><else>: <expr><literal type="string">"unique index"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force_reorg</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsRandomPartitioned</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distribution policy of relation \"%s\" already set to DISTRIBUTED RANDOMLY"</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TABLE \"%s\" SET WITH (REORGANIZE=TRUE) DISTRIBUTED RANDOMLY to force a random redistribution."</literal></expr></argument>,
									 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>policy</name> <operator>=</operator> <call><name>createRandomPartitionedPolicy</name><argument_list>(<argument><expr><name><name>ldistro</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* always need to rebuild if changed from replicated policy */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>GpPolicyReplace</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>=</operator> <call><name>GpPolicyCopy</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>policy</name></name> <operator>=</operator> <name>policy</name></expr>;</expr_stmt>

				<comment type="block">/* no need to rebuild if REORGANIZE=false*/</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force_reorg</name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>l_distro_fini</name>;</goto></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ldistro</name> <operator>&amp;&amp;</operator> <name><name>ldistro</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_REPLICATED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>rep_pol</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distribution policy of relation \"%s\" already set to DISTRIBUTED REPLICATED"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TABLE \"%s\" SET WITH (REORGANIZE=TRUE) DISTRIBUTED REPLICATED to force a replicated redistribution."</literal></expr></argument>,
								 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>policy</name> <operator>=</operator> <call><name>createReplicatedGpPolicy</name><argument_list>(<argument><expr><name><name>ldistro</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* rebuild only if policy changed */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>l_distro_fini</name>;</goto></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * system columns is not visiable to users for replicated table,
			 * so if table is convertint to replicated table, check if there
			 * are dependencies on the system columns.
			 */</comment>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>checkObjects</name> <init>= <expr><call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>attr</name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init>
				 <condition><expr><name>attr</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>;</condition> <incr><expr><name>attr</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>obj</name></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>attr</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>checkObjects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>checkDependencies</name><argument_list>(<argument><expr><name>checkObjects</name></expr></argument>,
							  <argument><expr><literal type="string">"cannot set distributed replicated because "</literal>
							  <literal type="string">"other object depend on its system columns"</literal></expr></argument>,
							  <argument><expr><literal type="string">"system columns of replicated table will be exposed "</literal>
							  <literal type="string">"to users after altering, resolve dependencies first"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>checkObjects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*--
	 * Changing a table from random distribution to a specific distribution
	 * policy is the hard bit. For that, we must do the following:
	 *
	 * a) Ensure that the proposed policy is sensible
	 * b) Create a temporary table and reorganise data according to our desired
	 *    distribution policy. To do this, we build a Query node which express
	 *    the query:
	 *    CREATE TABLE tmp_tab_nam AS SELECT * FROM cur_table DISTRIBUTED BY (policy)
	 * c) Execute the query across all nodes
	 * d) Update our parse tree to include the details of the newly created
	 *    table
	 * e) Update the ownership of the temporary table
	 * f) Swap the relfilenodes of the existing table and the temporary table
	 * g) Update the policy on the QD to reflect the underlying data
	 * h) Drop the temporary table -- and with it, the old copy of the data
	 *--
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>change_policy</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	<modifier>*</modifier></type><name>policykeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	<modifier>*</modifier></type><name>policyopclasses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Step (a) */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>rand_pol</name> <operator>||</operator> <name>rep_pol</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ldistro-&gt;keyCols</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DistributionKeyElem</name> <modifier>*</modifier></type><name>dkelem</name> <init>= <expr><operator>(</operator><name>DistributionKeyElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colName</name> <init>= <expr><name><name>dkelem</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attform</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>opclass</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
										<argument><expr><name>colName</name></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>attform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

					<comment type="block">/* Prevent them from altering a system attribute */</comment>
					<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute by system column \"%s\""</literal></expr></argument>,
										<argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Look up the opclass, like we do in for CREATE TABLE.
					 */</comment>
					<expr_stmt><expr><name>opclass</name> <operator>=</operator> <call><name>cdb_get_opclass_for_column_def</name><argument_list>(<argument><expr><name><name>dkelem</name><operator>-&gt;</operator><name>opclass</name></name></expr></argument>, <argument><expr><name><name>attform</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>policykeys</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>policykeys</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>policyopclasses</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>policyopclasses</name></expr></argument>, <argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cols</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block> <comment type="block">/* end foreach */</comment>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>policykeys</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>policy</name> <operator>=</operator> <call><name>createHashPartitionedPolicy</name><argument_list>(<argument><expr><name>policykeys</name></expr></argument>,
													 <argument><expr><name>policyopclasses</name></expr></argument>,
													 <argument><expr><name><name>ldistro</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * See if the old policy is the same as the new one.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force_reorg</name> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>nattrs</name></name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>diff</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>diff</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>diff</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>diff</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ldistro-&gt;keyCols</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>DistributionKeyElem</name> <modifier>*</modifier></type><name>dkelem</name> <init>= <expr><operator>(</operator><name>DistributionKeyElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>dkelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distribution policy of relation \"%s\" "</literal>
								<literal type="string">"already set to (%s)"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TABLE \"%s\" "</literal>
								<literal type="string">"SET WITH (REORGANIZE=TRUE) "</literal>
								<literal type="string">"DISTRIBUTED BY (%s) "</literal>
								<literal type="string">"to force redistribution"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Tell QEs to do nothing */</comment>
						<return>return;</return>
						<comment type="block">/* don't goto l_distro_fini -- didn't do anything! */</comment>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>checkPolicyCompatibleWithIndexes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ldistro</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ldistro</name> <operator>=</operator> <call><name>make_distributedby_for_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>need_reorg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
			<call><name>rel_is_external_table</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>need_reorg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected relkind '%c'"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>need_reorg</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Force the use of Postgres query optimizer, since Pivotal Optimizer (GPORCA) will not
			 * redistribute the tuples if the current and required distributions
			 * are both RANDOM even when reorganize is set to "true"
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>saveOptimizerGucValue</name> <init>= <expr><name>optimizer</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>optimizer</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>saveOptimizerGucValue</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER SET DISTRIBUTED BY: falling back to Postgres query optimizer to ensure re-distribution of tuples."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<decl_stmt><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>original_policy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Disable optimizer_replicated_table_insert so planner 
			 * can force a broadcast motion even both source and target
			 * are replicated table. This is important when altering
			 * distribution policy is called by gpexpand.
			 */</comment>
			<expr_stmt><expr><name>save_optimizer_replicated_table_insert</name> <operator>=</operator> <name>optimizer_replicated_table_insert</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>optimizer_replicated_table_insert</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>force_reorg</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>rand_pol</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * since we force the reorg, we don't care about the original
				 * distribution policy of the source table hence, we can set the
				 * policy to random, which will force it to redistribute if the new
				 * distribution policy is partitioned, even the new partition policy
				 * is same as the original one, the query optimizer will generate
				 * redistribute plan.
				 */</comment>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>random_policy</name> <init>= <expr><call><name>createRandomPartitionedPolicy</name><argument_list>(<argument><expr><name><name>ldistro</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>original_policy</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr>;</expr_stmt>
				<comment type="block">/*
				 * break the link to avoid original_policy from getting deleted if
				 * relcache invalidation happens.
				 */</comment>
				<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<comment type="block">/* update the catalog first and then assign the policy to rd_cdbpolicy */</comment>
				<expr_stmt><expr><call><name>GpPolicyReplace</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>random_policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>=</operator> <call><name>GpPolicyCopy</name><argument_list>(<argument><expr><name>random_policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Step (b) - build CTAS */</comment>
			<expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>build_ctas_with_dist</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ldistro</name></expr></argument>,
											 <argument><expr><call><name>untransformRelOptions</name><argument_list>(<argument><expr><call><name>get_rel_opts</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>tmprv</name></expr></argument>,
											 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* 
			 * We need to update our snapshot here to make sure we see all
			 * committed work. We have an exclusive lock on the table so no one
			 * will be able to access the table now.
			 */</comment>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Step (c) - run on all nodes */</comment>
			<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>QueryDispatchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name><operator>-&gt;</operator><name>useChangedAOOpts</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		
			<comment type="block">/* GPDB hook for collecting query info */</comment>
			<if_stmt><if>if <condition>(<expr><name>query_info_collect_hook</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call>(<modifier>*</modifier><name>query_info_collect_hook</name>)<argument_list>(<argument><expr><name>METRICS_QUERY_SUBMIT</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>query_mem</name></name> <operator>=</operator>
				<call><name>ResourceManagerGetQueryMemoryLimit</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>autostats_get_cmdtype</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmdType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>rDestroy</name></name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>dest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>auto_stats</name><argument_list>(<argument><expr><name>cmdType</name></expr></argument>, <argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Restore the old snapshot */</comment>
			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>optimizer</name> <operator>=</operator> <name>saveOptimizerGucValue</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>optimizer_replicated_table_insert</name> <operator>=</operator> <name>save_optimizer_replicated_table_insert</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* see the effects of the command */</comment>

			<if_stmt><if>if <condition>(<expr><name>original_policy</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * update catalog first and then update the rd_cdbpolicy. This order
				 * avoids original_policy from getting freed before we use it for
				 * GpPolicyReplace() if relcache invalidation happens. Also, helps
				 * to have the rd_cdbpolicy current instead of reverse order which
				 * can invalidate our assignment to rd_cdbpolicy.
				 */</comment>
				<expr_stmt><expr><call><name>GpPolicyReplace</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>original_policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>=</operator> <name>original_policy</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Step (d) - tell the seg nodes about the temporary relation. We use
			 * the global 'qe_data' variable to pass this information up to the
			 * caller, so that it can be included when the command is dispatched.
			 */</comment>
			<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>backendId</name></name> <operator>=</operator> <name>MyBackendId</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>backend_id</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Extract the already-transformed representation of the DistributedBy
		 * policy that the QD should have included for us.
		 */</comment>
		<expr_stmt><expr><name>policy</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>policy</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>policy</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>GpPolicyReplace</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Set to random distribution on master with no reorganisation.
		 * Or this is a partitioned table, with no data.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>backendId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<goto>goto <name>l_distro_fini</name>;</goto>			
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>backend_id</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>backendId</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmprv</name> <operator>=</operator> <call><name>make_temp_table_name</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>backend_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>need_reorg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_reorg</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Step (e) - Correct ownership on temporary table:
		 *   necessary so that the toast tables/indices have the correct
		 *   owner after we swap them.
		 *
		 * Note: ATExecChangeOwner does NOT dispatch, so this does not
		 * belong in the dispatch block above (MPP-9663).
		 */</comment>
		<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>tmprv</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* see the effects of the command */</comment>

		<comment type="block">/*
		 * Update pg_attribute for dropped columns. The temp table we built
		 * uses int4 to stand in for any dropped columns, so we need to update
		 * the original table's definition to match the new contents.
		 */</comment>
		<expr_stmt><expr><call><name>change_dropped_col_datatypes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Step (f) - swap relfilenodes and MORE !!!
		 */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmprelid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>tmprv</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>swap_relation_files</name><argument_list>(<argument><expr><name>tarrelid</name></expr></argument>, <argument><expr><name>tmprelid</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <comment type="block">/* target_is_pg_class */</comment>
							<argument><expr><name>false</name></expr></argument>, <comment type="block">/* swap_toast_by_content */</comment>
							<argument><expr><name>false</name></expr></argument>, <comment type="block">/* swap_stats */</comment>
							<argument><expr><name>true</name></expr></argument>,
							<argument><expr><name>RecentXmin</name></expr></argument>,
							<argument><expr><call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make changes from swapping relation files visible. */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* now, reindex */</comment>
		<expr_stmt><expr><call><name>reindex_relation</name><argument_list>(<argument><expr><name>tarrelid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Step (g) */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>change_policy</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>GpPolicyReplace</name><argument_list>(<argument><expr><name>tarrelid</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>policy</name></name> <operator>=</operator> <name>policy</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Step (h) Drop the table */</comment>
	<if_stmt><if>if <condition>(<expr><name>need_reorg</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>tmprelid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
<label><name>l_distro_fini</name>:</label>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distro_str</name> <init>= <expr><call><name>make_distro_str</name><argument_list>(<argument><expr><name>lwith</name></expr></argument>, <argument><expr><name>ldistro</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* don't check relkind - must be a table */</comment>
		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>tarrelid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"ALTER"</literal></expr></argument>,
						   <argument><expr><name>distro_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ALTER TABLE ... SPLIT PARTITION */</comment>

<comment type="block">/* Given a Relation, make a DISTRIBUTED BY (...) clause for parser consumption. */</comment>
<function><type><name>DistributedBy</name> <modifier>*</modifier></type>
<name>make_distributedby_for_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedBy</name> <modifier>*</modifier></type><name>dist</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DistributedBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>!=</operator> <name>POLICYTYPE_ENTRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* must be random distribution */</comment>
		<expr_stmt><expr><name><name>dist</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name>POLICYTYPE_REPLICATED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dist</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dist</name><operator>-&gt;</operator><name>keyCols</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> 		<modifier>*</modifier></type><name>keys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>opclassoid</name> <init>= <expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DistributionKeyElem</name> <modifier>*</modifier></type><name>dkelem</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_opc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opcrec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ht_opc</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclassoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opclassoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>opcrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>opcrec</name><operator>-&gt;</operator><name>opcnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opcname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>opcrec</name><operator>-&gt;</operator><name>opcname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>dkelem</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DistributionKeyElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dkelem</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>attname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dkelem</name><operator>-&gt;</operator><name>opclass</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dkelem</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>dkelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>dist</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name>POLICYTYPE_PARTITIONED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dist</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dist</name><operator>-&gt;</operator><name>keyCols</name></name> <operator>=</operator> <name>keys</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>dist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE OF
 *
 * Attach a table to a composite type, as though it had been created with CREATE
 * TABLE OF.  All attname, atttypid, atttypmod and attcollation must match.  The
 * subject table must not have inheritance parents.  These restrictions ensure
 * that you cannot create a configuration impossible with CREATE TABLE OF alone.
 *
 * The address of the type is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAddOf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeName</name> <modifier>*</modifier></type><name>ofTypename</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Type</name></type>		<name>typetuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>inheritsRelation</name></decl>,
				<decl><type ref="prev"/><name>relationRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>table_attno</name></decl>,
				<decl><type ref="prev"/><name>type_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>typeTupleDesc</name></decl>,
				<decl><type ref="prev"/><name>tableTupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>tableobj</name></decl>,
				<decl><type ref="prev"/><name>typeobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>classtuple</name></decl>;</decl_stmt>

	<comment type="block">/* Validate the type. */</comment>
	<expr_stmt><expr><name>typetuple</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ofTypename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_of_type</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typeform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typeid</name> <operator>=</operator> <name><name>typeform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>

	<comment type="block">/* Fail if the table has any inheritance parents. */</comment>
	<expr_stmt><expr><name>inheritsRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
				<argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>inheritsRelation</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typed tables cannot inherit"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>inheritsRelation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check the tuple descriptors for compatibility.  Unlike inheritance, we
	 * require that the order also match.  However, attnotnull need not match.
	 */</comment>
	<expr_stmt><expr><name>typeTupleDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tableTupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>table_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>type_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>type_attno</name> <operator>&lt;=</operator> <name><name>typeTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>type_attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>type_attr</name></decl>,
					<decl><type ref="prev"/><name>table_attr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_attname</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>table_attname</name></decl>;</decl_stmt>

		<comment type="block">/* Get the next non-dropped type attribute. */</comment>
		<expr_stmt><expr><name>type_attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>typeTupleDesc</name></expr></argument>, <argument><expr><name>type_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>type_attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>type_attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>type_attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get the next non-dropped table attribute. */</comment>
		<do>do
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>table_attno</name> <operator>&gt;</operator> <name><name>tableTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table is missing column \"%s\""</literal></expr></argument>,
								<argument><expr><name>type_attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>table_attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tableTupleDesc</name></expr></argument>, <argument><expr><name>table_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>table_attno</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name><name>table_attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>;</do>
		<expr_stmt><expr><name>table_attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>table_attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Compare name. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>table_attname</name></expr></argument>, <argument><expr><name>type_attname</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table has column \"%s\" where type requires \"%s\""</literal></expr></argument>,
							<argument><expr><name>table_attname</name></expr></argument>, <argument><expr><name>type_attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Compare type. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>table_attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name><name>type_attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
			<name><name>table_attr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>!=</operator> <name><name>type_attr</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>||</operator>
			<name><name>table_attr</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>!=</operator> <name><name>type_attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" has different type for column \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type_attname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>typeTupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Any remaining columns at the end of the table had better be dropped. */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>table_attno</name> <operator>&lt;=</operator> <name><name>tableTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>table_attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>table_attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tableTupleDesc</name></expr></argument>,
													 <argument><expr><name>table_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>table_attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table has extra column \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>table_attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If the table was already typed, drop the existing dependency. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>drop_parent_dependency</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>,
							   <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Record a dependency on the new type. */</comment>
	<expr_stmt><expr><name><name>tableobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tableobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typeobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typeobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>typeid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typeobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tableobj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeobj</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update pg_class.reloftype */</comment>
	<expr_stmt><expr><name>relationRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>classtuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classtuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>reloftype</name> <operator>=</operator> <name>typeid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>classtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>classtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>classtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typetuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>typeobj</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE NOT OF
 *
 * Detach a typed table from its originating type.  Just clear reloftype and
 * remove the dependency.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecDropOf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relationRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a typed table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't bother to check ownership of the type --- ownership of the
	 * table is presumed enough rights.  No lock required on the type, either.
	 */</comment>

	<expr_stmt><expr><call><name>drop_parent_dependency</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>,
						   <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear pg_class.reloftype */</comment>
	<expr_stmt><expr><name>relationRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>reloftype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relationRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * relation_mark_replica_identity: Update a table's replica identity
 *
 * Iff ri_type = REPLICA_IDENTITY_INDEX, indexOid must be the Oid of a suitable
 * index. Otherwise, it should be InvalidOid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>relation_mark_replica_identity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>ri_type</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>pg_class_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>pg_index_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>pg_class_form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>pg_index_form</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check whether relreplident has changed, and update it if so.
	 */</comment>
	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_class_tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
										 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pg_class_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pg_class_form</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>!=</operator> <name>ri_type</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pg_class_form</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>=</operator> <name>ri_type</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>pg_class_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check whether the correct index is marked indisreplident; if so, we're
	 * done.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ri_type</name> <operator>==</operator> <name>REPLICA_IDENTITY_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pg_index_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pg_index_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pg_index_form</name><operator>-&gt;</operator><name>indisreplident</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Clear the indisreplident flag from any index that had it previously,
	 * and set it for any index that should have it now.
	 */</comment>
	<expr_stmt><expr><name>pg_index</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>index</argument>, <argument>RelationGetIndexList(rel)</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>thisIndexOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>dirty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pg_index_tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
											 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>thisIndexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>thisIndexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pg_index_form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Unset the bit if set.  We know it's wrong because we checked this
		 * earlier.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_index_form</name><operator>-&gt;</operator><name>indisreplident</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pg_index_form</name><operator>-&gt;</operator><name>indisreplident</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>thisIndexOid</name> <operator>==</operator> <name>indexOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pg_index_form</name><operator>-&gt;</operator><name>indisreplident</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>dirty</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pg_index_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>thisIndexOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>pg_index_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE &lt;name&gt; REPLICA IDENTITY ...
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ReplicaIdentityStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>key</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_DEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_mark_replica_identity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_FULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_mark_replica_identity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_NOTHING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_mark_replica_identity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_INDEX</name></expr>)</condition>
	<block>{<block_content>
		 <comment type="block">/* fallthrough */</comment> <empty_stmt>;</empty_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected identity type %u"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Check that the index exists */</comment>
	<expr_stmt><expr><name>indexOid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" for table \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check that the index is on the relation we're altering. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index for table \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* The AM must support uniqueness, and the index must in fact be unique. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexRel</name><operator>-&gt;</operator><name>rd_indam</name><operator>-&gt;</operator><name>amcanunique</name></name> <operator>||</operator>
		<operator>!</operator><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use non-unique index \"%s\" as replica identity"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Deferred indexes are not guaranteed to be always unique. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use non-immediate index \"%s\" as replica identity"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Expression indexes aren't supported. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetIndexExpressions</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use expression index \"%s\" as replica identity"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Predicate indexes aren't supported. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetIndexPredicate</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use partial index \"%s\" as replica identity"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* And neither are invalid indexes. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use invalid index \"%s\" as replica identity"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check index for nullable columns. */</comment>
	<for>for <control>(<init><expr><name>key</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>key</name> <operator>&lt;</operator> <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>key</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int16</name></type>		<name>attno</name> <init>= <expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>key</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Reject any other system columns.  (Going forward, we'll disallow
		 * indexes containing such columns in the first place, but they might
		 * exist in older branches.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" cannot be used as replica identity because column %d is a system column"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" cannot be used as replica identity because column \"%s\" is nullable"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* This index is suitable for use as a replica identity. Mark it. */</comment>
	<expr_stmt><expr><call><name>relation_mark_replica_identity</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>identity_type</name></name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE ENABLE/DISABLE ROW LEVEL SECURITY
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecEnableRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relrowsecurity</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecDisableRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Pull the record for this relation and update it */</comment>
	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relrowsecurity</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE FORCE/NO FORCE ROW LEVEL SECURITY
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecForceNoForceRowSecurity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_rls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relforcerowsecurity</name> <operator>=</operator> <name>force_rls</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER FOREIGN TABLE &lt;name&gt; OPTIONS (...)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATExecGenericOptions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>ftrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignDataWrapper</name> <modifier>*</modifier></type><name>fdw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_foreign_table</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_foreign_table</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_foreign_table</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_foreign_table</name></type> <name>tableform</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ftrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>FOREIGNTABLEREL</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign table \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tableform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_foreign_table</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>server</name> <operator>=</operator> <call><name>GetForeignServer</name><argument_list>(<argument><expr><name><name>tableform</name><operator>-&gt;</operator><name>ftserver</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fdw</name> <operator>=</operator> <call><name>GetForeignDataWrapper</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract the current options */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>FOREIGNTABLEREL</name></expr></argument>,
							<argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_foreign_table_ftoptions</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Transform the options */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>transformGenericOptions</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>,
									<argument><expr><name>datum</name></expr></argument>,
									<argument><expr><name>options</name></expr></argument>,
									<argument><expr><name><name>fdw</name><operator>-&gt;</operator><name>fdwvalidator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_foreign_table_ftoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_foreign_table_ftoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_foreign_table_ftoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Everything looks good - update the tuple */</comment>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Invalidate relcache so that all sessions will refresh any cached plans
	 * that might depend on the old options.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>,
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>ftrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Preparation phase for SET LOGGED/UNLOGGED
 *
 * This verifies that we're not trying to change a temp table.  Also,
 * existing foreign key constraints are checked to avoid ending up with
 * permanent tables referencing unlogged tables.
 *
 * Return value is false if the operation is a no-op (in which case the
 * checks are skipped), otherwise true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ATPrepChangePersistence</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>toLogged</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_constraint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Disallow changing status for a temp table.  Also verify whether we can
	 * get away with doing nothing; in such cases we don't need to run the
	 * checks below, either.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELPERSISTENCE_TEMP</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change logged status of table \"%s\" because it is temporary"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errtable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELPERSISTENCE_PERMANENT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>toLogged</name></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* nothing to do */</comment>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELPERSISTENCE_UNLOGGED</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>toLogged</name></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* nothing to do */</comment>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Check that the table is not part any publication when changing to
	 * UNLOGGED as UNLOGGED tables can't be published.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>toLogged</name> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><call><name>GetRelationPublications</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot change table \"%s\" to unlogged because it is part of a publication"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unlogged relations cannot be replicated."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check existing foreign key constraints to preserve the invariant that
	 * permanent tables cannot reference unlogged ones.  Self-referencing
	 * foreign keys can safely be ignored.
	 */</comment>
	<expr_stmt><expr><name>pg_constraint</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan conrelid if changing to permanent, else confrelid.  This also
	 * determines whether a useful index exists.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><ternary><condition><expr><name>toLogged</name></expr> ?</condition><then> <expr><name>Anum_pg_constraint_conrelid</name></expr> </then><else>:
				<expr><name>Anum_pg_constraint_confrelid</name></expr></else></ternary></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>,
							  <argument><expr><ternary><condition><expr><name>toLogged</name></expr> ?</condition><then> <expr><name>ConstraintRelidTypidNameIndexId</name></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>foreignrelid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>foreignrel</name></decl>;</decl_stmt>

			<comment type="block">/* the opposite end of what we used as scankey */</comment>
			<expr_stmt><expr><name>foreignrelid</name> <operator>=</operator> <ternary><condition><expr><name>toLogged</name></expr> ?</condition><then> <expr><name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr> </then><else>: <expr><name><name>con</name><operator>-&gt;</operator><name>conrelid</name></name></expr></else></ternary></expr>;</expr_stmt>

			<comment type="block">/* ignore if self-referencing */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>foreignrelid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>foreignrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>foreignrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>toLogged</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>foreignrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not change table \"%s\" to logged because it references unlogged table \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>foreignrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not change table \"%s\" to unlogged because it references logged table \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>foreignrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Execute ALTER TABLE SET SCHEMA
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterTableNamespace</name><parameter_list>(<parameter><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>oldschema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldNspOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nspOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>newrv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
									 <argument><expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr> ?</condition><then> <expr><name>RVR_MISSING_OK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
									 <argument><expr><name>RangeVarCallbackForAlterRelation</name></expr></argument>,
									 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist, skipping"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidObjectAddress</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldNspOid</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If it's an owned sequence, disallow moving it by itself. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>tableId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>colId</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>sequenceIsOwned</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colId</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>sequenceIsOwned</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move an owned sequence into another schema"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Sequence \"%s\" is linked to table \"%s\"."</literal></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get and lock schema OID and check its permissions. */</comment>
	<expr_stmt><expr><name>newrv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspOid</name> <operator>=</operator> <call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name>newrv</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* common checks on switching namespaces */</comment>
	<expr_stmt><expr><call><name>CheckSetNamespace</name><argument_list>(<argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>objsMoved</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AlterTableNamespaceInternal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>myself</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldschema</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>oldschema</name> <operator>=</operator> <name>oldNspOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* close rel, but keep lock until commit */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>myself</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The guts of relocating a table to another namespace: besides moving
 * the table itself, its dependent objects are relocated to the new schema.
 */</comment>
<function><type><name>void</name></type>
<name>AlterTableNamespaceInternal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspOid</name></decl></parameter>,
							<parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>classRel</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>objsMoved</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK, modify the pg_class row and pg_depend entry */</comment>
	<expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AlterRelationNamespaceInternal</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>,
								   <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fix the table's row type too */</comment>
	<expr_stmt><expr><call><name>AlterTypeNamespaceInternal</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>,
							   <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fix other dependent stuff */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AlterIndexNamespaces</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AlterSeqNamespaces</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>,
						   <argument><expr><name>objsMoved</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AlterConstraintNamespaces</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>nspOid</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The guts of relocating a relation to another namespace: fix the pg_class
 * entry, and the pg_depend entry if any.  Caller must already have
 * opened and write-locked pg_class.
 */</comment>
<function><type><name>void</name></type>
<name>AlterRelationNamespaceInternal</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>hasDependEntry</name></decl></parameter>,
							   <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>classTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>thisobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>already_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>classTup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>==</operator> <name>oldNspOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the object has already been moved, don't move it again.  If it's
	 * already in the right place, don't move it, but still fire the object
	 * access hook.
	 */</comment>
	<expr_stmt><expr><name>already_done</name> <operator>=</operator> <call><name>object_address_present</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>already_done</name> <operator>&amp;&amp;</operator> <name>oldNspOid</name> <operator>!=</operator> <name>newNspOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check for duplicate name (more friendly than unique-index failure) */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>newNspOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists in schema \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>newNspOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* classTup is a copy, so OK to scribble on */</comment>
		<expr_stmt><expr><name><name>classForm</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>=</operator> <name>newNspOid</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>classTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update dependency on schema if caller said so */</comment>
		<if_stmt><if>if <condition>(<expr><name>hasDependEntry</name> <operator>&amp;&amp;</operator>
			<call><name>changeDependencyFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
								<argument><expr><name>relOid</name></expr></argument>,
								<argument><expr><name>NamespaceRelationId</name></expr></argument>,
								<argument><expr><name>oldNspOid</name></expr></argument>,
								<argument><expr><name>newNspOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to change schema dependency for relation \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>already_done</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Move all indexes for the specified relation to another namespace.
 *
 * Note: we assume adequate permission checking was done by the caller,
 * and that the caller has a suitable lock on the owning relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterIndexNamespaces</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>indexList</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>indexList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>thisobj</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>indexOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thisobj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note: currently, the index will not have its own dependency on the
		 * namespace, so we don't need to do changeDependencyFor(). There's no
		 * row type in pg_type, either.
		 *
		 * XXX this objsMoved test may be pointless -- surely we have a single
		 * dependency link from a relation to each index?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>object_address_present</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AlterRelationNamespaceInternal</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>,
										   <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>newNspOid</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thisobj</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Move all identity and SERIAL-column sequences of the specified relation to another
 * namespace.
 *
 * Note: we assume adequate permission checking was done by the caller,
 * and that the caller has a suitable lock on the owning relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AlterSeqNamespaces</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>classRel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newNspOid</name></decl></parameter>, <parameter><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>objsMoved</name></decl></parameter>,
				   <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>depRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * SERIAL sequences are those having an auto dependency on one of the
	 * table's columns (we don't care *which* column, exactly).
	 */</comment>
	<expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we leave refobjsubid unspecified */</comment>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>depForm</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>seqRel</name></decl>;</decl_stmt>

		<comment type="block">/* skip dependencies other than auto dependencies on columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>depForm</name><operator>-&gt;</operator><name>refobjsubid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<name><name>depForm</name><operator>-&gt;</operator><name>classid</name></name> <operator>!=</operator> <name>RelationRelationId</name> <operator>||</operator>
			<name><name>depForm</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>!</operator><operator>(</operator><name><name>depForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_AUTO</name> <operator>||</operator> <name><name>depForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_INTERNAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Use relation_open just in case it's an index */</comment>
		<expr_stmt><expr><name>seqRel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>depForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* skip non-sequence relations */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relkind</name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No need to keep the lock */</comment>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Fix the pg_class and pg_depend entries */</comment>
		<expr_stmt><expr><call><name>AlterRelationNamespaceInternal</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name><name>depForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>,
									   <argument><expr><name>oldNspOid</name></expr></argument>, <argument><expr><name>newNspOid</name></expr></argument>,
									   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sequences have entries in pg_type. We need to be careful to move
		 * them to the new namespace, too.
		 */</comment>
		<expr_stmt><expr><call><name>AlterTypeNamespaceInternal</name><argument_list>(<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>reltype</name></expr></argument>,
								   <argument><expr><name>newNspOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>objsMoved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now we can close it.  Keep the lock till end of transaction. */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>seqRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * This code supports
 *	CREATE TEMP TABLE ... ON COMMIT { DROP | PRESERVE ROWS | DELETE ROWS }
 *
 * Because we only support this for TEMP tables, it's sufficient to remember
 * the state in a backend-local data structure.
 */</comment>

<comment type="block">/*
 * Register a newly-created relation's ON COMMIT action.
 */</comment>
<function><type><name>void</name></type>
<name>register_on_commit_action</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>OnCommitAction</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We needn't bother registering the relation unless there is an ON COMMIT
	 * action we need to take.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>ONCOMMIT_NOOP</name> <operator>||</operator> <name>action</name> <operator>==</operator> <name>ONCOMMIT_PRESERVE_ROWS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oc</name> <operator>=</operator> <operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OnCommitItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>on_commits</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>oc</name></expr></argument>, <argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unregister any ON COMMIT action when a relation is deleted.
 *
 * Actually, we only mark the OnCommitItem entry as to be deleted after commit.
 */</comment>
<function><type><name>void</name></type>
<name>remove_on_commit_action</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>on_commits</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>relid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Perform ON COMMIT actions.
 *
 * This is invoked just before actually committing, since it's possible
 * to encounter errors.
 */</comment>
<function><type><name>void</name></type>
<name>PreCommit_on_commit_actions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oids_to_truncate</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oids_to_drop</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We skip this operation in the catchup handler, especially
	 * between prepare and commit state, as we may not see the heap
	 * that has just been created in the prepared transaction that
	 * is not visible yet.  Skipping this under the catchup handler
	 * should be ok in known cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>in_process_catchup_event</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>on_commits</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore entry if already dropped in this xact */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>oncommit</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ONCOMMIT_NOOP</name></expr>:</case>
			<case>case <expr><name>ONCOMMIT_PRESERVE_ROWS</name></expr>:</case>
				<comment type="block">/* Do nothing (there shouldn't be such entries, actually) */</comment>
				<break>break;</break>
			<case>case <expr><name>ONCOMMIT_DELETE_ROWS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
				<comment type="block">/*
				 * If this transaction hasn't accessed any temporary
				 * relations, we can skip truncating ON COMMIT DELETE ROWS
				 * tables, as they must still be empty.
				 */</comment>
				if ((MyXactFlags &amp; XACT_FLAGS_ACCESSEDTEMPNAMESPACE))
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>oids_to_truncate</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids_to_truncate</name></expr></argument>, <argument><expr><name><name>oc</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ONCOMMIT_DROP</name></expr>:</case>
				<expr_stmt><expr><name>oids_to_drop</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids_to_drop</name></expr></argument>, <argument><expr><name><name>oc</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/*
	 * Truncate relations before dropping so that all dependencies between
	 * relations are removed after they are worked on.  Doing it like this
	 * might be a waste as it is possible that a relation being truncated will
	 * be dropped anyway due to its parent being dropped, but this makes the
	 * code more robust because of not having to re-check that the relation
	 * exists at truncation time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oids_to_truncate</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_truncate</name><argument_list>(<argument><expr><name>oids_to_truncate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>oids_to_drop</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>targetObjects</name> <init>= <expr><call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>oids_to_drop</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>object_address_present</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>targetObjects</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>targetObjects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Since this is an automatic drop, rather than one directly initiated
		 * by the user, we pass the PERFORM_DELETION_INTERNAL flag.
		 */</comment>
		<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>targetObjects</name></expr></argument>, <argument><expr><name>DROP_CASCADE</name></expr></argument>,
								 <argument><expr><name>PERFORM_DELETION_INTERNAL</name> <operator>|</operator> <name>PERFORM_DELETION_QUIETLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>

		<comment type="block">/*
		 * Note that table deletion will call remove_on_commit_action, so the
		 * entry should get marked as deleted.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>on_commits</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>!=</operator> <name>ONCOMMIT_DROP</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Post-commit or post-abort cleanup for ON COMMIT management.
 *
 * All we do here is remove no-longer-needed OnCommitItem entries.
 *
 * During commit, remove entries that were deleted during this transaction;
 * during abort, remove those created during this transaction.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_on_commit_actions</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev_item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>cur_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cur_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>isCommit</name></expr> ?</condition><then> <expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr> </then><else>:
			<expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>!=</operator> <name>InvalidSubTransactionId</name></expr></else></ternary></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* cur_item must be removed */</comment>
			<expr_stmt><expr><name>on_commits</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>, <argument><expr><name>cur_item</name></expr></argument>, <argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>prev_item</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* cur_item must be preserved */</comment>
			<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>cur_item</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Post-subcommit or post-subabort cleanup for ON COMMIT management.
 *
 * During subabort, we can immediately remove entries created during this
 * subtransaction.  During subcommit, just relabel entries marked during
 * this subtransaction as being the parent's responsibility.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOSubXact_on_commit_actions</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
							  <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev_item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>cur_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OnCommitItem</name> <modifier>*</modifier></type><name>oc</name> <init>= <expr><operator>(</operator><name>OnCommitItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cur_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isCommit</name> <operator>&amp;&amp;</operator> <name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* cur_item must be removed */</comment>
			<expr_stmt><expr><name>on_commits</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>, <argument><expr><name>cur_item</name></expr></argument>, <argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>prev_item</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>on_commits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* cur_item must be preserved */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>creating_subid</name></name> <operator>=</operator> <name>parentSubid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>oc</name><operator>-&gt;</operator><name>deleting_subid</name></name> <operator>=</operator> <ternary><condition><expr><name>isCommit</name></expr> ?</condition><then> <expr><name>parentSubid</name></expr> </then><else>: <expr><name>InvalidSubTransactionId</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>cur_item</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * This is intended as a callback for RangeVarGetRelidExtended().  It allows
 * the relation to be locked only if (1) it's a plain table, materialized
 * view, or TOAST table and (2) the current user is the owner (or the
 * superuser).  This meets the permission-checking needs of CLUSTER, REINDEX
 * TABLE, and REFRESH MATERIALIZED VIEW; we expose it here so that it can be
 * used by all.
 */</comment>
<function><type><name>void</name></type>
<name>RangeVarCallbackOwnsTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if the relation was not found. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the relation does exist, check whether it's an index.  But note that
	 * the relation might have been dropped between the time we did the name
	 * lookup and now.  In that case, there's nothing to do.
	 */</comment>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relkind</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_TOASTVALUE</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or materialized view"</literal></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check permissions */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback to RangeVarGetRelidExtended() for TRUNCATE processing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForTruncate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if the relation was not found. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>truncate_check_rel</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback to RangeVarGetRelidExtended(), similar to
 * RangeVarCallbackOwnsTable() but without checks on the type of the relation.
 */</comment>
<function><type><name>void</name></type>
<name>RangeVarCallbackOwnsRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if the relation was not found. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator>
		<call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Common RangeVarGetRelid callback for rename, set schema, and alter table
 * processing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForAlterRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldrelid</name></decl></parameter>,
								 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectType</name></type>	<name>reltype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* concurrently dropped */</comment>
	<expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>

	<comment type="block">/* Must own relation. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* No system table modifications unless explicitly allowed. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>classform</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
						<argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Extract the specified relation type from the statement parse tree.
	 *
	 * Also, for ALTER .. RENAME, check permissions: the user must (still)
	 * have CREATE rights on the containing namespace.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>RenameStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>,
										  <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
						   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>reltype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>renameType</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reltype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>objectType</name></expr>;</expr_stmt></block_content></block></if>

	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reltype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>stmt</name><operator>)</operator><operator>-&gt;</operator><name>relkind</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reltype</name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt> <comment type="block">/* placate compiler */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * For compatibility with prior releases, we allow ALTER TABLE to be used
	 * with most other types of relations (but not composite types). We allow
	 * similar flexibility for ALTER INDEX in the case of RENAME, but not
	 * otherwise.  Otherwise, the user must select the correct form of the
	 * command for the relation at issue.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_SEQUENCE</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a sequence"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_VIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a view"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_MATVIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a materialized view"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a foreign table"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_TYPE</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a composite type"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>==</operator> <name>OBJECT_INDEX</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name>
		<operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>RenameStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't allow ALTER TABLE on composite types. We want people to use ALTER
	 * TYPE for that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>reltype</name> <operator>!=</operator> <name>OBJECT_TYPE</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a composite type"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use ALTER TYPE instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't allow ALTER TABLE .. SET SCHEMA on relations that can't be moved
	 * to a different schema, such as indexes and TOAST tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, sequence, or foreign table"</literal></expr></argument>,
						<argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transform any expressions present in the partition key
 *
 * Returns a transformed PartitionSpec, as well as the strategy code
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionSpec</name> <modifier>*</modifier></type>
<name>transformPartitionSpec</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>partspec</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>newspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newspec</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>partParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>partspec</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>gpPartDef</name></name> <operator>=</operator> <name><name>partspec</name><operator>-&gt;</operator><name>gpPartDef</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>subPartSpec</name></name> <operator>=</operator> <name><name>partspec</name><operator>-&gt;</operator><name>subPartSpec</name></name></expr>;</expr_stmt>

	<comment type="block">/* Parse partitioning strategy name */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>PARTITION_STRATEGY_HASH</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>, <argument><expr><literal type="string">"range"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized partitioning strategy \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Check valid number of columns for strategy */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>partspec</name><operator>-&gt;</operator><name>partParams</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use \"list\" partition strategy with more than one column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * In GPDB, the dispatcher does the transformation and the QEs get
	 * already-transformed expressions. So all we had to do here was parse
	 * the strategy name
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>partspec</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create a dummy ParseState and insert the target relation as its sole
	 * rangetable entry.  We need a ParseState for transformExpr.
	 */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* take care of any partition expressions */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>partspec-&gt;partParams</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionElem</name> <modifier>*</modifier></type><name>pelem</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionElem</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Copy, to avoid scribbling on the input */</comment>
			<expr_stmt><expr><name>pelem</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>pelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Now do parse transformation of the expression */</comment>
			<expr_stmt><expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
										<argument><expr><name>EXPR_KIND_PARTITION_EXPRESSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* we have to fix its collations too */</comment>
			<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>newspec</name><operator>-&gt;</operator><name>partParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>newspec</name><operator>-&gt;</operator><name>partParams</name></name></expr></argument>, <argument><expr><name>pelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>newspec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute per-partition-column information from a list of PartitionElems.
 * Expressions in the PartitionElems must be parse-analyzed already.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ComputePartitionAttrs</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partParams</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>partattrs</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>partexprs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partopclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
					  <parameter><decl><type><name>char</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>attn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>am_oid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>attn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partParams</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionElem</name> <modifier>*</modifier></type><name>pelem</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionElem</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>atttype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>attcollation</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Simple attribute reference */</comment>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attform</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>atttuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" named in partition key does not exist"</literal></expr></argument>,
								<argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>attform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use system column \"%s\" in partition key"</literal></expr></argument>,
								<argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Generated columns cannot work: They are computed after BEFORE
			 * triggers, but partition routing is done before all triggers.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attform</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use generated column in partition key"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Column \"%s\" is a generated column."</literal></expr></argument>,
								   <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>partattrs</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>atttype</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Expression */</comment>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>pelem</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>atttype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Strip any top-level COLLATE clause.  This ensures that we treat
			 * "x COLLATE y" and "(x COLLATE y)" alike.
			 */</comment>
			<while>while <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * User wrote "(column)" or "(column COLLATE something)".
				 * Treat it like simple attribute anyway.
				 */</comment>
				<expr_stmt><expr><name><name>partattrs</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>expr_attrs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>partattrs</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* marks the column as expression */</comment>
				<expr_stmt><expr><operator>*</operator><name>partexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>partexprs</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Try to simplify the expression before checking for
				 * mutability.  The main practical value of doing it in this
				 * order is that an inline-able SQL-language function will be
				 * accepted if its expansion is immutable, whether or not the
				 * function itself is marked immutable.
				 *
				 * Note that expression_planner does not change the passed in
				 * expression destructively and we have already saved the
				 * expression to be stored into the catalog above.
				 */</comment>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Partition expression cannot contain mutable functions,
				 * because a given row must always map to the same partition
				 * as long as there is no change in the partition boundary
				 * structure.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"functions in partition key expression must be marked IMMUTABLE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * transformPartitionSpec() should have already rejected
				 * subqueries, aggregates, window functions, and SRFs, based
				 * on the EXPR_KIND_ for partition expressions.
				 */</comment>

				<comment type="block">/*
				 * Cannot have expressions containing whole-row references or
				 * system column references.
				 */</comment>
				<expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>expr_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
								  <argument><expr><name>expr_attrs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition key expressions cannot contain whole-row references"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
									  <argument><expr><name>expr_attrs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition key expressions cannot contain system column references"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/*
				 * Generated columns cannot work: They are computed after
				 * BEFORE triggers, but partition routing is done before all
				 * triggers.
				 */</comment>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>expr_attrs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name>i</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attgenerated</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use generated column in partition key"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Column \"%s\" is a generated column."</literal></expr></argument>,
										   <argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></while>

				<comment type="block">/*
				 * While it is not exactly *wrong* for a partition expression
				 * to be a constant, it seems better to reject such keys.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use constant expression as partition key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Apply collation override if any
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pelem</name><operator>-&gt;</operator><name>collation</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <call><name>get_collation_oid</name><argument_list>(<argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check we have a collation iff it's a collatable type.  The only
		 * expected failures here are (1) COLLATE applied to a noncollatable
		 * type, or (2) partition expression had an unresolved collation. But
		 * we might as well code this to be a complete consistency check.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>type_is_collatable</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine which collation to use for partition expression"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collations are not supported by type %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>partcollation</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <name>attcollation</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Identify the appropriate operator class.  For list and range
		 * partitioning, we use a btree operator class; hash partitioning uses
		 * a hash operator class.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>am_oid</name> <operator>=</operator> <name>HASH_AM_OID</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>am_oid</name> <operator>=</operator> <name>BTREE_AM_OID</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pelem</name><operator>-&gt;</operator><name>opclass</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>partopclass</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>, <argument><expr><name>am_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>partopclass</name><index>[<expr><name>attn</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data type %s has no default operator class for access method \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You must specify a hash operator class or define a default hash operator class for the data type."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data type %s has no default operator class for access method \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"btree"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You must specify a btree operator class or define a default btree operator class for the data type."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>partopclass</name><index>[<expr><name>attn</name></expr>]</index></name> <operator>=</operator> <call><name>ResolveOpClass</name><argument_list>(<argument><expr><name><name>pelem</name><operator>-&gt;</operator><name>opclass</name></name></expr></argument>,
											   <argument><expr><name>atttype</name></expr></argument>,
											   <argument><expr><ternary><condition><expr><name>am_oid</name> <operator>==</operator> <name>HASH_AM_OID</name></expr> ?</condition><then> <expr><literal type="string">"hash"</literal></expr> </then><else>: <expr><literal type="string">"btree"</literal></expr></else></ternary></expr></argument>,
											   <argument><expr><name>am_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>attn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * PartConstraintImpliedByRelConstraint
 *		Do scanrel's existing constraints imply the partition constraint?
 *
 * "Existing constraints" include its check constraints and column-level
 * NOT NULL constraints.  partConstraint describes the partition constraint,
 * in implicit-AND form.
 */</comment>
<function><type><name>bool</name></type>
<name>PartConstraintImpliedByRelConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>scanrel</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partConstraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>existConstraint</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>constr</name> <operator>&amp;&amp;</operator> <name><name>constr</name><operator>-&gt;</operator><name>has_not_null</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>scanrel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>scanrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
											  <argument><expr><name>i</name></expr></argument>,
											  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
											  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
											  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
											  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * argisrow=false is correct even for a composite column,
				 * because attnotnull does not represent a SQL-spec IS NOT
				 * NULL test in such a case, just IS DISTINCT FROM NULL.
				 */</comment>
				<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>existConstraint</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>existConstraint</name></expr></argument>, <argument><expr><name>ntest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>ConstraintImpliedByRelConstraint</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>, <argument><expr><name>partConstraint</name></expr></argument>, <argument><expr><name>existConstraint</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ConstraintImpliedByRelConstraint
 *		Do scanrel's existing constraints imply the given constraint?
 *
 * testConstraint is the constraint to validate. provenConstraint is a
 * caller-provided list of conditions which this function may assume
 * to be true. Both provenConstraint and testConstraint must be in
 * implicit-AND form, must only contain immutable clauses, and must
 * contain only Vars with varno = 1.
 */</comment>
<function><type><name>bool</name></type>
<name>ConstraintImpliedByRelConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>scanrel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>testConstraint</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>provenConstraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>existConstraint</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>provenConstraint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_check</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>num_check</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>constr</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_check</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>cexpr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this constraint hasn't been fully validated yet, we must ignore
		 * it here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccvalid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Run each expression through const-simplification and
		 * canonicalization.  It is necessary, because we will be comparing it
		 * to similarly-processed partition constraint expressions, and may
		 * fail to detect valid matches without this.
		 */</comment>
		<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>existConstraint</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>existConstraint</name></expr></argument>,
									  <argument><expr><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Try to make the proof.  Since we are comparing CHECK constraints, we
	 * need to use weak implication, i.e., we assume existConstraint is
	 * not-false and try to prove the same for testConstraint.
	 *
	 * Note that predicate_implied_by assumes its first argument is known
	 * immutable.  That should always be true for both NOT NULL and partition
	 * constraints, so we don't test it here.
	 */</comment>
	<return>return <expr><call><name>predicate_implied_by</name><argument_list>(<argument><expr><name>testConstraint</name></expr></argument>, <argument><expr><name>existConstraint</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * QueuePartitionConstraintValidation
 *
 * Add an entry to wqueue to have the given partition constraint validated by
 * Phase 3, for the given relation, and all its children.
 *
 * We first verify whether the given constraint is implied by pre-existing
 * relation constraints; if it is, there's no need to scan the table to
 * validate, so don't queue in that case.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>QueuePartitionConstraintValidation</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>scanrel</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partConstraint</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>validate_default</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Based on the table's existing constraints, determine whether or not we
	 * may skip scanning the table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartConstraintImpliedByRelConstraint</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>, <argument><expr><name>partConstraint</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>validate_default</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition constraint for table \"%s\" is implied by existing constraints"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated partition constraint for default partition \"%s\" is implied by existing constraints"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Constraints proved insufficient. For plain relations, queue a
	 * validation item now; for partitioned tables, recurse to process each
	 * partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scanrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>

		<comment type="block">/* Grab a work queue entry. */</comment>
		<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>ATGetQueueEntry</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In the QE, we receive these from the QD. We should reach
			 * the same conclusions if we re-did the work here.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>equal</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>validate_default</name></name> <operator>==</operator> <name>validate_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>partition_constraint</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>validate_default</name></name> <operator>=</operator> <name>validate_default</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>scanrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>scanrel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>part_rel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>thisPartConstraint</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * This is the minimum lock we need to prevent deadlocks.
			 */</comment>
			<expr_stmt><expr><name>part_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Adjust the constraint for scanrel so that it matches this
			 * partition's attribute numbers.
			 */</comment>
			<expr_stmt><expr><name>thisPartConstraint</name> <operator>=</operator>
				<call><name>map_partition_varattnos</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>scanrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* There can never be a whole-row reference here */</comment>
			<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected whole-row reference found in partition constraint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>QueuePartitionConstraintValidation</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>part_rel</name></expr></argument>,
											   <argument><expr><name>thisPartConstraint</name></expr></argument>,
											   <argument><expr><name>validate_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* keep lock till commit */</comment>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE &lt;name&gt; ATTACH PARTITION &lt;partition-name&gt; FOR VALUES
 *
 * Return the address of the newly attached partition.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAttachPartition</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attachrel</name></decl>,
				<decl><type ref="prev"/><name>catalog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attachrel_children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partConstraint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trigger_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>defaultPartOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partBoundConstraint</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must lock the default partition if one exists, because attaching a
	 * new partition will change its partition constraint.
	 */</comment>
	<expr_stmt><expr><name>defaultPartOid</name> <operator>=</operator>
		<call><name>get_default_oid_from_partdesc</name><argument_list>(<argument><expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attachrel</name> <operator>=</operator> <call><name>table_openrv</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX I think it'd be a good idea to grab locks on all tables referenced
	 * by FKs at this point also.
	 */</comment>

	<comment type="block">/*
	 * Must be owner of both parent and source table -- parent was checked by
	 * ATSimplePermissions call in ATPrepCmd
	 */</comment>
	<expr_stmt><expr><call><name>ATSimplePermissions</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>ATT_TABLE</name> <operator>|</operator> <name>ATT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* A partition can only have one parent */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is already a partition"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach a typed table as partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Table being attached should not already be part of inheritance; either
	 * as a child table...
	 */</comment>
	<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach inheritance child as partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ...or as a parent table (except the case when it is partitioned) */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_inherits_inhparent</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>InheritsParentIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach inheritance parent as partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prevent circularity by seeing if rel is a partition of attachrel. (In
	 * particular, this disallows making a rel a partition of itself.)
	 *
	 * We do that by checking if rel is a member of the list of attachrel's
	 * partitions provided the latter is partitioned at all.  We want to avoid
	 * having to construct this list again, so we request the strongest lock
	 * on all partitions.  We need the strongest lock, because we may decide
	 * to scan them if we find out that the table being attached (or its leaf
	 * partitions) may contain rows that violate the partition constraint. If
	 * the table has a constraint that would prevent such rows, which by
	 * definition is present in all the partitions, we need not scan the
	 * table, nor its partitions.  But we cannot risk a deadlock by taking a
	 * weaker lock now and the stronger one only when needed.
	 */</comment>
	<expr_stmt><expr><name>attachrel_children</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>attachrel_children</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"circular inheritance not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is already a child of \"%s\"."</literal></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If the parent is permanent, so must be all of its partitions. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach a temporary relation as partition of permanent relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Temp parent cannot have a partition that is itself not a temp */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach a permanent relation as partition of temporary relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If the parent is temp, it must belong to this session */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach as partition of temporary relation of another session"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Ditto for the partition */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>attachrel</name><operator>-&gt;</operator><name>rd_islocaltemp</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach temporary relation of another session as partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check if there are any columns in attachrel that aren't in the parent */</comment>
	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Try to find the column in parent (matching on column name) */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>ATTNAME</name></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" contains column \"%s\" not found in parent \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attributeName</name></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The new partition may contain only the columns present in parent."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Check that the distribution policy matches. The columns might be in
	 * different order, so use GpPolicyEqualByName() rather than just
	 * GpPolicyEqual() here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>GpPolicyEqualByName</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>,
							 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distribution policy for \"%s\" must be the same as that for \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If child_rel has row-level triggers with transition tables, we
	 * currently don't allow it to become a partition.  See also prohibitions
	 * in ATExecAddInherit() and CreateTrigger().
	 */</comment>
	<expr_stmt><expr><name>trigger_name</name> <operator>=</operator> <call><name>FindTriggerIncompatibleWithInheritance</name><argument_list>(<argument><expr><name><name>attachrel</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>trigger_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" prevents table \"%s\" from becoming a partition"</literal></expr></argument>,
						<argument><expr><name>trigger_name</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ROW triggers with transition tables are not supported on partitions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the new partition's bound is valid and does not overlap any
	 * of existing partitions of the parent - note that it does not return on
	 * error.
	 */</comment>
	<expr_stmt><expr><call><name>check_new_partition_bound</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
							  <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK to create inheritance.  Rest of the checks performed there */</comment>
	<expr_stmt><expr><call><name>CreateInheritance</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the pg_class entry. */</comment>
	<expr_stmt><expr><call><name>StorePartitionBound</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure there exists a correct set of indexes in the partition. */</comment>
	<expr_stmt><expr><call><name>AttachPartitionEnsureIndexes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* and triggers */</comment>
	<expr_stmt><expr><call><name>CloneRowTriggersToPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clone foreign key constraints.  Callee is responsible for setting up
	 * for phase 3 constraint verification.
	 */</comment>
	<expr_stmt><expr><call><name>CloneForeignKeyConstraints</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate partition constraint from the partition bound specification.
	 * If the parent itself is a partition, make sure to include its
	 * constraint as well.
	 */</comment>
	<expr_stmt><expr><name>partBoundConstraint</name> <operator>=</operator> <call><name>get_qual_from_partbound</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partConstraint</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>partBoundConstraint</name></expr></argument>,
								 <argument><expr><call><name>RelationGetPartitionQual</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Skip validation if there are no constraints to validate. */</comment>
	<if_stmt><if>if <condition>(<expr><name>partConstraint</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Run the partition quals through const-simplification similar to
		 * check constraints.  We skip canonicalize_qual, though, because
		 * partition quals should be in canonical form already.
		 */</comment>
		<expr_stmt><expr><name>partConstraint</name> <operator>=</operator>
			<operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>partConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* XXX this sure looks wrong */</comment>
		<expr_stmt><expr><name>partConstraint</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Adjust the generated constraint to match this partition's attribute
		 * numbers.
		 */</comment>
		<expr_stmt><expr><name>partConstraint</name> <operator>=</operator> <call><name>map_partition_varattnos</name><argument_list>(<argument><expr><name>partConstraint</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>attachrel</name></expr></argument>,
												 <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* There can never be a whole-row reference here */</comment>
		<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"unexpected whole-row reference found in partition key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Validate partition constraints against the table being attached. */</comment>
		<expr_stmt><expr><call><name>QueuePartitionConstraintValidation</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>partConstraint</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're attaching a partition other than the default partition and a
	 * default one exists, then that partition's partition constraint changes,
	 * so add an entry to the work queue to validate it, too.  (We must not do
	 * this when the partition being attached is the default one; we already
	 * did it above!)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>defaultrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>defPartConstraint</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>bound</name><operator>-&gt;</operator><name>is_default</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we already hold a lock on the default partition */</comment>
		<expr_stmt><expr><name>defaultrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>defPartConstraint</name> <operator>=</operator>
			<call><name>get_proposed_default_constraint</name><argument_list>(<argument><expr><name>partBoundConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Map the Vars in the constraint expression from rel's attnos to
		 * defaultrel's.
		 */</comment>
		<expr_stmt><expr><name>defPartConstraint</name> <operator>=</operator>
			<call><name>map_partition_varattnos</name><argument_list>(<argument><expr><name>defPartConstraint</name></expr></argument>,
									<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>defaultrel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>QueuePartitionConstraintValidation</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>, <argument><expr><name>defaultrel</name></expr></argument>,
										   <argument><expr><name>defPartConstraint</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* keep our lock until commit. */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>defaultrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
					   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
					   <argument><expr><literal type="string">"PARTITION"</literal></expr></argument>, <argument><expr><literal type="string">"ATTACH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* keep our lock until commit */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AttachPartitionEnsureIndexes
 *		subroutine for ATExecAttachPartition to create/match indexes
 *
 * Enforce the indexing rule for partitioned tables during ALTER TABLE / ATTACH
 * PARTITION: every partition must have an index attached to each index on the
 * partitioned table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AttachPartitionEnsureIndexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>attachrel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>idxes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attachRelIdxs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>attachrelIdxRels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>attachInfos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								<argument><expr><literal type="string">"AttachPartitionEnsureIndexes"</literal></expr></argument>,
								<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>idxes</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attachRelIdxs</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attachrelIdxRels</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attachRelIdxs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attachInfos</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attachRelIdxs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build arrays of all existing indexes and their IndexInfos */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>attachRelIdxs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>cldIdxId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>cldIdxId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attachInfos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we're attaching a foreign table, we must fail if any of the indexes
	 * is a constraint index; otherwise, there's nothing to do here.  Do this
	 * before starting work, to avoid wasting the effort of building a few
	 * non-unique indexes before coming across a unique one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attachrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>idxes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>idx</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>idxRel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>||</operator>
				<name><name>idxRel</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach foreign table \"%s\" as partition of partitioned table \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table \"%s\" contains unique indexes."</literal></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<goto>goto <name>out</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For each index on the partitioned table, find a matching one in the
	 * partition-to-be; if one is not found, create one.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>idxes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>idx</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>idxRel</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore indexes in the partitioned table other than partitioned
		 * indexes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* construct an indexinfo to compare existing indexes against */</comment>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>constraintOid</name> <operator>=</operator> <call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Scan the list of existing indexes in the partition-to-be, and mark
		 * the first matching, unattached one we find, if any, as partition of
		 * the parent index.  If we find one, we're done.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attachRelIdxs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>cldIdxId</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>cldConstrOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* does this index have a parent?  if so, can't use it */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CompareIndexInfo</name><argument_list>(<argument><expr><name><name>attachInfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>info</name></expr></argument>,
								 <argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>rd_indcollation</name></expr></argument>,
								 <argument><expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></argument>,
								 <argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>rd_opfamily</name></expr></argument>,
								 <argument><expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_opfamily</name></name></expr></argument>,
								 <argument><expr><name>attmap</name></expr></argument>,
								 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If this index is being created in the parent because of a
				 * constraint, then the child needs to have a constraint also,
				 * so look for one.  If there is no such constraint, this
				 * index is no good, so keep looking.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cldConstrOid</name> <operator>=</operator>
						<call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><name>cldIdxId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* no dice */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cldConstrOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* bingo. */</comment>
				<expr_stmt><expr><call><name>IndexSetParentIndex</name><argument_list>(<argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name>cldConstrOid</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
												  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If no suitable index was found in the partition-to-be, create one
		 * now.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>generateClonedIndexStmt</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
										   <argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>attmap</name></expr></argument>,
										   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DefineIndex</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>attachrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>constraintOid</name></expr></argument>,
						<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument> <comment type="block">/* not a new table */</comment>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

<label><name>out</name>:</label>
	<comment type="block">/* Clean up. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attachRelIdxs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name><name>attachrelIdxRels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CloneRowTriggersToPartition
 *		subroutine for ATExecAttachPartition/DefineRelation to create row
 *		triggers on partitions
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CloneRowTriggersToPartition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_trigger</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>perTupCxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgrelid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_trigger</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_trigger</name></expr></argument>, <argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>perTupCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									  <argument><expr><literal type="string">"clone trig"</literal></expr></argument>, <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>trigForm</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>trigStmt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cols</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>trigargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore statement-level triggers; those are not cloned.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FOR_ROW</name><argument_list>(<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* We don't clone internal triggers, either */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgisinternal</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Complain if we find an unexpected trigger type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FOR_AFTER</name><argument_list>(<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected trigger \"%s\" found"</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Use short-lived context for CREATE TRIGGER */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>perTupCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there is a WHEN clause, generate a 'cooked' version of it that's
		 * appropriate for the partition.
		 */</comment>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgqual</name></expr></argument>,
							 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_trigger</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>map_partition_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>, <argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>,
													<argument><expr><name>partition</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected whole-row reference found in trigger WHEN clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>map_partition_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>, <argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>,
													<argument><expr><name>partition</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected whole-row reference found in trigger WHEN clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there is a column list, transform it to a list of column names.
		 * Note we don't need to map this list in any way ...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgattr</name><operator>.</operator><name>dim1</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigForm</name><operator>-&gt;</operator><name>tgattr</name><operator>.</operator><name>dim1</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>col</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
									<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgattr</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cols</name></expr></argument>,
							   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>col</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Reconstruct trigger arguments list. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgargs</name></expr></argument>,
								 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_trigger</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tgargs is null for trigger \"%s\" in partition \"%s\""</literal></expr></argument>,
					 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigForm</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>trigargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>trigargs</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>trigStmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>trigname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* passed separately */</comment>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>trigargs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <name><name>trigForm</name><operator>-&gt;</operator><name>tgtype</name></name> <operator>&amp;</operator> <name>TRIGGER_TYPE_TIMING_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name><name>trigForm</name><operator>-&gt;</operator><name>tgtype</name></name> <operator>&amp;</operator> <name>TRIGGER_TYPE_EVENT_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>cols</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* passed separately */</comment>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgconstraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>transitionRels</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt> <comment type="block">/* not supported at present */</comment>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>trigForm</name><operator>-&gt;</operator><name>tgdeferrable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>trigForm</name><operator>-&gt;</operator><name>tginitdeferred</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigStmt</name><operator>-&gt;</operator><name>constrrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* passed separately */</comment>

		<expr_stmt><expr><call><name>CreateTrigger</name><argument_list>(<argument><expr><name>trigStmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgconstrrelid</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
					  <argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>tgfoid</name></name></expr></argument>, <argument><expr><name><name>trigForm</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>,
					  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>perTupCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>perTupCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_trigger</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER TABLE DETACH PARTITION
 *
 * Return the address of the relation that is no longer a partition of rel.
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecDetachPartition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>partRel</name></decl>,
				<decl><type ref="prev"/><name>classRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>,
				<decl><type ref="prev"/><name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>new_val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>new_null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>new_repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>defaultPartOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must lock the default partition, because detaching this partition
	 * will change its partition constraint.
	 */</comment>
	<expr_stmt><expr><name>defaultPartOid</name> <operator>=</operator>
		<call><name>get_default_oid_from_partdesc</name><argument_list>(<argument><expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>partRel</name> <operator>=</operator> <call><name>table_openrv</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure that foreign keys still hold after this detach */</comment>
	<expr_stmt><expr><call><name>ATDetachCheckNoForeignKeyRefs</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* All inheritance related checks are performed within the function */</comment>
	<expr_stmt><expr><call><name>RemoveInheritance</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update pg_class tuple */</comment>
	<expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relispartition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clear relpartbound and reset relispartition */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_val</name><index>[<expr><name>Anum_pg_class_relpartbound</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_null</name><index>[<expr><name>Anum_pg_class_relpartbound</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_repl</name><index>[<expr><name>Anum_pg_class_relpartbound</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>new_val</name></expr></argument>, <argument><expr><name>new_null</name></expr></argument>, <argument><expr><name>new_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relispartition</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the relation being detached is the default partition itself,
		 * remove it from the parent's pg_partitioned_table entry.
		 *
		 * If not, we must invalidate default partition's relcache entry, as
		 * in StorePartitionBound: its partition constraint depends on every
		 * other partition's partition constraint.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>defaultPartOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>update_default_partition_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* detach indexes too */</comment>
	<expr_stmt><expr><name>indexes</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>indexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>idxid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>idx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constrOid</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_superclass</name><argument_list>(<argument><expr><name>idxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>IndexGetRelation</name><argument_list>(<argument><expr><call><name>get_partition_parent</name><argument_list>(<argument><expr><name>idxid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator>
				<call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>idxid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>IndexSetParentIndex</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If there's a constraint associated with the index, detach it too */</comment>
		<expr_stmt><expr><name>constrOid</name> <operator>=</operator> <call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><name>idxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name>constrOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Detach any foreign keys that are inherited.  This includes creating
	 * additional action triggers.
	 */</comment>
	<expr_stmt><expr><name>fks</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>RelationGetFKeyList</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>fks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>fk</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>contup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>conform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fkconstraint</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>contup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>conform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* consider only the inherited foreign keys */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conform</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_FOREIGN</name> <operator>||</operator>
			<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>conform</name><operator>-&gt;</operator><name>conparentid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* unset conparentid and adjust conislocal, coninhcount, etc. */</comment>
		<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make the action triggers on the referenced relation.  When this was
		 * a partition the action triggers pointed to the parent rel (they
		 * still do), but now we need separate ones of our own.
		 */</comment>
		<expr_stmt><expr><name>fkconstraint</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>conform</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name> <operator>=</operator> <name><name>conform</name><operator>-&gt;</operator><name>confupdtype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>fk_del_action</name></name> <operator>=</operator> <name><name>conform</name><operator>-&gt;</operator><name>confdeltype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>conform</name><operator>-&gt;</operator><name>condeferrable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkconstraint</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>conform</name><operator>-&gt;</operator><name>condeferred</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>createForeignKeyActionTriggers</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name><name>conform</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>,
									   <argument><expr><name>fkconstraint</name></expr></argument>, <argument><expr><name><name>fk</name><operator>-&gt;</operator><name>conoid</name></name></expr></argument>,
									   <argument><expr><name><name>conform</name><operator>-&gt;</operator><name>conindid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>fks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Any sub-constrains that are in the referenced-side of a larger
	 * constraint have to be removed.  This partition is no longer part of the
	 * key space of the constraint.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>GetParentedForeignKeyRefs(partRel)</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constrOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>constraint</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name>constrOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deleteDependencyRecordsForClass</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>,
										<argument><expr><name>constrOid</name></expr></argument>,
										<argument><expr><name>ConstraintRelationId</name></expr></argument>,
										<argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>constraint</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>constraint</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Invalidate the parent's relcache so that the partition is no longer
	 * included in its partition descriptor.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
					   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
					   <argument><expr><literal type="string">"PARTITION"</literal></expr></argument>, <argument><expr><literal type="string">"DETACH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* keep our lock until commit */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Before acquiring lock on an index, acquire the same lock on the owning
 * table.
 */</comment>
<struct>struct <name>AttachIndexCallbackState</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>partitionOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>parentTblOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lockedParentTbl</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForAttachIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelOid</name></decl></parameter>,
							   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>AttachIndexCallbackState</name></name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator>struct <name>AttachIndexCallbackState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>lockedParentTbl</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>parentTblOid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lockedParentTbl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we previously locked some other heap, and the name we're looking up
	 * no longer refers to an index on that relation, release the now-useless
	 * lock.  XXX maybe we should do *after* we verify whether the index does
	 * not actually belong to the same relation ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relOid</name> <operator>!=</operator> <name>oldRelOid</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Didn't find a relation, so no need for locking or permission checks. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* concurrently dropped, so nothing to do */</comment>
	<expr_stmt><expr><name>classform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>, <argument><expr><name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we need only examine the heap's tupledesc, an access share lock
	 * on it (preventing any DDL) is sufficient.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>partitionOid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ALTER INDEX i1 ATTACH PARTITION i2
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>ATExecAttachPartitionIdx</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>wqueue</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parentIdx</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>partIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>partTbl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>parentTbl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>partIdxId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>currParent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>AttachIndexCallbackState</name></name></type> <name>state</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need to obtain lock on the index 'name' to modify it, but we also
	 * need to read its owning table's tuple descriptor -- so we need to lock
	 * both.  To avoid deadlocks, obtain lock on the table before doing so on
	 * the index.  Furthermore, we need to examine the parent table of the
	 * partition, so lock that one too.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>partitionOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>parentTblOid</name></name> <operator>=</operator> <name><name>parentIdx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>lockedParentTbl</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>partIdxId</name> <operator>=</operator>
		<call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>RangeVarCallbackForAttachIndex</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Not there? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partIdxId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name><name>name</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* no deadlock risk: RangeVarGetRelidExtended already acquired the lock */</comment>
	<expr_stmt><expr><name>partIdx</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>partIdxId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we already hold locks on both tables, so this is safe: */</comment>
	<expr_stmt><expr><name>parentTbl</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>parentIdx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partTbl</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>partIdx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Silently do nothing if already in the right state */</comment>
	<expr_stmt><expr><name>currParent</name> <operator>=</operator> <ternary><condition><expr><name><name>partIdx</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr> ?</condition><then>
		<expr><call><name>get_partition_parent</name><argument_list>(<argument><expr><name>partIdxId</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>currParent</name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>childInfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>parentInfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name></decl>,
					<decl><type ref="prev"/><name>cldConstrId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this partition already has an index attached, refuse the
		 * operation.
		 */</comment>
		<expr_stmt><expr><call><name>refuseDupeIndexAttach</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>partIdx</name></expr></argument>, <argument><expr><name>partTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>currParent</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index \"%s\" is already attached to another index."</literal></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Make sure it indexes a partition of the other index's table */</comment>
		<expr_stmt><expr><name>partDesc</name> <operator>=</operator> <call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partDesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>partDesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>state</name><operator>.</operator><name>partitionOid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index \"%s\" is not an index on any partition of table \"%s\"."</literal></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Ensure the indexes are compatible */</comment>
		<expr_stmt><expr><name>childInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attmap</name> <operator>=</operator> <call><name>convert_tuples_by_name_map</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>partTbl</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CompareIndexInfo</name><argument_list>(<argument><expr><name>childInfo</name></expr></argument>, <argument><expr><name>parentInfo</name></expr></argument>,
							  <argument><expr><name><name>partIdx</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></argument>,
							  <argument><expr><name><name>parentIdx</name><operator>-&gt;</operator><name>rd_indcollation</name></name></expr></argument>,
							  <argument><expr><name><name>partIdx</name><operator>-&gt;</operator><name>rd_opfamily</name></name></expr></argument>,
							  <argument><expr><name><name>parentIdx</name><operator>-&gt;</operator><name>rd_opfamily</name></name></expr></argument>,
							  <argument><expr><name>attmap</name></expr></argument>,
							  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The index definitions do not match."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If there is a constraint in the parent, make sure there is one in
		 * the child too.
		 */</comment>
		<expr_stmt><expr><name>constraintOid</name> <operator>=</operator> <call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cldConstrId</name> <operator>=</operator> <call><name>get_relation_idx_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partTbl</name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><name>partIdxId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cldConstrId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The index \"%s\" belongs to a constraint in table \"%s\" but no constraint exists for index \"%s\"."</literal></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* All good -- do it */</comment>
		<expr_stmt><expr><call><name>IndexSetParentIndex</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ConstraintSetParentConstraint</name><argument_list>(<argument><expr><name>cldConstrId</name></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>,
										  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partTbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>validatePartitionedIndex</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* keep these locks till commit */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>partTbl</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Verify whether the given partition already contains an index attached
 * to the given partitioned index.  If so, raise an error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>refuseDupeIndexAttach</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parentIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partitionTbl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>existingIdx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>existingIdx</name> <operator>=</operator> <call><name>index_get_partition</name><argument_list>(<argument><expr><name>partitionTbl</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>existingIdx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot attach index \"%s\" as a partition of index \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partIdx</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Another index is already attached for partition \"%s\"."</literal></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partitionTbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Verify whether the set of attached partition indexes to a parent index on
 * a partitioned table is complete.  If it is, mark the parent index valid.
 *
 * This should be called each time a partition index is attached.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validatePartitionedIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>partedIdx</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>partedTbl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>inheritsRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>inhTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>updated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>partedIdx</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan pg_inherits for this parent index.  Count each valid index we find
	 * (verifying the pg_index entry for each), and if we reach the total
	 * amount we expect, we can mark this parent index as valid.
	 */</comment>
	<expr_stmt><expr><name>inheritsRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>Anum_pg_inherits_inhparent</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partedIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>inheritsRel</name></expr></argument>, <argument><expr><name>InheritsParentIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>inhTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_inherits</name></type> <name>inhForm</name> <init>= <expr><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>inhTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indTup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>inhForm</name><operator>-&gt;</operator><name>inhrelid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name><name>inhForm</name><operator>-&gt;</operator><name>inhrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Done with pg_inherits */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>inheritsRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we found as many inherited indexes as the partitioned table has
	 * partitions, we're good; update pg_index to set indisvalid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>==</operator> <call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>partedTbl</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nparts</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>idxRel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>idxRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name><name>partedIdx</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>indisvalid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>updated</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>partedIdx</name><operator>-&gt;</operator><name>rd_indextuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this index is in turn a partition of a larger index, validating it
	 * might cause the parent to become valid also.  Try that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>updated</name> <operator>&amp;&amp;</operator> <name><name>partedIdx</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parentIdxId</name></decl>,
					<decl><type ref="prev"/><name>parentTblId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>parentIdx</name></decl>,
					<decl><type ref="prev"/><name>parentTbl</name></decl>;</decl_stmt>

		<comment type="block">/* make sure we see the validation we just did */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>parentIdxId</name> <operator>=</operator> <call><name>get_partition_parent</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partedIdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentTblId</name> <operator>=</operator> <call><name>get_partition_parent</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partedTbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentIdx</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>parentIdxId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentTbl</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>parentTblId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>parentIdx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>validatePartitionedIndex</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>parentTbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parentIdx</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parentTbl</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return an OID list of constraints that reference the given relation
 * that are marked as having a parent constraints.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetParentedForeignKeyRefs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>partition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_constraint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>constraints</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If no indexes, or no columns are referenceable by FKs, we can avoid the
	 * scan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name> <operator>||</operator>
		<call><name>bms_is_empty</name><argument_list>(<argument><expr><call><name>RelationGetIndexAttrBitmap</name><argument_list>(<argument><expr><name>partition</name></expr></argument>,
												<argument><expr><name>INDEX_ATTR_BITMAP_KEY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Search for constraints referencing this table */</comment>
	<expr_stmt><expr><name>pg_constraint</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_confrelid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_contype</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_CHAREQ</name></expr></argument>, <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>CONSTRAINT_FOREIGN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX This is a seqscan, as we don't have a usable index */</comment>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constrForm</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We only need to process constraints that are part of larger ones.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conparentid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>constraints</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>, <argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_constraint</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>constraints</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * During DETACH PARTITION, verify that any foreign keys pointing to the
 * partitioned table would not become invalid.  An error is raised if any
 * referenced values exist.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ATDetachCheckNoForeignKeyRefs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>partition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>constraints</name> <operator>=</operator> <call><name>GetParentedForeignKeyRefs</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>constraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constrOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constrForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Trigger</name></type>		<name>trig</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name>constrOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>constrForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conparentid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>confrelid</name></name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prevent data changes into the referencing table until commit */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trig</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgname</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>constrForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgenabled</name></name> <operator>=</operator> <name>TRIGGER_FIRES_ON_ORIGIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgisinternal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgconstrrelid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgconstrindid</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>conindid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgconstraint</name></name> <operator>=</operator> <name><name>constrForm</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tgdeferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trig</name><operator>.</operator><name>tginitdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<comment type="block">/* we needn't fill in remaining fields */</comment>

		<expr_stmt><expr><call><name>RI_PartitionRemove_Check</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trig</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>partition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>
</unit>
