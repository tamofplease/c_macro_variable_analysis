<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/commands/cluster.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cluster.c
 *	  CLUSTER a table on an index.  This is now also used for VACUUM FULL.
 *
 * There is hardly anything left of Paul Brown's original implementation...
 *
 *
 * Portions Copyright (c) 2006-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994-5, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/cluster.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_appendonly.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute_encoding.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/toasting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/cluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_rusage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relmapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/aocatalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/oid_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdboidsync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>

<comment type="block">/*
 * This struct is used to pass around the information on tables to be
 * clustered. We need this so we can make a list of them when invoked without
 * a specific table/index pair.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tableOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name></decl>;</decl_stmt>
}</block></struct></type> <name>RelToCluster</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rebuild_relation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>OldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_table_data</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDOldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDOldIndex</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>pSwapToastByContent</name></decl></parameter>,
							<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>pFreezeXid</name></decl></parameter>, <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>pCutoffMulti</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_tables_to_cluster</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>cluster_context</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*---------------------------------------------------------------------------
 * This cluster code allows for clustering multiple tables at once. Because
 * of this, we cannot just run everything on a single transaction, or we
 * would be forced to acquire exclusive locks on all the tables being
 * clustered, simultaneously --- very likely leading to deadlock.
 *
 * To solve this we follow a similar strategy to VACUUM code,
 * clustering each relation in a separate transaction. For this to work,
 * we need to:
 *	- provide a separate memory context so that we can pass information in
 *	  a way that survives across transactions
 *	- start a new transaction every time a new relation is clustered
 *	- check for validity of the information on to-be-clustered relations,
 *	  as someone might have deleted a relation behind our back, or
 *	  clustered one on a different index
 *	- end the transaction
 *
 * The single-relation case does not have any such overhead.
 *
 * We also allow a relation to be specified without index.  In that case,
 * the indisclustered bit will be looked up, and an ERROR will be thrown
 * if there is no index with the bit set.
 *---------------------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>cluster</name><parameter_list>(<parameter><decl><type><name>ClusterStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This is the single-relation case. */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>tableOid</name></decl>,
					<decl><type ref="prev"/><name>indexOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

		<comment type="block">/* Find, lock, and check permissions on the table */</comment>
		<expr_stmt><expr><name>tableOid</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
											<argument><expr><name>AccessExclusiveLock</name></expr></argument>,
											<argument><expr><literal type="number">0</literal></expr></argument>,
											<argument><expr><name>RangeVarCallbackOwnsTable</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reject clustering a remote temp table ... their local buffer
		 * manager is not going to cope.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cluster temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Reject clustering a partitioned table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cluster a partitioned table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>indexname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>

			<comment type="block">/* We need to find the index that has indisclustered set. */</comment>
			<macro><name>foreach</name><argument_list>(<argument>index</argument>, <argument>RelationGetIndexList(rel)</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>idxtuple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>indexOid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>idxtuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
										   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>idxtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>idxtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisclustered</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>idxtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>idxtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>indexOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no previously clustered index for table \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * The index is expected to be in the same namespace as the
			 * relation.
			 */</comment>
			<expr_stmt><expr><name>indexOid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>indexname</name></name></expr></argument>,
										 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" for table \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>indexname</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* close relation, keep lock till commit */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do the job. */</comment>
		<expr_stmt><expr><call><name>cluster_rel</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* printError */</comment>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
										<argument><expr><name>DF_CANCEL_ON_ERROR</name><operator>|</operator>
										<name>DF_WITH_SNAPSHOT</name><operator>|</operator>
										<name>DF_NEED_TWO_PHASE</name></expr></argument>,
										<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * This is the "multi relation" case. We need to cluster all tables
		 * that have some index with indisclustered set.
		 */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cluster_context</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rvs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We cannot run this form of CLUSTER inside a user transaction block;
		 * we'd be holding locks way too long.
		 */</comment>
		<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create special memory context for cross-transaction storage.
		 *
		 * Since it is a child of PortalContext, it will go away even in case
		 * of error.
		 */</comment>
		<expr_stmt><expr><name>cluster_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>,
												<argument><expr><literal type="string">"Cluster"</literal></expr></argument>,
												<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Build the list of relations to cluster.  Note that this lives in
		 * cluster_context.
		 */</comment>
		<expr_stmt><expr><name>rvs</name> <operator>=</operator> <call><name>get_tables_to_cluster</name><argument_list>(<argument><expr><name>cluster_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Commit to get out of starting transaction */</comment>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Ok, now that we've got them all, cluster them one by one */</comment>
		<macro><name>foreach</name><argument_list>(<argument>rv</argument>, <argument>rvs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelToCluster</name> <modifier>*</modifier></type><name>rvtc</name> <init>= <expr><operator>(</operator><name>RelToCluster</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>dispatch</name></decl>;</decl_stmt>

			<comment type="block">/* Start a new transaction for each relation. */</comment>
			<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* functions in indexes may want a snapshot set */</comment>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Do the job. */</comment>
			<expr_stmt><expr><name>dispatch</name> <operator>=</operator> <call><name>cluster_rel</name><argument_list>(<argument><expr><name><name>rvtc</name><operator>-&gt;</operator><name>tableOid</name></name></expr></argument>, <argument><expr><name><name>rvtc</name><operator>-&gt;</operator><name>indexOid</name></name></expr></argument>,
								   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>|</operator> <name>CLUOPT_RECHECK</name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument> <comment type="block">/* printError */</comment>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name>dispatch</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>rvtc</name><operator>-&gt;</operator><name>tableOid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rvtc</name><operator>-&gt;</operator><name>tableOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
											<argument><expr><name>DF_CANCEL_ON_ERROR</name><operator>|</operator>
											<name>DF_WITH_SNAPSHOT</name></expr></argument>,
											<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Start a new transaction for the cleanup work. */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Clean up working storage */</comment>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>cluster_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cluster_rel
 *
 * This clusters the table by creating a new, clustered table and
 * swapping the relfilenodes of the new table and the old table, so
 * the OID of the original table is preserved.  Thus we do not lose
 * GRANT, inheritance nor references to this table (this was a bug
 * in releases through 7.3).
 *
 * Indexes are rebuilt too, via REINDEX. Since we are effectively bulk-loading
 * the new table, it's better to create the indexes afterwards than to fill
 * them incrementally while we load the table.
 *
 * If indexOid is InvalidOid, the table will be rewritten in physical order
 * instead of index order.  This is the new implementation of VACUUM FULL,
 * and error messages should refer to the operation as VACUUM not CLUSTER.
 *
 * Note that we don't support clustering on an AO table. If printError is true,
 * this function errors out when the relation is an AO table. Otherwise, this
 * functions prints out a warning message when the relation is an AO table.
 */</comment>
<function><type><name>bool</name></type>
<name>cluster_rel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>printError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>OldHeap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>verbose</name> <init>= <expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>CLUOPT_VERBOSE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recheck</name> <init>= <expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>CLUOPT_RECHECK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check for user-requested abort. */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_progress_start_command</name><argument_list>(<argument><expr><name>PROGRESS_COMMAND_CLUSTER</name></expr></argument>, <argument><expr><name>tableOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CLUSTER_COMMAND</name></expr></argument>,
									 <argument><expr><name>PROGRESS_CLUSTER_COMMAND_CLUSTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CLUSTER_COMMAND</name></expr></argument>,
									 <argument><expr><name>PROGRESS_CLUSTER_COMMAND_VACUUM_FULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We grab exclusive access to the target rel and index for the duration
	 * of the transaction.  (This is redundant for the single-transaction
	 * case, since cluster() already did it.)  The index lock is taken inside
	 * check_index_is_clusterable.
	 */</comment>
	<expr_stmt><expr><name>OldHeap</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the table has gone away, we can skip processing it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>OldHeap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since we may open a new transaction for each relation, we have to check
	 * that the relation still is what we think it is.
	 *
	 * If this is a single-transaction CLUSTER, we can skip these tests. We
	 * *must* skip the one on indisclustered since it would reject an attempt
	 * to cluster a not-previously-clustered index.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>recheck</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>

		<comment type="block">/* Check that the user still owns the relation */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Silently skip a temp table for a remote session.  Only doing this
		 * check in the "recheck" case is appropriate (which currently means
		 * somebody is executing a database-wide CLUSTER), because there is
		 * another check in cluster() which will stop any attempt to cluster
		 * remote temp tables by name.  There is another check in cluster_rel
		 * which is redundant, but we leave it for extra safety.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Check that the index still exists
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Check that the index is still the one with indisclustered set.
			 */</comment>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>	<comment type="block">/* probably can't happen */</comment>
			<block>{<block_content>
				<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indisclustered</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We allow VACUUM FULL, but not CLUSTER, on shared catalogs.  CLUSTER
	 * would work in most respects, but the index would only get marked as
	 * indisclustered in the current database, leading to unexpected behavior
	 * if CLUSTER were later invoked in another database.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cluster a shared catalog"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't process temp tables of other backends ... their local buffer
	 * manager is not going to cope.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cluster temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot vacuum temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Also check for active uses of the relation in the current transaction,
	 * including open scans and pending AFTER trigger events.
	 */</comment>
	<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"CLUSTER"</literal></expr> </then><else>: <expr><literal type="string">"VACUUM"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check heap and index are valid to cluster on */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_index_is_clusterable</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>recheck</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Quietly ignore the request if this is a materialized view which has not
	 * been populated from its query. No harm is done because there is no data
	 * to deal with, and we don't want to throw an error if this is part of a
	 * multi-relation request -- for example, CLUSTER was run on the entire
	 * database.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>RelationIsPopulated</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * All predicate locks on the tuples or pages are about to be made
	 * invalid, because we move tuples around.  Promote them to relation
	 * locks.  Predicate locks on indexes will be promoted when they are
	 * reindexed.
	 */</comment>
	<expr_stmt><expr><call><name>TransferPredicateLocksToHeapRelation</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* rebuild_relation does all the dirty work */</comment>
	<expr_stmt><expr><call><name>rebuild_relation</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>verbose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: rebuild_relation does table_close() on OldHeap */</comment>

	<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Verify that the specified heap and index are valid to cluster on
 *
 * Side effect: obtains lock on the index.  The caller may
 * in some cases already have AccessExclusiveLock on the table, but
 * not in all cases so we can't rely on the table-level lock for
 * protection here.
 */</comment>
<function><type><name>void</name></type>
<name>check_index_is_clusterable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>OldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recheck</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>OldIndex</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>OldIndex</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that index is in fact an index on the given relation
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>OldIndex</name><operator>-&gt;</operator><name>rd_index</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>OldIndex</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index for table \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldIndex</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Index AM must allow clustering */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>OldIndex</name><operator>-&gt;</operator><name>rd_indam</name><operator>-&gt;</operator><name>amclusterable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cluster on index \"%s\" because access method does not support clustering"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Disallow clustering on incomplete indexes (those that might not index
	 * every row of the relation).  We could relax this by making a separate
	 * seqscan pass over the table to copy the missing rows, but that seems
	 * expensive and tedious.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name><name>OldIndex</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>, <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cluster on partial index \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Disallow if index is left over from a failed CREATE INDEX CONCURRENTLY;
	 * it might well not contain entries for every heap row, or might not even
	 * be internally consistent.  (But note that we don't check indcheckxmin;
	 * the worst consequence of following broken HOT chains would be that we
	 * might put recently-dead tuples out-of-order in the new table, and there
	 * is little harm in that.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>OldIndex</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cluster on invalid index \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Drop relcache refcnt on OldIndex, but keep lock */</comment>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>OldIndex</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * mark_index_clustered: mark the specified index as the one clustered on
 *
 * With indexOid == InvalidOid, will mark all indexes of rel not-clustered.
 */</comment>
<function><type><name>void</name></type>
<name>mark_index_clustered</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>

	<comment type="block">/* Disallow applying to a partitioned table */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot mark index clustered in partitioned table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the index is already marked clustered, no need to do anything.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisclustered</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check each index of the relation and set/clear the bit as needed.
	 */</comment>
	<expr_stmt><expr><name>pg_index</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>index</argument>, <argument>RelationGetIndexList(rel)</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>thisIndexOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
										 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>thisIndexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>thisIndexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Unset the bit if set.  We know it's wrong because we checked this
		 * earlier.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisclustered</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisclustered</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>thisIndexOid</name> <operator>==</operator> <name>indexOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* this was checked earlier, but let's be real sure */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indisvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot cluster on invalid index %u"</literal></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisclustered</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>thisIndexOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * rebuild_relation: rebuild an existing relation in index or physical order
 *
 * OldHeap: table to rebuild --- must be opened and exclusive-locked!
 * indexOid: index to cluster by, or InvalidOid to rewrite in physical order.
 *
 * NB: this routine closes OldHeap at the right time; caller should not.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rebuild_relation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>OldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tableOid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>accessMethod</name> <init>= <expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tableSpace</name> <init>= <expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>OIDNewHeap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relpersistence</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_system_catalog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>swap_toast_by_content</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>frozenXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>cutoffMulti</name></decl>;</decl_stmt>
	<comment type="block">/*
	 * GPDB_12_MERGE_FIXME: We use specific bool in abstract code. This should
	 * be somehow hidden by table am api or necessity of this switch should be
	 * revisited.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_ao</name> <init>= <expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Mark the correct index as clustered */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>mark_index_clustered</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Remember info about rel before closing OldHeap */</comment>
	<expr_stmt><expr><name>relpersistence</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_system_catalog</name> <operator>=</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close relcache entry, but keep lock until transaction commit */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the transient table that will receive the re-ordered data */</comment>
	<expr_stmt><expr><name>OIDNewHeap</name> <operator>=</operator> <call><name>make_new_heap</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>tableSpace</name></expr></argument>,
							   <argument><expr><name>accessMethod</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>relpersistence</name></expr></argument>,
							   <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
							   <argument><expr><name>true</name></expr></argument> <comment type="block">/* createAoBlockDirectory */</comment>,
							   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the heap data into the new table in the desired order */</comment>
	<expr_stmt><expr><call><name>copy_table_data</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>verbose</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>swap_toast_by_content</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>frozenXid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cutoffMulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Swap the physical files of the target and transient tables, then
	 * rebuild the target's indexes and throw away the transient table.
	 */</comment>
	<expr_stmt><expr><call><name>finish_heap_swap</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>is_system_catalog</name></expr></argument>,
					 <argument><expr><name>swap_toast_by_content</name></expr></argument>,
					 <argument><expr><operator>!</operator><name>is_ao</name></expr></argument> <comment type="block">/* swap_stats */</comment>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
					 <argument><expr><name>frozenXid</name></expr></argument>, <argument><expr><name>cutoffMulti</name></expr></argument>,
					 <argument><expr><name>relpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>make_column_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>namebuf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>namebuf</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>namebuf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create the transient table that will be filled with new data during
 * CLUSTER, ALTER TABLE, and similar operations.  The transient table
 * duplicates the logical structure of the OldHeap; but will have the
 * specified physical storage properties NewTableSpace, NewAccessMethod, and
 * relpersistence.
 *
 * Specify a colprefix can create a table with different colname, incase
 * column conflict issue happens in REFRESH MATERIALIZED VIEW operation.
 *
 * After this, the caller should load the new heap with transferred/modified
 * data, then call finish_heap_swap to complete the operation.
 */</comment>
<function><type><name>Oid</name></type>
<name>make_new_heap_with_colname</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>OIDOldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>NewTableSpace</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>NewAccessMethod</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>NewEncodings</name></decl></parameter>,
			  <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>,
			  <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>createAoBlockDirectory</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>makeCdbPolicy</name></decl></parameter>,
			  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colprefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>OldHeapDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>NewHeapName</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>OIDNewHeap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>toastid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>OldHeap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>reloptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>OldHeap</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>OldHeapDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>colprefix</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>OldHeapDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>OldHeapDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>make_column_name</name><argument_list>(<argument><expr><name>colprefix</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Note that the NewHeap will not receive any of the defaults or
	 * constraints associated with the OldHeap; we don't need 'em, and there's
	 * no reason to spend cycles inserting them into the catalogs only to
	 * delete them.
	 */</comment>

	<comment type="block">/*
	 * But we do want to use reloptions of the old heap for new heap.
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>OIDOldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* 
	 * Unless we are changing access method between heap and AO/CO, look further.
	 */</comment>
	<comment type="block">/*
	 * GPDB: some considerations when AM is going to change between heap and AO/CO:
	 *
	 * If user has also requested setting new reloptions, the new reloptions should have
	 * replaced the old ones at this point. We just need to reuse those on the new table.
	 *
	 * If user does NOT request new reloptions, we should discard the existing reloptions.
	 * And one more consideration if we are changing the table from heap to AO: we should
	 * also pick up options from gp_default_storage_options, just like CREATE TABLE does.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsHeap</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsAccessMethodAO</name><argument_list>(<argument><expr><name>NewAccessMethod</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Heap to AO/CO: filter out any reloptions that belong to heap, 
		 * and pick up from gp_default_storage_options.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> 		<name>numoptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>relopt_value</name> 	<modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>

		<comment type="block">/* 
		 * Process the reloptions as for AO tables. And validate=false will silently 
		 * filter out any reloptions that belong to heap.
		 */</comment>
		<decl_stmt><decl><type><name>StdRdOptions</name> <modifier>*</modifier></type><name>stdRdOptions</name> <init>= <expr><operator>(</operator><name>StdRdOptions</name> <operator>*</operator><operator>)</operator><call><name>default_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>,
																	<argument><expr><name>false</name></expr></argument>, <comment type="block">/* validate */</comment>
																	<argument><expr><name>RELOPT_KIND_APPENDOPTIMIZED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Pick up from gp_default_storage_options. */</comment>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>parseRelOptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>RELOPT_KIND_APPENDOPTIMIZED</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>validate_and_refill_options</name><argument_list>(<argument><expr><name>stdRdOptions</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>numoptions</name></expr></argument>, <argument><expr><name>RELOPT_KIND_APPENDOPTIMIZED</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the reloptions string. */</comment>
		<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <call><name>transformAOStdRdOptions</name><argument_list>(<argument><expr><name>stdRdOptions</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free_options_deep</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>numoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>NewAccessMethod</name> <operator>==</operator> <name>HEAP_TABLE_AM_OID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * AO/CO to Heap: unfortunately we don't have a convenient routine to transform
		 * heap StdRdOptions back to reloption string. So we take a slightly different
		 * approach than the case of heap to AO/CO: we check if there is any AO reloptions:
		 * 
		 * (1) If there is, just discard them (AO options do not apply to heap). 
		 * (2) If there is none, that means we either have replaced it with heap reloptions
		 * or the reloptions field is just empty, and either way we will pass the existing
		 * reloptions on to the new table.
		 *
		 * This is possible because at this point we only have either AO/AOCO reloptions or
		 * heap reloptions, but we cannot have both (see ATExecSetRelOptions).
		 */</comment>
		<decl_stmt><decl><type><name>Datum</name></type> 	<name>aoreloptions</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StdRdOptions</name> <modifier>*</modifier></type><name>stdRdOptions</name> <init>= <expr><operator>(</operator><name>StdRdOptions</name> <operator>*</operator><operator>)</operator><call><name>default_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>,
																	<argument><expr><name>false</name></expr></argument>, <comment type="block">/* validate */</comment>
																	<argument><expr><name>RELOPT_KIND_APPENDOPTIMIZED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Transform the stdRdOptions to get a reloptions string, from which we will 
		 * know if there is any AO reloptions.
		 */</comment>
		<expr_stmt><expr><name>aoreloptions</name> <operator>=</operator> <call><name>transformAOStdRdOptions</name><argument_list>(<argument><expr><name>stdRdOptions</name></expr></argument>, <argument><expr><name>aoreloptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aoreloptions</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>relpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>namespaceid</name> <operator>=</operator> <call><name>LookupCreationNamespace</name><argument_list>(<argument><expr><literal type="string">"pg_temp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>namespaceid</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Create the new heap, using a temporary name in the same namespace as
	 * the existing table.  NOTE: there is some risk of collision with user
	 * relnames.  Working around this seems more trouble than it's worth; in
	 * particular, we can't create the new heap in a different namespace from
	 * the old, or we will have problems with the TEMP status of temp tables.
	 *
	 * Note: the new heap is not a shared relation, even if we are rebuilding
	 * a shared rel.  However, we do make the new heap mapped if the source is
	 * mapped.  This simplifies swap_relation_files, and is absolutely
	 * necessary for rebuilding pg_class, for reasons explained there.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>NewHeapName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NewHeapName</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_temp_%u"</literal></expr></argument>, <argument><expr><name>OIDOldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>OIDNewHeap</name> <operator>=</operator> <call><name>heap_create_with_catalog</name><argument_list>(<argument><expr><name>NewHeapName</name></expr></argument>,
										  <argument><expr><name>namespaceid</name></expr></argument>,
										  <argument><expr><name>NewTableSpace</name></expr></argument>,
										  <argument><expr><name>InvalidOid</name></expr></argument>,
										  <argument><expr><name>InvalidOid</name></expr></argument>,
										  <argument><expr><name>InvalidOid</name></expr></argument>,
										  <argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
										  <argument><expr><name>NewAccessMethod</name></expr></argument>,
										  <argument><expr><name>OldHeapDesc</name></expr></argument>,
										  <argument><expr><name>NIL</name></expr></argument>,
										  <argument><expr><name>RELKIND_RELATION</name></expr></argument>,
										  <argument><expr><name>relpersistence</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><call><name>RelationIsMapped</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>ONCOMMIT_NOOP</name></expr></argument>,
										  <argument><expr><ternary><condition><expr><name>makeCdbPolicy</name></expr>?</condition><then> <expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,<comment type="block">/*CDB*/</comment>
										  <argument><expr><name>reloptions</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>,
										  <argument><expr><name>OIDOldHeap</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>OIDNewHeap</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Advance command counter so that the newly-created relation's catalog
	 * tuples will be visible to table_open.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If necessary, create a TOAST table for the new relation, or an Append
	 * Only segment table.
	 *
	 * If the relation doesn't have a TOAST table already, we can't need one
	 * for the new relation.  The other way around is possible though: if some
	 * wide columns have been dropped, NewHeapCreateToastTable can decide that
	 * no TOAST table is needed for the new table.
	 *
	 * Note that NewHeapCreateToastTable ends with CommandCounterIncrement, so
	 * that the TOAST table will be visible for insertion.
	 */</comment>
	<expr_stmt><expr><name>toastid</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>toastid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* keep the existing toast table's reloptions, if any */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>toastid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>toastid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>NewHeapCreateToastTable</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsAccessMethodAO</name><argument_list>(<argument><expr><name>NewAccessMethod</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>NewRelationCreateAOAuxTables</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>createAoBlockDirectory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * Copy the pg_attribute_encoding entries over if new table needs them.
	 * Note that in the case of AM change from heap/ao to aoco, we still need 
	 * to do this since we created those entries for the heap/ao table at the 
	 * phase 2 of ATSETAM (see ATExecCmd).
	 *
	 * If we are also altering any column's encodings, (AT_SetColumnEncoding)
	 * we update those columns with the new encoding values
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>NewAccessMethod</name> <operator>==</operator> <name>AO_COLUMN_TABLE_AM_OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CloneAttributeEncodings</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>,
								<argument><expr><name>OIDNewHeap</name></expr></argument>,
								<argument><expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UpdateAttributeEncodings</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>NewEncodings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>OIDNewHeap</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>make_new_heap</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>OIDOldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>NewTableSpace</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>NewAccessMethod</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>NewEncodings</name></decl></parameter>,
			  <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>,
			  <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>createAoBlockDirectory</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>makeCdbPolicy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>make_new_heap_with_colname</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>, <argument><expr><name>NewTableSpace</name></expr></argument>, <argument><expr><name>NewAccessMethod</name></expr></argument>,
						<argument><expr><name>NewEncodings</name></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>createAoBlockDirectory</name></expr></argument>, <argument><expr><name>makeCdbPolicy</name></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<comment type="block">/*
 * Do the physical copying of table data.
 *
 * There are three output parameters:
 * *pSwapToastByContent is set true if toast tables must be swapped by content.
 * *pFreezeXid receives the TransactionId used as freeze cutoff point.
 * *pCutoffMulti receives the MultiXactId used as a cutoff point.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_table_data</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDOldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDOldIndex</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>pSwapToastByContent</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>pFreezeXid</name></decl></parameter>,
				<parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>pCutoffMulti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>NewHeap</name></decl>,
				<decl><type ref="prev"/><name>OldHeap</name></decl>,
				<decl><type ref="prev"/><name>OldIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name>	<name>oldTupDesc</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name>	<name>newTupDesc</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>FreezeXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>MultiXactCutoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_sort</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>num_tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>tups_vacuumed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>tups_recently_dead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>num_pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name> <init>= <expr><ternary><condition><expr><name>verbose</name></expr> ?</condition><then> <expr><name>INFO</name></expr> </then><else>: <expr><name>DEBUG2</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGRUsage</name></type>	<name>ru0</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the relations we need.
	 */</comment>
	<expr_stmt><expr><name>NewHeap</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>OldHeap</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>OIDOldIndex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>OldIndex</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>OIDOldIndex</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>OldIndex</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Their tuple descriptors should be exactly alike, but here we only need
	 * assume that they have the same number of columns.
	 */</comment>
	<expr_stmt><expr><name>oldTupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newTupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>newTupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name><name>oldTupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the OldHeap has a toast table, get lock on the toast table to keep
	 * it from being vacuumed.  This is needed because autovacuum processes
	 * toast tables independently of their main tables, with no lock on the
	 * latter.  If an autovacuum were to start on the toast table after we
	 * compute our OldestXmin below, it would use a later OldestXmin, and then
	 * possibly remove as DEAD toast tuples belonging to main tuples we think
	 * are only RECENTLY_DEAD.  Then we'd fail while trying to copy those
	 * tuples.
	 *
	 * We don't need to open the toast relation here, just lock it.  The lock
	 * will be held till end of transaction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If both tables have TOAST tables, perform toast swap by content.  It is
	 * possible that the old table has a toast table but the new one doesn't,
	 * if toastable columns have been dropped.  In that case we have to do
	 * swap by links.  This is okay because swap by content is only essential
	 * for system catalogs, and we don't support schema changes for them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>&amp;&amp;</operator> <name><name>NewHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>pSwapToastByContent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * When doing swap by content, any toast pointers written into NewHeap
		 * must use the old toast table's OID, because that's where the toast
		 * data will eventually be found.  Set this up by setting rd_toastoid.
		 * This also tells toast_save_datum() to preserve the toast value
		 * OIDs, which we want so as not to invalidate toast pointers in
		 * system catalog caches, and to avoid making multiple copies of a
		 * single toast value.
		 *
		 * Note that we must hold NewHeap open until we are done writing data,
		 * since the relcache will not guarantee to remember this setting once
		 * the relation is closed.  Also, this technique depends on the fact
		 * that no one will try to read from the NewHeap until after we've
		 * finished writing it and swapping the rels --- otherwise they could
		 * follow the toast pointers to the wrong place.  (It would actually
		 * work for values copied over from the old toast table, but not for
		 * any values that we toast which were previously not toasted.)
		 */</comment>
		<expr_stmt><expr><name><name>NewHeap</name><operator>-&gt;</operator><name>rd_toastoid</name></name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>pSwapToastByContent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Compute xids used to freeze and weed out dead tuples and multixacts.
	 * Since we're going to rewrite the whole table anyway, there's no reason
	 * not to be aggressive about this.
	 */</comment>
	<expr_stmt><expr><call><name>vacuum_set_xid_limits</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>OldestXmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>FreezeXid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>MultiXactCutoff</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * FreezeXid will become the table's new relfrozenxid, and that mustn't go
	 * backwards, so take the max.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>FreezeXid</name></expr></argument>, <argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>FreezeXid</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * MultiXactCutoff, similarly, shouldn't go backwards either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>MultiXactCutoff</name></expr></argument>, <argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>MultiXactCutoff</name> <operator>=</operator> <name><name>OldHeap</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relminmxid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Decide whether to use an indexscan or seqscan-and-optional-sort to scan
	 * the OldHeap.  We know how to use a sort to duplicate the ordering of a
	 * btree index, and will use seqscan-and-sort for that case if the planner
	 * tells us it's cheaper.  Otherwise, always indexscan if an index is
	 * provided, else plain seqscan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>OldIndex</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>OldIndex</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_sort</name> <operator>=</operator> <call><name>plan_cluster_use_sort</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>, <argument><expr><name>OIDOldIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_sort</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Log what we're doing */</comment>
	<if_stmt><if>if <condition>(<expr><name>OldIndex</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"clustering \"%s.%s\" using index scan on \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>use_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"clustering \"%s.%s\" using sequential scan and sort"</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"vacuuming \"%s.%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Hand of the actual copying to AM specific function, the generic code
	 * cannot know how to deal with visibility across AMs. Note that this
	 * routine is allowed to set FreezeXid / MultiXactCutoff to different
	 * values (e.g. because the AM doesn't use freezing).
	 */</comment>
	<expr_stmt><expr><call><name>table_relation_copy_for_cluster</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NewHeap</name></expr></argument>, <argument><expr><name>OldIndex</name></expr></argument>, <argument><expr><name>use_sort</name></expr></argument>,
									<argument><expr><name>OldestXmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>FreezeXid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>MultiXactCutoff</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>num_tuples</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tups_vacuumed</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>tups_recently_dead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* return selected values to caller, get set as relfrozenxid/minmxid */</comment>
	<expr_stmt><expr><operator>*</operator><name>pFreezeXid</name> <operator>=</operator> <name>FreezeXid</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>pCutoffMulti</name> <operator>=</operator> <name>MultiXactCutoff</name></expr>;</expr_stmt>

	<comment type="block">/* Reset rd_toastoid just to be tidy --- it shouldn't be looked at again */</comment>
	<expr_stmt><expr><name><name>NewHeap</name><operator>-&gt;</operator><name>rd_toastoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_pages</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Log what we did */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": found %.0f removable, %.0f nonremovable row versions in %u pages"</literal></expr></argument>,
					<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>tups_vacuumed</name></expr></argument>, <argument><expr><name>num_tuples</name></expr></argument>,
					<argument><expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%.0f dead row versions cannot be removed yet.\n"</literal>
					   <literal type="string">"%s."</literal></expr></argument>,
					   <argument><expr><name>tups_recently_dead</name></expr></argument>,
					   <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>OldIndex</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>OldIndex</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update pg_class to reflect the correct values of pages and tuples. */</comment>
	<expr_stmt><expr><name>relRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>OIDNewHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>relform</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <name>num_pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <name>num_tuples</name></expr>;</expr_stmt>

	<comment type="block">/* Don't update the stats for pg_class.  See swap_relation_files. */</comment>
	<if_stmt><if>if <condition>(<expr><name>OIDOldHeap</name> <operator>!=</operator> <name>RelationRelationId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByTuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Clean up. */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make the update visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Change dependency links for objects that are being swapped.
 *
 * 'tabletype' can be "TOAST table", "aoseg", "aoblkdir".
 * It is used for printing error messages.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>changeDependencyLinks</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>baseOid1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>baseOid2</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid2</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tabletype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>baseobject</name></decl>, <decl><type ref="prev"/><name>newobject</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>count</name></decl>;</decl_stmt>

	<comment type="block">/* Delete old dependencies */</comment>
	<if_stmt><if>if <condition>(<expr><name>oid1</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>oid1</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected one dependency record for %s table, found %ld"</literal></expr></argument>,
				 <argument><expr><name>tabletype</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>oid2</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>oid2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected one dependency record for %s table, found %ld"</literal></expr></argument>,
				 <argument><expr><name>tabletype</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Register new dependencies */</comment>
	<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>oid1</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>baseOid1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>oid1</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseobject</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>oid2</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>baseOid2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>oid2</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseobject</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Swap the physical files of two given relations.
 *
 * We swap the physical identity (reltablespace, relfilenode) while keeping the
 * same logical identities of the two relations.  relpersistence is also
 * swapped, which is critical since it determines where buffers live for each
 * relation.
 *
 * We can swap associated TOAST data in either of two ways: recursively swap
 * the physical content of the toast tables (and their indexes), or swap the
 * TOAST links in the given relations' pg_class entries.  The former is needed
 * to manage rewrites of shared catalogs (where we cannot change the pg_class
 * links) while the latter is the only way to handle cases in which a toast
 * table is added or removed altogether.
 *
 * Additionally, the first relation is marked with relfrozenxid set to
 * frozenXid.  It seems a bit ugly to have this here, but the caller would
 * have to do it anyway, so having it here saves a heap_update.  Note: in
 * the swap-toast-links case, we assume we don't need to change the toast
 * table's relfrozenxid: the new version of the toast table should already
 * have relfrozenxid set to RecentXmin, which is good enough.
 *
 * Lastly, if r2 and its toast table and toast index (if any) are mapped,
 * their OIDs are emitted into mapped_tables[].  This is hacky but beats
 * having to look the information up again later in finish_heap_swap.
 *
 * GPDB: also swap aoseg, aoblkdir links.
 */</comment>
<function><type><name>void</name></type>
<name>swap_relation_files</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>r1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>r2</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>target_is_pg_class</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>swap_toast_by_content</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>swap_stats</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>,
					<parameter><decl><type><name>TransactionId</name></type> <name>frozenXid</name></decl></parameter>,
					<parameter><decl><type><name>MultiXactId</name></type> <name>cutoffMulti</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>mapped_tables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relRelation</name></decl>,
				<decl><type ref="prev"/><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>reltup1</name></decl>,
				<decl><type ref="prev"/><name>reltup2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform1</name></decl>,
				<decl><type ref="prev"/><name>relform2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relfilenode1</name></decl>,
				<decl><type ref="prev"/><name>relfilenode2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>swaptemp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>swptmpchr</name></decl>;</decl_stmt>

	<comment type="block">/* We need writable copies of both pg_class tuples. */</comment>
	<expr_stmt><expr><name>relRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reltup1</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relform1</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reltup2</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relform2</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>AO_ROW_TABLE_AM_OID</name> <operator>||</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>AO_COLUMN_TABLE_AM_OID</name> <operator>||</operator>
		<name><name>relform2</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>AO_ROW_TABLE_AM_OID</name> <operator>||</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>AO_COLUMN_TABLE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ATAOEntries</name><argument_list>(<argument><expr><name>relform1</name></expr></argument>, <argument><expr><name>relform2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also swap reloptions if we are swaping between heap and AO/AOCO tables. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>relform1</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>HEAP_TABLE_AM_OID</name> <operator>&amp;&amp;</operator> <call><name>IsAccessMethodAO</name><argument_list>(<argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name><name>relform2</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>HEAP_TABLE_AM_OID</name> <operator>&amp;&amp;</operator> <call><name>IsAccessMethodAO</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> 		<name>isNull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>val</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>reltup2</name></expr></argument>, <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>null</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>isNull</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repl</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>reltup1</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>reltup1</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>val</name></expr></argument>, <argument><expr><name>null</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relform1</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relform2</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>AO_COLUMN_TABLE_AM_OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RemoveAttributeEncodingsByRelid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloneAttributeEncodings</name><argument_list>(<argument><expr><name>r2</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>relnatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>relfilenode1</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>relfilenode2</name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relfilenode1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>relfilenode2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Normal non-mapped relations: swap relfilenodes, reltablespaces,
		 * relpersistence
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>target_is_pg_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>swaptemp</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>swaptemp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>swaptemp</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <name>swaptemp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>swaptemp</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relam</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relam</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relam</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>relam</name></name> <operator>=</operator> <name>swaptemp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>swptmpchr</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name>swptmpchr</name></expr>;</expr_stmt>

		<comment type="block">/* Also swap toast links, if we're swapping by links */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>swap_toast_by_content</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>swaptemp</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>=</operator> <name>swaptemp</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Mapped-relation case.  Here we have to swap the relation mappings
		 * instead of modifying the pg_class columns.  Both must be mapped.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relfilenode1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>relfilenode2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot swap mapped relation \"%s\" with non-mapped relation"</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We can't change the tablespace nor persistence of a mapped rel, and
		 * we can't handle toast link swapping for one either, because we must
		 * not apply any critical changes to its pg_class row.  These cases
		 * should be prevented by upstream permissions tests, so these checks
		 * are non-user-facing emergency backstop.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>!=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot change tablespace of mapped relation \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot change persistence of mapped relation \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relam</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot change access method of mapped relation \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>swap_toast_by_content</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>||</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot swap toast by links for mapped relation \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Fetch the mappings --- shouldn't fail, but be paranoid
		 */</comment>
		<expr_stmt><expr><name>relfilenode1</name> <operator>=</operator> <call><name>RelationMapOidToFilenode</name><argument_list>(<argument><expr><name>r1</name></expr></argument>, <argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relfilenode1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find relation mapping for relation \"%s\", OID %u"</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>relfilenode2</name> <operator>=</operator> <call><name>RelationMapOidToFilenode</name><argument_list>(<argument><expr><name>r2</name></expr></argument>, <argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relfilenode2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find relation mapping for relation \"%s\", OID %u"</literal></expr></argument>,
				 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Send replacement mappings to relmapper.  Note these won't actually
		 * take effect until CommandCounterIncrement.
		 */</comment>
		<expr_stmt><expr><call><name>RelationMapUpdateMap</name><argument_list>(<argument><expr><name>r1</name></expr></argument>, <argument><expr><name>relfilenode2</name></expr></argument>, <argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationMapUpdateMap</name><argument_list>(<argument><expr><name>r2</name></expr></argument>, <argument><expr><name>relfilenode1</name></expr></argument>, <argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Pass OIDs of mapped r2 tables back to caller */</comment>
		<expr_stmt><expr><operator>*</operator><name>mapped_tables</name><operator>++</operator> <operator>=</operator> <name>r2</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * In the case of a shared catalog, these next few steps will only affect
	 * our own database's pg_class row; but that's okay, because they are all
	 * noncritical updates.  That's also an important fact for the case of a
	 * mapped catalog, because it's possible that we'll commit the map change
	 * and then fail to commit the pg_class update.
	 */</comment>

	<comment type="block">/* set rel1's frozen Xid and minimum MultiXid */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>frozenXid</name></expr></argument>)</argument_list></call> <operator>||</operator>
			   <call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>frozenXid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>=</operator> <name>frozenXid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>cutoffMulti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relminmxid</name></name> <operator>=</operator> <name>cutoffMulti</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Greenplum: append-optimized tables do not have a valid relfrozenxid.
	 * Overwrite the entry for both relations.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator> <call><name>IsAccessMethodAO</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relform2</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator> <call><name>IsAccessMethodAO</name><argument_list>(<argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* swap size statistics too, since new rel has freshly-updated stats */</comment>
	<if_stmt><if>if <condition>(<expr><name>swap_stats</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>swap_pages</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float4</name></type>		<name>swap_tuples</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>swap_allvisible</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>swap_pages</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <name>swap_pages</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>swap_tuples</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <name>swap_tuples</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>swap_allvisible</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relallvisible</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relallvisible</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <name>swap_allvisible</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Update the tuples in pg_class --- unless the target relation of the
	 * swap is pg_class itself.  In that case, there is zero point in making
	 * changes because we'd be updating the old data that we're about to throw
	 * away.  Because the real work being done here for a mapped relation is
	 * just to change the relation map settings, it's all right to not update
	 * the pg_class rows in this case. The most important changes will instead
	 * performed later, in finish_heap_swap() itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>target_is_pg_class</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatalogIndexState</name></type> <name>indstate</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indstate</name> <operator>=</operator> <call><name>CatalogOpenIndexes</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdateWithInfo</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup1</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup1</name></expr></argument>,
								   <argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdateWithInfo</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup2</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup2</name></expr></argument>,
								   <argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogCloseIndexes</name><argument_list>(<argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no update ... but we do still need relcache inval */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByTuple</name><argument_list>(<argument><expr><name>reltup1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByTuple</name><argument_list>(<argument><expr><name>reltup2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Post alter hook for modified relations. The change to r2 is always
	 * internal, but r1 depends on the invocation context.
	 */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have toast tables associated with the relations being swapped,
	 * deal with them too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>||</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>swap_toast_by_content</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>&amp;&amp;</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Recursively swap the contents of the toast tables */</comment>
				<expr_stmt><expr><call><name>swap_relation_files</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>,
									<argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>,
									<argument><expr><name>target_is_pg_class</name></expr></argument>,
									<argument><expr><name>swap_toast_by_content</name></expr></argument>,
									<argument><expr><name>swap_stats</name></expr></argument>,
									<argument><expr><name>is_internal</name></expr></argument>,
									<argument><expr><name>frozenXid</name></expr></argument>,
									<argument><expr><name>cutoffMulti</name></expr></argument>,
									<argument><expr><name>mapped_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* caller messed up */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot swap toast files by content when there's only one"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We swapped the ownership links, so we need to change dependency
			 * data to match.
			 *
			 * NOTE: it is possible that only one table has a toast table.
			 *
			 * NOTE: at present, a TOAST table's only dependency is the one on
			 * its owning table.  If more are ever created, we'd need to use
			 * something more selective than deleteDependencyRecordsFor() to
			 * get rid of just the link we want.
			 */</comment>

			<comment type="block">/*
			 * We disallow this case for system catalogs, to avoid the
			 * possibility that the catalog we're rebuilding is one of the
			 * ones the dependency changes would change.  It's too late to be
			 * making any data changes to the target catalog.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsSystemClass</name><argument_list>(<argument><expr><name>r1</name></expr></argument>, <argument><expr><name>relform1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot swap toast files by links for system catalogs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Delete old dependencies */</comment>
			<expr_stmt><expr><call><name>changeDependencyLinks</name><argument_list>(<argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>,
								  <argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>, <argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>,
								  <argument><expr><literal type="string">"TOAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<comment type="block">/* 
		 * Check with assert if AO table's toast table kept existing relfrozenxid unchanged.
		 * 
		 * CLUSTER operation on append-optimized tables does not
		 * compute freeze limit (frozenXid) because AO tables do not
		 * have relfrozenxid.  The toast tables need to keep existing
		 * relfrozenxid value unchanged in this case.
		*/</comment>
		<if_stmt><if>if <condition>(<expr><name>swap_toast_by_content</name> 
			<operator>&amp;&amp;</operator> <name>frozenXid</name> <operator>==</operator> <name>InvalidTransactionId</name> 
			<operator>&amp;&amp;</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name> 
			<operator>&amp;&amp;</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>==</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If we're swapping two toast tables by content, do the same for their
	 * valid index. The swap can actually be safely done only if the relations
	 * have indexes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>swap_toast_by_content</name> <operator>&amp;&amp;</operator>
		<name><name>relform1</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name> <operator>&amp;&amp;</operator>
		<name><name>relform2</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>toastIndex1</name></decl>,
					<decl><type ref="prev"/><name>toastIndex2</name></decl>;</decl_stmt>

		<comment type="block">/* Get valid index for each relation */</comment>
		<expr_stmt><expr><name>toastIndex1</name> <operator>=</operator> <call><name>toast_get_valid_index</name><argument_list>(<argument><expr><name>r1</name></expr></argument>,
											<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>toastIndex2</name> <operator>=</operator> <call><name>toast_get_valid_index</name><argument_list>(<argument><expr><name>r2</name></expr></argument>,
											<argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>swap_relation_files</name><argument_list>(<argument><expr><name>toastIndex1</name></expr></argument>,
							<argument><expr><name>toastIndex2</name></expr></argument>,
							<argument><expr><name>target_is_pg_class</name></expr></argument>,
							<argument><expr><name>swap_toast_by_content</name></expr></argument>,
							<argument><expr><name>swap_stats</name></expr></argument>,
							<argument><expr><name>is_internal</name></expr></argument>,
							<argument><expr><name>InvalidTransactionId</name></expr></argument>,
							<argument><expr><name>InvalidMultiXactId</name></expr></argument>,
							<argument><expr><name>mapped_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Send statistics from QE to QD */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <name>swap_stats</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsSystemClass</name><argument_list>(<argument><expr><name>r1</name></expr></argument>, <argument><expr><name>relform1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>r1</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>vac_send_relstats_to_qd</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relpages</name></name></expr></argument>,
								<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltuples</name></name></expr></argument>,
								<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relallvisible</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Clean up. */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Close both relcache entries' smgr links.  We need this kluge because
	 * both links will be invalidated during upcoming CommandCounterIncrement.
	 * Whichever of the rels is the second to be cleared will have a dangling
	 * reference to the other's smgr entry.  Rather than trying to avoid this
	 * by ordering operations just so, it's easiest to close the links first.
	 * (Fortunately, since one of the entries is local in our transaction,
	 * it's sufficient to clear out our own relcache this way; the problem
	 * cannot arise for other backends when they see our update on the
	 * non-transient relation.)
	 *
	 * Caution: the placement of this step interacts with the decision to
	 * handle toast rels by recursion.  When we are trying to rebuild pg_class
	 * itself, the smgr close on pg_class must happen after all accesses in
	 * this function.
	 */</comment>
	<expr_stmt><expr><call><name>RelationCloseSmgrByOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RelationCloseSmgrByOid</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the transient table that was built by make_new_heap, and finish
 * cleaning up (including rebuilding all indexes on the old heap).
 */</comment>
<function><type><name>void</name></type>
<name>finish_heap_swap</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>OIDOldHeap</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>OIDNewHeap</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>is_system_catalog</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>swap_toast_by_content</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>swap_stats</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>check_constraints</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>,
				 <parameter><decl><type><name>TransactionId</name></type> <name>frozenXid</name></decl></parameter>,
				 <parameter><decl><type><name>MultiXactId</name></type> <name>cutoffMulti</name></decl></parameter>,
				 <parameter><decl><type><name>char</name></type> <name>newrelpersistence</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>mapped_tables</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>reindex_flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Report that we are now swapping relation files */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CLUSTER_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_CLUSTER_PHASE_SWAP_REL_FILES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Zero out possible results from swapped_relation_files */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mapped_tables</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mapped_tables</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Swap the contents of the heap relations (including any toast tables).
	 * Also set old heap's relfrozenxid to frozenXid.
	 */</comment>
	<expr_stmt><expr><call><name>swap_relation_files</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>, <argument><expr><name>OIDNewHeap</name></expr></argument>,
						<argument><expr><operator>(</operator><name>OIDOldHeap</name> <operator>==</operator> <name>RelationRelationId</name><operator>)</operator></expr></argument>,
						<argument><expr><name>swap_toast_by_content</name></expr></argument>,
						<argument><expr><name>swap_stats</name></expr></argument>,
						<argument><expr><name>is_internal</name></expr></argument>,
						<argument><expr><name>frozenXid</name></expr></argument>, <argument><expr><name>cutoffMulti</name></expr></argument>, <argument><expr><name>mapped_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"after_swap_relation_files"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a system catalog, queue a sinval message to flush all catcaches
	 * on the catalog when we reach CommandCounterIncrement.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_system_catalog</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CacheInvalidateCatalog</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Rebuild each index on the relation (but not the toast table, which is
	 * all-new at this point).  It is important to do this before the DROP
	 * step because if we are processing a system catalog that will be used
	 * during DROP, we want to have its indexes available.  There is no
	 * advantage to the other order anyway because this is all transactional,
	 * so no chance to reclaim disk space before commit.  We do not need a
	 * final CommandCounterIncrement() because reindex_relation does it.
	 *
	 * Note: because index_build is called via reindex_relation, it will never
	 * set indcheckxmin true for the indexes.  This is OK even though in some
	 * sense we are building new indexes rather than rebuilding existing ones,
	 * because the new heap won't contain any HOT chains at all, let alone
	 * broken ones, so it can't be necessary to set indcheckxmin.
	 */</comment>
	<expr_stmt><expr><name>reindex_flags</name> <operator>=</operator> <name>REINDEX_REL_SUPPRESS_INDEX_USE</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>check_constraints</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reindex_flags</name> <operator>|=</operator> <name>REINDEX_REL_CHECK_CONSTRAINTS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ensure that the indexes have the same persistence as the parent
	 * relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newrelpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reindex_flags</name> <operator>|=</operator> <name>REINDEX_REL_FORCE_INDEXES_UNLOGGED</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>newrelpersistence</name> <operator>==</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reindex_flags</name> <operator>|=</operator> <name>REINDEX_REL_FORCE_INDEXES_PERMANENT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Report that we are now reindexing relations */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CLUSTER_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_CLUSTER_PHASE_REBUILD_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>reindex_relation</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>, <argument><expr><name>reindex_flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report that we are now doing clean up */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_CLUSTER_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_CLUSTER_PHASE_FINAL_CLEANUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the relation being rebuild is pg_class, swap_relation_files()
	 * couldn't update pg_class's own pg_class entry (check comments in
	 * swap_relation_files()), thus relfrozenxid was not updated. That's
	 * annoying because a potential reason for doing a VACUUM FULL is a
	 * imminent or actual anti-wraparound shutdown.  So, now that we can
	 * access the new relation using its indices, update relfrozenxid.
	 * pg_class doesn't have a toast relation, so we don't need to update the
	 * corresponding toast relation. Not that there's little point moving all
	 * relfrozenxid updates here since swap_relation_files() needs to write to
	 * pg_class for non-mapped relations anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>OIDOldHeap</name> <operator>==</operator> <name>RelationRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>relRelation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>reltup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>relRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>OIDOldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>relform</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>=</operator> <name>frozenXid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform</name><operator>-&gt;</operator><name>relminmxid</name></name> <operator>=</operator> <name>cutoffMulti</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Destroy new heap with old filenode */</comment>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>OIDNewHeap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * The new relation is local to our transaction and we know nothing
	 * depends on it, so DROP_RESTRICT should be OK.
	 */</comment>
	<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><name>PERFORM_DELETION_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* performDeletion does CommandCounterIncrement at end */</comment>

	<comment type="block">/*
	 * Now we must remove any relation mapping entries that we set up for the
	 * transient table, as well as its toast table and toast index if any. If
	 * we fail to do this before commit, the relmapper will complain about new
	 * permanent map entries being added post-bootstrap.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>mapped_tables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationMapRemoveMapping</name><argument_list>(<argument><expr><name><name>mapped_tables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * At this point, everything is kosher except that, if we did toast swap
	 * by links, the toast table's name corresponds to the transient table.
	 * The name is irrelevant to the backend because it's referenced by OID,
	 * but users looking at the catalogs could be confused.  Rename it to
	 * prevent this problem.
	 *
	 * Note no lock required on the relation, because we already hold an
	 * exclusive lock on it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>swap_toast_by_content</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>newrel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>newrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>toastidx</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>NewToastName</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

			<comment type="block">/* Get the associated valid index to be renamed */</comment>
			<expr_stmt><expr><name>toastidx</name> <operator>=</operator> <call><name>toast_get_valid_index</name><argument_list>(<argument><expr><name><name>newrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>,
											 <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* rename the toast table ... */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>NewToastName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_%u"</literal></expr></argument>,
					 <argument><expr><name>OIDOldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name><name>newrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>,
								   <argument><expr><name>NewToastName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* ... and its valid index too. */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>NewToastName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_%u_index"</literal></expr></argument>,
					 <argument><expr><name>OIDOldHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name>toastidx</name></expr></argument>,
								   <argument><expr><name>NewToastName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if it's not a catalog table, clear any missing attribute settings */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_system_catalog</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>newrel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OIDOldHeap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationClearMissing</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>newrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Get a list of tables that the current user owns and
 * have indisclustered set.  Return the list in a List * of rvsToCluster
 * with the tableOid and the indexOid on which the table is already
 * clustered.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_tables_to_cluster</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>cluster_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelToCluster</name> <modifier>*</modifier></type><name>rvtc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rvs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get all indexes that have indisclustered set and are owned by
	 * appropriate user. System relations or nailed-in relations cannot ever
	 * have indisclustered set, because CLUSTER will refuse to set it when
	 * called with one of them as argument.
	 */</comment>
	<expr_stmt><expr><name>indRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>,
				<argument><expr><name>Anum_pg_index_indisclustered</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_BOOLEQ</name></expr></argument>,
				<argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>indRelation</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>indexTuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We have to build the list in a different memory context so it will
		 * survive the cross-transaction processing
		 */</comment>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>cluster_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rvtc</name> <operator>=</operator> <operator>(</operator><name>RelToCluster</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelToCluster</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rvtc</name><operator>-&gt;</operator><name>tableOid</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rvtc</name><operator>-&gt;</operator><name>indexOid</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indexrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rvs</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>rvtc</name></expr></argument>, <argument><expr><name>rvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>indRelation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rvs</name></expr>;</return>
</block_content>}</block></function>
</unit>
