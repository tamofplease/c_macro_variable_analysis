<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/commands/exttablecmds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * exttablecmds.c
 *	  Commands for creating and altering external tables
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/exttablecmds.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/external.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/extprotocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/oid_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extprotocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/uri.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsreh.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>transformLocationUris</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>locs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isweb</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iswritable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>transformExecOnClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>on_clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>transformFormatType</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>formatname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>transformFormatOpts</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>formattype</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>formatOpts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numcols</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iswritable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvokeProtocolValidation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>procOid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>procName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iswritable</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>locs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExtractErrorLogPersistent</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GenerateExtTableEntryOptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tbloid</name></decl></parameter>,
										   <parameter><decl><type><name>bool</name></type> <name>iswritable</name></decl></parameter>,
										   <parameter><decl><type><name>bool</name></type> <name>issreh</name></decl></parameter>,
										   <parameter><decl><type><name>char</name></type> <name>formattype</name></decl></parameter>,
										   <parameter><decl><type><name>char</name></type> <name>rejectlimittype</name></decl></parameter>,
										   <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>commandString</name></decl></parameter>,
										   <parameter><decl><type><name>int</name></type> <name>rejectlimit</name></decl></parameter>,
										   <parameter><decl><type><name>char</name></type> <name>logerrors</name></decl></parameter>,
										   <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>,
										   <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>locationExec</name></decl></parameter>,
										   <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>locationUris</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------------------------------------------------------
*		DefineExternalRelation
*				Creates a new external relation.
*
* In here we first dispatch a normal DefineRelation() (with relstorage
* external) in order to create the external relation entries in pg_class
* pg_type etc. Then once this is done we dispatch ourselves (DefineExternalRelation)
* in order to create the pg_foreign_table entry across the gp array.
*
* Why don't we just do all of this in one dispatch run? Because that
* involves duplicating the DefineRelation() code or severely modifying it
* to have special cases for external tables. IMHO it's better and cleaner
* to leave it intact and do another dispatch.
* ----------------------------------------------------------------
*/</comment>
<function><type><name>void</name></type>
<name>DefineExternalRelation</name><parameter_list>(<parameter><decl><type><name>CreateExternalStmt</name> <modifier>*</modifier></type><name>createExtStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateForeignTableStmt</name> <modifier>*</modifier></type><name>createForeignTableStmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createStmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtTableTypeDesc</name> <modifier>*</modifier></type><name>exttypeDesc</name> <init>= <expr><operator>(</operator><name>ExtTableTypeDesc</name> <operator>*</operator><operator>)</operator> <name><name>createExtStmt</name><operator>-&gt;</operator><name>exttypedesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SingleRowErrorDesc</name> <modifier>*</modifier></type><name>singlerowerrorDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>dencoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>objAddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>formatOpts</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>entryOptions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>locationUris</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>locationExec</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>commandString</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>rejectlimittype</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>formattype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rejectlimit</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>encoding</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>issreh</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* is single row error handling requested? */</comment>
	<decl_stmt><decl><type><name>char</name></type> 		<name>logerrors</name> <init>= <expr><name>LOG_ERRORS_DISABLE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>log_persistent_option</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>iswritable</name> <init>= <expr><name><name>createExtStmt</name><operator>-&gt;</operator><name>iswritable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isweb</name> <init>= <expr><name><name>createExtStmt</name><operator>-&gt;</operator><name>isweb</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldDispatch</name> <init>= <expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator>
								  <call><name>IsNormalProcessingMode</name><argument_list>()</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Identify user ID that will own the table */</comment>
	<expr_stmt><expr><name>userid</name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * now set the parameters for keys/inheritance etc. Most of these are
	 * uninteresting for external relations...
	 */</comment>
	<expr_stmt><expr><name>createForeignTableStmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateForeignTableStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>createStmt</name> <operator>=</operator> <operator>&amp;</operator><name><name>createForeignTableStmt</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name><name>createExtStmt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <name><name>createExtStmt</name><operator>-&gt;</operator><name>tableElts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>=</operator> <name>ONCOMMIT_NOOP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>tablespacename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>distributedBy</name></name> <operator>=</operator> <name><name>createExtStmt</name><operator>-&gt;</operator><name>distributedBy</name></name></expr>;</expr_stmt> <comment type="block">/* policy was set in transform */</comment>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>ownerid</name></name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>gp_style_alter_part</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>exttypeDesc</name><operator>-&gt;</operator><name>exttabletype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXTTBL_TYPE_LOCATION</name></expr>:</case>
			<comment type="block">/* Parse and validate URI strings (LOCATION clause) */</comment>
			<expr_stmt><expr><name>locationExec</name> <operator>=</operator> <call><name>transformExecOnClause</name><argument_list>(<argument><expr><name><name>exttypeDesc</name><operator>-&gt;</operator><name>on_clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>locationUris</name> <operator>=</operator> <call><name>transformLocationUris</name><argument_list>(<argument><expr><name><name>exttypeDesc</name><operator>-&gt;</operator><name>location_list</name></name></expr></argument>,
												 <argument><expr><name>isweb</name></expr></argument>, <argument><expr><name>iswritable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXTTBL_TYPE_EXECUTE</name></expr>:</case>
			<expr_stmt><expr><name>locationExec</name> <operator>=</operator> <call><name>transformExecOnClause</name><argument_list>(<argument><expr><name><name>exttypeDesc</name><operator>-&gt;</operator><name>on_clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>commandString</name> <operator>=</operator> <name><name>exttypeDesc</name><operator>-&gt;</operator><name>command_string</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>commandString</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid EXECUTE clause, command string is empty"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"internal error: unknown external table type: %i"</literal></expr></argument>,
				 <argument><expr><name><name>exttypeDesc</name><operator>-&gt;</operator><name>exttabletype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Parse and validate FORMAT clause.
	 */</comment>
	<expr_stmt><expr><name>formattype</name> <operator>=</operator> <call><name>transformFormatType</name><argument_list>(<argument><expr><name><name>createExtStmt</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>formatOpts</name> <operator>=</operator> <call><name>transformFormatOpts</name><argument_list>(<argument><expr><name>formattype</name></expr></argument>,
									   <argument><expr><name><name>createExtStmt</name><operator>-&gt;</operator><name>formatOpts</name></name></expr></argument>,
									   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>createExtStmt</name><operator>-&gt;</operator><name>tableElts</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name>iswritable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parse and validate OPTION clause.
	 */</comment>
	<expr_stmt><expr><name>log_persistent_option</name> <operator>=</operator> <call><name>ExtractErrorLogPersistent</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>createExtStmt</name><operator>-&gt;</operator><name>extOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * createExtStmt-&gt;extOptions is in a temporary context, duplicate it,
	 * checkout transformCreateExternalStmt() for the details.
	 */</comment>
	<expr_stmt><expr><name>formatOpts</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>formatOpts</name></expr></argument>, <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>createExtStmt</name><operator>-&gt;</operator><name>extOptions</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Parse single row error handling info if available
	 */</comment>
	<expr_stmt><expr><name>singlerowerrorDesc</name> <operator>=</operator> <operator>(</operator><name>SingleRowErrorDesc</name> <operator>*</operator><operator>)</operator> <name><name>createExtStmt</name><operator>-&gt;</operator><name>sreh</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>singlerowerrorDesc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>iswritable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>issreh</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>logerrors</name> <operator>=</operator> <name><name>singlerowerrorDesc</name><operator>-&gt;</operator><name>log_error_type</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IS_LOG_ERRORS_ENABLE</name><argument_list>(<argument><expr><name>logerrors</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>log_persistent_option</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>logerrors</name> <operator>=</operator> <name>LOG_ERRORS_PERSISTENTLY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>singlerowerrorDesc</name><operator>-&gt;</operator><name>log_error_type</name></name> <operator>=</operator> <name>LOG_ERRORS_PERSISTENTLY</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* get reject limit, and reject limit type */</comment>
		<expr_stmt><expr><name>rejectlimit</name> <operator>=</operator> <name><name>singlerowerrorDesc</name><operator>-&gt;</operator><name>rejectlimit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rejectlimittype</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>singlerowerrorDesc</name><operator>-&gt;</operator><name>is_limit_in_rows</name></name></expr> ?</condition><then> <expr><literal type="char">'r'</literal></expr> </then><else>: <expr><literal type="char">'p'</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>VerifyRejectLimit</name><argument_list>(<argument><expr><name>rejectlimittype</name></expr></argument>, <argument><expr><name>rejectlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Parse external table data encoding
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>createExtStmt-&gt;encoding</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>dencoding</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant ENCODING specification"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>dencoding</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>dencoding</name> <operator>&amp;&amp;</operator> <name><name>dencoding</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding_name</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>dencoding</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Integer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>dencoding</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>encoding_name</name> <operator>=</operator> <call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding_name</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>pg_valid_client_encoding</name><argument_list>(<argument><expr><name>encoding_name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%d is not a valid encoding code"</literal></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>dencoding</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>encoding_name</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name><name>dencoding</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>pg_valid_client_encoding</name><argument_list>(<argument><expr><name>encoding_name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not a valid encoding name"</literal></expr></argument>,
								<argument><expr><name>encoding_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>pg_char_to_encoding</name><argument_list>(<argument><expr><name>encoding_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>dencoding</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If encoding is defaulted, use database server encoding */</comment>
	<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the number of locations (file or http URIs) exceed the number of
	 * segments in the cluster, then all queries against the table will fail
	 * since locations must be mapped at most one per segment. Allow the
	 * creation since this is old pre-existing behavior but throw a WARNING
	 * that the user must expand the cluster in order to use it (or alter
	 * the table).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>exttypeDesc</name><operator>-&gt;</operator><name>exttabletype</name></name> <operator>==</operator> <name>EXTTBL_TYPE_LOCATION</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Value</name>	<modifier>*</modifier></type><name>loc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>exttypeDesc</name><operator>-&gt;</operator><name>location_list</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Uri</name> 	<modifier>*</modifier></type><name>uri</name> <init>= <expr><call><name>ParseExternalTableUri</name><argument_list>(<argument><expr><name><name>loc</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_FILE</name> <operator>||</operator> <name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_HTTP</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>exttypeDesc</name><operator>-&gt;</operator><name>location_list</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of locations (%d) exceeds the number of segments (%d)"</literal></expr></argument>,
									<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>exttypeDesc</name><operator>-&gt;</operator><name>location_list</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The table cannot be queried until cluster is expanded so that there are at least as many segments as locations."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * First, create the pg_class and other regular relation catalog entries.
	 */</comment>
	<expr_stmt><expr><name>objAddr</name> <operator>=</operator> <call><name>DefineRelation</name><argument_list>(<argument><expr><name>createStmt</name></expr></argument>,
							 <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* dispatch */</comment>
							 <argument><expr><name>true</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reloid</name> <operator>=</operator> <name><name>objAddr</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now add pg_foreign_table entries.
	 *
	 * get our pg_class external rel OID. If we're the QD we just created it
	 * above. If we're a QE DefineRelation() was already dispatched to us and
	 * therefore we have a local entry in pg_class. get the OID from cache.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>reloid</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>reloid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>createExtStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>entryOptions</name> <operator>=</operator> <call><name>GenerateExtTableEntryOptions</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>,
										   <argument><expr><name>iswritable</name></expr></argument>,
										   <argument><expr><name>issreh</name></expr></argument>,
										   <argument><expr><name>formattype</name></expr></argument>,
										   <argument><expr><name>rejectlimittype</name></expr></argument>,
										   <argument><expr><name>commandString</name></expr></argument>,
										   <argument><expr><name>rejectlimit</name></expr></argument>,
										   <argument><expr><name>logerrors</name></expr></argument>,
										   <argument><expr><name>encoding</name></expr></argument>,
										   <argument><expr><name>locationExec</name></expr></argument>,
										   <argument><expr><name>locationUris</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>createForeignTableStmt</name><operator>-&gt;</operator><name>servername</name></name> <operator>=</operator> <name>GP_EXTTABLE_SERVER_NAME</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createForeignTableStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>formatOpts</name></expr></argument>, <argument><expr><name>entryOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CreateForeignTable</name><argument_list>(<argument><expr><name>createForeignTableStmt</name></expr></argument>, <argument><expr><name>reloid</name></expr></argument>,
					   <argument><expr><name>true</name></expr></argument> <comment type="block">/* skip permission checks, we checked them ourselves */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * DefineRelation loaded the new relation into relcache, but the relcache
	 * contains the distribution policy, which in turn depends on the contents
	 * of pg_foreign_table, for EXECUTE-type external tables (see GpPolicyFetch()).
	 * Now that we have created the pg_foreign_table entry, invalidate the
	 * relcache, so that it gets loaded with the correct information.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>shouldDispatch</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Dispatch the statement tree to all primary segdbs. Doesn't wait for
		 * the QEs to finish execution.
		 */</comment>
		<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>createExtStmt</name></expr></argument>,
									<argument><expr><name>DF_CANCEL_ON_ERROR</name> <operator>|</operator>
									<name>DF_WITH_SNAPSHOT</name> <operator>|</operator>
									<name>DF_NEED_TWO_PHASE</name></expr></argument>,
									<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transform the URI string list into a string. While at it we validate the URI
 * strings.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>
<name>transformLocationUris</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>locs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isweb</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iswritable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>UriProtocol</name></type> <name>first_protocol</name> <init>= <expr><name>URI_FILE</name></expr></init></decl>;</decl_stmt>		<comment type="block">/* initialize to keep gcc
												 * quiet */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first_uri</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FDIST_DEF_PORT</name></cpp:macro> <cpp:value>8080</cpp:value></cpp:define>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parser should not let this happen */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>locs</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * iterate through the user supplied URI list from LOCATION clause.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>locs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Uri</name>		   <modifier>*</modifier></type><name>uri</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>uri_str_orig</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>uri_str_final</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* get the current URI string from the command */</comment>
		<expr_stmt><expr><name>uri_str_orig</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>

		<comment type="block">/* parse it to its components */</comment>
		<expr_stmt><expr><name>uri</name> <operator>=</operator> <call><name>ParseExternalTableUri</name><argument_list>(<argument><expr><name>uri_str_orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * in here edit the uri string if needed
		 */</comment>

		<comment type="block">/*
		 * no port was specified for gpfdist, gpfdists or hdfs. add the
		 * default
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_GPFDIST</name> <operator>||</operator> <name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_GPFDISTS</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>uri</name><operator>-&gt;</operator><name>port</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>at_hostname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>uri_str_orig</name>
			<operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_GPFDIST</name></expr> ?</condition><then> <expr><literal type="string">"gpfdist://"</literal></expr> </then><else>: <expr><literal type="string">"gpfdists://"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>after_hostname</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>at_hostname</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><name>after_hostname</name> <operator>-</operator> <name>at_hostname</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>hostname</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>at_hostname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>hostname</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<comment type="block">/* add the default port number to the uri string */</comment>
			<expr_stmt><expr><name>uri_str_final</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s:%d%s"</literal></expr></argument>,
					<argument><expr><operator>(</operator><ternary><condition><expr><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_GPFDIST</name></expr> ?</condition><then> <expr><name>PROTOCOL_GPFDIST</name></expr> </then><else>: <expr><name>PROTOCOL_GPFDISTS</name></expr></else></ternary><operator>)</operator></expr></argument>,
					<argument><expr><name>hostname</name></expr></argument>,
					<argument><expr><name>FDIST_DEF_PORT</name></expr></argument>, <argument><expr><name>after_hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* no changes to original uri string */</comment>
			<expr_stmt><expr><name>uri_str_final</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>uri_str_orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If a custom protocol is used, validate its existence. If it exists,
		 * and a custom protocol url validator exists as well, invoke it now.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>first_uri</name> <operator>&amp;&amp;</operator> <name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_CUSTOM</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>procOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>procOid</name> <operator>=</operator> <call><name>LookupExtProtocolFunction</name><argument_list>(<argument><expr><name><name>uri</name><operator>-&gt;</operator><name>customprotocol</name></name></expr></argument>,
												<argument><expr><name>EXTPTC_FUNC_VALIDATOR</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>InvokeProtocolValidation</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>,
										 <argument><expr><name><name>uri</name><operator>-&gt;</operator><name>customprotocol</name></name></expr></argument>,
										 <argument><expr><name>iswritable</name></expr></argument>,
										 <argument><expr><name>locs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>first_uri</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>first_protocol</name> <operator>=</operator> <name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>!=</operator> <name>first_protocol</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"URI protocols must be the same for all data sources"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Available protocols are 'http', 'file', 'gpfdist' and 'gpfdists'."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>!=</operator> <name>URI_HTTP</name> <operator>&amp;&amp;</operator> <name>isweb</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"an EXTERNAL WEB TABLE may only use http URI\'s, problem in: \'%s\'"</literal></expr></argument>, <argument><expr><name>uri_str_final</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use CREATE EXTERNAL TABLE instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_HTTP</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isweb</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"http URI\'s can only be used in an external web table"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use CREATE EXTERNAL WEB TABLE instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>iswritable</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_HTTP</name> <operator>||</operator> <name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_FILE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported URI protocol \'%s\' for writable external table"</literal></expr></argument>,
							<argument><expr><operator>(</operator><ternary><condition><expr><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_HTTP</name></expr> ?</condition><then> <expr><literal type="string">"http"</literal></expr> </then><else>: <expr><literal type="string">"file"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Writable external tables may use \'gpfdist\' or \'gpfdists\' URIs only."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>!=</operator> <name>URI_CUSTOM</name> <operator>&amp;&amp;</operator> <name>iswritable</name> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>uri</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported use of wildcard in a writable external web table definition: \'%s\'"</literal></expr></argument>,
							<argument><expr><name>uri_str_final</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify the explicit path and file name to write into."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_GPFDIST</name> <operator>||</operator> <name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_GPFDISTS</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>iswritable</name> <operator>&amp;&amp;</operator> <name><name>uri</name><operator>-&gt;</operator><name>path</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>uri</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported use of a directory name in a writable gpfdist(s) external table : \'%s\'"</literal></expr></argument>,
							<argument><expr><name>uri_str_final</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify the explicit path and file name to write into."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>first_uri</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>uri_str_final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first_uri</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"|%s"</literal></expr></argument>, <argument><expr><name>uri_str_final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>FreeExternalTableUri</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>uri_str_final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>
<name>transformExecOnClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>on_clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>exec_location_opt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exec_location_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>on_clause</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>exec_location_str</name> <operator>=</operator> <literal type="string">"ALL_SEGMENTS"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Extract options from the statement node tree NOTE: as of now we only
		 * support one option in the ON clause and therefore more than one is an
		 * error (check here in case the sql parser isn't strict enough).
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>exec_location_opt</argument>, <argument>on_clause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>exec_location_opt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* only one element is allowed! */</comment>
			<if_stmt><if>if <condition>(<expr><name>exec_location_str</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON clause must not have more than one element"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* result: "ALL_SEGMENTS" */</comment>
				<expr_stmt><expr><name>exec_location_str</name> <operator>=</operator> <literal type="string">"ALL_SEGMENTS"</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"hostname"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* result: "HOST:&lt;hostname&gt;" */</comment>
				<expr_stmt><expr><name>exec_location_str</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"HOST:%s"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"eachhost"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* result: "PER_HOST" */</comment>
				<expr_stmt><expr><name>exec_location_str</name> <operator>=</operator> <literal type="string">"PER_HOST"</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"coordinator"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* result: "COORDINATOR_ONLY" */</comment>
				<expr_stmt><expr><name>exec_location_str</name> <operator>=</operator> <literal type="string">"COORDINATOR_ONLY"</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"segment"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* result: "SEGMENT_ID:&lt;segid&gt;" */</comment>
				<expr_stmt><expr><name>exec_location_str</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"SEGMENT_ID:%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"random"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* result: "TOTAL_SEGS:&lt;number&gt;" */</comment>
				<expr_stmt><expr><name>exec_location_str</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"TOTAL_SEGS:%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>intVal</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown location code for EXECUTE in tablecmds"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>exec_location_str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform format name for external table FORMAT option to format code and
 * validate that the requested format is supported.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name></type>
<name>transformFormatType</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>formatname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>result</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>formatname</name></expr></argument>, <argument><expr><literal type="string">"text"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>formatname</name></expr></argument>, <argument><expr><literal type="string">"csv"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="char">'c'</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>formatname</name></expr></argument>, <argument><expr><literal type="string">"custom"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported format '%s'"</literal></expr></argument>, <argument><expr><name>formatname</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Available formats for external tables are \"text\", \"csv\" and \"custom\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Join the elements of the list separated by the specified delimiter and
 * return as a string. There will be no whitespace added for prettyprinting,
 * this is more intended for serializing. The caller is responsible for
 * managing the returned memory.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>list_join</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>delimiter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>	   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cellval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cellval</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%c"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>cellval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Rather than keeping track of when we're adding the last element, trim
	 * the final delimiter to keep it simple.
	 */</comment>
	<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>data</name><index>[<expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform the FORMAT options List into a new List suitable for storing in
 * pg_foreigntable.ftoptions.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>transformFormatOpts</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>formattype</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>formatOpts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numcols</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iswritable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> 	   <modifier>*</modifier></type><name>cslist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CopyState</name></type> <name>cstate</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyStateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>fmttype_is_custom</name><argument_list>(<argument><expr><name>formattype</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>fmttype_is_text</name><argument_list>(<argument><expr><name>formattype</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>fmttype_is_csv</name><argument_list>(<argument><expr><name>formattype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract options from the statement node tree */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fmttype_is_text</name><argument_list>(<argument><expr><name>formattype</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>fmttype_is_csv</name><argument_list>(<argument><expr><name>formattype</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>formatOpts</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"delimiter"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"header"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"quote"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"escape"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"force_not_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"force_quote"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"fill_missing_fields"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"newline"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ok */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"formatter"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"formatter option only valid for custom formatters"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>,
					 <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/* If CSV format was chosen, make it visible to ProcessCopyOptions. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>fmttype_is_csv</name><argument_list>(<argument><expr><name>formattype</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>formatOpts</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>formatOpts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>formatOpts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>formatOpts</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"format"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"csv"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cslist</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"format"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"csv"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cslist</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"format"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"text"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* verify all user supplied control char combinations are legal */</comment>
		<expr_stmt><expr><call><name>ProcessCopyOptions</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
						   <argument><expr><name>cstate</name></expr></argument>,
						   <argument><expr><operator>!</operator><name>iswritable</name></expr></argument>, <comment type="block">/* is_from */</comment>
						   <argument><expr><name>formatOpts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>delim_off</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>numcols</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"using no delimiter is only possible for a single column table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iswritable</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* RET */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"HEADER means that each one of the data files has a header row"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* WET */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_FEATURE_NOT_YET</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"HEADER is not yet supported for writable external tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* keep the same order with the original pg_exttable catalog's fmtopt field */</comment>
		<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cslist</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"delimiter"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cslist</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>null_print</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cslist</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"escape"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>escape</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>fmttype_is_csv</name><argument_list>(<argument><expr><name>formattype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cslist</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"quote"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>quote</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>header_line</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cslist</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"header"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>fill_missing</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cslist</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"fill_missing_fields"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Re-construct the FORCE NOT NULL list string */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cslist</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"force_not_null"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>list_join</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_notnull</name></name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Re-construct the FORCE QUOTE list string */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cslist</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"force_quote"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>list_join</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote</name></name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>force_quote_all</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cslist</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"force_quote"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_str</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cslist</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"newline"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>eol_str</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>formatOpts</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"formatter"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"redundant formatter option"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no formatter function specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>formatOpts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cslist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cslist</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"format"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"custom"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>cslist</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvokeProtocolValidation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>procOid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>procName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iswritable</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>locs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtProtocolValidatorData</name> <modifier>*</modifier></type><name>validator_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>validator_udf</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>validator_data</name> <operator>=</operator> <operator>(</operator><name>ExtProtocolValidatorData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExtProtocolValidatorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>validator_udf</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>procOid</name></expr></argument>, <argument><expr><name>validator_udf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>validator_data</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_ExtProtocolValidatorData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>validator_data</name><operator>-&gt;</operator><name>url_list</name></name> <operator>=</operator> <name>locs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>validator_data</name><operator>-&gt;</operator><name>errmsg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>validator_data</name><operator>-&gt;</operator><name>direction</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>iswritable</name></expr> ?</condition><then> <expr><name>EXT_VALIDATE_WRITE</name></expr> </then><else>:
								 <expr><name>EXT_VALIDATE_READ</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>( <comment type="block">/* FunctionCallInfoData */</comment> <argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>,
							  <comment type="block">/* FmgrInfo */</comment> <argument><expr><name>validator_udf</name></expr></argument>,
							  <comment type="block">/* nArgs */</comment> <argument><expr><literal type="number">0</literal></expr></argument>,
							  <comment type="block">/* Collation */</comment> <argument><expr><name>InvalidOid</name></expr></argument>, 
							  <comment type="block">/* Call Context */</comment> <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>validator_data</name></expr></argument>,
							  <comment type="block">/* ResultSetInfo */</comment> <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* invoke validator. if this function returns - validation passed */</comment>
	<expr_stmt><expr><call><name>FunctionCallInvoke</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We do not expect a null result */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"validator function %u returned NULL"</literal></expr></argument>,
			 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>validator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>validator_udf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExtractErrorLogPersistent - load LOG ERRORS PERSISTENTLY from options.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExtractErrorLogPersistent</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>*options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"error_log_persistent"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>options</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><operator>*</operator><name>options</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* these accept only boolean values */</comment>
			<return>return <expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a list of ExtTableEntry options
 */</comment>
<function><type><specifier>static</specifier> <name>List</name><modifier>*</modifier></type>
<name>GenerateExtTableEntryOptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> 	<name>tbloid</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> 	<name>iswritable</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type>	<name>issreh</name></decl></parameter>,
							 <parameter><decl><type><name>char</name></type>	<name>formattype</name></decl></parameter>,
							 <parameter><decl><type><name>char</name></type>	<name>rejectlimittype</name></decl></parameter>,
							 <parameter><decl><type><name>char</name><modifier>*</modifier></type>	<name>commandString</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type>	<name>rejectlimit</name></decl></parameter>,
							 <parameter><decl><type><name>char</name></type>	<name>logerrors</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type>	<name>encoding</name></decl></parameter>,
							 <parameter><decl><type><name>char</name><modifier>*</modifier></type>	<name>locationExec</name></decl></parameter>,
							 <parameter><decl><type><name>char</name><modifier>*</modifier></type>	<name>locationUris</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>entryOptions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>entryOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entryOptions</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"format_type"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>formattype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>commandString</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* EXECUTE type table - store command and command location */</comment>
		<expr_stmt><expr><name>entryOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entryOptions</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"command"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>commandString</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>entryOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entryOptions</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"execute_on"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>locationExec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* LOCATION type table - store uri locations. command is NULL */</comment>
		<expr_stmt><expr><name>entryOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entryOptions</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"location_uris"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>locationUris</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>entryOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entryOptions</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"execute_on"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>locationExec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>issreh</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>entryOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entryOptions</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"reject_limit"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>rejectlimit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>entryOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entryOptions</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"reject_limit_type"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>rejectlimittype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>entryOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entryOptions</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"log_errors"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>logerrors</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entryOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entryOptions</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"encoding"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entryOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entryOptions</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"is_writable"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><ternary><condition><expr><name>iswritable</name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add the dependency of custom external table
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>locationUris</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>locationUris_list</name> <init>= <expr><call><name>TokenizeLocationUris</name><argument_list>(<argument><expr><name>locationUris</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>locationUris_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type>	<name>myself</name></decl>, <decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>location</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>protocol</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>position</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>position</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call> <operator>-</operator> <name>location</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>protocol</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>tbloid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ExtprotocolRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>get_extprotocol_oid</name><argument_list>(<argument><expr><name>protocol</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * Only tables with custom protocol should create dependency, for
			 * internal protocols will get referenced.objectId as 0.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>entryOptions</name></expr>;</return>
</block_content>}</block></function>
</unit>
