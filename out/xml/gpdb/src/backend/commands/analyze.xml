<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/commands/analyze.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * analyze.c
 *	  the Postgres statistics generator
 *
 *
 * There are a few things in Greenplum that make this more complicated
 * than in upstream:
 *
 * Dispatching
 * -----------
 *
 * Greenplum is an MPP system, so we need to collect the statistics from
 * all the segments. The segment servers don't keep statistics (unless you
 * connect to a segment in utility node and run ANALYZE directly), and
 * the orchestration of ANALYZE happens in the dispatcher. The high
 * level logic is the same as in upstream, but a few functions have been
 * modified to gather data from the segments, instead of reading directly
 * from local disk:
 *
 * acquire_sample_rows(), when called in the dispatcher, calls into the
 * segments to acquire the sample across all segments.
 * RelationGetNumberOfBlocks() calls have been replaced with a wrapper
 * function, AcquireNumberOfBlocks(), which likewise calls into the
 * segments, to get total relation size across all segments.
 *
 * AcquireNumberOfBlocks() calls pg_relation_size(), which already
 * contains the logic to gather the size from all segments.
 *
 * Acquiring the sample rows is more tricky. When called in dispatcher,
 * acquire_sample_rows() calls a helper function called gp_acquire_sample_rows()
 * in the segments, to collect a sample on each segment. It then merges
 * the sample rows from each segment to produce a sample of the whole
 * cluster. gp_acquire_sample_rows() in turn calls acquire_sample_rows(), to
 * collect the sample on the segment.
 *
 * One complication with collecting the sample is the way that very
 * large datums are handled. We don't want to transfer multi-gigabyte
 * tuples from each segment. That would slow things down, and risk
 * running out of memory, if the sample contains a lot of them. They
 * are not very useful for statistics, anyway; hardly anyone builds an
 * index or does lookups where the histogram or MCV is meaningful for
 * very large keys. PostgreSQL also ignores any datums larger than
 * WIDTH_THRESHOLD (1kB) in the statistics computation, and we use the
 * same limit to restrict what gets transferred from the segments.
 * We substitute the very large datums with NULLs in the sample, but
 * keep track separately, which datums came out as NULLs because they
 * were too large, as opposed to "real" NULLs.
 *
 *
 * Merging leaf statistics with hyperloglog
 * ----------------------------------------
 *
 * TODO: explain how this works.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/analyze.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupconvert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/extended_stats_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/statistics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/attoptcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_rusage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sampling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sortsupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbaocsam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/analyzeutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hyperloglog/gp_hyperloglog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * For Hyperloglog, we define an error margin of 0.3%. If the number of
 * distinct values estimated by hyperloglog is within an error of 0.3%,
 * we consider everything as distinct.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GP_HLL_ERROR_MARGIN</name></cpp:macro>  <cpp:value>0.003</cpp:value></cpp:define>

<comment type="block">/* Fix attr number of return record of function gp_acquire_sample_rows */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIX_ATTR_NUM</name></cpp:macro>  <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* Per-index data for ANALYZE */</comment>
<typedef>typedef <type><struct>struct <name>AnlIndexData</name>
<block>{
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>		<comment type="block">/* BuildIndexInfo result */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>tupleFract</name></decl>;</decl_stmt>		<comment type="block">/* fraction of rows for partial index */</comment>
	<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl>;</decl_stmt>	<comment type="block">/* index attrs to analyze */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>attr_cnt</name></decl>;</decl_stmt>
}</block></struct></type> <name>AnlIndexData</name>;</typedef>


<comment type="block">/* Default statistics target (GUC parameter) */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>default_statistics_target</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* A few variables that don't seem worth passing around as parameters */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>anl_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BufferAccessStrategy</name></type> <name>vac_strategy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Bitmapset</name>	<modifier>*</modifier><modifier>*</modifier></type><name>acquire_func_colLargeRowIndexes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name>		 <modifier>*</modifier></type><name>acquire_func_colLargeRowLength</name></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_analyze_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>,
						   <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>,
						   <parameter><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>relpages</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_outer_xact</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
						   <parameter><decl><type><name>gp_acquire_sample_rows_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_index_stats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>,
								<parameter><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>indexdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>,
								<parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>,
								<parameter><decl><type><name>MemoryContext</name></type> <name>col_context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>VacAttrStats</name> <modifier>*</modifier></type><name>examine_attribute</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>,
									   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>index_expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>acquire_sample_rows_dispatcher</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
										  <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
										  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BlockNumber</name></type> <name>acquire_index_number_of_blocks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexrel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>tablerel</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>compare_rows</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>update_attstats</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>, <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>std_fetch_func</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ind_fetch_func</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>analyze_rel_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
								 <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>in_outer_xact</name></decl></parameter>, <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>,
								 <parameter><decl><type><name>gp_acquire_sample_rows_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>acquire_hll_by_query</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nattrs</name></decl></parameter>, <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>attrstats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 *	analyze_rel() -- analyze one relation
 *
 * relid identifies the relation to analyze.  If relation is supplied, use
 * the name therein for reporting any failure to open/lock the rel; do not
 * use it once we've successfully opened the rel, since it might be stale.
 */</comment>
<function><type><name>void</name></type>
<name>analyze_rel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
			<parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_outer_xact</name></decl></parameter>,
			<parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>, <parameter><decl><type><name>gp_acquire_sample_rows_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>optimizerBackup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Temporarily disable ORCA because it's slow to start up, and it
	 * wouldn't come up with any better plan for the simple queries that
	 * we run.
	 */</comment>
	<expr_stmt><expr><name>optimizerBackup</name> <operator>=</operator> <name>optimizer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>optimizer</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>analyze_rel_internal</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>va_cols</name></expr></argument>,
							 <argument><expr><name>in_outer_xact</name></expr></argument>, <argument><expr><name>bstrategy</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<comment type="block">/* Clean up in case of error. */</comment>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>optimizer</name> <operator>=</operator> <name>optimizerBackup</name></expr>;</expr_stmt>

		<comment type="block">/* Carry on with error handling. */</comment>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>optimizer</name> <operator>=</operator> <name>optimizerBackup</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>analyze_rel_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
			<parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_outer_xact</name></decl></parameter>,
			<parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>, <parameter><decl><type><name>gp_acquire_sample_rows_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>onerel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relpages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Select logging level */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VERBOSE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>INFO</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>DEBUG2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Set up static variables */</comment>
	<expr_stmt><expr><name>vac_strategy</name> <operator>=</operator> <name>bstrategy</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for user-requested abort.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the relation, getting ShareUpdateExclusiveLock to ensure that two
	 * ANALYZEs don't run on it concurrently.  (This also locks out a
	 * concurrent VACUUM, which doesn't matter much at the moment but might
	 * matter if we ever try to accumulate stats on dead tuples.) If the rel
	 * has been dropped since we last saw it, we don't need to process it.
	 *
	 * Make sure to generate only logs for ANALYZE in this case.
	 */</comment>
	<expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>vacuum_open_relation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>VACOPT_VACUUM</name><operator>)</operator></expr></argument>,
								  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>,
								  <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* leave if relation could not be opened or locked */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>onerel</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(
		<argument><expr><literal type="string">"analyze_after_hold_lock"</literal></expr></argument>, <argument><expr><name>DDLNotSpecified</name></expr></argument>,
		<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * analyze_rel can be called in 3 different contexts:  explicitly by the user
	 * (eg. ANALYZE, VACUUM ANALYZE), implicitly by autovacuum, or implicitly by
	 * autostats.
	 *
	 * In the first case, we always want to make sure the user is the owner of the
	 * table.  In the autovacuum case, it will be called as superuser so we don't
	 * really care, but the ownership check should always succeed.  For autostats,
	 * we only do the check if gp_autostats_allow_nonowner=false, otherwise we can
	 * proceed with the analyze.
	 *
	 * This check happens also when building the relation list to analyze for a
	 * manual operation, and needs to be done additionally here as ANALYZE could
	 * happen across multiple transactions where relation ownership could have
	 * changed in-between.  Make sure to generate only logs for ANALYZE in
	 * this case.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>auto_stats</name></name> <operator>&amp;&amp;</operator> <name>gp_autostats_allow_nonowner</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vacuum_is_relation_owner</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>,
		  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<block>{<block_content>
				<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Silently ignore tables that are temp tables of other backends ---
	 * trying to analyze these is rather pointless, since their contents are
	 * probably not up-to-date on disk.  (We don't throw a warning here; it
	 * would just lead to chatter during a database-wide ANALYZE.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We can ANALYZE any table except pg_statistic. See update_attstats
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>StatisticRelationId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that it's of an analyzable relkind, and set up appropriately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Regular table, so we'll use the regular row acquisition function */</comment>
		<expr_stmt><expr><name>acquirefunc</name> <operator>=</operator> <name>acquire_sample_rows</name></expr>;</expr_stmt>

		<comment type="block">/* Also get regular table's size */</comment>
		<expr_stmt><expr><name>relpages</name> <operator>=</operator> <call><name>AcquireNumberOfBlocks</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a foreign table, call the FDW's hook function to see whether it
		 * supports analysis.
		 */</comment>
		<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>acquirefunc</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>relpages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- cannot analyze this foreign table"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For partitioned tables, we want to do the recursive ANALYZE below.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No need for a WARNING if we already complained during VACUUM */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping \"%s\" --- cannot analyze non-tables or special system tables"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * OK, let's do it.  First let other backends know I'm in ANALYZE.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>|=</operator> <name>PROC_IN_ANALYZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do the normal non-recursive ANALYZE.  We can skip this for partitioned
	 * tables, which don't contain any rows.
	 *
	 * On QE, when receiving ANALYZE request through gp_acquire_sample_rows.
	 * We should only perform do_analyze_rel for the parent table only
	 * or all it's children tables. Because, QD will send two acquire sample
	 * rows requests to QE.
	 * To distinguish the two requests, we check the ctx-&gt;inherited value here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>ctx</name> <operator>||</operator> <operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>inherited</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_analyze_rel</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>va_cols</name></expr></argument>, <argument><expr><name>acquirefunc</name></expr></argument>,
					   <argument><expr><name>relpages</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>in_outer_xact</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there are child tables, do recursive ANALYZE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhassubclass</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>ctx</name> <operator>||</operator> <name><name>ctx</name><operator>-&gt;</operator><name>inherited</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_analyze_rel</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>va_cols</name></expr></argument>, <argument><expr><name>acquirefunc</name></expr></argument>, <argument><expr><name>relpages</name></expr></argument>,
					   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>in_outer_xact</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vacuumStatement_IsTemporary</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>asubtype</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>asubtype</name> <operator>=</operator> <literal type="string">"AUTO"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
						   <argument><expr><literal type="string">"ANALYZE"</literal></expr></argument>,
						   <argument><expr><name>asubtype</name></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<comment type="block">/*
	 * Close source relation now, but keep lock so that no one deletes it
	 * before we commit.  (If someone did, they'd fail to clean up the entries
	 * we made in pg_statistic.  Also, releasing the lock before commit would
	 * expose us to concurrent-update failures in update_attstats.)
	 */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset my PGXACT flag.  Note: we need this here, and not in vacuum_rel,
	 * because the vacuum flag is cleared by the end-of-xact code.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>vacuumFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PROC_IN_ANALYZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	do_analyze_rel() -- analyze one relation, recursively or not
 *
 * Note that "acquirefunc" is only relevant for the non-inherited case.
 * For the inherited case, acquire_inherited_sample_rows() determines the
 * appropriate acquirefunc for each child table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_analyze_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>, <parameter><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name></decl></parameter>,
			   <parameter><decl><type><name>BlockNumber</name></type> <name>relpages</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in_outer_xact</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>gp_acquire_sample_rows_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>attr_cnt</name></decl>,
				<decl><type ref="prev"/><name>tcnt</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>,
				<decl><type ref="prev"/><name>ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>Irel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nindexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>indexdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>targrows</name></decl>,
				<decl><type ref="prev"/><name>numrows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>totalrows</name></decl>,
				<decl><type ref="prev"/><name>totaldeadrows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name>  <modifier>*</modifier></type><name>rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGRUsage</name></type>	<name>ru0</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>starttime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>caller_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>save_userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_sec_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>colLargeRowIndexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name>     <modifier>*</modifier></type><name>colLargeRowLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sample_needed</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>inh</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"analyzing \"%s.%s\" inheritance tree"</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"analyzing \"%s.%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Set up a working context so that we can easily free whatever junk gets
	 * created.
	 */</comment>
	<expr_stmt><expr><name>anl_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
										<argument><expr><literal type="string">"Analyze"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>caller_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>anl_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to the table owner's userid, so that any index functions are run
	 * as that user.  Also lock down security-restricted operations and
	 * arrange to make GUC variable changes local to this command.
	 */</comment>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
						   <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_RESTRICTED_OPERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* measure elapsed time iff autovacuum logging requires it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>starttime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine which columns to analyze
	 *
	 * Note that system attributes are never analyzed, so we just reject them
	 * at the lookup stage.  We also reject duplicate column mentions.  (We
	 * could alternatively ignore duplicates, but analyzing a column twice
	 * won't work; we'd end up making a conflicting update in pg_statistic.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>va_cols</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>unique_cols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>vacattrstats</name> <operator>=</operator> <operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>va_cols</name></expr></argument>)</argument_list></call> <operator>*</operator>
												<sizeof>sizeof<argument_list>(<argument><expr><name>VacAttrStats</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>va_cols</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>col</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>attnameAttNum</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name>col</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>unique_cols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" appears more than once"</literal></expr></argument>,
								<argument><expr><name>col</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>unique_cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>unique_cols</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <call><name>examine_attribute</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tcnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>attr_cnt</name> <operator>=</operator> <name>tcnt</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>attr_cnt</name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>vacattrstats</name> <operator>=</operator> <operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VacAttrStats</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <call><name>examine_attribute</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tcnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>attr_cnt</name> <operator>=</operator> <name>tcnt</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Open all indexes of the relation, and see if there are any analyzable
	 * columns in the indexes.  We do not analyze index columns if there was
	 * an explicit column list in the ANALYZE command, however.  If we are
	 * doing a recursive scan, we don't want to touch the parent's indexes at
	 * all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inh</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>vac_open_indexes</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nindexes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Irel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>Irel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nindexes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>hasindex</name> <operator>=</operator> <operator>(</operator><name>nindexes</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>indexdata</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasindex</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>indexdata</name> <operator>=</operator> <operator>(</operator><name>AnlIndexData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nindexes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AnlIndexData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>indexInfo</name></name> <operator>=</operator> <name>indexInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>tupleFract</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt> <comment type="block">/* fix later if partial */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>va_cols</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexpr_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name></name> <operator>=</operator> <operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>*</operator><operator>)</operator>
					<call><name>palloc</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VacAttrStats</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>keycol</name> <init>= <expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>keycol</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Found an index expression */</comment>
						<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>indexkey</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in indexprs list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator>
							<call><name>examine_attribute</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>indexkey</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>tcnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>attr_cnt</name></name> <operator>=</operator> <name>tcnt</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine how many rows we need to sample, using the worst case from
	 * all analyzable columns.  We use a lower bound of 100 rows to avoid
	 * possible overflow in Vitter's algorithm.  (Note: that will also be the
	 * target in the corner case where there are no analyzable columns.)
	 *
	 * GPDB: If the caller specified the 'targrows', just use that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ctx</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>targrows</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>targrows</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <comment type="block">/* funny indentation to avoid re-indenting upstream code */</comment>
  <block>{<block_content>
	<expr_stmt><expr><name>targrows</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>targrows</name> <operator>&lt;</operator> <name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>minrows</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>targrows</name> <operator>=</operator> <name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>minrows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>thisdata</name><operator>-&gt;</operator><name>attr_cnt</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>targrows</name> <operator>&lt;</operator> <name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>minrows</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>targrows</name> <operator>=</operator> <name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>minrows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
	<comment type="block">/* end of funny indentation */</comment>

	<comment type="block">/*
	 * Maintain information if the row of a column exceeds WIDTH_THRESHOLD
	 */</comment>
	<expr_stmt><expr><name>colLargeRowIndexes</name> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Bitmapset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>colLargeRowLength</name> <operator>=</operator> <operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_FULLSCAN</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>acquire_hll_by_query</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>attr_cnt</name></expr></argument>, <argument><expr><name>vacattrstats</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"HLL FULL SCAN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>sample_needed</name> <operator>=</operator> <call><name>needs_sample</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>vacattrstats</name></expr></argument>, <argument><expr><name>attr_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>||</operator> <name>sample_needed</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>ctx</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>caller_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rows</name> <operator>=</operator> <operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>targrows</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Acquire the sample rows
		 *
		 * colLargeRowIndexes is passed out-of-band, in a global variable,
		 * to avoid changing the function signature from upstream's.
		 *
		 * The same as colLargeRowIndexes. colLargeRowLength stores total
		 * length of too wide rows in the sample for every attribute of
		 * the target relation. ANALYZE ignores too wide columns during
		 * analysis(See comments of WIDTH_THRESHOLD), the stawidth can be
		 * far smaller than the real average width for varlena datums which
		 * are larger than WIDTH_THRESHOLD but stored uncompressed.
		 */</comment>
		<expr_stmt><expr><name>acquire_func_colLargeRowIndexes</name> <operator>=</operator> <name>colLargeRowIndexes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>acquire_func_colLargeRowLength</name> <operator>=</operator> <name>colLargeRowLength</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>inh</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>numrows</name> <operator>=</operator> <call><name>acquire_inherited_sample_rows</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
													<argument><expr><name>rows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>totalrows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>totaldeadrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numrows</name> <operator>=</operator> <call>(<modifier>*</modifier><name>acquirefunc</name>) <argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
									  <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>totalrows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>totaldeadrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>acquire_func_colLargeRowIndexes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>acquire_func_colLargeRowLength</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ctx</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>anl_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If we're just merging stats from leafs, these are not needed either */</comment>
		<expr_stmt><expr><name>totalrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>totaldeadrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>numrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>rows</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ctx</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sample_rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>num_sample_rows</name></name> <operator>=</operator> <name>numrows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>totalrows</name></name> <operator>=</operator> <name>totalrows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>totaldeadrows</name></name> <operator>=</operator> <name>totaldeadrows</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Compute the statistics.  Temporary results during the calculations for
	 * each column are stored in a child context.  The calc routines are
	 * responsible to make sure that whatever they store into the VacAttrStats
	 * structure is allocated in anl_context.
	 *
	 * When we have a root partition, we use the leaf partition statistics to
	 * derive root table statistics. In that case, we do not need to collect a
	 * sample. Therefore, the statistics calculation depends on root level have
	 * any tuples. In addition, we continue for statistics calculation if
	 * optimizer_analyze_root_partition or ROOTPARTITION is specified in the
	 * ANALYZE statement.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numrows</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>sample_needed</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>validRows</name> <init>= <expr><operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numrows</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>col_context</name></decl>,
					<decl><type ref="prev"/><name>old_context</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>build_ext_stats</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>col_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>anl_context</name></expr></argument>,
											<argument><expr><literal type="string">"Analyze Column"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>
			<comment type="block">/*
			 * utilize hyperloglog and merge utilities to derive
			 * root table statistics by directly calling merge_leaf_stats()
			 * if all leaf partition attributes are analyzed
			 */</comment>
			<if_stmt><if>if<condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>merge_stats</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call>(<modifier>*</modifier><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name>) <argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>std_fetch_func</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sample_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>rowIndexes</name> <init>= <expr><name><name>colLargeRowIndexes</name><index>[<expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>validRowsLength</name></decl>;</decl_stmt>

			<comment type="block">/* If there are too wide rows in the sample, remove them
			 * from the sample being sent for stats collection
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>rowIndexes</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>validRowsLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<for>for <control>(<init><decl><type><name>int</name></type> <name>rownum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rownum</name> <operator>&lt;</operator> <name>numrows</name></expr>;</condition> <incr><expr><name>rownum</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<comment type="block">/* if row is too wide, leave it out of the sample */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>rownum</name></expr></argument>, <argument><expr><name>rowIndexes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>validRows</name><index>[<expr><name>validRowsLength</name></expr>]</index></name> <operator>=</operator> <name><name>rows</name><index>[<expr><name>rownum</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>validRowsLength</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>validRows</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>validRowsLength</name> <operator>=</operator> <name>numrows</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<decl_stmt><decl><type><name>AttributeOpts</name> <modifier>*</modifier></type><name>aopt</name> <init>=
			<expr><call><name>get_attribute_options</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * get total length and number of too wide rows in the sample,
			 * in case get wrong stawidth.
			 */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>totalwidelength</name></name> <operator>=</operator> <name><name>colLargeRowLength</name><index>[<expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>widerow_num</name></name> <operator>=</operator> <name>numrows</name> <operator>-</operator> <name>validRowsLength</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>validRowsLength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name><argument_list>(<argument><expr><name>stats</name></expr></argument>,
									 <argument><expr><name>std_fetch_func</name></expr></argument>,
									 <argument><expr><name>validRowsLength</name></expr></argument>, <comment type="line">// numbers of rows in sample excluding toowide if any.</comment>
									 <argument><expr><name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/*
				 * Store HLL/HLL fullscan information for leaf partitions in
				 * the stats object. If table was created with "analyze_hll_non_part_table" option, also collect
				 * HLL stats for non-leaf tables
				 */</comment>
				<decl_stmt><decl><type><name>bool</name></type> <name>analyze_hll_non_part_table</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_options</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
							<operator>(</operator><operator>(</operator><name>StdRdOptions</name> <operator>*</operator><operator>)</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_options</name></name><operator>)</operator><operator>-&gt;</operator><name>analyze_hll_non_part_table</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>analyze_hll_non_part_table</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>||</operator> <name>analyze_hll_non_part_table</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>hll_values</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>hll_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<decl_stmt><decl><type><name>int16</name></type> <name>hll_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int16</name></type> <name>stakind</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if<condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stahll_full</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>hll_length</name> <operator>=</operator> <call><name>datumGetSize</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stahll_full</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>hll_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stahll_full</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>hll_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>stakind</name> <operator>=</operator> <name>STATISTIC_KIND_FULLHLL</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if<condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><operator>(</operator><operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>relPages</name> <operator>=</operator> <name>relpages</name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>(</operator><operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>relTuples</name> <operator>=</operator> <name>totalrows</name></expr>;</expr_stmt>

						<expr_stmt><expr><name>hll_length</name> <operator>=</operator> <call><name>gp_hyperloglog_len</name><argument_list>(<argument><expr><operator>(</operator><name>GpHLLCounter</name><operator>)</operator><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>hll_values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>hll_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>stakind</name> <operator>=</operator> <name>STATISTIC_KIND_HLL</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>stakind</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>STATISTIC_NUM_SLOTS</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>stakind</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>STATISTIC_NUM_SLOTS</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>hll_values</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>STATISTIC_NUM_SLOTS</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator>  <literal type="number">1</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><name>STATISTIC_NUM_SLOTS</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>hll_length</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="line">// All the rows were too wide to be included in the sample. We cannot</comment>
				<comment type="line">// do much in that case, but at least we know there were no NULLs, and</comment>
				<comment type="line">// that every item was &gt;= WIDTH_THRESHOLD in width.</comment>
				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>totalwidelength</name></name><operator>/</operator><name>numrows</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>		<comment type="block">/* "unknown" */</comment>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt> <comment type="line">// Reset to original rows</comment>

			<comment type="block">/*
			 * If the appropriate flavor of the n_distinct option is
			 * specified, override with the corresponding value.
			 */</comment>
			<expr_stmt><expr><name>aopt</name> <operator>=</operator> <call><name>get_attribute_options</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>aopt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>float8</name></type>		<name>n_distinct</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>n_distinct</name> <operator>=</operator> <ternary><condition><expr><name>inh</name></expr> ?</condition><then> <expr><name><name>aopt</name><operator>-&gt;</operator><name>n_distinct_inherited</name></name></expr> </then><else>: <expr><name><name>aopt</name><operator>-&gt;</operator><name>n_distinct</name></name></expr></else></ternary></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>n_distinct</name> <operator>!=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <name>n_distinct</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Datums exceeding WIDTH_THRESHOLD are masked as NULL in the sample, and
		 * are used as is to evaluate index statistics. It is less likely to have
		 * indexes on very wide columns, so the effect will be minimal.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hasindex</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>compute_index_stats</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>,
								<argument><expr><name>indexdata</name></expr></argument>, <argument><expr><name>nindexes</name></expr></argument>,
								<argument><expr><name>rows</name></expr></argument>, <argument><expr><name>numrows</name></expr></argument>,
								<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Emit the completed stats rows into pg_statistic, replacing any
		 * previous statistics for the target columns.  (If there are stats in
		 * pg_statistic for columns we didn't process, we leave them alone.)
		 */</comment>
		<expr_stmt><expr><call><name>update_attstats</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>inh</name></expr></argument>,
						<argument><expr><name>attr_cnt</name></expr></argument>, <argument><expr><name>vacattrstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>update_attstats</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							<argument><expr><name><name>thisdata</name><operator>-&gt;</operator><name>attr_cnt</name></name></expr></argument>, <argument><expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Should we build extended statistics for this relation?
		 *
		 * The extended statistics catalog does not include an inheritance
		 * flag, so we can't store statistics built both with and without
		 * data from child relations. We can store just one set of statistics
		 * per relation. For plain relations that's fine, but for inheritance
		 * trees we have to pick whether to store statistics for just the
		 * one relation or the whole tree. For plain inheritance we store
		 * the (!inh) version, mostly for backwards compatibility reasons.
		 * For partitioned tables that's pointless (the non-leaf tables are
		 * always empty), so we store stats representing the whole tree.
		 */</comment>
		<expr_stmt><expr><name>build_ext_stats</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr> ?</condition><then> <expr><name>inh</name></expr> </then><else>: <expr><operator>(</operator><operator>!</operator><name>inh</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/*
		 * Build extended statistics (if there are any).
		 *
		 * For now we only build extended statistics on individual relations,
		 * not for relations representing inheritance trees.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>build_ext_stats</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BuildRelationExtStatistics</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>, <argument><expr><name>numrows</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>,
									   <argument><expr><name>attr_cnt</name></expr></argument>, <argument><expr><name>vacattrstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Update pages/tuples stats in pg_class ... but not if we're doing
	 * inherited stats.
	 *
	 * GPDB_92_MERGE_FIXME: In postgres it is sufficient to check the number of
	 * pages that are visible with visibilitymap_count(), but in GPDB this
	 * needs to be the count of all pages marked all visible across the all the
	 * QEs. We need to gather this information from the segments and then update
	 * it here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inh</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relallvisible</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>relallvisible</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>visibilitymap_count</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relallvisible</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>vac_update_relstats</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,
							<argument><expr><name>relpages</name></expr></argument>,
							<argument><expr><name>totalrows</name></expr></argument>,
							<argument><expr><name>relallvisible</name></expr></argument>,
							<argument><expr><name>hasindex</name></expr></argument>,
							<argument><expr><name>InvalidTransactionId</name></expr></argument>,
							<argument><expr><name>InvalidMultiXactId</name></expr></argument>,
							<argument><expr><name>in_outer_xact</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument> <comment type="block">/* isVacuum */</comment>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Same for indexes. Vacuum always scans all indexes, so if we're part of
	 * VACUUM ANALYZE, don't overwrite the accurate count already inserted by
	 * VACUUM.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inh</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>totalindexrows</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BlockNumber</name></type>	<name>estimatedIndexPages</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>totalrows</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block" format="doxygen">/**
				 * If there are no rows in the relation, no point trying to estimate
				 * number of pages in the index.
				 */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"ANALYZE skipping index %s since relation %s has no rows."</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>estimatedIndexPages</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block" format="doxygen">/**
				 * NOTE: we don't attempt to estimate the number of tuples in an index.
				 * We will assume it to be equal to the estimated number of tuples in the relation.
				 * This does not hold for partial indexes. The number of tuples matching will be
				 * derived in selfuncs.c using the base table statistics.
				 */</comment>
				<expr_stmt><expr><name>estimatedIndexPages</name> <operator>=</operator> <call><name>acquire_index_number_of_blocks</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>, <argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"ANALYZE estimated relpages=%u for index %s"</literal></expr></argument>,
					 <argument><expr><name>estimatedIndexPages</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>totalindexrows</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>thisdata</name><operator>-&gt;</operator><name>tupleFract</name></name> <operator>*</operator> <name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>vac_update_relstats</name><argument_list>(<argument><expr><name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr></argument>,
								<argument><expr><name>estimatedIndexPages</name></expr></argument>,
								<argument><expr><name>totalindexrows</name></expr></argument>,
								<argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name>false</name></expr></argument>,
								<argument><expr><name>InvalidTransactionId</name></expr></argument>,
								<argument><expr><name>InvalidMultiXactId</name></expr></argument>,
								<argument><expr><name>in_outer_xact</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument> <comment type="block">/* isVacuum */</comment>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Report ANALYZE to the stats collector, too.  However, if doing
	 * inherited stats we shouldn't report, because the stats collector only
	 * tracks per-table stats.  Reset the changes_since_analyze counter only
	 * if we analyzed all columns; otherwise, there is still work for
	 * auto-analyze to do.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inh</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_report_analyze</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>, <argument><expr><name>totaldeadrows</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>va_cols</name> <operator>==</operator> <name>NIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If this isn't part of VACUUM ANALYZE, let index AMs do cleanup */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexVacuumInfo</name></type> <name>ivinfo</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name><name>Irel</name><index>[<expr><name>ind</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>analyze_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>estimated_count</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>message_level</name></name> <operator>=</operator> <name>elevel</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>num_heap_tuples</name></name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>strategy</name></name> <operator>=</operator> <name>vac_strategy</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>stats</name> <operator>=</operator> <call><name>index_vacuum_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ivinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>stats</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Done with indexes */</comment>
	<expr_stmt><expr><call><name>vac_close_indexes</name><argument_list>(<argument><expr><name>nindexes</name></expr></argument>, <argument><expr><name>Irel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Log the action if appropriate */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>,
									   <argument><expr><name><name>params</name><operator>-&gt;</operator><name>log_min_duration</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"automatic analyze of table \"%s.%s.%s\" system usage: %s"</literal></expr></argument>,
							<argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Roll back any GUC changes executed by index functions */</comment>
	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore userid and security context */</comment>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore current context and release memory */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>caller_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>anl_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>anl_context</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute statistics about indexes of a relation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_index_stats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>,
					<parameter><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>indexdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nindexes</name></decl></parameter>,
					<parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>,
					<parameter><decl><type><name>MemoryContext</name></type> <name>col_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>ind_context</name></decl>,
				<decl><type ref="prev"/><name>old_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ind</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ind_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>anl_context</name></expr></argument>,
										<argument><expr><literal type="string">"Analyze Index"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ind_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>ind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ind</name> <operator>&lt;</operator> <name>nindexes</name></expr>;</condition> <incr><expr><name>ind</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AnlIndexData</name> <modifier>*</modifier></type><name>thisdata</name> <init>= <expr><operator>&amp;</operator><name><name>indexdata</name><index>[<expr><name>ind</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name> <init>= <expr><name><name>thisdata</name><operator>-&gt;</operator><name>indexInfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attr_cnt</name> <init>= <expr><name><name>thisdata</name><operator>-&gt;</operator><name>attr_cnt</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>predicate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>exprvals</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>exprnulls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numindexrows</name></decl>,
					<decl><type ref="prev"/><name>tcnt</name></decl>,
					<decl><type ref="prev"/><name>rowno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>totalindexrows</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore index if no columns to analyze and not partial */</comment>
		<if_stmt><if>if <condition>(<expr><name>attr_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Need an EState for evaluation of index expressions and
		 * partial-index predicates.  Create it in the per-index context to be
		 * sure it gets cleaned up at the bottom of the loop.
		 */</comment>
		<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Need a slot to hold the current heap tuple, too */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>TTSOpsHeapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

		<comment type="block">/* Set up execution state for predicate. */</comment>
		<expr_stmt><expr><name>predicate</name> <operator>=</operator> <call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Compute and save index expression values */</comment>
		<expr_stmt><expr><name>exprvals</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numrows</name> <operator>*</operator> <name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exprnulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numrows</name> <operator>*</operator> <name>attr_cnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numindexrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>tcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>rowno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rowno</name> <operator>&lt;</operator> <name>numrows</name></expr>;</condition> <incr><expr><name>rowno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heapTuple</name> <init>= <expr><name><name>rows</name><index>[<expr><name>rowno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Reset the per-tuple context each time, to reclaim any cruft
			 * left behind by evaluating the predicate or index expressions.
			 */</comment>
			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Set up for predicate or expression evaluation */</comment>
			<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If index is partial, check predicate */</comment>
			<if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>numindexrows</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>attr_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Evaluate the index row to compute expression values. We
				 * could do this by hand, but FormIndexDatum is convenient.
				 */</comment>
				<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
							   <argument><expr><name>slot</name></expr></argument>,
							   <argument><expr><name>estate</name></expr></argument>,
							   <argument><expr><name>values</name></expr></argument>,
							   <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Save just the columns we care about.  We copy the values
				 * into ind_context from the estate's per-tuple context.
				 */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>exprvals</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>exprnulls</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>exprvals</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
												   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
												   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>exprnulls</name><index>[<expr><name>tcnt</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><name>tcnt</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Having counted the number of rows that pass the predicate in the
		 * sample, we can estimate the total number of rows in the index.
		 */</comment>
		<expr_stmt><expr><name><name>thisdata</name><operator>-&gt;</operator><name>tupleFract</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>numindexrows</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>numrows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalindexrows</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>thisdata</name><operator>-&gt;</operator><name>tupleFract</name></name> <operator>*</operator> <name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we can compute the statistics for the expression columns.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>numindexrows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>thisdata</name><operator>-&gt;</operator><name>vacattrstats</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AttributeOpts</name> <modifier>*</modifier></type><name>aopt</name> <init>=
				<expr><call><name>get_attribute_options</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>,
									  <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>exprvals</name></name> <operator>=</operator> <name>exprvals</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>exprnulls</name></name> <operator>=</operator> <name>exprnulls</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>rowstride</name></name> <operator>=</operator> <name>attr_cnt</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name><argument_list>(<argument><expr><name>stats</name></expr></argument>,
									 <argument><expr><name>ind_fetch_func</name></expr></argument>,
									 <argument><expr><name>numindexrows</name></expr></argument>,
									 <argument><expr><name>totalindexrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the n_distinct option is specified, it overrides the
				 * above computation.  For indices, we always use just
				 * n_distinct, not n_distinct_inherited.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>aopt</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>aopt</name><operator>-&gt;</operator><name>n_distinct</name></name> <operator>!=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <name><name>aopt</name><operator>-&gt;</operator><name>n_distinct</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>col_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* And clean up */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ind_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>ind_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>ind_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * examine_attribute -- pre-analysis of a single column
 *
 * Determine whether the column is analyzable; if so, create and initialize
 * a VacAttrStats struct for it.  If not, return NULL.
 *
 * If index_expr isn't NULL, then we're trying to analyze an expression index,
 * and index_expr is the expression tree representing the column's data.
 */</comment>
<function><type><specifier>static</specifier> <name>VacAttrStats</name> <modifier>*</modifier></type>
<name>examine_attribute</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>index_expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name></decl>;</decl_stmt>

	<comment type="block">/* Never analyze dropped columns */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Don't analyze column if user has specified not to */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create the VacAttrStats struct.  Note that we only have a copy of the
	 * fixed fields of the pg_attribute tuple.
	 */</comment>
	<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VacAttrStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>elevel</name></name> <operator>=</operator> <name>elevel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name></name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When analyzing an expression index, believe the expression tree's type
	 * not the column datatype --- the latter might be the opckeytype storage
	 * type of the opclass, which is not interesting for our purposes.  (Note:
	 * if we did anything with non-expression index columns, we'd need to
	 * figure out where to get the correct type info from, but for now that's
	 * not a problem.)	It's not clear whether anyone will care about the
	 * typmod, but we store that too just in case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>index_expr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>index_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>index_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If a collation has been specified for the index column, use that in
		 * preference to anything else; but if not, fall back to whatever we
		 * can get from the expression.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrcollid</name></name> <operator>=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrcollid</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>index_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypmod</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrcollid</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>typtuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name></name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name> <operator>=</operator> <name>anl_context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>tupattnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The fields describing the stats-&gt;stavalues[n] element types default to
	 * the type of the data being analyzed, but the type-specific typanalyze
	 * function can change them if it wants to store something else.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypid</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypbyval</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypalign</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * The last slots of statistics is reserved for hyperloglog counter which
	 * is saved as a bytea. Therefore the type information is hardcoded for the
	 * bytea.
	 */</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypid</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>BYTEAOID</name></expr>;</expr_stmt> <comment type="line">// oid for bytea</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">// variable length type</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypbyval</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="line">// bytea is pass by reference</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypalign</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt> <comment type="line">// INT alignment (4-byte)</comment>

	<comment type="block">/*
	 * Call the type-specific typanalyze function.  If none is specified, use
	 * std_typanalyze().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typanalyze</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typanalyze</name></name></expr></argument>,
										   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>std_typanalyze</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name> <operator>||</operator> <name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>typtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * acquire_sample_rows -- acquire a random sample of rows from the table
 *
 * Selected rows are returned in the caller-allocated array rows[], which
 * must have at least targrows entries.
 * The actual number of rows selected is returned as the function result.
 * We also estimate the total numbers of live and dead rows in the table,
 * and return them into *totalrows and *totaldeadrows, respectively.
 *
 * The returned list of tuples is in order by physical position in the table.
 * (We will rely on this later to derive correlation estimates.)
 *
 * As of May 2004 we use a new two-stage method:  Stage one selects up
 * to targrows random blocks (or all blocks, if there aren't so many).
 * Stage two scans these blocks and uses the Vitter algorithm to create
 * a random sample of targrows rows (or less, if there are less in the
 * sample of blocks).  The two stages are executed simultaneously: each
 * block is processed as soon as stage one returns its number and while
 * the rows are read stage two controls which ones are to be inserted
 * into the sample.
 *
 * Although every row has an equal chance of ending up in the final
 * sample, this sampling method is not perfect: not every possible
 * sample has an equal chance of being selected.  For large relations
 * the number of different blocks represented by the sample tends to be
 * too small.  We can live with that for now.  Improvements are welcome.
 *
 * An important property of this sampling method is that because we do
 * look at a statistically unbiased set of blocks, we should get
 * unbiased estimates of the average numbers of live and dead rows per
 * block.  The previous sampling method put too much credence in the row
 * density near the start of the table.
 *
 * The returned list of tuples is in order by physical position in the table.
 * (We will rely on this later to derive correlation estimates.)
 *
 * GPDB: If we are the dispatcher, then issue analyze on the segments and
 * collect the statistics from them.
 */</comment>
<function><type><name>int</name></type>
<name>acquire_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
					<parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
					<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* # rows now in reservoir */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>samplerows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* total # rows collected */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>liverows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* # live rows seen */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>deadrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* # dead rows seen */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>rowstoskip</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* -1 means not set yet */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>totalblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockSamplerData</name></type> <name>bs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReservoirStateData</name></type> <name>rstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targrows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GpPolicyIsEntry</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Fetch sample from the segments. */</comment>
		<return>return <expr><call><name>acquire_sample_rows_dispatcher</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
											  <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>,
											  <argument><expr><name>totalrows</name></expr></argument>, <argument><expr><name>totaldeadrows</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * GPDB: Analyze does make a lot of assumptions regarding the file layout of a
	 * relation. These assumptions are heap specific and do not hold for AO/AOCO
	 * relations. In the case of AO/AOCO, what is actually needed and used instead
	 * of number of blocks, is number of tuples.
	 *
	 * GPDB_12_MERGE_FIXME: BlockNumber is uint32 and Number of tuples is uint64.
	 * That means that after row number UINT_MAX we will never analyze the table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pages</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>tuples</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>allvisfrac</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>attr_widths</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>table_relation_estimate_size</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,	<argument><expr><operator>&amp;</operator><name>attr_widths</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pages</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>tuples</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>allvisfrac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>tuples</name> <operator>&gt;</operator> <name>UINT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tuples</name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>totalblocks</name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator><name>tuples</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>totalblocks</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Need a cutoff xmin for HeapTupleSatisfiesVacuum */</comment>
	<expr_stmt><expr><name>OldestXmin</name> <operator>=</operator> <call><name>GetOldestXmin</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>PROCARRAY_FLAGS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare for sampling block numbers */</comment>
	<expr_stmt><expr><call><name>BlockSampler_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bs</name></expr></argument>, <argument><expr><name>totalblocks</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>, <argument><expr><call><name>random</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Prepare for sampling rows */</comment>
	<expr_stmt><expr><call><name>reservoir_init_selection_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstate</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_analyze</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Outer loop over blocks to sample */</comment>
	<while>while <condition>(<expr><call><name>BlockSampler_HasMore</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bs</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>targblock</name> <init>= <expr><call><name>BlockSampler_Next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_scan_analyze_next_block</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>targblock</name></expr></argument>, <argument><expr><name>vac_strategy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<while>while <condition>(<expr><call><name>table_scan_analyze_next_tuple</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>liverows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>deadrows</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The first targrows sample rows are simply copied into the
			 * reservoir. Then we start replacing tuples in the sample until
			 * we reach the end of the relation.  This algorithm is from Jeff
			 * Vitter's paper (see full citation in utils/misc/sampling.c). It
			 * works by repeatedly computing the number of tuples to skip
			 * before selecting a tuple, which replaces a randomly chosen
			 * element of the reservoir (current set of tuples).  At all times
			 * the reservoir is a true random sample of the tuples we've
			 * passed over so far, so when we fall off the end of the relation
			 * we're done.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>numrows</name> <operator>&lt;</operator> <name>targrows</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rows</name><index>[<expr><name>numrows</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ExecCopySlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * t in Vitter's paper is the number of records already
				 * processed.  If we need to compute a new S value, we must
				 * use the not-yet-incremented value of samplerows as t.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>rowstoskip</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rowstoskip</name> <operator>=</operator> <call><name>reservoir_get_next_S</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstate</name></expr></argument>, <argument><expr><name>samplerows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>rowstoskip</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Found a suitable tuple, so save it, replacing one old
					 * tuple at random
					 */</comment>
					<decl_stmt><decl><type><name>int</name></type>			<name>k</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>targrows</name> <operator>*</operator> <call><name>sampler_random_fract</name><argument_list>(<argument><expr><name><name>rstate</name><operator>.</operator><name>randstate</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rows</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <call><name>ExecCopySlotHeapTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>rowstoskip</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>samplerows</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we didn't find as many tuples as we wanted then we're done. No sort
	 * is needed, since they're already in order.
	 *
	 * Otherwise we need to sort the collected tuples by position
	 * (itempointer). It's not worth worrying about corner cases where the
	 * tuples are already sorted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numrows</name> <operator>==</operator> <name>targrows</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>rows</name></expr></argument>, <argument><expr><name>numrows</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Estimate total numbers of live and dead rows in relation, extrapolating
	 * on the assumption that the average tuple density in pages we didn't
	 * scan is the same as in the pages we did scan.  Since what we scanned is
	 * a random sample of the pages in the relation, this should be a good
	 * assumption.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>bs</name><operator>.</operator><name>m</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><operator>(</operator><name>liverows</name> <operator>/</operator> <name><name>bs</name><operator>.</operator><name>m</name></name><operator>)</operator> <operator>*</operator> <name>totalblocks</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><operator>(</operator><name>deadrows</name> <operator>/</operator> <name><name>bs</name><operator>.</operator><name>m</name></name><operator>)</operator> <operator>*</operator> <name>totalblocks</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Emit some interesting relation info
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": scanned %d of %u pages, "</literal>
				<literal type="string">"containing %.0f live rows and %.0f dead rows; "</literal>
				<literal type="string">"%d rows in sample, %.0f estimated total rows"</literal></expr></argument>,
				<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name><name>bs</name><operator>.</operator><name>m</name></name></expr></argument>, <argument><expr><name>totalblocks</name></expr></argument>,
				<argument><expr><name>liverows</name></expr></argument>, <argument><expr><name>deadrows</name></expr></argument>,
				<argument><expr><name>numrows</name></expr></argument>, <argument><expr><operator>*</operator><name>totalrows</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>numrows</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for sorting rows[] array
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_rows</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ha</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>HeapTuple</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>hb</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>HeapTuple</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * GPDB_12_MERGE_FIXME: For AO/AOCO tables, blocknumber does not have a
	 * meaning and is not set. The current implementation of analyze makes
	 * assumptions about the file layout which do not hold for these two cases.
	 * The compare function should maintain the row order as consrtucted, hence
	 * return 0;
	 *
	 * There should be no apparent and measurable perfomance hit from calling
	 * this function.
	 *
	 * One possible proper fix is to refactor analyze to use the tableam api and
	 * this sorting should move to the specific implementation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><call><name>ItemPointerGetBlockNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ha</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>ba</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ha</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>oa</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ha</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>bb</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hb</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>ob</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hb</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ba</name> <operator>&lt;</operator> <name>bb</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ba</name> <operator>&gt;</operator> <name>bb</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>oa</name> <operator>&lt;</operator> <name>ob</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>oa</name> <operator>&gt;</operator> <name>ob</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * acquire_inherited_sample_rows -- acquire sample rows from inheritance tree
 *
 * This has the same API as acquire_sample_rows, except that rows are
 * collected from all inheritance children as well as the specified table.
 * We fail and return zero if there are no inheritance children, or if all
 * children are foreign tables that don't support ANALYZE.
 */</comment>
<function><type><name>int</name></type>
<name>acquire_inherited_sample_rows</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
							  <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
							  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tableOIDs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AcquireSampleRowsFunc</name> <modifier>*</modifier></type><name>acquirefuncs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name>	   <modifier>*</modifier></type><name>relblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>totalblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numrows</name></decl>,
				<decl><type ref="prev"/><name>nrels</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_child</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Like in acquire_sample_rows(), if we're in the QD, fetch the sample
	 * from segments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>acquire_sample_rows_dispatcher</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>,
											  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* inherited stats */</comment>
											  <argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>,
											  <argument><expr><name>totalrows</name></expr></argument>, <argument><expr><name>totaldeadrows</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find all members of inheritance set.  We only need AccessShareLock on
	 * the children.
	 */</comment>
	<expr_stmt><expr><name>tableOIDs</name> <operator>=</operator>
		<call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that there's at least one descendant, else fail.  This could
	 * happen despite analyze_rel's relhassubclass check, if table once had a
	 * child but no longer does.  In that case, we can clear the
	 * relhassubclass field so as not to make the same mistake again later.
	 * (This is safe because we hold ShareUpdateExclusiveLock.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableOIDs</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* CCI because we already updated the pg_class row in this command */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetRelationHasSubclass</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping analyze of \"%s.%s\" inheritance tree --- this inheritance tree contains no child tables"</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Identify acquirefuncs to use, and count blocks in all the relations.
	 * The result could overflow BlockNumber, so we use double arithmetic.
	 */</comment>
	<expr_stmt><expr><name>rels</name> <operator>=</operator> <operator>(</operator><name>Relation</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableOIDs</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>acquirefuncs</name> <operator>=</operator> <operator>(</operator><name>AcquireSampleRowsFunc</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableOIDs</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AcquireSampleRowsFunc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relblocks</name> <operator>=</operator> <operator>(</operator><name>double</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableOIDs</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>totalblocks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nrels</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>has_child</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tableOIDs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>childOID</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relpages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* We already got the needed lock */</comment>
		<expr_stmt><expr><name>childrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>childOID</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Ignore if temp table of another backend */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ... but release the lock on it */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childrel</name> <operator>!=</operator> <name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check table type (MATVIEW can't happen, but might as well allow) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			<name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Regular table, so use the regular row acquisition function */</comment>
			<expr_stmt><expr><name>acquirefunc</name> <operator>=</operator> <name>acquire_sample_rows</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>relpages</name> <operator>=</operator> <call><name>AcquireNumberOfBlocks</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For a foreign table, call the FDW's hook function to see
			 * whether it supports analysis.
			 */</comment>
			<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>AnalyzeForeignTable</name></name><argument_list>(<argument><expr><name>childrel</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>acquirefunc</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>relpages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ignore, but release the lock on it */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childrel</name> <operator>!=</operator> <name>onerel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * ignore, but release the lock on it.  don't try to unlock the
			 * passed-in relation
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>childrel</name> <operator>!=</operator> <name>onerel</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* OK, we'll process this child */</comment>
		<expr_stmt><expr><name>has_child</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rels</name><index>[<expr><name>nrels</name></expr>]</index></name> <operator>=</operator> <name>childrel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>acquirefuncs</name><index>[<expr><name>nrels</name></expr>]</index></name> <operator>=</operator> <name>acquirefunc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relblocks</name><index>[<expr><name>nrels</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>relpages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalblocks</name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>relpages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nrels</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we don't have at least one child table to consider, fail.  If the
	 * relation is a partitioned table, it's not counted as a child table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_child</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping analyze of \"%s.%s\" inheritance tree --- this inheritance tree contains no analyzable child tables"</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now sample rows from each relation, proportionally to its fraction of
	 * the total block count.  (This might be less than desirable if the child
	 * rels have radically different free-space percentages, but it's not
	 * clear that it's worth working harder.)
	 */</comment>
	<expr_stmt><expr><name>numrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>childrel</name> <init>= <expr><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AcquireSampleRowsFunc</name></type> <name>acquirefunc</name> <init>= <expr><name><name>acquirefuncs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>childblocks</name> <init>= <expr><name><name>relblocks</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>childblocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>childtargrows</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>childtargrows</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>rint</name><argument_list>(<argument><expr><name>targrows</name> <operator>*</operator> <name>childblocks</name> <operator>/</operator> <name>totalblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Make sure we don't overrun due to roundoff error */</comment>
			<expr_stmt><expr><name>childtargrows</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>childtargrows</name></expr></argument>, <argument><expr><name>targrows</name> <operator>-</operator> <name>numrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>childtargrows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>childrows</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>double</name></type>		<name>trows</name></decl>,
							<decl><type ref="prev"/><name>tdrows</name></decl>;</decl_stmt>

				<comment type="block">/* Fetch a random sample of the child's rows */</comment>
				<expr_stmt><expr><name>childrows</name> <operator>=</operator> <call>(<modifier>*</modifier><name>acquirefunc</name>) <argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
											<argument><expr><name>rows</name> <operator>+</operator> <name>numrows</name></expr></argument>, <argument><expr><name>childtargrows</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>trows</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* We may need to convert from child's rowtype to parent's */</comment>
				<if_stmt><if>if <condition>(<expr><name>childrows</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>equalTupleDescs</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TupleConversionMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>map</name> <operator>=</operator> <call><name>convert_tuples_by_name</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not convert row type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

						<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>childrows</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
						<block>{<block_content>
							<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>execute_attr_map_tuple</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>numrows</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>numrows</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>rows</name><index>[<expr><name>numrows</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>=</operator> <name>newtup</name></expr>;</expr_stmt>
						</block_content>}</block></for>
						<expr_stmt><expr><call><name>free_conversion_map</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* And add to counts */</comment>
				<expr_stmt><expr><name>numrows</name> <operator>+=</operator> <name>childrows</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>+=</operator> <name>trows</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>+=</operator> <name>tdrows</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Note: we cannot release the child-table locks, since we may have
		 * pointers to their TOAST tables in the sampled rows.
		 */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>childrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>numrows</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function acquires the HLL counter for the entire table by
 * using the hyperloglog extension gp_hyperloglog_accum().
 *
 * Unlike acquire_sample_rows(), this returns the HLL counter for
 * the entire table, and not jsut a sample, and it stores the HLL
 * counter into a separate attribute in the stats stahll_full to
 * distinguish it from the HLL for sampled data. This functions scans
 * the full table only once.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>acquire_hll_by_query</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nattrs</name></decl></parameter>, <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>attrstats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>, <decl><type ref="prev"/><name>columnStr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>vals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>columnStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attrstats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>columnStr</name></expr></argument>, <argument><expr><literal type="string">"pg_catalog.gp_hyperloglog_accum(%s)"</literal></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>i</name> <operator>!=</operator> <name>nattrs</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>columnStr</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"select %s from %s.%s as Ta "</literal></expr></argument>,
					 <argument><expr><name><name>columnStr</name><operator>.</operator><name>data</name></name></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>SPI_OK_CONNECT</name> <operator>!=</operator> <call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to connect to execute internal query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"Executing SQL: %s"</literal></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do the query. We pass readonly==false, to force SPI to take a new
	 * snapshot. That ensures that we see all changes by our own transaction.
	 */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * targrows in analyze_rel_internal() is an int,
	 * it's unlikely that this query will return more rows
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SPI_processed</name> <operator>&lt;</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sampleTuples</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name>SPI_processed</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Ok, read in the tuples to *rows */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vals</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sampleTuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>sampletup</name> <init>= <expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nattrs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>	<name>tupattnum</name> <init>= <expr><name><name>attrstats</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>tupattnum</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupattnum</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>tupattnum</name> <operator>&lt;=</operator> <name>nattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>vals</name><index>[<expr><name>tupattnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>sampletup</name></expr></argument>, <argument><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
											   <argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>attrstats</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>stahll_full</name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator><call><name>gp_hyperloglog_init_def</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>int16</name></type> <name>typlen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>typbyval</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>hll_length</name> <init>= <expr><call><name>datumGetSize</name><argument_list>(<argument><expr><name><name>vals</name><index>[<expr><name>tupattnum</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>attrstats</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>stahll_full</name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator><call><name>datumCopy</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>vals</name><index>[<expr><name>tupattnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>hll_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute relation size.
 *
 * In upstream, this is a simple RelationGetNumberOfBlocks() call.
 * In GPDB if we're in the dispatcher, we need to get the size from the
 * segments.
 */</comment>
<function><type><name>BlockNumber</name></type>
<name>AcquireNumberOfBlocks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>totalbytes</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator>
		<name><name>onerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GpPolicyIsEntry</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Query the segments using pg_relation_size(&lt;rel&gt;). */</comment>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>relsize_sql</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>relsize_sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>relsize_sql</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"select pg_catalog.pg_relation_size(%u, 'main')"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalbytes</name> <operator>=</operator> <call><name>get_size_from_segDBs</name><argument_list>(<argument><expr><name>relsize_sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * pg_relation_size sums up the table size on each segment. That's
			 * correct for hash and randomly distributed tables. But for a
			 * replicated table, we want pg_class.relpages to count the data
			 * only once.
			 */</comment>
			<expr_stmt><expr><name>totalbytes</name> <operator>=</operator> <name>totalbytes</name> <operator>/</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><call><name>RelationGuessNumberOfBlocksFromSize</name><argument_list>(<argument><expr><name>totalbytes</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<comment type="block">/* Check size on this server. */</comment>
	<else>else
	<block>{<block_content>
		<return>return <expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute index relation's size.
 *
 * Like AcquireNumberOfBlocks(), but for indexes. Indexes don't
 * have a distribution policy, so we use the parent table's policy
 * to determine whether we need to get the size on segments or
 * locally.
 */</comment>
<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>acquire_index_number_of_blocks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexrel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>tablerel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>totalbytes</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator>
		<name><name>tablerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GpPolicyIsEntry</name><argument_list>(<argument><expr><name><name>tablerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Query the segments using pg_relation_size(&lt;rel&gt;). */</comment>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>relsize_sql</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>relsize_sql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>relsize_sql</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"select pg_catalog.pg_relation_size(%u, 'main')"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalbytes</name> <operator>=</operator> <call><name>get_size_from_segDBs</name><argument_list>(<argument><expr><name>relsize_sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name><name>tablerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * pg_relation_size sums up the table size on each segment. That's
			 * correct for hash and randomly distributed tables. But for a
			 * replicated table, we want pg_class.relpages to count the data
			 * only once.
			 */</comment>
			<expr_stmt><expr><name>totalbytes</name> <operator>=</operator> <name>totalbytes</name> <operator>/</operator> <name><name>tablerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><call><name>RelationGuessNumberOfBlocksFromSize</name><argument_list>(<argument><expr><name>totalbytes</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<comment type="block">/* Check size on this server. */</comment>
	<else>else
	<block>{<block_content>
		<return>return <expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * parse_record_to_string
 *
 * CDB: a copy of record_in, but only parse the record string
 * into separate strs for each column.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_record_to_string</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>ncolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>needComma</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>string</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>values</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nulls</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan the string.  We use "buf" to accumulate the de-quoted data for
	 * each column, which is then fed to the appropriate input converter.
	 */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>

	<comment type="block">/* Allow leading whitespace */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>!=</operator> <literal type="char">'('</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed record literal: \"%s\""</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Missing left parenthesis."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Ignore dropped columns in datatype, but fill with nulls */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>needComma</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Skip comma that separates prior field from this one */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* *ptr must be ')' */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed record literal: \"%s\""</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Too few columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check for null: completely empty input means null */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">','</literal> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Extract string for this column */</comment>
			<decl_stmt><decl><type><name>bool</name></type>		<name>inquote</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>inquote</name> <operator>||</operator> <operator>!</operator><operator>(</operator><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">','</literal> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">')'</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><operator>*</operator><name>ptr</name><operator>++</operator></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed record literal: \"%s\""</literal></expr></argument>,
									<argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unexpected end of input."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed record literal: \"%s\""</literal></expr></argument>,
										<argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unexpected end of input."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inquote</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>inquote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* doubled quote within quote sequence */</comment>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>inquote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Prep for next column
		 */</comment>
		<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>!=</operator> <literal type="char">')'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed record literal: \"%s\""</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Too many columns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Allow trailing whitespace */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed record literal: \"%s\""</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Junk after right parenthesis."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Collect a sample from segments.
 *
 * Calls the gp_acquire_sample_rows() helper function on each segment,
 * and merges the results.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>acquire_sample_rows_dispatcher</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>onerel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
							   <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>,
							   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totalrows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>totaldeadrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * 'colLargeRowIndexes' is essentially an argument, but it's passed via a
	 * global variable to avoid changing the AcquireSampleRowsFunc prototype.
	 */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>colLargeRowIndexes</name> <init>= <expr><name>acquire_func_colLargeRowIndexes</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name>     <modifier>*</modifier></type><name>colLargeRowLength</name> <init>= <expr><name>acquire_func_colLargeRowLength</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>relDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>funcTupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>sampleTupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sampleTuples</name></decl>;</decl_stmt>	<comment type="block">/* 32 bit - assume that number of tuples will not &gt; 2B */</comment>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>funcRetValues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>funcRetNulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numLiveColumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>perseg_targrows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPgResults</name></type> <name>cdb_pgresults</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targrows</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Acquire an evenly-sized sample from each segment.
	 *
	 * XXX: If there's a significant bias between the segments, i.e. some
	 * segments have a lot more rows than others, the sample will biased, too.
	 * Would be nice to improve that, but it's not clear how. We could issue
	 * another query to get the table size from each segment first, and use
	 * those to weigh the sample size to get from each segment. But that'd
	 * require an extra round-trip, which is also not good. The caller
	 * actually already did that, to get the total relation size, but it
	 * doesn't pass that down to us, let alone the per-segment sizes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>perseg_targrows</name> <operator>=</operator> <name>targrows</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>GpPolicyIsPartitioned</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>perseg_targrows</name> <operator>=</operator> <name>targrows</name> <operator>/</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"acquire_sample_rows_dispatcher() cannot be used on a non-distributed table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Count the number of columns, excluding dropped columns. We'll need that
	 * later.
	 */</comment>
	<expr_stmt><expr><name>numLiveColumns</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>relDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>relDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>numLiveColumns</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Construct SQL command to dispatch to segments.
	 *
	 * Did not use 'select * from pg_catalog.gp_acquire_sample_rows(...) as (..);'
	 * here. Because it requires to specify columns explicitly which leads to
	 * permission check on each columns. This is not consistent with GPDB5 and
	 * may result in different behaviour under different acl configuration.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"select pg_catalog.gp_acquire_sample_rows(%u, %d, '%s');"</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>perseg_targrows</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>inh</name></expr> ?</condition><then> <expr><literal type="string">"t"</literal></expr> </then><else>: <expr><literal type="string">"f"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Execute it.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"Executing SQL: %s"</literal></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CdbDispatchCommand</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>DF_WITH_SNAPSHOT</name> <operator>|</operator> <name>DF_CANCEL_ON_ERROR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build a modified tuple descriptor for the table.
	 *
	 * Some datatypes need special treatment, so we cannot use the relation's
	 * original tupledesc.
	 *
	 * Also create tupledesc of return record of function gp_acquire_sample_rows.
	 */</comment>
	<expr_stmt><expr><name>sampleTupleDesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>relDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <name>numLiveColumns</name> <operator>+</operator> <name>FIX_ATTR_NUM</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>funcTupleDesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>funcTupleDesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>FLOAT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>funcTupleDesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>FLOAT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>funcTupleDesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>FLOAT8ARRAYOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>relDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>relDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name> <init>= <expr><call><name>gp_acquire_sample_rows_col_type</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>sampleTupleDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>funcTupleDesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal> <operator>+</operator> <name>index</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
							   <argument><expr><name>typid</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attndims</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
			<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* For RECORD results, make sure a typmod has been assigned */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>funcTupleDesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator> <name><name>funcTupleDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assign_record_type_typmod</name><argument_list>(<argument><expr><name>funcTupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>sampleTupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the result set from each segment. Gather the sample rows *rows,
	 * and sum up the summary rows for grand 'totalrows' and 'totaldeadrows'.
	 */</comment>
	<expr_stmt><expr><name>funcRetValues</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>funcTupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcRetNulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>funcTupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>relDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sampleTuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>totalrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>totaldeadrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>resultno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>resultno</name> <operator>&lt;</operator> <name><name>cdb_pgresults</name><operator>.</operator><name>numResults</name></name></expr>;</condition> <incr><expr><name>resultno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>pg_result</name></name> <modifier>*</modifier></type><name>pgresult</name> <init>= <expr><name><name>cdb_pgresults</name><operator>.</operator><name>pg_results</name><index>[<expr><name>resultno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>got_summary</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>this_totalrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>this_totaldeadrows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>cdbdisp_clearCdbPgResults</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected result from segment: %d"</literal></expr></argument>,
							<argument><expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * A replicated table has the same data in all segments. Arbitrarily,
			 * use the sample from the first segment, and discard the rest.
			 * (This is rather inefficient, of course. It would be better to
			 * dispatch to only one segment, but there is no easy API for that
			 * in the dispatcher.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>resultno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>rowno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rowno</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>rowno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/*
			 * We cannot use record_in function to get row record here.
			 * Since the result row may contain just the totalrows info where the data columns
			 * are NULLs. Consider domain: 'create domain dnotnull varchar(15) NOT NULL;'
			 * NULLs are not allowed in data columns.
			 */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>rowStr</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>rowno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>rowStr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"got NULL pointer from return value of gp_acquire_sample_rows"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>parse_record_to_string</name><argument_list>(<argument><expr><name>rowStr</name></expr></argument>, <argument><expr><name>funcTupleDesc</name></expr></argument>, <argument><expr><name>funcRetValues</name></expr></argument>, <argument><expr><name>funcRetNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>funcRetNulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* This is a summary row. */</comment>
				<if_stmt><if>if <condition>(<expr><name>got_summary</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"got duplicate summary row from gp_acquire_sample_rows"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>this_totalrows</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float8in</name></expr></argument>,
																	<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>funcRetValues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>this_totaldeadrows</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float8in</name></expr></argument>,
																		<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>funcRetValues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>got_summary</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* This is a sample row. */</comment>
				<if_stmt><if>if <condition>(<expr><name>sampleTuples</name> <operator>&gt;=</operator> <name>targrows</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many sample rows received from gp_acquire_sample_rows"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Read the 'toolarge' bitmap, if any */</comment>
				<if_stmt><if>if <condition>(<expr><name>colLargeRowIndexes</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>funcRetNulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arrayVal</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>largelength</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>	    <name>numelems</name></decl>;</decl_stmt>
					<expr_stmt><expr><name>arrayVal</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><call><name>OidFunctionCall3</name><argument_list>(<argument><expr><name>F_ARRAY_IN</name></expr></argument>,
											<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>funcRetValues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>FLOAT8OID</name></expr></argument>,
											<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arrayVal</name></expr></argument>, <argument><expr><name>FLOAT8OID</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>largelength</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>relDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>relDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>largelength</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>colLargeRowIndexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>colLargeRowIndexes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>sampleTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>colLargeRowLength</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name><name>largelength</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Process the columns */</comment>
				<expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>relDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>relDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>funcRetNulls</name><index>[<expr><name>FIX_ATTR_NUM</name> <operator>+</operator> <name>index</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>funcRetValues</name><index>[<expr><name>FIX_ATTR_NUM</name> <operator>+</operator> <name>index</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Move index to the next result set attribute */</comment>
				</block_content>}</block></for>

				<expr_stmt><expr><name><name>rows</name><index>[<expr><name>sampleTuples</name></expr>]</index></name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name>attinmeta</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sampleTuples</name><operator>++</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * note: we don't set the OIDs in the sample. ANALYZE doesn't
				 * collect stats for them
				 */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>got_summary</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"did not get summary row from gp_acquire_sample_rows"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>resultno</name> <operator>&gt;=</operator> <name><name>onerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This result is for a segment that's not holding any data for this
			 * table. Should get 0 rows.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>this_totalrows</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"table \"%s\" contains rows in segment %d, which is outside the # of segments for the table's policy (%d segments)"</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>onerel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>resultno</name></expr></argument>, <argument><expr><name><name>onerel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>totalrows</name><operator>)</operator> <operator>+=</operator> <name>this_totalrows</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>totaldeadrows</name><operator>)</operator> <operator>+=</operator> <name>this_totaldeadrows</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>funcTupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>funcRetValues</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>funcRetValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>funcRetValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>funcRetNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_clearCdbPgResults</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>sampleTuples</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	update_attstats() -- update attribute statistics for one relation
 *
 *		Statistics are stored in several places: the pg_class row for the
 *		relation has stats about the whole relation, and there is a
 *		pg_statistic row for each (non-system) attribute that has ever
 *		been analyzed.  The pg_class values are updated by VACUUM, not here.
 *
 *		pg_statistic rows are just added or updated normally.  This means
 *		that pg_statistic will probably contain some deleted rows at the
 *		completion of a vacuum cycle, unless it happens to get vacuumed last.
 *
 *		To keep things simple, we punt for pg_statistic, and don't try
 *		to compute or store rows for pg_statistic itself in pg_statistic.
 *		This could possibly be made to work, but it's not worth the trouble.
 *		Note analyze_rel() has seen to it that we won't come here when
 *		vacuuming pg_statistic itself.
 *
 *		Note: there would be a race condition here if two backends could
 *		ANALYZE the same table concurrently.  Presently, we lock that out
 *		by taking a self-exclusive lock on the relation in analyze_rel().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_attstats</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>, <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>vacattrstats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>sd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attno</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>natts</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><name>sd</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attno</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><name><name>vacattrstats</name><index>[<expr><name>attno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>stup</name></decl>,
					<decl><type ref="prev"/><name>oldtup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
					<decl><type ref="prev"/><name>k</name></decl>,
					<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_statistic</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_statistic</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_statistic</name></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* Ignore attr if we weren't able to collect stats */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Construct a new pg_statistic tuple
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Natts_pg_statistic</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_starelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_staattnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_stainherit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_stanullfrac</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_stawidth</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_statistic_stadistinct</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Anum_pg_statistic_stakind1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* stakindN */</comment>
		</block_content>}</block></for>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Anum_pg_statistic_staop1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* staopN */</comment>
		</block_content>}</block></for>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Anum_pg_statistic_stacoll1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stacoll</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* stacollN */</comment>
		</block_content>}</block></for>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Anum_pg_statistic_stanumbers1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nnum</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>nnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>numdatums</name> <init>= <expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nnum</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arry</name></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>nnum</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>numdatums</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
				<comment type="block">/* XXX knows more than it should about type float4: */</comment>
				<expr_stmt><expr><name>arry</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>numdatums</name></expr></argument>, <argument><expr><name>nnum</name></expr></argument>,
									   <argument><expr><name>FLOAT4OID</name></expr></argument>,
									   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>FLOAT4PASSBYVAL</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* stanumbersN */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>Anum_pg_statistic_stavalues1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>k</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arry</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>arry</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>statypid</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>statypbyval</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>statypalign</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* stavaluesN */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Is there already a pg_statistic tuple for this attribute? */</comment>
		<expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Yes, replace it */</comment>
			<expr_stmt><expr><name>stup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>,
									 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>values</name></expr></argument>,
									 <argument><expr><name>nulls</name></expr></argument>,
									 <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* No, insert new tuple */</comment>
			<expr_stmt><expr><name>stup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>sd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>stup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>sd</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Standard fetch function for use by compute_stats subroutines.
 *
 * This exists to provide some insulation between compute_stats routines
 * and the actual storage of the sample data.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>std_fetch_func</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>tupattnum</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>rows</name><index>[<expr><name>rownum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch function for analyzing index expressions.
 *
 * We have not bothered to construct index tuples, instead the data is
 * just in Datum arrays.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ind_fetch_func</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rownum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* exprvals and exprnulls are already offset for proper column */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>rownum</name> <operator>*</operator> <name><name>stats</name><operator>-&gt;</operator><name>rowstride</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>isNull</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>exprnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	<return>return <expr><name><name>stats</name><operator>-&gt;</operator><name>exprvals</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*==========================================================================
 *
 * Code below this point represents the "standard" type-specific statistics
 * analysis algorithms.  This code can be replaced on a per-data-type basis
 * by setting a nonzero value in pg_type.typanalyze.
 *
 *==========================================================================
 */</comment>


<comment type="block">/*
 * In PostgreSQL, WIDTH_THRESHOLD is here, but we've moved it to vacuum.h in
 * GPDB.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>swapInt</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>do {int _tmp; _tmp=a; a=b; b=_tmp;} while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>swapDatum</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>do {Datum _tmp; _tmp=a; a=b; b=_tmp;} while(0)</cpp:value></cpp:define>

<comment type="block">/*
 * Extra information used by the default analysis routines
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>			<comment type="block">/* # of duplicates */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>first</name></decl>;</decl_stmt>			<comment type="block">/* values[] index of first occurrence */</comment>
}</block></struct></type> <name>ScalarMCVItem</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>tupnoLink</name></decl>;</decl_stmt>
}</block></struct></type> <name>CompareScalarsContext</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_trivial_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
								  <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
								  <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_distinct_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
								   <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
								   <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_scalar_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
								 <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
								 <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>merge_leaf_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
								 <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
								 <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>compare_scalars</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>compare_mcvs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>analyze_mcv_list</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mcv_counts</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>num_mcv</name></decl></parameter>,
							 <parameter><decl><type><name>double</name></type> <name>stadistinct</name></decl></parameter>,
							 <parameter><decl><type><name>double</name></type> <name>stanullfrac</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
							 <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * std_typanalyze -- the default type-specific typanalyze function
 */</comment>
<function><type><name>bool</name></type>
<name>std_typanalyze</name><parameter_list>(<parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ltopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>eqopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StdAnalyzeData</name> <modifier>*</modifier></type><name>mystats</name></decl>;</decl_stmt>

	<comment type="block">/* If the attstattarget column is negative, use the default value */</comment>
	<comment type="block">/* NB: it is okay to scribble on stats-&gt;attr since it's a copy */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <name>default_statistics_target</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Look for default "&lt;" and "=" operators for column's type */</comment>
	<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>ltopr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqopr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save the operator info for compute_stats routines */</comment>
	<expr_stmt><expr><name>mystats</name> <operator>=</operator> <operator>(</operator><name>StdAnalyzeData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StdAnalyzeData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mystats</name><operator>-&gt;</operator><name>eqopr</name></name> <operator>=</operator> <name>eqopr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mystats</name><operator>-&gt;</operator><name>eqfunc</name></name> <operator>=</operator> <ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name> <operator>=</operator> <name>ltopr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name> <operator>=</operator> <name>mystats</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>merge_stats</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine which standard statistics algorithm to use
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>get_rel_relispartition</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>leaf_parts_analyzed</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>va_cols</name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>op_hashjoinable</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>merge_stats</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>=</operator> <name>merge_leaf_stats</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>=</operator> <literal type="number">300</literal> <operator>*</operator> <name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else
		if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>ltopr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Seems to be a scalar datatype */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>=</operator> <name>compute_scalar_stats</name></expr>;</expr_stmt>
		<comment type="block">/*--------------------
		 * The following choice of minrows is based on the paper
		 * "Random sampling for histogram construction: how much is enough?"
		 * by Surajit Chaudhuri, Rajeev Motwani and Vivek Narasayya, in
		 * Proceedings of ACM SIGMOD International Conference on Management
		 * of Data, 1998, Pages 436-447.  Their Corollary 1 to Theorem 5
		 * says that for table size n, histogram size k, maximum relative
		 * error in bin size f, and error probability gamma, the minimum
		 * random sample size is
		 *		r = 4 * k * ln(2*n/gamma) / f^2
		 * Taking f = 0.5, gamma = 0.01, n = 10^6 rows, we obtain
		 *		r = 305.82 * k
		 * Note that because of the log function, the dependence on n is
		 * quite weak; even at n = 10^12, a 300*k sample gives &lt;= 0.66
		 * bin size error with probability 0.99.  So there's no real need to
		 * scale for n, which is a good thing because we don't necessarily
		 * know it at this point.
		 *--------------------
		 */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>=</operator> <literal type="number">300</literal> <operator>*</operator> <name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We can still recognize distinct values */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>=</operator> <name>compute_distinct_stats</name></expr>;</expr_stmt>
		<comment type="block">/* Might as well use the same minrows as above */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>=</operator> <literal type="number">300</literal> <operator>*</operator> <name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Can't do much but the trivial stuff */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>=</operator> <name>compute_trivial_stats</name></expr>;</expr_stmt>
		<comment type="block">/* Might as well use the same minrows as above */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>minrows</name></name> <operator>=</operator> <literal type="number">300</literal> <operator>*</operator> <name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>va_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	compute_trivial_stats() -- compute very basic column statistics
 *
 *	We use this when we cannot find a hash "=" operator for the datatype.
 *
 *	We determine the fraction of non-null rows and the average datum width.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_trivial_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
					  <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
					  <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>null_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nonnull_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_varlena</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
							  <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_varwidth</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
							   <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>samplerows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fetchfunc</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for null/nonnull */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>null_cnt</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nonnull_cnt</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a variable-width field, add up widths for average width
		 * calculation.  Note that if the value is toasted, we use the toasted
		 * width.  We don't bother with this calculation if it's a fixed-width
		 * type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_varlena</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>is_varwidth</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* must be cstring */</comment>
			<expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* We can only compute average width if we found some non-null values. */</comment>
	<if_stmt><if>if <condition>(<expr><name>nonnull_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Do the simple null-frac and width stats */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name>total_width</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>	<comment type="block">/* "unknown" */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>null_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We found only nulls; assume the column is entirely null */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* "unknown" */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>	<comment type="block">/* "unknown" */</comment>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	compute_distinct_stats() -- compute column statistics including ndistinct
 *
 *	We use this when we can find only an "=" operator for the datatype.
 *
 *	We determine the fraction of non-null rows, the average width, the
 *	most common values, and the (estimated) number of distinct values.
 *
 *	The most common values are determined by brute force: we keep a list
 *	of previously seen values, ordered by number of times seen, as we scan
 *	the samples.  A newly seen value is inserted just after the last
 *	multiply-seen value, causing the bottommost (oldest) singly-seen value
 *	to drop off the list.  The accuracy of this method, and also its cost,
 *	depend mainly on the length of the list we are willing to keep.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_distinct_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
					   <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
					   <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>null_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nonnull_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>toowide_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_varlena</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
							  <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_varwidth</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
							   <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>f_cmpeq</name></decl>;</decl_stmt>
	<typedef>typedef <type><struct>struct
	<block>{
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>
	}</block></struct></type> <name>TrackItem</name>;</typedef>
	<decl_stmt><decl><type><name>TrackItem</name>  <modifier>*</modifier></type><name>track</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>track_cnt</name></decl>,
				<decl><type ref="prev"/><name>track_max</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_mcv</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StdAnalyzeData</name> <modifier>*</modifier></type><name>mystats</name> <init>= <expr><operator>(</operator><name>StdAnalyzeData</name> <operator>*</operator><operator>)</operator> <name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We track up to 2*n values for an n-element MCV list; but at least 10
	 */</comment>
	<expr_stmt><expr><name>track_max</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>num_mcv</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>track_max</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>track_max</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>track</name> <operator>=</operator> <operator>(</operator><name>TrackItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>track_max</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TrackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>track_cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>mystats</name><operator>-&gt;</operator><name>eqfunc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f_cmpeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator><call><name>gp_hyperloglog_init_def</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Computing Minimal Stats for column %s"</literal></expr></argument>,
					<argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>samplerows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>match</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>firstcount1</name></decl>,
					<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fetchfunc</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for null/nonnull */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>null_cnt</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nonnull_cnt</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator><call><name>gp_hyperloglog_add_item</name><argument_list>(<argument><expr><operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a variable-width field, add up widths for average width
		 * calculation.  Note that if the value is toasted, we use the toasted
		 * width.  We don't bother with this calculation if it's a fixed-width
		 * type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_varlena</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the value is toasted, we want to detoast it just once to
			 * avoid repeated detoastings and resultant excess memory usage
			 * during the comparisons.  Also, check to see if the value is
			 * excessively wide, and if so don't detoast at all --- just
			 * ignore the value.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>WIDTH_THRESHOLD</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>toowide_cnt</name><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>is_varwidth</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* must be cstring */</comment>
			<expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * See if the value matches anything we're already tracking.
		 */</comment>
		<expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>firstcount1</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>track_cnt</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>f_cmpeq</name></expr></argument>,
											   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrcollid</name></name></expr></argument>,
											   <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>firstcount1</name> <operator>&amp;&amp;</operator> <name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>firstcount1</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a match */</comment>
			<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* This value may now need to "bubble up" in the track list */</comment>
			<while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>swapDatum</name><argument_list>(<argument><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>swapInt</name><argument_list>(<argument><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>, <argument><expr><name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* No match.  Insert at head of count-1 list */</comment>
			<if_stmt><if>if <condition>(<expr><name>track_cnt</name> <operator>&lt;</operator> <name>track_max</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>track_cnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>track_cnt</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <name>firstcount1</name></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>firstcount1</name> <operator>&lt;</operator> <name>track_cnt</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>track</name><index>[<expr><name>firstcount1</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>track</name><index>[<expr><name>firstcount1</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* We can only compute real stats if we found some non-null values. */</comment>
	<if_stmt><if>if <condition>(<expr><name>nonnull_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nmultiple</name></decl>,
					<decl><type ref="prev"/><name>summultiple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Do the simple null-frac and width stats */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <operator>(</operator><name>total_width</name> <operator>+</operator> <name><name>stats</name><operator>-&gt;</operator><name>totalwidelength</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>nonnull_cnt</name> <operator>+</operator> <name><name>stats</name><operator>-&gt;</operator><name>widerow_num</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Count the number of values we found multiple times */</comment>
		<expr_stmt><expr><name>summultiple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>nmultiple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>nmultiple</name> <operator>&lt;</operator> <name>track_cnt</name></expr>;</condition> <incr><expr><name>nmultiple</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>track</name><index>[<expr><name>nmultiple</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>summultiple</name> <operator>+=</operator> <name><name>track</name><index>[<expr><name>nmultiple</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>nmultiples</name> <operator>=</operator> <name>nmultiple</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>ndistinct</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>samplerows</name> <operator>=</operator> <name>samplerows</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nmultiple</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we found no repeated non-null values, assume it's a unique
			 * column; but be sure to discount for any nulls we found.
			 */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>track_cnt</name> <operator>&lt;</operator> <name>track_max</name> <operator>&amp;&amp;</operator> <name>toowide_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				 <name>nmultiple</name> <operator>==</operator> <name>track_cnt</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Our track list includes every value in the sample, and every
			 * value appeared more than once.  Assume the column has just
			 * these values.  (This case is meant to address columns with
			 * small, fixed sets of possible values, such as boolean or enum
			 * columns.  If there are any values that appear just once in the
			 * sample, including too-wide values, we should assume that that's
			 * not what we're dealing with.)
			 */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*----------
			 * Estimate the number of distinct values using the estimator
			 * proposed by Haas and Stokes in IBM Research Report RJ 10025:
			 *		n*d / (n - f1 + f1*n/N)
			 * where f1 is the number of distinct values that occurred
			 * exactly once in our sample of n rows (from a total of N),
			 * and d is the total number of distinct values in the sample.
			 * This is their Duj1 estimator; the other estimators they
			 * recommend are considerably more complex, and are numerically
			 * very unstable when n is much smaller than N.
			 *
			 * In this calculation, we consider only non-nulls.  We used to
			 * include rows with null values in the n and N counts, but that
			 * leads to inaccurate answers in columns with many nulls, and
			 * it's intuitively bogus anyway considering the desired result is
			 * the number of distinct non-null values.
			 *
			 * We assume (not very reliably!) that all the multiply-occurring
			 * values are reflected in the final track[] list, and the other
			 * nonnull values all appeared but once.  (XXX this usually
			 * results in a drastic overestimate of ndistinct.  Can we do
			 * any better?)
			 *----------
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>f1</name> <init>= <expr><name>nonnull_cnt</name> <operator>-</operator> <name>summultiple</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>d</name> <init>= <expr><name>f1</name> <operator>+</operator> <name>nmultiple</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>n</name> <init>= <expr><name>samplerows</name> <operator>-</operator> <name>null_cnt</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>N</name> <init>= <expr><name>totalrows</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>stadistinct</name></decl>;</decl_stmt>

			<comment type="block">/* N == 0 shouldn't happen, but just in case ... */</comment>
			<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>*</operator> <name>d</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>n</name> <operator>-</operator> <name>f1</name><operator>)</operator> <operator>+</operator> <name>f1</name> <operator>*</operator> <name>n</name> <operator>/</operator> <name>N</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Clamp to sane range in case of roundoff error */</comment>
			<if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&lt;</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&gt;</operator> <name>N</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>N</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* And round to integer */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>stadistinct</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we estimated the number of distinct values at more than 10% of
		 * the total row count (a very arbitrary limit), then assume that
		 * stadistinct should scale with the row count rather than be a fixed
		 * value.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>&gt;</operator> <literal type="number">0.1</literal> <operator>*</operator> <name>totalrows</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>/</operator> <name>totalrows</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Decide how many values are worth storing as most-common values. If
		 * we are able to generate a complete MCV list (all the values in the
		 * sample will fit, and we think these are all the ones in the table),
		 * then do so.  Otherwise, store only those values that are
		 * significantly more common than the values not in the list.
		 *
		 * Note: the first of these cases is meant to address columns with
		 * small, fixed sets of possible values, such as boolean or enum
		 * columns.  If we can *completely* represent the column population by
		 * an MCV list that will fit into the stats target, then we should do
		 * so and thus provide the planner with complete information.  But if
		 * the MCV list is not complete, it's generally worth being more
		 * selective, and not just filling it all the way up to the stats
		 * target.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>track_cnt</name> <argument_list type="generic">&lt; <argument><expr><name>track_max</name> <operator>&amp;&amp;</operator> <name>toowide_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>track_cnt</name> <operator>&lt;=</operator> <name>num_mcv</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Track list includes all values seen, and all will fit */</comment>
			<expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>mcv_counts</name></decl>;</decl_stmt>

			<comment type="block">/* Incomplete list; decide how many values are worth keeping */</comment>
			<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <name>track_cnt</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>mcv_counts</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>mcv_counts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt></block_content></block></for>

				<expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <call><name>analyze_mcv_list</name><argument_list>(<argument><expr><name>mcv_counts</name></expr></argument>, <argument><expr><name>num_mcv</name></expr></argument>,
										   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument>,
										   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr></argument>,
										   <argument><expr><name>samplerows</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Generate MCV slot entry */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>mcv_values</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>float4</name>	   <modifier>*</modifier></type><name>mcv_freqs</name></decl>;</decl_stmt>

			<comment type="block">/* Must copy the target values into anl_context */</comment>
			<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>mcv_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>mcv_freqs</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>mcv_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
										  <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
										  <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mcv_freqs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_MCV</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>eqopr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stacoll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrcollid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>mcv_freqs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>mcv_values</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Accept the defaults for stats-&gt;statypid and others. They have
			 * been set before we were called (see vacuum.h)
			 */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>null_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We found only nulls; assume the column is entirely null */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* "unknown" */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>		<comment type="block">/* "unknown" */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We don't need to bother cleaning up any of our temporary palloc's */</comment>
</block_content>}</block></function>


<comment type="block">/*
 *	compute_scalar_stats() -- compute column statistics
 *
 *	We use this when we can find "=" and "&lt;" operators for the datatype.
 *
 *	We determine the fraction of non-null rows, the average width, the
 *	most common values, the (estimated) number of distinct values, the
 *	distribution histogram, and the correlation of physical to logical order.
 *
 *	The desired stats can be determined fairly easily after sorting the
 *	data values into order.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_scalar_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
					 <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
					 <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>null_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nonnull_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>toowide_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_varlena</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
							  <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_varwidth</name> <init>= <expr><operator>(</operator><operator>!</operator><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator>
							   <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>corr_xysum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortSupportData</name></type> <name>ssup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScalarItem</name> <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>values_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>tupnoLink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScalarMCVItem</name> <modifier>*</modifier></type><name>track</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>track_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_mcv</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_bins</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StdAnalyzeData</name> <modifier>*</modifier></type><name>mystats</name> <init>= <expr><operator>(</operator><name>StdAnalyzeData</name> <operator>*</operator><operator>)</operator> <name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>ScalarItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>samplerows</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScalarItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupnoLink</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>samplerows</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>track</name> <operator>=</operator> <operator>(</operator><name>ScalarMCVItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScalarMCVItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ssup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ssup</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ssup</name><operator>.</operator><name>ssup_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ssup</name><operator>.</operator><name>ssup_collation</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrcollid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ssup</name><operator>.</operator><name>ssup_nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For now, don't perform abbreviated key conversion, because full values
	 * are required for MCV slot generation.  Supporting that optimization
	 * would necessitate teaching compare_scalars() to call a tie-breaker.
	 */</comment>
	<expr_stmt><expr><name><name>ssup</name><operator>.</operator><name>abbreviate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PrepareSortSupportFromOrderingOp</name><argument_list>(<argument><expr><name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ssup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize HLL counter to be stored in stats */</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator><call><name>gp_hyperloglog_init_def</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Computing Scalar Stats for column %s"</literal></expr></argument>,
					<argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initial scan to find sortable values */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>samplerows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fetchfunc</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for null/nonnull */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>null_cnt</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>nonnull_cnt</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator><call><name>gp_hyperloglog_add_item</name><argument_list>(<argument><expr><operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a variable-width field, add up widths for average width
		 * calculation.  Note that if the value is toasted, we use the toasted
		 * width.  We don't bother with this calculation if it's a fixed-width
		 * type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_varlena</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the value is toasted, we want to detoast it just once to
			 * avoid repeated detoastings and resultant excess memory usage
			 * during the comparisons.  Also, check to see if the value is
			 * excessively wide, and if so don't detoast at all --- just
			 * ignore the value.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>WIDTH_THRESHOLD</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>toowide_cnt</name><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>is_varwidth</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* must be cstring */</comment>
			<expr_stmt><expr><name>total_width</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Add it to the list to be sorted */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>values_cnt</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>values_cnt</name></expr>]</index></name><operator>.</operator><name>tupno</name> <operator>=</operator> <name>values_cnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tupnoLink</name><index>[<expr><name>values_cnt</name></expr>]</index></name> <operator>=</operator> <name>values_cnt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>values_cnt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* We can only compute real stats if we found some sortable values. */</comment>
	<if_stmt><if>if <condition>(<expr><name>values_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndistinct</name></decl>,	<comment type="block">/* # distinct values in sample */</comment>
					<decl><type ref="prev"/><name>nmultiple</name></decl>,	<comment type="block">/* # that appear multiple times */</comment>
					<decl><type ref="prev"/><name>num_hist</name></decl>,
					<decl><type ref="prev"/><name>dups_cnt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slot_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CompareScalarsContext</name></type> <name>cxt</name></decl>;</decl_stmt>

		<comment type="block">/* Sort the collected values */</comment>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ssup</name></name> <operator>=</operator> <operator>&amp;</operator><name>ssup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>tupnoLink</name></name> <operator>=</operator> <name>tupnoLink</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>values</name></expr></argument>, <argument><expr><name>values_cnt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScalarItem</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>compare_scalars</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now scan the values in order, find the most common ones, and also
		 * accumulate ordering-correlation statistics.
		 *
		 * To determine which are most common, we first have to count the
		 * number of duplicates of each value.  The duplicates are adjacent in
		 * the sorted list, so a brute-force approach is to compare successive
		 * datum values until we find two that are not equal. However, that
		 * requires N-1 invocations of the datum comparison routine, which are
		 * completely redundant with work that was done during the sort.  (The
		 * sort algorithm must at some point have compared each pair of items
		 * that are adjacent in the sorted order; otherwise it could not know
		 * that it's ordered the pair correctly.) We exploit this by having
		 * compare_scalars remember the highest tupno index that each
		 * ScalarItem has been found equal to.  At the end of the sort, a
		 * ScalarItem's tupnoLink will still point to itself if and only if it
		 * is the last item of its group of duplicates (since the group will
		 * be ordered by tupno).
		 */</comment>
		<expr_stmt><expr><name>corr_xysum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmultiple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>dups_cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>values_cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>tupno</name> <init>= <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tupno</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>corr_xysum</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>i</name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>tupno</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>dups_cnt</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tupnoLink</name><index>[<expr><name>tupno</name></expr>]</index></name> <operator>==</operator> <name>tupno</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Reached end of duplicates of this value */</comment>
				<expr_stmt><expr><name>ndistinct</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>dups_cnt</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>nmultiple</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>track_cnt</name> <argument_list type="generic">&lt; <argument><expr><name>num_mcv</name> <operator>||</operator>
						<name>dups_cnt</name></expr></argument> &gt;</argument_list></name> <name><name>track</name><index>[<expr><name>track_cnt</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Found a new item for the mcv list; find its
						 * position, bubbling down old items if needed. Loop
						 * invariant is that j points at an empty/ replaceable
						 * slot.
						 */</comment>
						<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>track_cnt</name> <operator>&lt;</operator> <name>num_mcv</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>track_cnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>track_cnt</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name>dups_cnt</name> <operator>&lt;=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>)</condition><block type="pseudo"><block_content>
								<break>break;</break></block_content></block></if></if_stmt>
							<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>first</name> <operator>=</operator> <name><name>track</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>first</name></expr>;</expr_stmt>
						</block_content>}</block></for>
						<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <name>dups_cnt</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>first</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>dups_cnt</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>dups_cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Do the simple null-frac and width stats */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <operator>(</operator><name>total_width</name> <operator>+</operator> <name><name>stats</name><operator>-&gt;</operator><name>totalwidelength</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>nonnull_cnt</name> <operator>+</operator> <name><name>stats</name><operator>-&gt;</operator><name>widerow_num</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="line">// interpolate NDV calculation based on the hll distinct count</comment>
		<comment type="line">// for each column in leaf partitions which will be used later</comment>
		<comment type="line">// to merge root stats</comment>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>nmultiples</name> <operator>=</operator> <name>nmultiple</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>ndistinct</name> <operator>=</operator> <name>ndistinct</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stahll</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>samplerows</name> <operator>=</operator> <name>samplerows</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nmultiple</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we found no repeated non-null values, assume it's a unique
			 * column; but be sure to discount for any nulls we found.
			 */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>toowide_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nmultiple</name> <operator>==</operator> <name>ndistinct</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Every value in the sample appeared more than once.  Assume the
			 * column has just these values.  (This case is meant to address
			 * columns with small, fixed sets of possible values, such as
			 * boolean or enum columns.  If there are any values that appear
			 * just once in the sample, including too-wide values, we should
			 * assume that that's not what we're dealing with.)
			 */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <name>ndistinct</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*----------
			 * Estimate the number of distinct values using the estimator
			 * proposed by Haas and Stokes in IBM Research Report RJ 10025:
			 *		n*d / (n - f1 + f1*n/N)
			 * where f1 is the number of distinct values that occurred
			 * exactly once in our sample of n rows (from a total of N),
			 * and d is the total number of distinct values in the sample.
			 * This is their Duj1 estimator; the other estimators they
			 * recommend are considerably more complex, and are numerically
			 * very unstable when n is much smaller than N.
			 *
			 * In this calculation, we consider only non-nulls.  We used to
			 * include rows with null values in the n and N counts, but that
			 * leads to inaccurate answers in columns with many nulls, and
			 * it's intuitively bogus anyway considering the desired result is
			 * the number of distinct non-null values.
			 *
			 * Overwidth values are assumed to have been distinct.
			 *----------
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>f1</name> <init>= <expr><name>ndistinct</name> <operator>-</operator> <name>nmultiple</name> <operator>+</operator> <name>toowide_cnt</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>d</name> <init>= <expr><name>f1</name> <operator>+</operator> <name>nmultiple</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>n</name> <init>= <expr><name>samplerows</name> <operator>-</operator> <name>null_cnt</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>N</name> <init>= <expr><name>totalrows</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>stadistinct</name></decl>;</decl_stmt>

			<comment type="block">/* N == 0 shouldn't happen, but just in case ... */</comment>
			<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>*</operator> <name>d</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>n</name> <operator>-</operator> <name>f1</name><operator>)</operator> <operator>+</operator> <name>f1</name> <operator>*</operator> <name>n</name> <operator>/</operator> <name>N</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Clamp to sane range in case of roundoff error */</comment>
			<if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&lt;</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&gt;</operator> <name>N</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>N</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* And round to integer */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>stadistinct</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * For FULLSCAN HLL, get ndistinct from the GpHLLCounter
		 * instead of computing it
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stahll_full</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hLLFull</name> <init>= <expr><operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <call><name>DatumGetByteaP</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stahll_full</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hllFull_copy</name> <init>= <expr><call><name>gp_hll_copy</name><argument_list>(<argument><expr><name>hLLFull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <call><name>round</name><argument_list>(<argument><expr><call><name>gp_hyperloglog_estimate</name><argument_list>(<argument><expr><name>hllFull_copy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllFull_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>fabs</name><argument_list>(<argument><expr><name>totalrows</name> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator> <name>totalrows</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0.05</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

		</block_content>}</block></if></if_stmt>
		<comment type="block">/*
		 * If we estimated the number of distinct values at more than 10% of
		 * the total row count (a very arbitrary limit), then assume that
		 * stadistinct should scale with the row count rather than be a fixed
		 * value.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>&gt;</operator> <literal type="number">0.1</literal> <operator>*</operator> <name>totalrows</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>/</operator> <name>totalrows</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Decide how many values are worth storing as most-common values. If
		 * we are able to generate a complete MCV list (all the values in the
		 * sample will fit, and we think these are all the ones in the table),
		 * then do so.  Otherwise, store only those values that are
		 * significantly more common than the values not in the list.
		 *
		 * Note: the first of these cases is meant to address columns with
		 * small, fixed sets of possible values, such as boolean or enum
		 * columns.  If we can *completely* represent the column population by
		 * an MCV list that will fit into the stats target, then we should do
		 * so and thus provide the planner with complete information.  But if
		 * the MCV list is not complete, it's generally worth being more
		 * selective, and not just filling it all the way up to the stats
		 * target.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>track_cnt</name> <operator>==</operator> <name>ndistinct</name> <operator>&amp;&amp;</operator> <name>toowide_cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>track_cnt</name> <operator>&lt;=</operator> <name>num_mcv</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Track list includes all values seen, and all will fit */</comment>
			<expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>mcv_counts</name></decl>;</decl_stmt>

			<comment type="block">/* Incomplete list; decide how many values are worth keeping */</comment>
			<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <name>track_cnt</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <name>track_cnt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>mcv_counts</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>mcv_counts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt></block_content></block></for>

				<expr_stmt><expr><name>num_mcv</name> <operator>=</operator> <call><name>analyze_mcv_list</name><argument_list>(<argument><expr><name>mcv_counts</name></expr></argument>, <argument><expr><name>num_mcv</name></expr></argument>,
										   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr></argument>,
										   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr></argument>,
										   <argument><expr><name>samplerows</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Generate MCV slot entry */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>mcv_values</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>float4</name>	   <modifier>*</modifier></type><name>mcv_freqs</name></decl>;</decl_stmt>

			<comment type="block">/* Must copy the target values into anl_context */</comment>
			<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>mcv_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>mcv_freqs</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcv</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>mcv_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>first</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
										  <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
										  <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mcv_freqs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>track</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_MCV</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>eqopr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stacoll</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrcollid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>mcv_freqs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>mcv_values</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Accept the defaults for stats-&gt;statypid and others. They have
			 * been set before we were called (see vacuum.h)
			 */</comment>
			<expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Generate a histogram slot entry if there are at least two distinct
		 * values not accounted for in the MCV list.  (This ensures the
		 * histogram won't collapse to empty or a singleton.)
		 */</comment>
		<expr_stmt><expr><name>num_hist</name> <operator>=</operator> <name>ndistinct</name> <operator>-</operator> <name>num_mcv</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>num_hist</name> <operator>&gt;</operator> <name>num_bins</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>num_hist</name> <operator>=</operator> <name>num_bins</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>num_hist</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>hist_values</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nvals</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>,
						<decl><type ref="prev"/><name>posfrac</name></decl>,
						<decl><type ref="prev"/><name>delta</name></decl>,
						<decl><type ref="prev"/><name>deltafrac</name></decl>;</decl_stmt>

			<comment type="block">/* Sort the MCV items into position order to speed next loop */</comment>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>track</name></expr></argument>, <argument><expr><name>num_mcv</name></expr></argument>,
				  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScalarMCVItem</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare_mcvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Collapse out the MCV items from the values[] array.
			 *
			 * Note we destroy the values[] array here... but we don't need it
			 * for anything more.  We do, however, still need values_cnt.
			 * nvals will be the number of remaining entries in values[].
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>src</name></decl>,
							<decl><type ref="prev"/><name>dest</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>src</name> <operator>=</operator> <name>dest</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* index of next interesting MCV item */</comment>
				<while>while <condition>(<expr><name>src</name> <operator>&lt;</operator> <name>values_cnt</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>ncopy</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>num_mcv</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>first</name> <init>= <expr><name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>first</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&gt;=</operator> <name>first</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* advance past this MCV item */</comment>
							<expr_stmt><expr><name>src</name> <operator>=</operator> <name>first</name> <operator>+</operator> <name><name>track</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>ncopy</name> <operator>=</operator> <name>first</name> <operator>-</operator> <name>src</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>ncopy</name> <operator>=</operator> <name>values_cnt</name> <operator>-</operator> <name>src</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><name>dest</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><name>src</name></expr>]</index></name></expr></argument>,
							<argument><expr><name>ncopy</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScalarItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>src</name> <operator>+=</operator> <name>ncopy</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>dest</name> <operator>+=</operator> <name>ncopy</name></expr>;</expr_stmt>
				</block_content>}</block></while>
				<expr_stmt><expr><name>nvals</name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>nvals</name> <operator>=</operator> <name>values_cnt</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nvals</name> <operator>&gt;=</operator> <name>num_hist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Must copy the target values into anl_context */</comment>
			<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hist_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_hist</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The object of this loop is to copy the first and last values[]
			 * entries along with evenly-spaced values in between.  So the
			 * i'th value is values[(i * (nvals - 1)) / (num_hist - 1)].  But
			 * computing that subscript directly risks integer overflow when
			 * the stats target is more than a couple thousand.  Instead we
			 * add (nvals - 1) / (num_hist - 1) to pos at each step, tracking
			 * the integral and fractional parts of the sum separately.
			 */</comment>
			<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator><name>nvals</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>deltafrac</name> <operator>=</operator> <operator>(</operator><name>nvals</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>posfrac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_hist</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>hist_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
										   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
										   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>posfrac</name> <operator>+=</operator> <name>deltafrac</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>posfrac</name> <operator>&gt;=</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* fractional part exceeds 1, carry to integer part */</comment>
					<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>posfrac</name> <operator>-=</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_HISTOGRAM</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stacoll</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrcollid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>hist_values</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_hist</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Accept the defaults for stats-&gt;statypid and others. They have
			 * been set before we were called (see vacuum.h)
			 */</comment>
			<expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Generate a correlation entry if there are multiple values */</comment>
		<if_stmt><if>if <condition>(<expr><name>values_cnt</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>float4</name>	   <modifier>*</modifier></type><name>corrs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>corr_xsum</name></decl>,
						<decl><type ref="prev"/><name>corr_x2sum</name></decl>;</decl_stmt>

			<comment type="block">/* Must copy the target values into anl_context */</comment>
			<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>corrs</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*----------
			 * Since we know the x and y value sets are both
			 *		0, 1, ..., values_cnt-1
			 * we have sum(x) = sum(y) =
			 *		(values_cnt-1)*values_cnt / 2
			 * and sum(x^2) = sum(y^2) =
			 *		(values_cnt-1)*values_cnt*(2*values_cnt-1) / 6.
			 *----------
			 */</comment>
			<expr_stmt><expr><name>corr_xsum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>values_cnt</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator>
				<operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>values_cnt</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>corr_x2sum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>values_cnt</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator>
				<operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>values_cnt</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>values_cnt</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">6.0</literal></expr>;</expr_stmt>

			<comment type="block">/* And the correlation coefficient reduces to */</comment>
			<expr_stmt><expr><name><name>corrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>values_cnt</name> <operator>*</operator> <name>corr_xysum</name> <operator>-</operator> <name>corr_xsum</name> <operator>*</operator> <name>corr_xsum</name><operator>)</operator> <operator>/</operator>
				<operator>(</operator><name>values_cnt</name> <operator>*</operator> <name>corr_x2sum</name> <operator>-</operator> <name>corr_xsum</name> <operator>*</operator> <name>corr_xsum</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_CORRELATION</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stacoll</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrcollid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>corrs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>nonnull_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We found some non-null values, but they were all too wide */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nonnull_cnt</name> <operator>==</operator> <name>toowide_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* Do the simple null-frac and width stats */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <operator>(</operator><name>total_width</name> <operator>+</operator> <name><name>stats</name><operator>-&gt;</operator><name>totalwidelength</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>nonnull_cnt</name> <operator>+</operator> <name><name>stats</name><operator>-&gt;</operator><name>widerow_num</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<comment type="block">/* Assume all too-wide values are distinct, so it's a unique column */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>null_cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We found only nulls; assume the column is entirely null */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* "unknown" */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>	<comment type="block">/* "unknown" */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * ORCA complains if a column has no statistics whatsoever, so store
		 * either the best we can figure out given what we have, or zero in
		 * case we don't have enough.
		 */</comment>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>samplerows</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>samplerows</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_varwidth</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* "unknown" */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attrtype</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>		<comment type="block">/* "unknown" */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* We don't need to bother cleaning up any of our temporary palloc's */</comment>
</block_content>}</block></function>

<comment type="block">/*
 *	merge_leaf_stats() -- merge leaf stats for the root
 *
 *	This is only used when the relation is the root partition and merges
 *	the statistics available in pg_statistic for the leaf partitions.
 *
 *  We use this for two scenarios:
 *
 *	1. When we can find "=" and "&lt;" operators for the datatype, and the
 *	"=" operator is hashjoinable. In this case, we determine the fraction
 *	of non-null rows, the average width, the most common values, the
 *	(estimated) number of distinct values, the distribution histogram.
 *
 *	2. When we can find neither "=" nor "&lt;" operator for the data type. In
 *	this case, we only determine the fraction of non-null rows and the
 *	average width.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>merge_leaf_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStatsP</name></type> <name>stats</name></decl></parameter>,
				 <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>all_children_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>oid_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StdAnalyzeData</name> <modifier>*</modifier></type><name>mystats</name> <init>= <expr><operator>(</operator><name>StdAnalyzeData</name> <operator>*</operator><operator>)</operator> <name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numPartitions</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>relTuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>nDistincts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name> <modifier>*</modifier></type><name>nMultiples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>relNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name></type> <name>totalTuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name></type> <name>nmultiple</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="line">// number of values that appeared more than once</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>allDistinct</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>slot_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sampleCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>ltopr</name> <init>= <expr><name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>eqopr</name> <init>= <expr><name><name>mystats</name><operator>-&gt;</operator><name>eqopr</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Merging leaf partition stats to calculate root partition stats : column %s"</literal></expr></argument>,
					<argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * Since we have acquired ShareUpdateExclusiveLock on the parent table when
	 * ANALYZE'ing it, we don't need extra lock to guard against concurrent DROP
	 * of either the parent or the child (which requries AccessExclusiveLock on
	 * the parent).
	 * Concurrent UPDATE is possible but because we are not updating the table
	 * ourselves, NoLock is sufficient here.
	 */</comment>
	<expr_stmt><expr><name>all_children_list</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"merge_leaf_stats_after_find_children"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oid_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>all_children_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pkrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* skip intermediate partitions, we're only interested in leaves */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>pkrelid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>oid_list</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oid_list</name></expr></argument>, <argument><expr><name>pkrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>numPartitions</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>oid_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relTuples</name> <operator>=</operator> <operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numPartitions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nDistincts</name> <operator>=</operator> <operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numPartitions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nMultiples</name> <operator>=</operator> <operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numPartitions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>oid_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pkrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>relTuples</name><index>[<expr><name>relNum</name></expr>]</index></name> <operator>=</operator> <call><name>get_rel_reltuples</name><argument_list>(<argument><expr><name>pkrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalTuples</name> <operator>=</operator> <name>totalTuples</name> <operator>+</operator> <name><name>relTuples</name><index>[<expr><name>relNum</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>relNum</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>totalTuples</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>heaptupleStats</name> <init>=
		<expr><operator>(</operator><name>HeapTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numPartitions</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTuple</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// NDV calculations</comment>
	<decl_stmt><decl><type><name>float4</name></type> <name>colAvgWidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type> <name>nullCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpHLLCounter</name> <modifier>*</modifier></type><name>hllcounters</name> <init>= <expr><operator>(</operator><name>GpHLLCounter</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numPartitions</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLCounter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpHLLCounter</name> <modifier>*</modifier></type><name>hllcounters_fullscan</name> <init>= <expr><operator>(</operator><name>GpHLLCounter</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numPartitions</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLCounter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpHLLCounter</name> <modifier>*</modifier></type><name>hllcounters_copy</name> <init>= <expr><operator>(</operator><name>GpHLLCounter</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numPartitions</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLCounter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>finalHLL</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>finalHLLFull</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>ndistinct</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fullhll_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>samplehll_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>totalhll_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>oid_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>		<name>leaf_relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>	<name>stawidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float4</name></type>	<name>stanullfrac</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * fetch_leaf_attnum and fetch_leaf_att_stats retrieve leaf partition
		 * table's pg_attribute tuple and pg_statistic tuple through index scan
		 * instead of system catalog cache. Since if using system catalog cache,
		 * the total tuple entries insert into the cache will up to:
		 * (number_of_leaf_tables * number_of_column_in_this_table) pg_attribute tuples
		 * +
		 * (number_of_leaf_tables * number_of_column_in_this_table) pg_statistic tuples
		 * which could use extremely large memroy in CacheMemoryContext.
		 * This happens when all of the leaf tables are analyzed. And the current function
		 * will execute for all columns.
		 *
		 * fetch_leaf_att_stats copy the original tuple, so remember to free it.
		 *
		 * As a side-effect, ANALYZE same root table serveral times in same session is much
		 * more slower than before since we don't rely on system catalog cache.
		 *
		 * But we still using the tuple descriptor in system catalog cache to retrieve
		 * attribute in fetched tuples. See get_attstatsslot.
		 */</comment>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>child_attno</name> <init>= <expr><call><name>fetch_leaf_attnum</name><argument_list>(<argument><expr><name>leaf_relid</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>fetch_leaf_att_stats</name><argument_list>(<argument><expr><name>leaf_relid</name></expr></argument>, <argument><expr><name>child_attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// if there is no colstats, we can skip this partition's stats</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>stawidth</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>stawidth</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>stanullfrac</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>stanullfrac</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>colAvgWidth</name> <operator>=</operator> <name>colAvgWidth</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>stawidth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>stawidth</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>*</operator> <name><name>relTuples</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nullCount</name> <operator>=</operator> <name>nullCount</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>stanullfrac</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr> ?</condition><then> <expr><name>stanullfrac</name></expr> </then><else>: <expr><literal type="number">0.0</literal></expr></else></ternary><operator>)</operator> <operator>*</operator> <name><name>relTuples</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>hllSlot</name></decl>;</decl_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hllSlot</name></expr></argument>, <argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>STATISTIC_KIND_FULLHLL</name></expr></argument>,
								<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hllSlot</name><operator>.</operator><name>nvalues</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>hllcounters_fullscan</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <call><name>DatumGetByteaP</name><argument_list>(<argument><expr><name><name>hllSlot</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>finalHLLFull_intermediate</name> <init>= <expr><name>finalHLLFull</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>finalHLLFull</name> <operator>=</operator> <call><name>gp_hyperloglog_merge_counters</name><argument_list>(<argument><expr><name>finalHLLFull_intermediate</name></expr></argument>, <argument><expr><name><name>hllcounters_fullscan</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>finalHLLFull_intermediate</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>finalHLLFull_intermediate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hllSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fullhll_count</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>totalhll_count</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hllSlot</name></expr></argument>, <argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>STATISTIC_KIND_HLL</name></expr></argument>,
								<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hllSlot</name><operator>.</operator><name>nvalues</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>hllcounters</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <call><name>DatumGetByteaP</name><argument_list>(<argument><expr><name><name>hllSlot</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nDistincts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator> <name><name>hllcounters</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ndistinct</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nMultiples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator> <name><name>hllcounters</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nmultiples</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sampleCount</name> <operator>+=</operator> <name><name>hllcounters</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>samplerows</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hllcounters_copy</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>gp_hll_copy</name><argument_list>(<argument><expr><name><name>hllcounters</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>finalHLL_intermediate</name> <init>= <expr><name>finalHLL</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>finalHLL</name> <operator>=</operator> <call><name>gp_hyperloglog_merge_counters</name><argument_list>(<argument><expr><name>finalHLL_intermediate</name></expr></argument>, <argument><expr><name><name>hllcounters</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>finalHLL_intermediate</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>finalHLL_intermediate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hllSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>samplehll_count</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>totalhll_count</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>totalhll_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If neither HLL nor HLL Full scan stats are available,
		 * continue merging stats based on the defaults, instead
		 * of reading them from HLL counter.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If all partitions have HLL full scan counters,
		 * merge root NDV's based on leaf partition HLL full scan
		 * counter
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fullhll_count</name> <operator>==</operator> <name>totalhll_count</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <call><name>gp_hyperloglog_estimate</name><argument_list>(<argument><expr><name>finalHLLFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>finalHLLFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			 * For fullscan the ndistinct is calculated based on the entire table scan
			 * so if it's within the marginal error, we consider everything as distinct,
			 * else the ndistinct value will provide the actual value and we do not ,
			 * need to do any additional calculation for the nmultiple
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>fabs</name><argument_list>(<argument><expr><name>totalTuples</name> <operator>-</operator> <name>ndistinct</name></expr></argument>)</argument_list></call> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator> <name>totalTuples</name><operator>)</operator> <operator>&lt;</operator> <name>GP_HLL_ERROR_MARGIN</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>allDistinct</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>nmultiple</name> <operator>=</operator> <name>ndistinct</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/*
		 * Else if all partitions have HLL counter based on sampled data,
		 * merge root NDV's based on leaf partition HLL counter on
		 * sampled data
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name>finalHLL</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>samplehll_count</name> <operator>==</operator> <name>totalhll_count</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <call><name>gp_hyperloglog_estimate</name><argument_list>(<argument><expr><name>finalHLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>finalHLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			 * For sampled HLL counter, the ndistinct calculated is based on the
			 * sampled data. We consider everything distinct if the ndistinct
			 * calculated is within marginal error, else we need to calculate
			 * the number of distinct values for the table based on the estimator
			 * proposed by Haas and Stokes, used later in the code.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>fabs</name><argument_list>(<argument><expr><name>sampleCount</name> <operator>-</operator> <name>ndistinct</name></expr></argument>)</argument_list></call> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator> <name>sampleCount</name><operator>)</operator> <operator>&lt;</operator> <name>GP_HLL_ERROR_MARGIN</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>allDistinct</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * The gp_hyperloglog_estimate() utility merges the number of
				 * distnct values accurately, but for the NDV estimator used later
				 * in the code, we also need additional information for nmultiples,
				 * i.e., the number of values that appeared more than once.
				 * At this point we have the information for nmultiples for each
				 * partition, but the nmultiples in one partition can be accounted as
				 * a distinct value in some other partition. In order to merge the
				 * approximate nmultiples better, we extract unique values in each
				 * partition as follows,
				 * P1 -&gt; ndistinct1 , nmultiple1
				 * P2 -&gt; ndistinct2 , nmultiple2
				 * P3 -&gt; ndistinct3 , nmultiple3
				 * Root -&gt; ndistinct(Root) (using gp_hyperloglog_estimate)
				 * nunique1 = ndistinct(Root) - gp_hyperloglog_estimate(P2 &amp; P3)
				 * nunique2 = ndistinct(Root) - gp_hyperloglog_estimate(P1 &amp; P3)
				 * nunique3 = ndistinct(Root) - gp_hyperloglog_estimate(P2 &amp; P1)
				 * And finally once we have unique values in individual partitions,
				 * we can get the nmultiples on the ROOT as seen below,
				 * nmultiple(Root) = ndistinct(Root) - (sum of uniques in each partition)
				 */</comment>
				<comment type="block">/*
				 * hllcounters_left array stores the merged hll result of all the
				 * hll counters towards the left of index i and excluding the hll
				 * counter at index i
				 */</comment>
				<decl_stmt><decl><type><name>GpHLLCounter</name> <modifier>*</modifier></type><name>hllcounters_left</name> <init>= <expr><operator>(</operator><name>GpHLLCounter</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numPartitions</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLCounter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * hllcounters_right array stores the merged hll result of all the
				 * hll counters towards the right of index i and excluding the hll
				 * counter at index i
				 */</comment>
				<decl_stmt><decl><type><name>GpHLLCounter</name> <modifier>*</modifier></type><name>hllcounters_right</name> <init>= <expr><operator>(</operator><name>GpHLLCounter</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numPartitions</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLCounter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>hllcounters_left</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>gp_hyperloglog_init_def</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hllcounters_right</name><index>[<expr><name>numPartitions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>gp_hyperloglog_init_def</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * The following loop populates the left and right array by accumulating the merged
				 * result of all the hll counters towards the left/right of the given index i excluding
				 * the counter at index i.
				 * Note that there might be empty values for some partitions, in which case the
				 * corresponding element in the left/right arrays will simply be the value
				 * of its neighbor.
				 * For E.g If the hllcounters_copy array is 1, null, 2, 3, null, 4
				 * the left and right arrays will be as follows:
				 * hllcounters_left:  default, 1, 1, (1,2), (1,2,3), (1,2,3)
				 * hllcounters_right: (2,3,4), (2,3,4), (3,4), 4, 4, default
				 */</comment>
				<comment type="block">/*
				 * The first and the last element in the left and right arrays
				 * are default values since there is no element towards
				 * the left or right of them
				 */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numPartitions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<comment type="block">/* populate left array */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>nDistincts</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>hllcounters_left</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>gp_hll_copy</name><argument_list>(<argument><expr><name><name>hllcounters_left</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hllcounter_temp1</name> <init>= <expr><call><name>gp_hll_copy</name><argument_list>(<argument><expr><name><name>hllcounters_copy</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hllcounter_temp2</name> <init>= <expr><call><name>gp_hll_copy</name><argument_list>(<argument><expr><name><name>hllcounters_left</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name><name>hllcounters_left</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>gp_hyperloglog_merge_counters</name><argument_list>(<argument><expr><name>hllcounter_temp1</name></expr></argument>, <argument><expr><name>hllcounter_temp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounter_temp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounter_temp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/* populate right array */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>nDistincts</name><index>[<expr><name>numPartitions</name> <operator>-</operator> <name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>hllcounters_right</name><index>[<expr><name>numPartitions</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>gp_hll_copy</name><argument_list>(<argument><expr><name><name>hllcounters_right</name><index>[<expr><name>numPartitions</name> <operator>-</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hllcounter_temp1</name> <init>= <expr><call><name>gp_hll_copy</name><argument_list>(<argument><expr><name><name>hllcounters_copy</name><index>[<expr><name>numPartitions</name> <operator>-</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hllcounter_temp2</name> <init>= <expr><call><name>gp_hll_copy</name><argument_list>(<argument><expr><name><name>hllcounters_right</name><index>[<expr><name>numPartitions</name> <operator>-</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name><name>hllcounters_right</name><index>[<expr><name>numPartitions</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>gp_hyperloglog_merge_counters</name><argument_list>(<argument><expr><name>hllcounter_temp1</name></expr></argument>, <argument><expr><name>hllcounter_temp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounter_temp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounter_temp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></for>

				<decl_stmt><decl><type><name>int</name></type> <name>nUnique</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numPartitions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<comment type="block">/* Skip if statistics are missing for the partition */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>nDistincts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hllcounter_temp1</name> <init>= <expr><call><name>gp_hll_copy</name><argument_list>(<argument><expr><name><name>hllcounters_left</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hllcounter_temp2</name> <init>= <expr><call><name>gp_hll_copy</name><argument_list>(<argument><expr><name><name>hllcounters_right</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>final</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>final</name> <operator>=</operator> <call><name>gp_hyperloglog_merge_counters</name><argument_list>(<argument><expr><name>hllcounter_temp1</name></expr></argument>, <argument><expr><name>hllcounter_temp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounter_temp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounter_temp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>final</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>float</name></type> <name>nUniques</name> <init>= <expr><name>ndistinct</name> <operator>-</operator> <call><name>gp_hyperloglog_estimate</name><argument_list>(<argument><expr><name>final</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name>nUnique</name> <operator>+=</operator> <name>nUniques</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>nmultiple</name> <operator>+=</operator> <name><name>nMultiples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>nUniques</name> <operator>/</operator> <name><name>nDistincts</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>nUnique</name> <operator>=</operator> <name>ndistinct</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></for>

				<comment type="line">// nmultiples for the ROOT</comment>
				<expr_stmt><expr><name>nmultiple</name> <operator>+=</operator> <name>ndistinct</name> <operator>-</operator> <name>nUnique</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>nmultiple</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>nmultiple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounters_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounters_right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Else error out due to incompatible leaf HLL counter merge */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounters_fullscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounters_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nDistincts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nMultiples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ANALYZE cannot merge since not all non-empty leaf partitions have consistent hyperloglog statistics for merge"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Re-run ANALYZE or ANALYZE FULLSCAN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounters_fullscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hllcounters_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nDistincts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nMultiples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>allDistinct</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If we found no repeated values, assume it's a unique column */</comment>
		<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ltopr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If operators are not available, NDV is unknown. */</comment>
		<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name>nmultiple</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>ndistinct</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Every value in the sample appeared more than once.  Assume the
		 * column has just these values.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*----------
		 * Estimate the number of distinct values using the estimator
		 * proposed by Haas and Stokes in IBM Research Report RJ 10025:
		 *		n*d / (n - f1 + f1*n/N)
		 * where f1 is the number of distinct values that occurred
		 * exactly once in our sample of n rows (from a total of N),
		 * and d is the total number of distinct values in the sample.
		 * This is their Duj1 estimator; the other estimators they
		 * recommend are considerably more complex, and are numerically
		 * very unstable when n is much smaller than N.
		 *
		 * Overwidth values are assumed to have been distinct.
		 *----------
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>f1</name> <init>= <expr><name>ndistinct</name> <operator>-</operator> <name>nmultiple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><name>f1</name> <operator>+</operator> <name>nmultiple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>numer</name></decl>, <decl><type ref="prev"/><name>denom</name></decl>, <decl><type ref="prev"/><name>stadistinct</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>numer</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>sampleCount</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>d</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>denom</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>sampleCount</name> <operator>-</operator> <name>f1</name><operator>)</operator> <operator>+</operator>
				<operator>(</operator><name>double</name><operator>)</operator> <name>f1</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>sampleCount</name> <operator>/</operator> <name>totalTuples</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>numer</name> <operator>/</operator> <name>denom</name></expr>;</expr_stmt>
		<comment type="block">/* Clamp to sane range in case of roundoff error */</comment>
		<if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&lt;</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>d</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&gt;</operator> <name>totalTuples</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name>totalTuples</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>stadistinct</name> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <call><name>round</name><argument_list>(<argument><expr><name>ndistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndistinct</name> <operator>&gt;</operator> <literal type="number">0.1</literal> <operator>*</operator> <name>totalTuples</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>ndistinct</name> <operator>/</operator> <name>totalTuples</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// finalize NDV calculation</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <name>ndistinct</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stats_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stawidth</name></name> <operator>=</operator> <name>colAvgWidth</name> <operator>/</operator> <name>totalTuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>nullCount</name> <operator>/</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>totalTuples</name></expr>;</expr_stmt>

	<comment type="line">// MCV calculations</comment>
	<decl_stmt><decl><type><name>MCVFreqPair</name> <modifier>*</modifier><modifier>*</modifier></type><name>mcvpairArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rem_mcv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num_mcv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndistinct</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>ndistinct</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <operator>-</operator><name>ndistinct</name> <operator>*</operator> <name>totalTuples</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>resultMCV</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mcvpairArray</name> <operator>=</operator> <call><name>aggregate_leaf_partition_MCVs</name><argument_list>(
			<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>,
			<argument><expr><name>numPartitions</name></expr></argument>, <argument><expr><name>heaptupleStats</name></expr></argument>, <argument><expr><name>relTuples</name></expr></argument>,
			<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></argument>, <argument><expr><name>ndistinct</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_mcv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rem_mcv</name></expr></argument>,
			<argument><expr><name>resultMCV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_MCV</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>eqopr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <name><name>resultMCV</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <name><name>resultMCV</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_mcv</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Histogram calculation</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqopr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>ltopr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>resultHistogram</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>num_hist</name> <init>= <expr><call><name>aggregate_leaf_partition_histograms</name><argument_list>(
			<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>, <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>,
			<argument><expr><name>numPartitions</name></expr></argument>, <argument><expr><name>heaptupleStats</name></expr></argument>, <argument><expr><name>relTuples</name></expr></argument>,
			<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></argument>, <argument><expr><name>mcvpairArray</name> <operator>+</operator> <name>num_mcv</name></expr></argument>,
			<argument><expr><name>rem_mcv</name></expr></argument>, <argument><expr><name>resultHistogram</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>num_hist</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_HISTOGRAM</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>mystats</name><operator>-&gt;</operator><name>ltopr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <name><name>resultHistogram</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_hist</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numPartitions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name><name>heaptupleStats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mcvpairArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>heaptupleStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_arg comparator for sorting ScalarItems
 *
 * Aside from sorting the items, we update the tupnoLink[] array
 * whenever two ScalarItems are found to contain equal datums.  The array
 * is indexed by tupno; for each ScalarItem, it contains the highest
 * tupno that that item's datum has been found to be equal to.  This allows
 * us to avoid additional comparisons in compute_scalar_stats().
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_scalars</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>da</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarItem</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ta</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarItem</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>tupno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>db</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarItem</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tb</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarItem</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>tupno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CompareScalarsContext</name> <modifier>*</modifier></type><name>cxt</name> <init>= <expr><operator>(</operator><name>CompareScalarsContext</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>compare</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>ApplySortComparator</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ssup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>compare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>compare</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The two datums are equal, so update cxt-&gt;tupnoLink[].
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>tupnoLink</name><index>[<expr><name>ta</name></expr>]</index></name> <operator>&lt;</operator> <name>tb</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>tupnoLink</name><index>[<expr><name>ta</name></expr>]</index></name> <operator>=</operator> <name>tb</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>tupnoLink</name><index>[<expr><name>tb</name></expr>]</index></name> <operator>&lt;</operator> <name>ta</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>tupnoLink</name><index>[<expr><name>tb</name></expr>]</index></name> <operator>=</operator> <name>ta</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For equal datums, sort by tupno
	 */</comment>
	<return>return <expr><name>ta</name> <operator>-</operator> <name>tb</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for sorting ScalarMCVItems by position
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_mcvs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>da</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarMCVItem</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>first</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>db</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ScalarMCVItem</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>first</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>da</name> <operator>-</operator> <name>db</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Analyze the list of common values in the sample and decide how many are
 * worth storing in the table's MCV list.
 *
 * mcv_counts is assumed to be a list of the counts of the most common values
 * seen in the sample, starting with the most common.  The return value is the
 * number that are significantly more common than the values not in the list,
 * and which are therefore deemed worth storing in the table's MCV list.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>analyze_mcv_list</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mcv_counts</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>num_mcv</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>stadistinct</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>stanullfrac</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>,
				 <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>ndistinct_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>sumcount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the entire table was sampled, keep the whole list.  This also
	 * protects us against division by zero in the code below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>samplerows</name> <operator>==</operator> <name>totalrows</name> <operator>||</operator> <name>totalrows</name> <operator>&lt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>num_mcv</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Re-extract the estimated number of distinct nonnull values in table */</comment>
	<expr_stmt><expr><name>ndistinct_table</name> <operator>=</operator> <name>stadistinct</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndistinct_table</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ndistinct_table</name> <operator>=</operator> <operator>-</operator><name>ndistinct_table</name> <operator>*</operator> <name>totalrows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Exclude the least common values from the MCV list, if they are not
	 * significantly more common than the estimated selectivity they would
	 * have if they weren't in the list.  All non-MCV values are assumed to be
	 * equally common, after taking into account the frequencies of all the
	 * values in the MCV list and the number of nulls (c.f. eqsel()).
	 *
	 * Here sumcount tracks the total count of all but the last (least common)
	 * value in the MCV list, allowing us to determine the effect of excluding
	 * that value from the list.
	 *
	 * Note that we deliberately do this by removing values from the full
	 * list, rather than starting with an empty list and adding values,
	 * because the latter approach can fail to add any values if all the most
	 * common values have around the same frequency and make up the majority
	 * of the table, so that the overall average frequency of all values is
	 * roughly the same as that of the common values.  This would lead to any
	 * uncommon values being significantly overestimated.
	 */</comment>
	<expr_stmt><expr><name>sumcount</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcv</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sumcount</name> <operator>+=</operator> <name><name>mcv_counts</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<while>while <condition>(<expr><name>num_mcv</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>,
					<decl><type ref="prev"/><name>otherdistinct</name></decl>,
					<decl><type ref="prev"/><name>N</name></decl>,
					<decl><type ref="prev"/><name>n</name></decl>,
					<decl><type ref="prev"/><name>K</name></decl>,
					<decl><type ref="prev"/><name>variance</name></decl>,
					<decl><type ref="prev"/><name>stddev</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Estimated selectivity the least common value would have if it
		 * wasn't in the MCV list (c.f. eqsel()).
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>sumcount</name> <operator>/</operator> <name>samplerows</name> <operator>-</operator> <name>stanullfrac</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>selec</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>selec</name> <operator>&gt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>otherdistinct</name> <operator>=</operator> <name>ndistinct_table</name> <operator>-</operator> <operator>(</operator><name>num_mcv</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>otherdistinct</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>/=</operator> <name>otherdistinct</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the value is kept in the MCV list, its population frequency is
		 * assumed to equal its sample frequency.  We use the lower end of a
		 * textbook continuity-corrected Wald-type confidence interval to
		 * determine if that is significantly more common than the non-MCV
		 * frequency --- specifically we assume the population frequency is
		 * highly likely to be within around 2 standard errors of the sample
		 * frequency, which equates to an interval of 2 standard deviations
		 * either side of the sample count, plus an additional 0.5 for the
		 * continuity correction.  Since we are sampling without replacement,
		 * this is a hypergeometric distribution.
		 *
		 * XXX: Empirically, this approach seems to work quite well, but it
		 * may be worth considering more advanced techniques for estimating
		 * the confidence interval of the hypergeometric distribution.
		 */</comment>
		<expr_stmt><expr><name>N</name> <operator>=</operator> <name>totalrows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name>samplerows</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>K</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name><name>mcv_counts</name><index>[<expr><name>num_mcv</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <name>n</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>variance</name> <operator>=</operator> <name>n</name> <operator>*</operator> <name>K</name> <operator>*</operator> <operator>(</operator><name>N</name> <operator>-</operator> <name>K</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>N</name> <operator>-</operator> <name>n</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>N</name> <operator>*</operator> <name>N</name> <operator>*</operator> <operator>(</operator><name>N</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>stddev</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>variance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>mcv_counts</name><index>[<expr><name>num_mcv</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name>selec</name> <operator>*</operator> <name>samplerows</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>stddev</name> <operator>+</operator> <literal type="number">0.5</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The value is significantly more common than the non-MCV
			 * selectivity would suggest.  Keep it, and all the other more
			 * common values in the list.
			 */</comment>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Discard this value and consider the next least common value */</comment>
			<expr_stmt><expr><name>num_mcv</name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>num_mcv</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>sumcount</name> <operator>-=</operator> <name><name>mcv_counts</name><index>[<expr><name>num_mcv</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>num_mcv</name></expr>;</return>
</block_content>}</block></function>
</unit>
