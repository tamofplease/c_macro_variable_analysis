<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/commands/operatorcmds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * operatorcmds.c
 *
 *	  Routines for operator manipulation commands
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/operatorcmds.c
 *
 * DESCRIPTION
 *	  The "DefineFoo" routines take the parse tree and pick out the
 *	  appropriate arguments/flags, passing the results to the
 *	  corresponding "FooDefine" routines (in src/catalog) that do
 *	  the actual catalog-munging.  These routines also verify permission
 *	  of the user to execute the command.
 *
 * NOTES
 *	  These things must be defined and committed in the following order:
 *		"create function":
 *				input/output, recv/send functions
 *		"create type":
 *				type
 *		"create operator":
 *				operators
 *
 *		Most of the parse-tree manipulation routines are defined in
 *		commands/manip.c.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/oid_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/alter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>ValidateRestrictionEstimator</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictionName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>ValidateJoinEstimator</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinName</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * DefineOperator
 *		this function extracts all the information from the
 *		parameter list generated by the parser and then has
 *		OperatorCreate() do all the actual work.
 *
 * 'parameters' is a list of DefElem
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>DefineOperator</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parameters</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oprNamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>canMerge</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* operator merges */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>canHash</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* operator hashes */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>functionName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* function for operator */</comment>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typeName1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* first type name */</comment>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typeName2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* second type name */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeId1</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* types converted to OID */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeId2</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>commutatorName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* optional commutator operator name */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>negatorName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* optional negator operator name */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>restrictionName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* optional restrict. sel. function */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>joinName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* optional join sel. function */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>functionOid</name></decl>;</decl_stmt>	<comment type="block">/* functions converted to OID */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>restrictionOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>joinOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>typeId</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* to hold left and right arg */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>pl</name></decl>;</decl_stmt>

	<comment type="block">/* Convert list of names to a name and namespace */</comment>
	<expr_stmt><expr><name>oprNamespace</name> <operator>=</operator> <call><name>QualifiedNameGetCreationNamespace</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oprName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The SQL standard committee has decided that =&gt; should be used for named
	 * parameters; therefore, a future release of PostgreSQL may disallow it
	 * as the name of a user-defined operator.
	 *
	 * Only complain in the QD node, to avoid being too noisy.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>oprName</name></expr></argument>, <argument><expr><literal type="string">"=&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"=&gt; is deprecated as an operator name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This name may be disallowed altogether in future versions of PostgreSQL."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check we have creation rights in target namespace */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>oprNamespace</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
					   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>oprNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * loop over the definition list and extract the information we need.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>pl</argument>, <argument>parameters</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>pl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"leftarg"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>typeName1</name> <operator>=</operator> <call><name>defGetTypeName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>typeName1</name><operator>-&gt;</operator><name>setof</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SETOF type not allowed for operator argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"rightarg"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>typeName2</name> <operator>=</operator> <call><name>defGetTypeName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>typeName2</name><operator>-&gt;</operator><name>setof</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SETOF type not allowed for operator argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* "function" and "procedure" are equivalent here */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"function"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>functionName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"procedure"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>functionName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"commutator"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>commutatorName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"negator"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>negatorName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"restrict"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>restrictionName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"join"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>joinName</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"hashes"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>canHash</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"merges"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>canMerge</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<comment type="block">/* These obsolete options are taken as meaning canMerge */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"sort1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>canMerge</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"sort2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>canMerge</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"ltcmp"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>canMerge</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"gtcmp"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>canMerge</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* WARNING, not ERROR, for historical backwards-compatibility */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator attribute \"%s\" not recognized"</literal></expr></argument>,
							<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * make sure we have our required definitions
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>functionName</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator function must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Transform type names to type OIDs */</comment>
	<if_stmt><if>if <condition>(<expr><name>typeName1</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typeId1</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>typeName2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typeId2</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typeId1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typeId2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"at least one of leftarg or rightarg must be specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typeName1</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>typeId1</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>typeId1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typeName2</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>typeId2</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>typeId2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Look up the operator's underlying function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typeId1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>typeId</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>typeId2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typeId2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>typeId</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>typeId1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>typeId</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>typeId1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typeId</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>typeId2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>functionOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>functionName</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We require EXECUTE rights for the function.  This isn't strictly
	 * necessary, since EXECUTE will be checked at any attempted use of the
	 * operator, but it seems like a good idea anyway.
	 */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
					   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>functionName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rettype</name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error_type</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look up restriction and join estimators if specified
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>restrictionName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>restrictionOid</name> <operator>=</operator> <call><name>ValidateRestrictionEstimator</name><argument_list>(<argument><expr><name>restrictionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>restrictionOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>joinName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>joinOid</name> <operator>=</operator> <call><name>ValidateJoinEstimator</name><argument_list>(<argument><expr><name>joinName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>joinOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * now have OperatorCreate do all the work..
	 */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>objAddr</name> <init>=
		<expr><call><name>OperatorCreate</name><argument_list>(<argument><expr><name>oprName</name></expr></argument>, <comment type="block">/* operator name */</comment>
					   <argument><expr><name>oprNamespace</name></expr></argument>,	<comment type="block">/* namespace */</comment>
					   <argument><expr><name>typeId1</name></expr></argument>, <comment type="block">/* left type id */</comment>
					   <argument><expr><name>typeId2</name></expr></argument>, <comment type="block">/* right type id */</comment>
					   <argument><expr><name>functionOid</name></expr></argument>, <comment type="block">/* function for operator */</comment>
					   <argument><expr><name>commutatorName</name></expr></argument>,	<comment type="block">/* optional commutator operator name */</comment>
					   <argument><expr><name>negatorName</name></expr></argument>, <comment type="block">/* optional negator operator name */</comment>
					   <argument><expr><name>restrictionOid</name></expr></argument>,	<comment type="block">/* optional restrict. sel. function */</comment>
					   <argument><expr><name>joinOid</name></expr></argument>, <comment type="block">/* optional join sel. function name */</comment>
					   <argument><expr><name>canMerge</name></expr></argument>,	<comment type="block">/* operator merges */</comment>
					   <argument><expr><name>canHash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* operator hashes */</comment>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefineStmt</name> <modifier>*</modifier></type> <name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>DefineStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>OBJECT_OPERATOR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>oldstyle</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name> <operator>=</operator> <name>names</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>definition</name></name> <operator>=</operator> <name>parameters</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CdbDispatchUtilityStatement</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
									<argument><expr><name>DF_CANCEL_ON_ERROR</name><operator>|</operator>
									<name>DF_WITH_SNAPSHOT</name><operator>|</operator>
									<name>DF_NEED_TWO_PHASE</name></expr></argument>,
									<argument><expr><call><name>GetAssignedOidsForDispatch</name><argument_list>()</argument_list></call></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>objAddr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Look up a restriction estimator function ny name, and verify that it has
 * the correct signature and we have the permissions to attach it to an
 * operator.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ValidateRestrictionEstimator</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictionName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>typeId</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>restrictionOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>typeId</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>	<comment type="block">/* PlannerInfo */</comment>
	<expr_stmt><expr><name><name>typeId</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>OIDOID</name></expr>;</expr_stmt>			<comment type="block">/* operator OID */</comment>
	<expr_stmt><expr><name><name>typeId</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>	<comment type="block">/* args list */</comment>
	<expr_stmt><expr><name><name>typeId</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>		<comment type="block">/* varRelid */</comment>

	<expr_stmt><expr><name>restrictionOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>restrictionName</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* estimators must return float8 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>restrictionOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>FLOAT8OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"restriction estimator function %s must return type %s"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>restrictionName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"float8"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Require EXECUTE rights for the estimator */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>restrictionOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
					   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>restrictionName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>restrictionOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Look up a join estimator function ny name, and verify that it has the
 * correct signature and we have the permissions to attach it to an
 * operator.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ValidateJoinEstimator</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>typeId</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>joinOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>typeId</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>	<comment type="block">/* PlannerInfo */</comment>
	<expr_stmt><expr><name><name>typeId</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>OIDOID</name></expr>;</expr_stmt>			<comment type="block">/* operator OID */</comment>
	<expr_stmt><expr><name><name>typeId</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>	<comment type="block">/* args list */</comment>
	<expr_stmt><expr><name><name>typeId</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>INT2OID</name></expr>;</expr_stmt>		<comment type="block">/* jointype */</comment>
	<expr_stmt><expr><name><name>typeId</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>	<comment type="block">/* SpecialJoinInfo */</comment>

	<comment type="block">/*
	 * As of Postgres 8.4, the preferred signature for join estimators has 5
	 * arguments, but we still allow the old 4-argument form. Try the
	 * preferred form first.
	 */</comment>
	<expr_stmt><expr><name>joinOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>joinName</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>joinOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>joinOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>joinName</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* If not found, reference the 5-argument signature in error msg */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>joinOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>joinOid</name> <operator>=</operator> <call><name>LookupFuncName</name><argument_list>(<argument><expr><name>joinName</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* estimators must return float8 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>joinOid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>FLOAT8OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"join estimator function %s must return type %s"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>joinName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"float8"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Require EXECUTE rights for the estimator */</comment>
	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>joinOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
					   <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>joinName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>joinOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Guts of operator deletion.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveOperatorById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>op</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OperatorRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>operOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset links from commutator and negator, if any.  In case of a
	 * self-commutator or self-negator, this means we have to re-fetch the
	 * updated tuple.  (We could optimize away updates on the tuple we're
	 * about to drop, but it doesn't seem worth convoluting the logic for.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>oprcom</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>oprnegate</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>OperatorUpd</name><argument_list>(<argument><expr><name>operOid</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>oprcom</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>oprnegate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>operOid</name> <operator>==</operator> <name><name>op</name><operator>-&gt;</operator><name>oprcom</name></name> <operator>||</operator> <name>operOid</name> <operator>==</operator> <name><name>op</name><operator>-&gt;</operator><name>oprnegate</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>operOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AlterOperator
 *		routine implementing ALTER OPERATOR &lt;operator&gt; SET (option = ...).
 *
 * Currently, only RESTRICT and JOIN estimator functions can be changed.
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>AlterOperator</name><parameter_list>(<parameter><decl><type><name>AlterOperatorStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>address</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oprId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>oprForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>pl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_operator</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_operator</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_operator</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>restrictionName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* optional restrict. sel. function */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>updateRestriction</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>restrictionOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>joinName</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* optional join sel. function */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>updateJoin</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>joinOid</name></decl>;</decl_stmt>

	<comment type="block">/* Look up the operator */</comment>
	<expr_stmt><expr><name>oprId</name> <operator>=</operator> <call><name>LookupOperWithArgs</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>opername</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>OperatorRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oprId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>oprId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>oprForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process options */</comment>
	<macro><name>foreach</name><argument_list>(<argument>pl</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>pl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>param</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>		<comment type="block">/* NONE, removes the function */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>defGetQualifiedName</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"restrict"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>restrictionName</name> <operator>=</operator> <name>param</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>updateRestriction</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"join"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>joinName</name> <operator>=</operator> <name>param</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>updateJoin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * The rest of the options that CREATE accepts cannot be changed.
		 * Check for them so that we can give a meaningful error message.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"leftarg"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"rightarg"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"function"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"procedure"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"commutator"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"negator"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"hashes"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"merges"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator attribute \"%s\" cannot be changed"</literal></expr></argument>,
							<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator attribute \"%s\" not recognized"</literal></expr></argument>,
							<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Check permissions. Must be owner. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_oper_ownercheck</name><argument_list>(<argument><expr><name>oprId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_OPERATOR</name></expr></argument>,
					   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>oprForm</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look up restriction and join estimators if specified
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>restrictionName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>restrictionOid</name> <operator>=</operator> <call><name>ValidateRestrictionEstimator</name><argument_list>(<argument><expr><name>restrictionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>restrictionOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>joinName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>joinOid</name> <operator>=</operator> <call><name>ValidateJoinEstimator</name><argument_list>(<argument><expr><name>joinName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>joinOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Perform additional checks, like OperatorCreate does */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>oprForm</name><operator>-&gt;</operator><name>oprleft</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>oprForm</name><operator>-&gt;</operator><name>oprright</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If it's not a binary op, these things mustn't be set: */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>joinOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only binary operators can have join selectivity"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>oprForm</name><operator>-&gt;</operator><name>oprresult</name></name> <operator>!=</operator> <name>BOOLOID</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>restrictionOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only boolean operators can have restriction selectivity"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>joinOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only boolean operators can have join selectivity"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Update the tuple */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Natts_pg_operator</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>updateRestriction</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_operator_oprrest</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_operator_oprrest</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>restrictionOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>updateJoin</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_operator_oprjoin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_operator_oprjoin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>joinOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name>makeOperatorDependencies</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>OperatorRelationId</name></expr></argument>, <argument><expr><name>oprId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>
</unit>
