<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/commands/explain_gp.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * explain_gp.c
 *	  Functions supporting the Greenplum extensions to EXPLAIN ANALYZE
 *
 * Portions Copyright (c) 2006-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/commands/explain_gp.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/instr_time.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbconn.h"</cpp:file></cpp:include>		<comment type="block">/* SegmentDatabaseDescriptor */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp.h"</cpp:file></cpp:include>                <comment type="block">/* CheckDispatchResult() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>	<comment type="block">/* CdbDispatchResults */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbexplain.h"</cpp:file></cpp:include>		<comment type="block">/* me */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpathlocus.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>		<comment type="block">/* GpIdentity.segindex */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbendpoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/memquota.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>		<comment type="block">/* pq_beginmessage() etc. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resscheduler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>		<comment type="block">/* MemoryContextGetPeakSpace() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/vmem_tracker.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbexplain.h"</cpp:file></cpp:include>             <comment type="block">/* cdbexplain_recvExecStats */</comment>

<comment type="block">/* Convert bytes into kilobytes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kb</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(floor((x + 1023.0) / 1024.0))</cpp:value></cpp:define>

<comment type="block">/* EXPLAIN ANALYZE statistics for one plan node of a slice */</comment>
<typedef>typedef <type><struct>struct <name>CdbExplain_StatInst</name>
<block>{
	<decl_stmt><decl><type><name>NodeTag</name></type>		<name>pstype</name></decl>;</decl_stmt>			<comment type="block">/* PlanState node type */</comment>

	<comment type="block">/* fields from Instrumentation struct */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>starttime</name></decl>;</decl_stmt>		<comment type="block">/* Start time of current iteration of node */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>counter</name></decl>;</decl_stmt>		<comment type="block">/* Accumulated runtime for this node */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>firsttuple</name></decl>;</decl_stmt>		<comment type="block">/* Time for first tuple of this cycle */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>startup</name></decl>;</decl_stmt>		<comment type="block">/* Total startup time (in seconds) */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>total</name></decl>;</decl_stmt>			<comment type="block">/* Total total time (in seconds) */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>ntuples</name></decl>;</decl_stmt>		<comment type="block">/* Total tuples produced */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>ntuples2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nloops</name></decl>;</decl_stmt>			<comment type="block">/* # of run cycles for this node */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>nfiltered1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nfiltered2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>execmemused</name></decl>;</decl_stmt>	<comment type="block">/* executor memory used (bytes) */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemused</name></decl>;</decl_stmt>	<comment type="block">/* work_mem actually used (bytes) */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemwanted</name></decl>;</decl_stmt>	<comment type="block">/* work_mem to avoid workfile i/o (bytes) */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>workfileCreated</name></decl>;</decl_stmt>	<comment type="block">/* workfile created in this node */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>firststart</name></decl>;</decl_stmt>		<comment type="block">/* Start time of first iteration of node */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>numPartScanned</name></decl>;</decl_stmt> <comment type="block">/* Number of part tables scanned */</comment>

	<decl_stmt><decl><type><name>TuplesortInstrumentation</name></type> <name>sortstats</name></decl>;</decl_stmt> <comment type="block">/* Sort stats, if this is a Sort node */</comment>
	<decl_stmt><decl><type><name>HashInstrumentation</name></type> <name>hashstats</name></decl>;</decl_stmt> <comment type="block">/* Hash stats, if this is a Hash node */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>bnotes</name></decl>;</decl_stmt>			<comment type="block">/* Offset to beginning of node's extra text */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>enotes</name></decl>;</decl_stmt>			<comment type="block">/* Offset to end of node's extra text */</comment>
}</block></struct></type> <name>CdbExplain_StatInst</name>;</typedef>


<comment type="block">/* EXPLAIN ANALYZE statistics for one process working on one slice */</comment>
<typedef>typedef <type><struct>struct <name>CdbExplain_SliceWorker</name>
<block>{
	<decl_stmt><decl><type><name>double</name></type>		<name>peakmemused</name></decl>;</decl_stmt>	<comment type="block">/* bytes alloc in per-query mem context tree */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>vmem_reserved</name></decl>;</decl_stmt>	<comment type="block">/* vmem reserved by a QE */</comment>
}</block></struct></type> <name>CdbExplain_SliceWorker</name>;</typedef>


<comment type="block">/* Header of EXPLAIN ANALYZE statistics message sent from qExec to qDisp */</comment>
<typedef>typedef <type><struct>struct <name>CdbExplain_StatHdr</name>
<block>{
	<decl_stmt><decl><type><name>NodeTag</name></type>		<name>type</name></decl>;</decl_stmt>			<comment type="block">/* T_CdbExplain_StatHdr */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>segindex</name></decl>;</decl_stmt>		<comment type="block">/* segment id */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nInst</name></decl>;</decl_stmt>			<comment type="block">/* num of StatInst entries following StatHdr */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>bnotes</name></decl>;</decl_stmt>			<comment type="block">/* offset to extra text area */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>enotes</name></decl>;</decl_stmt>			<comment type="block">/* offset to end of extra text area */</comment>

	<decl_stmt><decl><type><name>CdbExplain_SliceWorker</name></type> <name>worker</name></decl>;</decl_stmt>	<comment type="block">/* qExec's overall stats for slice */</comment>

	<comment type="block">/*
	 * During serialization, we use this as a temporary StatInst and save
	 * "one-at-a-time" StatInst into this variable. We then write this
	 * variable into buffer (serialize it) and then "recycle" the same inst
	 * for next plan node's StatInst. During deserialization, an Array
	 * [0..nInst-1] of StatInst entries is appended starting here.
	 */</comment>
	<decl_stmt><decl><type><name>CdbExplain_StatInst</name></type> <name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* extra text is appended after that */</comment>
}</block></struct></type> <name>CdbExplain_StatHdr</name>;</typedef>


<comment type="block">/* Dispatch status summarized over workers in a slice */</comment>
<typedef>typedef <type><struct>struct <name>CdbExplain_DispatchSummary</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>nResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nOk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nError</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nCanceled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nNotDispatched</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nIgnorableError</name></decl>;</decl_stmt>
}</block></struct></type> <name>CdbExplain_DispatchSummary</name>;</typedef>


<comment type="block">/* One node's EXPLAIN ANALYZE statistics for all the workers of its segworker group */</comment>
<typedef>typedef <type><struct>struct <name>CdbExplain_NodeSummary</name>
<block>{
	<comment type="block">/* Summary over all the node's workers */</comment>
	<decl_stmt><decl><type><name>CdbExplain_Agg</name></type> <name>ntuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_Agg</name></type> <name>execmemused</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_Agg</name></type> <name>workmemused</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_Agg</name></type> <name>workmemwanted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_Agg</name></type> <name>totalWorkfileCreated</name></decl>;</decl_stmt>
	<comment type="block">/* Used for DynamicSeqScan, DynamicIndexScan and DynamicBitmapHeapScan */</comment>
	<decl_stmt><decl><type><name>CdbExplain_Agg</name></type> <name>totalPartTableScanned</name></decl>;</decl_stmt>
	<comment type="block">/* Summary of space used by sort */</comment>
	<decl_stmt><decl><type><name>CdbExplain_Agg</name></type> <name><name>sortSpaceUsed</name><index>[<expr><name>NUM_SORT_SPACE_TYPE</name></expr>]</index><index>[<expr><name>NUM_SORT_METHOD</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* insts array info */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>segindex0</name></decl>;</decl_stmt>		<comment type="block">/* segment id of insts[0] */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>ninst</name></decl>;</decl_stmt>			<comment type="block">/* num of StatInst entries in inst array */</comment>

	<comment type="block">/* Array [0..ninst-1] of StatInst entries is appended starting here */</comment>
	<decl_stmt><decl><type><name>CdbExplain_StatInst</name></type> <name><name>insts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* variable size - must be last */</comment>
}</block></struct></type> <name>CdbExplain_NodeSummary</name>;</typedef>


<comment type="block">/* One slice's statistics for all the workers of its segworker group */</comment>
<typedef>typedef <type><struct>struct <name>CdbExplain_SliceSummary</name>
<block>{
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>slice</name></decl>;</decl_stmt>

	<comment type="block">/* worker array */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nworker</name></decl>;</decl_stmt>		<comment type="block">/* num of SliceWorker slots in worker array */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>segindex0</name></decl>;</decl_stmt>		<comment type="block">/* segment id of workers[0] */</comment>
	<decl_stmt><decl><type><name>CdbExplain_SliceWorker</name> <modifier>*</modifier></type><name>workers</name></decl>;</decl_stmt>	<comment type="block">/* -&gt; array [0..nworker-1] of
										 * SliceWorker */</comment>
	<decl_stmt><decl><type><name>CdbExplain_Agg</name></type> <name>peakmemused</name></decl>;</decl_stmt> <comment type="block">/* Summary of SliceWorker stats over all of
								 * the slice's workers */</comment>

	<decl_stmt><decl><type><name>CdbExplain_Agg</name></type> <name>vmem_reserved</name></decl>;</decl_stmt>	<comment type="block">/* vmem reserved by QEs */</comment>

	<comment type="block">/* Rollup of per-node stats over all of the slice's workers and nodes */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemused_max</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemwanted_max</name></decl>;</decl_stmt>

	<comment type="block">/* How many workers were dispatched and returned results? (0 if local) */</comment>
	<decl_stmt><decl><type><name>CdbExplain_DispatchSummary</name></type> <name>dispatchSummary</name></decl>;</decl_stmt>
}</block></struct></type> <name>CdbExplain_SliceSummary</name>;</typedef>


<comment type="block">/* State for cdbexplain_showExecStats() */</comment>
<typedef>typedef <type><struct>struct <name>CdbExplain_ShowStatCtx</name>
<block>{
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>extratextbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>querystarttime</name></decl>;</decl_stmt>

	<comment type="block">/* Rollup of per-node stats over the entire query plan */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemused_max</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemwanted_max</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>stats_gathered</name></decl>;</decl_stmt>
	<comment type="block">/* Per-slice statistics are deposited in this SliceSummary array */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nslice</name></decl>;</decl_stmt>			<comment type="block">/* num of slots in slices array */</comment>
	<decl_stmt><decl><type><name>CdbExplain_SliceSummary</name> <modifier>*</modifier></type><name>slices</name></decl>;</decl_stmt>	<comment type="block">/* -&gt; array[0..nslice-1] of
										 * SliceSummary */</comment>
}</block></struct></type> <name>CdbExplain_ShowStatCtx</name>;</typedef>


<comment type="block">/* State for cdbexplain_sendStatWalker() and cdbexplain_collectStatsFromNode() */</comment>
<typedef>typedef <type><struct>struct <name>CdbExplain_SendStatCtx</name>
<block>{
	<decl_stmt><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>notebuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_StatHdr</name></type> <name>hdr</name></decl>;</decl_stmt>
}</block></struct></type> <name>CdbExplain_SendStatCtx</name>;</typedef>


<comment type="block">/* State for cdbexplain_recvStatWalker() and cdbexplain_depositStatsToNode() */</comment>
<typedef>typedef <type><struct>struct <name>CdbExplain_RecvStatCtx</name>
<block>{
	<comment type="block">/*
	 * iStatInst is the current StatInst serial during the depositing process
	 * for a slice. We walk the plan tree, and for each node we deposit stat
	 * from all the QEs of the segworker group for current slice. After we
	 * finish one node, we increase iStatInst, which means we are done with
	 * one plan node's stat across all segments and now moving forward to the
	 * next one. Once we are done processing all the plan node of a PARTICULAR
	 * slice, then we switch to the next slice, read the messages from all the
	 * QEs of the next slice (another segworker group) store them in the
	 * msgptrs, reset the iStatInst and then start parsing these messages and
	 * depositing them in the nodes of the new slice.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>iStatInst</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * nStatInst is the total number of StatInst for current slice. Typically
	 * this is the number of plan nodes in the current slice.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nStatInst</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * segIndexMin is the min of segment index from which we collected message
	 * (i.e., saved msgptrs)
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>segindexMin</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * segIndexMax is the max of segment index from which we collected message
	 * (i.e., saved msgptrs)
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>segindexMax</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We deposit stat for one slice at a time. sliceIndex saves the current
	 * slice
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sliceIndex</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The number of msgptrs that we have saved for current slice. This is
	 * typically the number of QE processes
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmsgptr</name></decl>;</decl_stmt>
	<comment type="block">/* The actual messages. Contains an array of StatInst too */</comment>
	<decl_stmt><decl><type><name>CdbExplain_StatHdr</name> <modifier>*</modifier><modifier>*</modifier></type><name>msgptrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbDispatchResults</name> <modifier>*</modifier></type><name>dispatchResults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>extratextbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_ShowStatCtx</name> <modifier>*</modifier></type><name>showstatctx</name></decl>;</decl_stmt>

	<comment type="block">/* Rollup of per-node stats over all of the slice's workers and nodes */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemused_max</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>workmemwanted_max</name></decl>;</decl_stmt>
}</block></struct></type> <name>CdbExplain_RecvStatCtx</name>;</typedef>


<comment type="block">/* State for cdbexplain_localStatWalker() */</comment>
<typedef>typedef <type><struct>struct <name>CdbExplain_LocalStatCtx</name>
<block>{
	<decl_stmt><decl><type><name>CdbExplain_SendStatCtx</name></type> <name>send</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_RecvStatCtx</name></type> <name>recv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_StatHdr</name> <modifier>*</modifier></type><name><name>msgptrs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>CdbExplain_LocalStatCtx</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>cdbexplain_showExecStatsEnd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannedStmt</name></name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
							<parameter><decl><type><name><name>struct</name> <name>CdbExplain_ShowStatCtx</name></name>  <modifier>*</modifier></type><name>showstatctx</name></decl></parameter>,
                            <parameter><decl><type><name><name>struct</name> <name>EState</name></name>                  <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cdbexplain_showExecStats</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlanState</name></name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
									 <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CdbVisitOpt</name></type> <name>cdbexplain_localStatWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
											  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CdbVisitOpt</name></type> <name>cdbexplain_sendStatWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
											 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CdbVisitOpt</name></type> <name>cdbexplain_recvStatWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
											 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cdbexplain_collectSliceStats</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
										 <parameter><decl><type><name>CdbExplain_SliceWorker</name> <modifier>*</modifier></type><name>out_worker</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cdbexplain_depositSliceStats</name><parameter_list>(<parameter><decl><type><name>CdbExplain_StatHdr</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>,
										 <parameter><decl><type><name>CdbExplain_RecvStatCtx</name> <modifier>*</modifier></type><name>recvstatctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cdbexplain_collectStatsFromNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
											<parameter><decl><type><name>CdbExplain_SendStatCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cdbexplain_depositStatsToNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
										  <parameter><decl><type><name>CdbExplain_RecvStatCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cdbexplain_collectExtraText</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
									   <parameter><decl><type><name>StringInfo</name></type> <name>notebuf</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_motion_keys</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
							 <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>keycols</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>gpexplain_formatSlicesOutput</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbExplain_ShowStatCtx</name></name> <modifier>*</modifier></type><name>showstatctx</name></decl></parameter>,
                             <parameter><decl><type><name><name>struct</name> <name>EState</name></name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                             <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * cdbexplain_localExecStats
 *	  Called by qDisp to build NodeSummary and SliceSummary blocks
 *	  containing EXPLAIN ANALYZE statistics for a root slice that
 *	  has been executed locally in the qDisp process.  Attaches these
 *	  structures to the PlanState nodes' Instrumentation objects for
 *	  later use by cdbexplain_showExecStats().
 *
 * 'planstate' is the top PlanState node of the slice.
 * 'showstatctx' is a CdbExplain_ShowStatCtx object which was created by
 *		calling cdbexplain_showExecStatsBegin().
 */</comment>
<function><type><name>void</name></type>
<name>cdbexplain_localExecStats</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlanState</name></name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
						  <parameter><decl><type><name><name>struct</name> <name>CdbExplain_ShowStatCtx</name></name> <modifier>*</modifier></type><name>showstatctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbExplain_LocalStatCtx</name></type> <name>ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>planstate</name> <operator>&amp;&amp;</operator> <name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name> <operator>&amp;&amp;</operator> <name>showstatctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up send context area. */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>notebuf</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>showstatctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr>;</expr_stmt>

	<comment type="block">/* Set up a temporary StatHdr for both collecting and depositing stats. */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>hdr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>hdr</name><operator>.</operator><name>segindex</name></name> <operator>=</operator> <name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>hdr</name><operator>.</operator><name>nInst</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Set up receive context area referencing our temp StatHdr. */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>nStatInst</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>hdr</name><operator>.</operator><name>nInst</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>segindexMin</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>segindexMax</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>hdr</name><operator>.</operator><name>segindex</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>sliceIndex</name></name> <operator>=</operator> <call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>msgptrs</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>msgptrs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>nmsgptr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>dispatchResults</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>extratextbuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>recv</name><operator>.</operator><name>showstatctx</name></name> <operator>=</operator> <name>showstatctx</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Collect and redeposit statistics from each PlanState node in this
	 * slice. Any extra message text will be appended directly to
	 * extratextbuf.
	 */</comment>
	<expr_stmt><expr><call><name>planstate_walk_node</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>cdbexplain_localStatWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Obtain per-slice stats and put them in SliceSummary. */</comment>
	<expr_stmt><expr><call><name>cdbexplain_collectSliceStats</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>hdr</name><operator>.</operator><name>worker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbexplain_depositSliceStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>send</name><operator>.</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>recv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_localExecStats */</comment>


<comment type="block">/*
 * cdbexplain_localStatWalker
 */</comment>
<function><type><specifier>static</specifier> <name>CdbVisitOpt</name></type>
<name>cdbexplain_localStatWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbExplain_LocalStatCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>CdbExplain_LocalStatCtx</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Collect stats into our temporary StatInst and caller's extratextbuf. */</comment>
	<expr_stmt><expr><call><name>cdbexplain_collectStatsFromNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>send</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Redeposit stats back into Instrumentation, and attach a NodeSummary. */</comment>
	<expr_stmt><expr><call><name>cdbexplain_depositStatsToNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't descend across a slice boundary. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>MotionState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>CdbVisit_Skip</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>CdbVisit_Walk</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_localStatWalker */</comment>


<comment type="block">/*
 * cdbexplain_sendExecStats
 *	  Called by qExec process to send EXPLAIN ANALYZE statistics to qDisp.
 *	  On the qDisp, libpq will recognize our special message type ('Y') and
 *	  attach the message to the current command's PGresult object.
 */</comment>
<function><type><name>void</name></type>
<name>cdbexplain_sendExecStats</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_SendStatCtx</name></type> <name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>notebuf</name></decl>;</decl_stmt>

	<comment type="block">/* Header offset (where header begins in the message buffer) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>hoff</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>queryDesc</name> <operator>||</operator>
		<operator>!</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If executing a root slice (UPD/DEL/INS), start at top of plan tree. */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>RootSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>planstate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/* Non-root slice: Start at child of our sending Motion node. */</comment>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>planstate</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><call><name>getMotionState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><call><name>LocallyExecutingSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ps</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>planstate</name> <operator>&amp;&amp;</operator>
			   <call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>MotionState</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			   <name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>planstate</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>planstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Start building the message header in our context area. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_CdbExplain_StatHdr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>segindex</name></name> <operator>=</operator> <name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>nInst</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Allocate a separate buffer where nodes can append extra message text. */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>notebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>notebuf</name></name> <operator>=</operator> <operator>&amp;</operator><name>notebuf</name></expr>;</expr_stmt>

	<comment type="block">/* Reserve buffer space for the message header (excluding 'inst' array). */</comment>
	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'Y'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Where the actual StatHdr begins */</comment>
	<expr_stmt><expr><name>hoff</name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Write everything until inst member including "CdbExplain_SliceWorker
	 * worker"
	 */</comment>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>hdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>hdr</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>inst</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Append statistics from each PlanState node in this slice. */</comment>
	<expr_stmt><expr><call><name>planstate_walk_node</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>cdbexplain_sendStatWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Obtain per-slice stats and put them in StatHdr. */</comment>
	<expr_stmt><expr><call><name>cdbexplain_collectSliceStats</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>worker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Append the extra message text. */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>bnotes</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>hoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>notebuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>notebuf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>enotes</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>hoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>notebuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Move the message header into the buffer. Rewrite the updated header
	 * (with bnotes, enotes, nInst etc.) Note: this is the second time we are
	 * writing the header. The first write merely reserves space for the
	 * header
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>buf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name>hoff</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>hdr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>hdr</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>hdr</name><operator>.</operator><name>inst</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<comment type="block">/* Inject a fault before sending a message to qDisp process */</comment>
	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"send_exec_stats"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FAULT_INJECTOR */</comment>

	<comment type="block">/* Send message to qDisp process. */</comment>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_sendExecStats */</comment>


<comment type="block">/*
 * cdbexplain_sendStatWalker
 */</comment>
<function><type><specifier>static</specifier> <name>CdbVisitOpt</name></type>
<name>cdbexplain_sendStatWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbExplain_SendStatCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>CdbExplain_SendStatCtx</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_StatInst</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Stuff stats into our temporary StatInst.  Add extra text to notebuf. */</comment>
	<expr_stmt><expr><call><name>cdbexplain_collectStatsFromNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Append StatInst instance to message. */</comment>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>si</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>si</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nInst</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Don't descend across a slice boundary. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>MotionState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>CdbVisit_Skip</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>CdbVisit_Walk</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_sendStatWalker */</comment>


<comment type="block">/*
 * cdbexplain_recvExecStats
 *	  Called by qDisp to transfer a slice's EXPLAIN ANALYZE statistics
 *	  from the CdbDispatchResults structures to the PlanState tree.
 *	  Recursively does the same for slices that are descendants of the
 *	  one specified.
 *
 * 'showstatctx' is a CdbExplain_ShowStatCtx object which was created by
 *		calling cdbexplain_showExecStatsBegin().
 */</comment>
<function><type><name>void</name></type>
<name>cdbexplain_recvExecStats</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlanState</name></name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
						 <parameter><decl><type><name><name>struct</name> <name>CdbDispatchResults</name></name> <modifier>*</modifier></type><name>dispatchResults</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>,
						 <parameter><decl><type><name><name>struct</name> <name>CdbExplain_ShowStatCtx</name></name> <modifier>*</modifier></type><name>showstatctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResultBeg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResultEnd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_RecvStatCtx</name></type> <name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_DispatchSummary</name></type> <name>ds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>gpsegmentCount</name> <init>= <expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>iDispatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nDispatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>imsgptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>planstate</name> <operator>||</operator>
		<operator>!</operator><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name> <operator>||</operator>
		<operator>!</operator><name>showstatctx</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note that the caller may free the CdbDispatchResults upon return, maybe
	 * before EXPLAIN ANALYZE examines the PlanState tree.  Consequently we
	 * must not return ptrs into the dispatch result buffers, but must copy
	 * any needed information into a sufficiently long-lived memory context.
	 */</comment>

	<comment type="block">/* Initialize treewalk context. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>dispatchResults</name></name> <operator>=</operator> <name>dispatchResults</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>extratextbuf</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>showstatctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>showstatctx</name></name> <operator>=</operator> <name>showstatctx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>sliceIndex</name></name> <operator>=</operator> <name>sliceIndex</name></expr>;</expr_stmt>

	<comment type="block">/* Find the slice's CdbDispatchResult objects. */</comment>
	<expr_stmt><expr><name>dispatchResultBeg</name> <operator>=</operator> <call><name>cdbdisp_resultBegin</name><argument_list>(<argument><expr><name>dispatchResults</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dispatchResultEnd</name> <operator>=</operator> <call><name>cdbdisp_resultEnd</name><argument_list>(<argument><expr><name>dispatchResults</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nDispatch</name> <operator>=</operator> <name>dispatchResultEnd</name> <operator>-</operator> <name>dispatchResultBeg</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize worker counts. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>nResult</name></name> <operator>=</operator> <name>nDispatch</name></expr>;</expr_stmt>

	<comment type="block">/* Find and validate the statistics returned from each qExec. */</comment>
	<if_stmt><if>if <condition>(<expr><name>nDispatch</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name></name> <operator>=</operator> <operator>(</operator><name>CdbExplain_StatHdr</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nDispatch</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>iDispatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>iDispatch</name> <operator>&lt;</operator> <name>nDispatch</name></expr>;</condition> <incr><expr><name>iDispatch</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name> <init>= <expr><operator>&amp;</operator><name><name>dispatchResultBeg</name><index>[<expr><name>iDispatch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pgresult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbExplain_StatHdr</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pgCdbStatCell</name> <modifier>*</modifier></type><name>statcell</name></decl>;</decl_stmt>

		<comment type="block">/* Update worker counts. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>hasDispatched</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>nNotDispatched</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>wasCanceled</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>nCanceled</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>nError</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>nOk</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>			<comment type="block">/* qExec returned successful completion */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ds</name><operator>.</operator><name>nIgnorableError</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* qExec returned an error that's likely a
									 * side-effect of another qExec's failure,
									 * e.g. an interconnect error */</comment>

		<comment type="block">/* Find this qExec's last PGresult.  If none, skip to next qExec. */</comment>
		<expr_stmt><expr><name>pgresult</name> <operator>=</operator> <call><name>cdbdisp_getPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgresult</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Find our statistics in list of response messages.  If none, skip. */</comment>
		<for>for <control>(<init><expr><name>statcell</name> <operator>=</operator> <name><name>pgresult</name><operator>-&gt;</operator><name>cdbstats</name></name></expr>;</init> <condition><expr><name>statcell</name></expr>;</condition> <incr><expr><name>statcell</name> <operator>=</operator> <name><name>statcell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>statcell</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>CdbExplain_StatHdr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>statcell</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Validate the message header. */</comment>
		<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>CdbExplain_StatHdr</name> <operator>*</operator><operator>)</operator> <name><name>statcell</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>statcell</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hdr</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
			<operator>(</operator><name>size_t</name><operator>)</operator> <name><name>statcell</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hdr</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>inst</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
									   <name><name>hdr</name><operator>-&gt;</operator><name>nInst</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>inst</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
									   <name><name>hdr</name><operator>-&gt;</operator><name>enotes</name></name> <operator>-</operator> <name><name>hdr</name><operator>-&gt;</operator><name>bnotes</name></name><operator>)</operator> <operator>||</operator>
			<name><name>statcell</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>enotes</name></name> <operator>||</operator>
			<name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
			<name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name> <operator>&gt;=</operator> <name>gpsegmentCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"Invalid execution statistics "</literal>
											<literal type="string">"response returned from seg%d.  "</literal>
											<literal type="string">"length=%d"</literal></expr></argument>,
											<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>,
											<argument><expr><name><name>statcell</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please verify that all instances are using "</literal>
									<literal type="string">"the correct %s software version."</literal></expr></argument>,
									<argument><expr><name>PACKAGE_NAME</name></expr></argument>)</argument_list></call>
							<operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Slice should have same number of plan nodes on every qExec. */</comment>
		<if_stmt><if>if <condition>(<expr><name>iDispatch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>nStatInst</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>nInst</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Check for stats corruption */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>nStatInst</name></name> <operator>!=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>nInst</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid execution statistics "</literal>
									   <literal type="string">"received stats node-count mismatch: cdbexplain_recvExecStats() ctx.nStatInst %d hdr-&gt;nInst %d"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>.</operator><name>nStatInst</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nInst</name></name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please verify that all instances are using "</literal>
										<literal type="string">"the correct %s software version."</literal></expr></argument>,
										<argument><expr><name>PACKAGE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>nStatInst</name></name> <operator>==</operator> <name><name>hdr</name><operator>-&gt;</operator><name>nInst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Save lowest and highest segment id for which we have stats. */</comment>
		<if_stmt><if>if <condition>(<expr><name>iDispatch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>segindexMin</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>segindexMax</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>segindexMax</name></name> <operator>&lt;</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>segindexMax</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>segindexMin</name></name> <operator>&gt;</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>segindexMin</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Save message ptr for easy reference. */</comment>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name><index>[<expr><name><name>ctx</name><operator>.</operator><name>nmsgptr</name></name></expr>]</index></name> <operator>=</operator> <name>hdr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>nmsgptr</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Attach NodeSummary to each PlanState node's Instrumentation node. */</comment>
	<expr_stmt><expr><call><name>planstate_walk_node</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>cdbexplain_recvStatWalker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure we visited the right number of PlanState nodes. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>iStatInst</name></name> <operator>==</operator> <name><name>ctx</name><operator>.</operator><name>nStatInst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Transfer per-slice stats from message headers to the SliceSummary. */</comment>
	<for>for <control>(<init><expr><name>imsgptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>imsgptr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>.</operator><name>nmsgptr</name></name></expr>;</condition> <incr><expr><name>imsgptr</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cdbexplain_depositSliceStats</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name><index>[<expr><name>imsgptr</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Transfer worker counts to SliceSummary. */</comment>
	<expr_stmt><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name><operator>.</operator><name>dispatchSummary</name> <operator>=</operator> <name>ds</name></expr>;</expr_stmt>

	<comment type="block">/* Signal that we've gathered all the statistics
	 * For some query, which has initplan on top of the plan,
	 * its `ANALYZE EXPLAIN` invoke `cdbexplain_recvExecStats`
	 * multi-times in different recursive routine to collect
	 * metrics on both initplan and plan. Thus, this variable
	 * should only assign on slice 0 after gather result done
	 * to promise all slices information have been collected.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sliceIndex</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>stats_gathered</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean up. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>msgptrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_recvExecStats */</comment>


<comment type="block">/*
 * cdbexplain_recvStatWalker
 *	  Update the given PlanState node's Instrument node with statistics
 *	  received from qExecs.  Attach a CdbExplain_NodeSummary block to
 *	  the Instrument node.  At a MotionState node, descend to child slice.
 */</comment>
<function><type><specifier>static</specifier> <name>CdbVisitOpt</name></type>
<name>cdbexplain_recvStatWalker</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbExplain_RecvStatCtx</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator><name>CdbExplain_RecvStatCtx</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If slice was dispatched to qExecs, and stats came back, grab 'em. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>nmsgptr</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Transfer received stats to Instrumentation, NodeSummary, etc. */</comment>
		<expr_stmt><expr><call><name>cdbexplain_depositStatsToNode</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Advance to next node's entry in all of the StatInst arrays. */</comment>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>iStatInst</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Motion operator?  Descend to next slice. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>MotionState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>cdbexplain_recvExecStats</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>,
								 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dispatchResults</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>motionID</name></expr></argument>,
								 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>showstatctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>CdbVisit_Skip</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>CdbVisit_Walk</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_recvStatWalker */</comment>


<comment type="block">/*
 * cdbexplain_collectSliceStats
 *	  Obtain per-slice statistical observations from the current slice
 *	  (which has just completed execution in the current process) and
 *	  store the information in the given SliceWorker struct.
 *
 * 'planstate' is the top PlanState node of the current slice.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbexplain_collectSliceStats</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
							 <parameter><decl><type><name>CdbExplain_SliceWorker</name> <modifier>*</modifier></type><name>out_worker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Max bytes malloc'ed under executor's per-query memory context. */</comment>
	<expr_stmt><expr><name><name>out_worker</name><operator>-&gt;</operator><name>peakmemused</name></name> <operator>=</operator>
		<operator>(</operator><name>double</name><operator>)</operator> <call><name>MemoryContextGetPeakSpace</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>out_worker</name><operator>-&gt;</operator><name>vmem_reserved</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <call><name>VmemTracker_GetMaxReservedVmemBytes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_collectSliceStats */</comment>


<comment type="block">/*
 * cdbexplain_depositSliceStats
 *	  Transfer a worker's per-slice stats contribution from StatHdr into the
 *	  SliceSummary array in the ShowStatCtx.  Transfer the rollup of per-node
 *	  stats from the RecvStatCtx into the SliceSummary.
 *
 * Kludge: In a non-parallel plan, slice numbers haven't been assigned, so we
 * may be called more than once with sliceIndex == 0: once for the outermost
 * query and once for each InitPlan subquery.  In this case we dynamically
 * expand the SliceSummary array.  CDB TODO: Always assign proper root slice
 * ids (in qDispSliceId field of SubPlan node); then remove this kludge.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbexplain_depositSliceStats</name><parameter_list>(<parameter><decl><type><name>CdbExplain_StatHdr</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>,
							 <parameter><decl><type><name>CdbExplain_RecvStatCtx</name> <modifier>*</modifier></type><name>recvstatctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>sliceIndex</name> <init>= <expr><name><name>recvstatctx</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_ShowStatCtx</name> <modifier>*</modifier></type><name>showstatctx</name> <init>= <expr><name><name>recvstatctx</name><operator>-&gt;</operator><name>showstatctx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_SliceSummary</name> <modifier>*</modifier></type><name>ss</name> <init>= <expr><operator>&amp;</operator><name><name>showstatctx</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_SliceWorker</name> <modifier>*</modifier></type><name>ssw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>iworker</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sliceIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <name>sliceIndex</name> <operator>&lt;</operator> <name><name>showstatctx</name><operator>-&gt;</operator><name>nslice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Kludge:	QD can have more than one 'Slice 0' if plan is non-parallel. */</comment>
	<if_stmt><if>if <condition>(<expr><name>sliceIndex</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>recvstatctx</name><operator>-&gt;</operator><name>dispatchResults</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>ss</name><operator>-&gt;</operator><name>workers</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>nworker</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			   <name><name>recvstatctx</name><operator>-&gt;</operator><name>segindexMin</name></name> <operator>==</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name> <operator>&amp;&amp;</operator>
			   <name><name>recvstatctx</name><operator>-&gt;</operator><name>segindexMax</name></name> <operator>==</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Expand the SliceSummary array to make room for InitPlan subquery. */</comment>
		<expr_stmt><expr><name>sliceIndex</name> <operator>=</operator> <name><name>showstatctx</name><operator>-&gt;</operator><name>nslice</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <operator>(</operator><name>CdbExplain_SliceSummary</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>slices</name></name></expr></argument>, <argument><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>nslice</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ss</name> <operator>=</operator> <operator>&amp;</operator><name><name>showstatctx</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ss</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Slice's first worker? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ss</name><operator>-&gt;</operator><name>workers</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Allocate SliceWorker array and attach it to the SliceSummary. */</comment>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>segindex0</name></name> <operator>=</operator> <name><name>recvstatctx</name><operator>-&gt;</operator><name>segindexMin</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>nworker</name></name> <operator>=</operator> <name><name>recvstatctx</name><operator>-&gt;</operator><name>segindexMax</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>ss</name><operator>-&gt;</operator><name>segindex0</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>workers</name></name> <operator>=</operator> <operator>(</operator><name>CdbExplain_SliceWorker</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>nworker</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ss</name><operator>-&gt;</operator><name>workers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Save a copy of this SliceWorker instance in the worker array. */</comment>
	<expr_stmt><expr><name>iworker</name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name> <operator>-</operator> <name><name>ss</name><operator>-&gt;</operator><name>segindex0</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ssw</name> <operator>=</operator> <operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>workers</name><index>[<expr><name>iworker</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>iworker</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iworker</name> <operator>&lt;</operator> <name><name>ss</name><operator>-&gt;</operator><name>nworker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ssw</name><operator>-&gt;</operator><name>peakmemused</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* each worker should be seen just once */</comment>
	<expr_stmt><expr><operator>*</operator><name>ssw</name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>worker</name></name></expr>;</expr_stmt>

	<comment type="block">/* Rollup of per-worker stats into SliceSummary */</comment>
	<expr_stmt><expr><call><name>cdbexplain_agg_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>peakmemused</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbexplain_agg_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>vmem_reserved</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Rollup of per-node stats over all nodes of the slice into SliceSummary */</comment>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>workmemused_max</name></name> <operator>=</operator> <name><name>recvstatctx</name><operator>-&gt;</operator><name>workmemused_max</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>workmemwanted_max</name></name> <operator>=</operator> <name><name>recvstatctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name></expr>;</expr_stmt>

	<comment type="block">/* Rollup of per-node stats over the whole query into ShowStatCtx. */</comment>
	<expr_stmt><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>workmemused_max</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>workmemused_max</name></name></expr></argument>, <argument><expr><name><name>recvstatctx</name><operator>-&gt;</operator><name>workmemused_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>showstatctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name></expr></argument>, <argument><expr><name><name>recvstatctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_depositSliceStats */</comment>


<comment type="block">/*
 * cdbexplain_collectStatsFromNode
 *
 * Called by sendStatWalker and localStatWalker to obtain a node's statistics
 * and transfer them into the temporary StatHdr and StatInst in the SendStatCtx.
 * Also obtains the node's extra message text, which it appends to the caller's
 * cxt-&gt;nodebuf.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbexplain_collectStatsFromNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>CdbExplain_SendStatCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbExplain_StatInst</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We have to finalize statistics, since ExecutorEnd hasn't been called. */</comment>
	<expr_stmt><expr><call><name>InstrEndLoop</name><argument_list>(<argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the StatInst slot in the temporary StatHdr. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>si</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>si</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>pstype</name></name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>

	<comment type="block">/* Add this node's extra message text to notebuf.  Store final stats. */</comment>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>=</operator> <call><name>cdbexplain_collectExtraText</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>notebuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>enotes</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>notebuf</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

	<comment type="block">/* Make sure there is a '\0' between this node's message and the next. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>&lt;</operator> <name><name>si</name><operator>-&gt;</operator><name>enotes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>notebuf</name></name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Use the instrument's memory record if exists, or query the memory context. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>instr</name><operator>-&gt;</operator><name>execmemused</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>execmemused</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>execmemused</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>node_context</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>execmemused</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <call><name>MemoryContextGetPeakSpace</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>node_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Transfer this node's statistics from Instrumentation into StatInst. */</comment>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>starttime</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>starttime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>counter</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>counter</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>firsttuple</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>firsttuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>startup</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>startup</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>total</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>total</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>ntuples2</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ntuples2</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>nloops</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>nloops</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>nfiltered1</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>nfiltered1</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>nfiltered2</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>nfiltered2</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>workmemused</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>workmemused</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>workmemwanted</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>workmemwanted</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>workfileCreated</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>workfileCreated</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>firststart</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>firststart</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>numPartScanned</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>numPartScanned</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>SortState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortState</name> <modifier>*</modifier></type><name>sortstate</name> <init>= <expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>sortstats</name></name> <operator>=</operator> <name><name>sortstate</name><operator>-&gt;</operator><name>sortstats</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>HashState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HashState</name> <modifier>*</modifier></type><name>hashstate</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hashstate</name><operator>-&gt;</operator><name>hashtable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecHashGetInstrumentation</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>hashstats</name></name></expr></argument>, <argument><expr><name><name>hashstate</name><operator>-&gt;</operator><name>hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_collectStatsFromNode */</comment>


<comment type="block">/*
 * CdbExplain_DepStatAcc
 *	  Segment statistic accumulator used by cdbexplain_depositStatsToNode().
 */</comment>
<typedef>typedef <type><struct>struct <name>CdbExplain_DepStatAcc</name>
<block>{
	<comment type="block">/* vmax, vsum, vcnt, segmax */</comment>
	<decl_stmt><decl><type><name>CdbExplain_Agg</name></type> <name>agg</name></decl>;</decl_stmt>
	<comment type="block">/* max's received StatHdr */</comment>
	<decl_stmt><decl><type><name>CdbExplain_StatHdr</name> <modifier>*</modifier></type><name>rshmax</name></decl>;</decl_stmt>
	<comment type="block">/* max's received inst in StatHdr */</comment>
	<decl_stmt><decl><type><name>CdbExplain_StatInst</name> <modifier>*</modifier></type><name>rsimax</name></decl>;</decl_stmt>
	<comment type="block">/* max's inst in NodeSummary */</comment>
	<decl_stmt><decl><type><name>CdbExplain_StatInst</name> <modifier>*</modifier></type><name>nsimax</name></decl>;</decl_stmt>
	<comment type="block">/* max run-time of all the segments */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>max_total</name></decl>;</decl_stmt>
	<comment type="block">/* start time of the first iteration for node with maximum runtime */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>firststart_of_max_total</name></decl>;</decl_stmt>
}</block></struct></type> <name>CdbExplain_DepStatAcc</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbexplain_depStatAcc_init0</name><parameter_list>(<parameter><decl><type><name>CdbExplain_DepStatAcc</name> <modifier>*</modifier></type><name>acc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>cdbexplain_agg_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>acc</name><operator>-&gt;</operator><name>agg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>rshmax</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>rsimax</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>nsimax</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>max_total</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name><name>acc</name><operator>-&gt;</operator><name>firststart_of_max_total</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_depStatAcc_init0 */</comment>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>cdbexplain_depStatAcc_upd</name><parameter_list>(<parameter><decl><type><name>CdbExplain_DepStatAcc</name> <modifier>*</modifier></type><name>acc</name></decl></parameter>,
						  <parameter><decl><type><name>double</name></type> <name>v</name></decl></parameter>,
						  <parameter><decl><type><name>CdbExplain_StatHdr</name> <modifier>*</modifier></type><name>rsh</name></decl></parameter>,
						  <parameter><decl><type><name>CdbExplain_StatInst</name> <modifier>*</modifier></type><name>rsi</name></decl></parameter>,
						  <parameter><decl><type><name>CdbExplain_StatInst</name> <modifier>*</modifier></type><name>nsi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>cdbexplain_agg_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>acc</name><operator>-&gt;</operator><name>agg</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>rsh</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>rshmax</name></name> <operator>=</operator> <name>rsh</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>rsimax</name></name> <operator>=</operator> <name>rsi</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>nsimax</name></name> <operator>=</operator> <name>nsi</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>acc</name><operator>-&gt;</operator><name>max_total</name></name> <operator>&lt;</operator> <name><name>nsi</name><operator>-&gt;</operator><name>total</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>acc</name><operator>-&gt;</operator><name>max_total</name></name> <operator>=</operator> <name><name>nsi</name><operator>-&gt;</operator><name>total</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_ASSIGN</name><argument_list>(<argument><expr><name><name>acc</name><operator>-&gt;</operator><name>firststart_of_max_total</name></name></expr></argument>, <argument><expr><name><name>nsi</name><operator>-&gt;</operator><name>firststart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_depStatAcc_upd */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbexplain_depStatAcc_saveText</name><parameter_list>(<parameter><decl><type><name>CdbExplain_DepStatAcc</name> <modifier>*</modifier></type><name>acc</name></decl></parameter>,
							   <parameter><decl><type><name>StringInfoData</name> <modifier>*</modifier></type><name>extratextbuf</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>saved_inout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbExplain_StatHdr</name> <modifier>*</modifier></type><name>rsh</name> <init>= <expr><name><name>acc</name><operator>-&gt;</operator><name>rshmax</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_StatInst</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><name><name>acc</name><operator>-&gt;</operator><name>rsimax</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_StatInst</name> <modifier>*</modifier></type><name>nsi</name> <init>= <expr><name><name>acc</name><operator>-&gt;</operator><name>nsimax</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>acc</name><operator>-&gt;</operator><name>agg</name><operator>.</operator><name>vcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>nsi</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>==</operator> <name><name>nsi</name><operator>-&gt;</operator><name>enotes</name></name> <operator>&amp;&amp;</operator>
		<name><name>rsi</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>&lt;</operator> <name><name>rsi</name><operator>-&gt;</operator><name>enotes</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Locate extra message text in dispatch result buffer. */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>notelen</name> <init>= <expr><name><name>rsi</name><operator>-&gt;</operator><name>enotes</name></name> <operator>-</operator> <name><name>rsi</name><operator>-&gt;</operator><name>bnotes</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>notes</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>rsh</name> <operator>+</operator> <name><name>rsh</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>+</operator> <name><name>rsi</name><operator>-&gt;</operator><name>bnotes</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rsh</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>+</operator> <name><name>rsi</name><operator>-&gt;</operator><name>enotes</name></name> <operator>&lt;</operator> <name><name>rsh</name><operator>-&gt;</operator><name>enotes</name></name> <operator>&amp;&amp;</operator>
			   <name><name>notes</name><index>[<expr><name>notelen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Append to extratextbuf. */</comment>
		<expr_stmt><expr><name><name>nsi</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>=</operator> <name><name>extratextbuf</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>extratextbuf</name></expr></argument>, <argument><expr><name>notes</name></expr></argument>, <argument><expr><name>notelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsi</name><operator>-&gt;</operator><name>enotes</name></name> <operator>=</operator> <name><name>extratextbuf</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

		<comment type="block">/* Tell caller that some extra text has been saved. */</comment>
		<if_stmt><if>if <condition>(<expr><name>saved_inout</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>saved_inout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_depStatAcc_saveText */</comment>


<comment type="block">/*
 * cdbexplain_depositStatsToNode
 *
 * Called by recvStatWalker and localStatWalker to update the given
 * PlanState node's Instrument node with statistics received from
 * workers or collected locally.  Attaches a CdbExplain_NodeSummary
 * block to the Instrument node.  If top node of slice, per-slice
 * statistics are transferred from the StatHdr to the SliceSummary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbexplain_depositStatsToNode</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>CdbExplain_RecvStatCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_StatHdr</name> <modifier>*</modifier></type><name>rsh</name></decl>;</decl_stmt>	<comment type="block">/* The header (which includes StatInst) */</comment>
	<decl_stmt><decl><type><name>CdbExplain_StatInst</name> <modifier>*</modifier></type><name>rsi</name></decl>;</decl_stmt>	<comment type="block">/* The current StatInst */</comment>

	<comment type="block">/*
	 * Points to the insts array of node summary (CdbExplain_NodeSummary).
	 * Used for saving every rsi in the node summary (in addition to saving
	 * the max/avg).
	 */</comment>
	<decl_stmt><decl><type><name>CdbExplain_StatInst</name> <modifier>*</modifier></type><name>nsi</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * ns is the node summary across all QEs of the segworker group. It also
	 * contains detailed "unsummarized" raw stat for a node across all QEs in
	 * current segworker group (in the insts array)
	 */</comment>
	<decl_stmt><decl><type><name>CdbExplain_NodeSummary</name> <modifier>*</modifier></type><name>ns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_DepStatAcc</name></type> <name>ntuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_DepStatAcc</name></type> <name>nloops</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_DepStatAcc</name></type> <name>execmemused</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_DepStatAcc</name></type> <name>workmemused</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_DepStatAcc</name></type> <name>workmemwanted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_DepStatAcc</name></type> <name>totalWorkfileCreated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_DepStatAcc</name></type> <name>peakmemused</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_DepStatAcc</name></type> <name>vmem_reserved</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_DepStatAcc</name></type> <name>totalPartTableScanned</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_DepStatAcc</name></type> <name><name>sortSpaceUsed</name><index>[<expr><name>NUM_SORT_SPACE_TYPE</name></expr>]</index><index>[<expr><name>NUM_SORT_METHOD</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>imsgptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nInst</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>instr</name> <operator>&amp;&amp;</operator>
		   <name><name>ctx</name><operator>-&gt;</operator><name>iStatInst</name></name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nStatInst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate NodeSummary block. */</comment>
	<expr_stmt><expr><name>nInst</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>segindexMax</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>ctx</name><operator>-&gt;</operator><name>segindexMin</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ns</name> <operator>=</operator> <operator>(</operator><name>CdbExplain_NodeSummary</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ns</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>insts</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
											<name>nInst</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>insts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>segindex0</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>segindexMin</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>ninst</name></name> <operator>=</operator> <name>nInst</name></expr>;</expr_stmt>

	<comment type="block">/* Attach our new NodeSummary to the Instrumentation node. */</comment>
	<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>cdbNodeSummary</name></name> <operator>=</operator> <name>ns</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize per-node accumulators. */</comment>
	<expr_stmt><expr><call><name>cdbexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ntuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nloops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>execmemused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workmemused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workmemwanted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>totalWorkfileCreated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>totalPartTableScanned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_SORT_METHOD</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>NUM_SORT_SPACE_TYPE</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>cdbexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sortSpaceUsed</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></for>

	<comment type="block">/* Initialize per-slice accumulators. */</comment>
	<expr_stmt><expr><call><name>cdbexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>peakmemused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbexplain_depStatAcc_init0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vmem_reserved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Examine the statistics from each qExec. */</comment>
	<for>for <control>(<init><expr><name>imsgptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>imsgptr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nmsgptr</name></name></expr>;</condition> <incr><expr><name>imsgptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Locate PlanState node's StatInst received from this qExec. */</comment>
		<expr_stmt><expr><name>rsh</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>msgptrs</name><index>[<expr><name>imsgptr</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rsi</name> <operator>=</operator> <operator>&amp;</operator><name><name>rsh</name><operator>-&gt;</operator><name>inst</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>iStatInst</name></name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>pstype</name></name> <operator>==</operator> <name><name>planstate</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;&amp;</operator>
			   <name><name>ns</name><operator>-&gt;</operator><name>segindex0</name></name> <operator>&lt;=</operator> <name><name>rsh</name><operator>-&gt;</operator><name>segindex</name></name> <operator>&amp;&amp;</operator>
			   <name><name>rsh</name><operator>-&gt;</operator><name>segindex</name></name> <operator>&lt;</operator> <name><name>ns</name><operator>-&gt;</operator><name>segindex0</name></name> <operator>+</operator> <name><name>ns</name><operator>-&gt;</operator><name>ninst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Locate this qExec's StatInst slot in node's NodeSummary block. */</comment>
		<expr_stmt><expr><name>nsi</name> <operator>=</operator> <operator>&amp;</operator><name><name>ns</name><operator>-&gt;</operator><name>insts</name><index>[<expr><name><name>rsh</name><operator>-&gt;</operator><name>segindex</name></name> <operator>-</operator> <name><name>ns</name><operator>-&gt;</operator><name>segindex0</name></name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Copy the StatInst to NodeSummary from dispatch result buffer. */</comment>
		<expr_stmt><expr><operator>*</operator><name>nsi</name> <operator>=</operator> <operator>*</operator><name>rsi</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Drop qExec's extra text.  We rescue it below if qExec is a winner.
		 * For local qDisp slice, ctx-&gt;extratextbuf is NULL, which tells us to
		 * leave the extra text undisturbed in its existing buffer.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nsi</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>=</operator> <name><name>nsi</name><operator>-&gt;</operator><name>enotes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Update per-node accumulators. */</comment>
		<expr_stmt><expr><call><name>cdbexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ntuples</name></expr></argument>, <argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cdbexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nloops</name></expr></argument>, <argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>nloops</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cdbexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>execmemused</name></expr></argument>, <argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>execmemused</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cdbexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workmemused</name></expr></argument>, <argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>workmemused</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cdbexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workmemwanted</name></expr></argument>, <argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>workmemwanted</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cdbexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>totalWorkfileCreated</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>rsi</name><operator>-&gt;</operator><name>workfileCreated</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cdbexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>totalPartTableScanned</name></expr></argument>, <argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>numPartScanned</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>sortstats</name><operator>.</operator><name>sortMethod</name></name> <operator>&lt;</operator> <name>NUM_SORT_METHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>sortstats</name><operator>.</operator><name>spaceType</name></name> <operator>&lt;</operator> <name>NUM_SORT_SPACE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rsi</name><operator>-&gt;</operator><name>sortstats</name><operator>.</operator><name>sortMethod</name></name> <operator>!=</operator> <name>SORT_TYPE_STILL_IN_PROGRESS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>cdbexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sortSpaceUsed</name><index>[<expr><name><name>rsi</name><operator>-&gt;</operator><name>sortstats</name><operator>.</operator><name>spaceType</name></name></expr>]</index><index>[<expr><name><name>rsi</name><operator>-&gt;</operator><name>sortstats</name><operator>.</operator><name>sortMethod</name></name></expr>]</index></name></expr></argument>,
									  <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>rsi</name><operator>-&gt;</operator><name>sortstats</name><operator>.</operator><name>spaceUsed</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Update per-slice accumulators. */</comment>
		<expr_stmt><expr><call><name>cdbexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>peakmemused</name></expr></argument>, <argument><expr><name><name>rsh</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>peakmemused</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cdbexplain_depStatAcc_upd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vmem_reserved</name></expr></argument>, <argument><expr><name><name>rsh</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>vmem_reserved</name></name></expr></argument>, <argument><expr><name>rsh</name></expr></argument>, <argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Save per-node accumulated stats in NodeSummary. */</comment>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>agg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>execmemused</name></name> <operator>=</operator> <name><name>execmemused</name><operator>.</operator><name>agg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemused</name></name> <operator>=</operator> <name><name>workmemused</name><operator>.</operator><name>agg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemwanted</name></name> <operator>=</operator> <name><name>workmemwanted</name><operator>.</operator><name>agg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>totalWorkfileCreated</name></name> <operator>=</operator> <name><name>totalWorkfileCreated</name><operator>.</operator><name>agg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>totalPartTableScanned</name></name> <operator>=</operator> <name><name>totalPartTableScanned</name><operator>.</operator><name>agg</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_SORT_METHOD</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>NUM_SORT_SPACE_TYPE</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>sortSpaceUsed</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sortSpaceUsed</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>agg</name></expr>;</expr_stmt></block_content></block></for></block_content></block></for>

	<comment type="block">/* Roll up summary over all nodes of slice into RecvStatCtx. */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>workmemused_max</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>workmemused_max</name></name></expr></argument>, <argument><expr><name><name>workmemused</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name></expr></argument>, <argument><expr><name><name>workmemwanted</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>total</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>max_total</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_ASSIGN</name><argument_list>(<argument><expr><name><name>instr</name><operator>-&gt;</operator><name>firststart</name></name></expr></argument>, <argument><expr><name><name>ntuples</name><operator>.</operator><name>firststart_of_max_total</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Put winner's stats into qDisp PlanState's Instrument node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ntuples</name><operator>.</operator><name>agg</name><operator>.</operator><name>vcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>starttime</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>starttime</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>counter</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>counter</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>firsttuple</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>firsttuple</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>startup</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>startup</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>total</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>total</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>ntuples2</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>ntuples2</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>nloops</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>nloops</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>nfiltered1</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>nfiltered1</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>nfiltered2</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>nfiltered2</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>execmemused</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>execmemused</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>workmemused</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>workmemused</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>workmemwanted</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>workmemwanted</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>workfileCreated</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>workfileCreated</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>firststart</name></name> <operator>=</operator> <name><name>ntuples</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>firststart</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* Save non-zero nloops even when 0 tuple is returned */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>nloops</name><operator>.</operator><name>agg</name><operator>.</operator><name>vcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>nloops</name></name> <operator>=</operator> <name><name>nloops</name><operator>.</operator><name>nsimax</name><operator>-&gt;</operator><name>nloops</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Save extra message text for the most interesting winning qExecs. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>saved</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* One worker which used or wanted the most work_mem */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>workmemwanted</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name> <operator>&gt;=</operator> <name><name>workmemused</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>cdbexplain_depStatAcc_saveText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workmemwanted</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>workmemused</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name> <operator>&gt;</operator> <literal type="number">1.05</literal> <operator>*</operator> <call><name>cdbexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workmemused</name><operator>.</operator><name>agg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>cdbexplain_depStatAcc_saveText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workmemused</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Worker which used the most executor memory (this node's usage) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>execmemused</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name> <operator>&gt;</operator> <literal type="number">1.05</literal> <operator>*</operator> <call><name>cdbexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>execmemused</name><operator>.</operator><name>agg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>cdbexplain_depStatAcc_saveText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>execmemused</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * For the worker which had the highest peak executor memory usage
		 * overall across the whole slice, we'll report the extra message text
		 * from all of the nodes in the slice.  But only if that worker stands
		 * out more than 5% above the average.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>peakmemused</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name> <operator>&gt;</operator> <literal type="number">1.05</literal> <operator>*</operator> <call><name>cdbexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>peakmemused</name><operator>.</operator><name>agg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>cdbexplain_depStatAcc_saveText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>peakmemused</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * One worker which produced the greatest number of output rows.
		 * (Always give at least one node a chance to have its extra message
		 * text seen.  In case no node stood out above the others, make a
		 * repeatable choice based on the number of output rows.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>saved</name> <operator>||</operator>
			<name><name>ntuples</name><operator>.</operator><name>agg</name><operator>.</operator><name>vmax</name></name> <operator>&gt;</operator> <literal type="number">1.05</literal> <operator>*</operator> <call><name>cdbexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ntuples</name><operator>.</operator><name>agg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>cdbexplain_depStatAcc_saveText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ntuples</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this is a HashState, construct a SharedHashInfo with the stats from
	 * all the QEs. In PostgreSQL, SharedHashInfo is used to show stats of all
	 * the worker processes, we use it to show stats from all the QEs instead.
	 *
	 * GPDB_12_MERGE_FIXME: Should we do the same for Sort stats nowadays?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>HashState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* GPDB: Collect the results from all QE processes */</comment>
		<decl_stmt><decl><type><name>HashState</name> <modifier>*</modifier></type><name>hashstate</name> <init>= <expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SharedHashInfo</name> <modifier>*</modifier></type><name>shared_state</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>size_t</name></type>		<name>size</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>SharedHashInfo</name></expr></argument>, <argument><expr><name>hinstrument</name></expr></argument>)</argument_list></call> <operator>+</operator>
			<name><name>ctx</name><operator>-&gt;</operator><name>nmsgptr</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HashInstrumentation</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>shared_state</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared_state</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nmsgptr</name></name></expr>;</expr_stmt>

		<comment type="block">/* Examine the statistics from each qExec. */</comment>
		<for>for <control>(<init><expr><name>imsgptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>imsgptr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nmsgptr</name></name></expr>;</condition> <incr><expr><name>imsgptr</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Locate PlanState node's StatInst received from this qExec. */</comment>
			<expr_stmt><expr><name>rsh</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>msgptrs</name><index>[<expr><name>imsgptr</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rsi</name> <operator>=</operator> <operator>&amp;</operator><name><name>rsh</name><operator>-&gt;</operator><name>inst</name><index>[<expr><name><name>ctx</name><operator>-&gt;</operator><name>iStatInst</name></name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared_state</name><operator>-&gt;</operator><name>hinstrument</name><index>[<expr><name>imsgptr</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rsi</name><operator>-&gt;</operator><name>hashstats</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HashInstrumentation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>hashstate</name><operator>-&gt;</operator><name>shared_info</name></name> <operator>=</operator> <name>shared_state</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_depositStatsToNode */</comment>


<comment type="block">/*
 * cdbexplain_collectExtraText
 *	  Allow a node to supply additional text for its EXPLAIN ANALYZE report.
 *
 * Returns the starting offset of the extra message text from notebuf-&gt;data.
 * The caller can compute the length as notebuf-&gt;len minus the starting offset.
 * If the node did not provide any extra message text, the length will be 0.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cdbexplain_collectExtraText</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>notebuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bnotes</name> <init>= <expr><name><name>notebuf</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Invoke node's callback.  It may append to our notebuf and/or its own
	 * cdbexplainbuf; and store final statistics in its Instrumentation node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>cdbexplainfun</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>planstate</name><operator>-&gt;</operator><name>cdbexplainfun</name></name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>notebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Append contents of node's extra message buffer.  This allows nodes to
	 * contribute EXPLAIN ANALYZE info without having to set up a callback.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>cdbexplainbuf</name></name> <operator>&amp;&amp;</operator> <name><name>planstate</name><operator>-&gt;</operator><name>cdbexplainbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If callback added to notebuf, make sure text ends with a newline. */</comment>
		<if_stmt><if>if <condition>(<expr><name>bnotes</name> <operator>&lt;</operator> <name><name>notebuf</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator>
			<name><name>notebuf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>notebuf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>notebuf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>notebuf</name></expr></argument>, <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>cdbexplainbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							   <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>cdbexplainbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>cdbexplainbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>bnotes</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_collectExtraText */</comment>


<comment type="block">/*
 * cdbexplain_formatExtraText
 *	  Format extra message text into the EXPLAIN output buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbexplain_formatExtraText</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>indent</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>segindex</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>notes</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>notelen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name>notes</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><name>notes</name> <operator>+</operator> <name>notelen</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Could be more than one line... */</comment>
	<while>while <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name>ep</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nlp</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>ep</name> <operator>-</operator> <name>cp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><ternary><condition><expr><name>nlp</name></expr> ?</condition><then> <expr><name>nlp</name></expr> </then><else>: <expr><name>ep</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Strip trailing whitespace. */</comment>
		<while>while <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name>dp</name> <operator>&amp;&amp;</operator>
			   <call><name>isspace</name><argument_list>(<argument><expr><name><name>dp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dp</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/* Add to output buffer. */</comment>
		<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>&lt;</operator> <name>dp</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>indent</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>segindex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"(seg%d) "</literal></expr></argument>, <argument><expr><name>segindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>segindex</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>segindex</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>dp</name> <operator>-</operator> <name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nlp</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nlp</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>nlp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_formatExtraText */</comment>



<comment type="block">/*
 * cdbexplain_formatMemory
 *	  Convert memory size to string from (double) bytes.
 *
 *		outbuf:  [output] pointer to a char buffer to be filled
 *		bufsize: [input] maximum number of characters to write to outbuf (must be set by the caller)
 *		bytes:	 [input] a value representing memory size in bytes to be written to outbuf
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbexplain_formatMemory</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>outbuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsize</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>bytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outbuf</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"CDBEXPLAIN: char buffer is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"CDBEXPLAIN: size of char buffer is zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* check if truncation occurs */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type>			<name>nchars_written</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_ASSERT_CHECKING */</comment>
	<expr><call><name>snprintf</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><literal type="string">"%.0fK bytes"</literal></expr></argument>, <argument><expr><call><name>kb</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nchars_written</name> <operator>&lt;</operator> <name>bufsize</name> <operator>&amp;&amp;</operator>
		   <literal type="string">"CDBEXPLAIN:  size of char buffer is smaller than the required number of chars"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_formatMemory */</comment>



<comment type="block">/*
 * cdbexplain_formatSeconds
 *	  Convert time in seconds to readable string
 *
 *		outbuf:  [output] pointer to a char buffer to be filled
 *		bufsize: [input] maximum number of characters to write to outbuf (must be set by the caller)
 *		seconds: [input] a value representing no. of seconds to be written to outbuf
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbexplain_formatSeconds</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>outbuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsize</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>seconds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>unit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outbuf</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"CDBEXPLAIN: char buffer is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"CDBEXPLAIN: size of char buffer is zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>ms</name> <init>= <expr><name>seconds</name> <operator>*</operator> <literal type="number">1000.0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check if truncation occurs */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type>			<name>nchars_written</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_ASSERT_CHECKING */</comment>
	<expr><call><name>snprintf</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><literal type="string">"%.*f%s"</literal></expr></argument>,
			 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>ms</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">10.0</literal> <operator>&amp;&amp;</operator> <name>ms</name> <operator>!=</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator> <name>ms</name></expr></argument> &gt;</argument_list></name> <operator>-</operator><literal type="number">10.0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
			 <argument><expr><name>ms</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>unit</name></expr> ?</condition><then> <expr><literal type="string">" ms"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nchars_written</name> <operator>&lt;</operator> <name>bufsize</name> <operator>&amp;&amp;</operator>
		   <literal type="string">"CDBEXPLAIN:  size of char buffer is smaller than the required number of chars"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_formatSeconds */</comment>


<comment type="block">/*
 * cdbexplain_formatSeg
 *	  Convert segment id to string.
 *
 *		outbuf:  [output] pointer to a char buffer to be filled
 *		bufsize: [input] maximum number of characters to write to outbuf (must be set by the caller)
 *		segindex:[input] a value representing segment index to be written to outbuf
 *		nInst:	 [input] no. of stat instances
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbexplain_formatSeg</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>outbuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segindex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nInst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>outbuf</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"CDBEXPLAIN: char buffer is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufsize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"CDBEXPLAIN: size of char buffer is zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nInst</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>segindex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check if truncation occurs */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<decl_stmt><decl><type><name>int</name></type>			<name>nchars_written</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_ASSERT_CHECKING */</comment>
		<expr><call><name>snprintf</name><argument_list>(<argument><expr><name>outbuf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><literal type="string">" (seg%d)"</literal></expr></argument>, <argument><expr><name>segindex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nchars_written</name> <operator>&lt;</operator> <name>bufsize</name> <operator>&amp;&amp;</operator>
			   <literal type="string">"CDBEXPLAIN:  size of char buffer is smaller than the required number of chars"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>outbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_formatSeg */</comment>


<comment type="block">/*
 * cdbexplain_showExecStatsBegin
 *	  Called by qDisp process to create a CdbExplain_ShowStatCtx structure
 *	  in which to accumulate overall statistics for a query.
 *
 * 'querystarttime' is the timestamp of the start of the query, in a
 *		platform-dependent format.
 *
 * Note this function is called before ExecutorStart(), so there is no EState
 * or SliceTable yet.
 */</comment>
<function><type><name><name>struct</name> <name>CdbExplain_ShowStatCtx</name></name> <modifier>*</modifier></type>
<name>cdbexplain_showExecStatsBegin</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>QueryDesc</name></name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
							  <parameter><decl><type><name>instr_time</name></type> <name>querystarttime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbExplain_ShowStatCtx</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nslice</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate and zero the ShowStatCtx */</comment>
	<expr_stmt><expr><name>ctx</name> <operator>=</operator> <operator>(</operator><name>CdbExplain_ShowStatCtx</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>querystarttime</name></name> <operator>=</operator> <name>querystarttime</name></expr>;</expr_stmt>

	<comment type="block">/* Determine number of slices.  (SliceTable hasn't been built yet.) */</comment>
	<expr_stmt><expr><name>nslice</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</expr_stmt>

	<comment type="block">/* Allocate and zero the SliceSummary array. */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>nslice</name></name> <operator>=</operator> <name>nslice</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <operator>(</operator><name>CdbExplain_SliceSummary</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nslice</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate a buffer in which we can collect any extra message text. */</comment>
	<expr_stmt><expr><call><name>initStringInfoOfSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name></name></expr></argument>, <argument><expr><literal type="number">4000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ctx</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_showExecStatsBegin */</comment>

<comment type="block">/*
 * nodeSupportWorkfileCaching
 *	 Return true if a given node supports workfile caching.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>nodeSupportWorkfileCaching</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>SortState</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>HashJoinState</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>(</operator><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>aggstrategy</name> <operator>==</operator> <name>AGG_HASHED</name><operator>)</operator> <operator>||</operator>
			<call><name>IsA</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>, <argument><expr><name>MaterialState</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbexplain_showExecStats
 *	  Called by qDisp process to format a node's EXPLAIN ANALYZE statistics.
 *
 * 'planstate' is the node whose statistics are to be displayed.
 * 'str' is the output buffer.
 * 'indent' is the root indentation for all the text generated for explain output
 * 'ctx' is a CdbExplain_ShowStatCtx object which was created by a call to
 *		cdbexplain_showExecStatsBegin().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbexplain_showExecStats</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlanState</name></name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>CdbExplain_ShowStatCtx</name></name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>es</name><operator>-&gt;</operator><name>showstatctx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>instrument</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbExplain_NodeSummary</name> <modifier>*</modifier></type><name>ns</name> <init>= <expr><name><name>instr</name><operator>-&gt;</operator><name>cdbNodeSummary</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>timediff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type>		<name><name>totalbuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>avgbuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>maxbuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>segbuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>startbuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Might not have received stats from qExecs if they hit errors. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ns</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>instr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Executor memory used by this individual node, if it allocates from a
	 * memory context of its own instead of sharing the per-query context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <name><name>ns</name><operator>-&gt;</operator><name>execmemused</name><operator>.</operator><name>vcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Executor Memory: %ldkB  Segments: %d  Max: %ldkB (segment %d)\n"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>kb</name><argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>execmemused</name><operator>.</operator><name>vsum</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>execmemused</name><operator>.</operator><name>vcnt</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>kb</name><argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>execmemused</name><operator>.</operator><name>vmax</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>execmemused</name><operator>.</operator><name>imax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Executor Memory"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><call><name>kb</name><argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>execmemused</name><operator>.</operator><name>vsum</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Executor Memory Segments"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>execmemused</name><operator>.</operator><name>vcnt</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Executor Max Memory"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><call><name>kb</name><argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>execmemused</name><operator>.</operator><name>vmax</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Executor Max Memory Segment"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>execmemused</name><operator>.</operator><name>imax</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Actual work_mem used and wanted
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>verbose</name></name> <operator>&amp;&amp;</operator> <name><name>ns</name><operator>-&gt;</operator><name>workmemused</name><operator>.</operator><name>vcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"work_mem: %ldkB  Segments: %d  Max: %ldkB (segment %d)"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>kb</name><argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemused</name><operator>.</operator><name>vsum</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemused</name><operator>.</operator><name>vcnt</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>kb</name><argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemused</name><operator>.</operator><name>vmax</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemused</name><operator>.</operator><name>imax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Total number of segments in which this node reuses cached or
			 * creates workfiles.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>nodeSupportWorkfileCaching</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"  Workfile: (%d spilling)"</literal></expr></argument>,
								 <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>totalWorkfileCreated</name><operator>.</operator><name>vcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ns</name><operator>-&gt;</operator><name>workmemwanted</name><operator>.</operator><name>vcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>cdbexplain_formatMemory</name><argument_list>(<argument><expr><name>maxbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>maxbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemwanted</name><operator>.</operator><name>vmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ns</name><operator>-&gt;</operator><name>ninst</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
								 <argument><expr><literal type="string">"Work_mem wanted: %s to lessen workfile I/O."</literal></expr></argument>,
								 <argument><expr><name>maxbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>cdbexplain_formatMemory</name><argument_list>(<argument><expr><name>avgbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>avgbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>cdbexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ns</name><operator>-&gt;</operator><name>workmemwanted</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>cdbexplain_formatSeg</name><argument_list>(<argument><expr><name>segbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>segbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemwanted</name><operator>.</operator><name>imax</name></name></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>ninst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
									 <argument><expr><literal type="string">"Work_mem wanted: %s avg, %s max%s"</literal>
									 <literal type="string">" to lessen workfile I/O affecting %d workers."</literal></expr></argument>,
									 <argument><expr><name>avgbuf</name></expr></argument>, <argument><expr><name>maxbuf</name></expr></argument>, <argument><expr><name>segbuf</name></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemwanted</name><operator>.</operator><name>vcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"work_mem"</literal></expr></argument>, <argument><expr><literal type="string">"work_mem"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Used"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><call><name>kb</name><argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemused</name><operator>.</operator><name>vsum</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Segments"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemused</name><operator>.</operator><name>vcnt</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Max Memory"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><call><name>kb</name><argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemused</name><operator>.</operator><name>vmax</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Max Memory Segment"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemused</name><operator>.</operator><name>imax</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Total number of segments in which this node reuses cached or
			 * creates workfiles.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>nodeSupportWorkfileCaching</name><argument_list>(<argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Workfile Spilling"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>totalWorkfileCreated</name><operator>.</operator><name>vcnt</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ns</name><operator>-&gt;</operator><name>workmemwanted</name><operator>.</operator><name>vcnt</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Max Memory Wanted"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><call><name>kb</name><argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemwanted</name><operator>.</operator><name>vmax</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>ns</name><operator>-&gt;</operator><name>ninst</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Max Memory Wanted Segment"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>workmemwanted</name><operator>.</operator><name>imax</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Avg Memory Wanted"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><call><name>kb</name><argument_list>(<argument><expr><call><name>cdbexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ns</name><operator>-&gt;</operator><name>workmemwanted</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Segments Affected"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>ninst</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"work_mem"</literal></expr></argument>, <argument><expr><literal type="string">"work_mem"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Print number of partitioned tables scanned for dynamic scans.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name><name>ns</name><operator>-&gt;</operator><name>totalPartTableScanned</name><operator>.</operator><name>vcnt</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>T_DynamicSeqScanState</name> <operator>==</operator> <name><name>planstate</name><operator>-&gt;</operator><name>type</name></name>
												<operator>||</operator> <name>T_DynamicIndexScanState</name> <operator>==</operator> <name><name>planstate</name><operator>-&gt;</operator><name>type</name></name>
												<operator>||</operator> <name>T_DynamicBitmapHeapScanState</name> <operator>==</operator> <name><name>planstate</name><operator>-&gt;</operator><name>type</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * FIXME: Only displayed in TEXT format
		 * [#159443692]
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>nPartTableScanned_avg</name> <init>= <expr><call><name>cdbexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ns</name><operator>-&gt;</operator><name>totalPartTableScanned</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>nPartTableScanned_avg</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>T_DynamicBitmapHeapScanState</name> <operator>==</operator> <name><name>planstate</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
									 <argument><expr><literal type="string">"Partitions scanned:  0 .\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>cdbexplain_formatSeg</name><argument_list>(<argument><expr><name>segbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>segbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>totalPartTableScanned</name><operator>.</operator><name>imax</name></name></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>ninst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* only 1 segment scans partitions */</comment>
				<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <name><name>ns</name><operator>-&gt;</operator><name>totalPartTableScanned</name><operator>.</operator><name>vcnt</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* rescan */</comment>
					<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name><name>instr</name><operator>-&gt;</operator><name>nloops</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>double</name></type>		<name>totalPartTableScannedPerRescan</name> <init>= <expr><name><name>ns</name><operator>-&gt;</operator><name>totalPartTableScanned</name><operator>.</operator><name>vmax</name></name> <operator>/</operator> <name><name>instr</name><operator>-&gt;</operator><name>nloops</name></name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
										 <argument><expr><literal type="string">"Partitions scanned:  %.0f %s of %ld scans.\n"</literal></expr></argument>,
										 <argument><expr><name>totalPartTableScannedPerRescan</name></expr></argument>,
										 <argument><expr><name>segbuf</name></expr></argument>,
										 <argument><expr><name><name>instr</name><operator>-&gt;</operator><name>nloops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
										 <argument><expr><literal type="string">"Partitions scanned:  %.0f %s.\n"</literal></expr></argument>,
										 <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>totalPartTableScanned</name><operator>.</operator><name>vmax</name></name></expr></argument>,
										 <argument><expr><name>segbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* rescan */</comment>
					<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name><name>instr</name><operator>-&gt;</operator><name>nloops</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>double</name></type>		<name>totalPartTableScannedPerRescan</name> <init>= <expr><name>nPartTableScanned_avg</name> <operator>/</operator> <name><name>instr</name><operator>-&gt;</operator><name>nloops</name></name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>double</name></type>		<name>maxPartTableScannedPerRescan</name> <init>= <expr><name><name>ns</name><operator>-&gt;</operator><name>totalPartTableScanned</name><operator>.</operator><name>vmax</name></name> <operator>/</operator> <name><name>instr</name><operator>-&gt;</operator><name>nloops</name></name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
										 <argument><expr><literal type="string">"Partitions scanned:  Avg %.1f x %d workers of %ld scans."</literal>
										 <literal type="string">"  Max %.0f parts%s.\n"</literal></expr></argument>,
										 <argument><expr><name>totalPartTableScannedPerRescan</name></expr></argument>,
										 <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>totalPartTableScanned</name><operator>.</operator><name>vcnt</name></name></expr></argument>,
										 <argument><expr><name><name>instr</name><operator>-&gt;</operator><name>nloops</name></name></expr></argument>,
										 <argument><expr><name>maxPartTableScannedPerRescan</name></expr></argument>,
										 <argument><expr><name>segbuf</name></expr></argument>
							)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
										 <argument><expr><literal type="string">"Partitions scanned:  Avg %.1f x %d workers."</literal>
										 <literal type="string">"  Max %.0f parts%s.\n"</literal></expr></argument>,
										 <argument><expr><name>nPartTableScanned_avg</name></expr></argument>,
										 <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>totalPartTableScanned</name><operator>.</operator><name>vcnt</name></name></expr></argument>,
										 <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>totalPartTableScanned</name><operator>.</operator><name>vmax</name></name></expr></argument>,
										 <argument><expr><name>segbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> 			<name>haveExtraText</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>extraData</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extraData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ns</name><operator>-&gt;</operator><name>ninst</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbExplain_StatInst</name> <modifier>*</modifier></type><name>nsi</name> <init>= <expr><operator>&amp;</operator><name><name>ns</name><operator>-&gt;</operator><name>insts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>nsi</name><operator>-&gt;</operator><name>bnotes</name></name> <operator>&lt;</operator> <name><name>nsi</name><operator>-&gt;</operator><name>enotes</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>haveExtraText</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Extra Text"</literal></expr></argument>, <argument><expr><literal type="string">"Extra Text"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Segment"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>haveExtraText</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			
			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extraData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>cdbexplain_formatExtraText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extraData</name></expr></argument>,
									   <argument><expr><literal type="number">0</literal></expr></argument>,
									   <argument><expr><ternary><condition><expr><operator>(</operator><name><name>ns</name><operator>-&gt;</operator><name>ninst</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr>
									   </then><else>: <expr><name><name>ns</name><operator>-&gt;</operator><name>segindex0</name></name> <operator>+</operator> <name>i</name></expr></else></ternary></expr></argument>,
									   <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>extratextbuf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>nsi</name><operator>-&gt;</operator><name>bnotes</name></name></expr></argument>,
									   <argument><expr><name><name>nsi</name><operator>-&gt;</operator><name>enotes</name></name> <operator>-</operator> <name><name>nsi</name><operator>-&gt;</operator><name>bnotes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExplainPropertyStringInfo</name><argument_list>(<argument><expr><literal type="string">"Extra Text"</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>extraData</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>haveExtraText</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Segment"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Extra Text"</literal></expr></argument>, <argument><expr><literal type="string">"Extra Text"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>extraData</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Dump stats for all workers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>gp_enable_explain_allstat</name> <operator>&amp;&amp;</operator> <name><name>ns</name><operator>-&gt;</operator><name>segindex0</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ns</name><operator>-&gt;</operator><name>ninst</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * create a header for all stats: separate each individual stat by an
			 * underscore, separate the grouped stats for each node by a slash
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
								   <argument><expr><literal type="string">"allstat: seg_firststart_total_ntuples"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Allstat"</literal></expr></argument>, <argument><expr><literal type="string">"Allstat"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ns</name><operator>-&gt;</operator><name>ninst</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CdbExplain_StatInst</name> <modifier>*</modifier></type><name>nsi</name> <init>= <expr><operator>&amp;</operator><name><name>ns</name><operator>-&gt;</operator><name>insts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name><name>nsi</name><operator>-&gt;</operator><name>firststart</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Time from start of query on qDisp to worker's first result row */</comment>
			<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>timediff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INSTR_TIME_ACCUM_DIFF</name><argument_list>(<argument><expr><name>timediff</name></expr></argument>, <argument><expr><name><name>nsi</name><operator>-&gt;</operator><name>firststart</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>querystarttime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>cdbexplain_formatSeconds</name><argument_list>(<argument><expr><name>startbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>startbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										 <argument><expr><call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>timediff</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>cdbexplain_formatSeconds</name><argument_list>(<argument><expr><name>totalbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>totalbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										 <argument><expr><name><name>nsi</name><operator>-&gt;</operator><name>total</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
								 <argument><expr><literal type="string">"/seg%d_%s_%s_%.0f"</literal></expr></argument>,
								 <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>segindex0</name></name> <operator>+</operator> <name>i</name></expr></argument>,
								 <argument><expr><name>startbuf</name></expr></argument>,
								 <argument><expr><name>totalbuf</name></expr></argument>,
								 <argument><expr><name><name>nsi</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>cdbexplain_formatSeconds</name><argument_list>(<argument><expr><name>startbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>startbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										 <argument><expr><call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>timediff</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>cdbexplain_formatSeconds</name><argument_list>(<argument><expr><name>totalbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>totalbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										 <argument><expr><name><name>nsi</name><operator>-&gt;</operator><name>total</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Segment"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Segment index"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>segindex0</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Time To First Result"</literal></expr></argument>, <argument><expr><name>startbuf</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Time To Total Result"</literal></expr></argument>, <argument><expr><name>totalbuf</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Tuples"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>nsi</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Segment"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"//end\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Allstat"</literal></expr></argument>, <argument><expr><literal type="string">"Allstat"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_showExecStats */</comment>

<comment type="block">/*
 *	ExplainPrintExecStatsEnd
 *			External API wrapper for cdbexplain_showExecStatsEnd
 *
 * This is an externally exposed wrapper for cdbexplain_showExecStatsEnd such
 * that extensions, such as auto_explain, can leverage the Greenplum specific
 * parts of the EXPLAIN machinery.
 */</comment>
<function><type><name>void</name></type>
<name>ExplainPrintExecStatsEnd</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>cdbexplain_showExecStatsEnd</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>,
								<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>showstatctx</name></name></expr></argument>,
								<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cdbexplain_showExecStatsEnd
 *	  Called by qDisp process to format the overall statistics for a query
 *	  into the caller's buffer.
 *
 * 'ctx' is the CdbExplain_ShowStatCtx object which was created by a call to
 *		cdbexplain_showExecStatsBegin() and contains statistics which have
 *		been accumulated over a series of calls to cdbexplain_showExecStats().
 *		Invalid on return (it is freed).
 *
 * This doesn't free the CdbExplain_ShowStatCtx object or buffers, because
 * they will be free'd shortly by the end of statement anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbexplain_showExecStatsEnd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannedStmt</name></name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
							<parameter><decl><type><name><name>struct</name> <name>CdbExplain_ShowStatCtx</name></name> <modifier>*</modifier></type><name>showstatctx</name></decl></parameter>,
							<parameter><decl><type><name><name>struct</name> <name>EState</name></name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
							<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>es</name><operator>-&gt;</operator><name>summary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>gpexplain_formatSlicesOutput</name><argument_list>(<argument><expr><name>showstatctx</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResManagerMemoryPolicyNone</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Statement statistics"</literal></expr></argument>, <argument><expr><literal type="string">"Statement statistics"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Memory used:  %ldkB\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>kb</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query_mem</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Memory used"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><call><name>kb</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>query_mem</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>showstatctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>long</name></type> <name>mem_wanted</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>mem_wanted</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <call><name>PolicyAutoStatementMemForNoSpill</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
							<argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name><name>showstatctx</name><operator>-&gt;</operator><name>workmemwanted_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Round up to a kilobyte in case we end up requiring less than
			 * that.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>mem_wanted</name> <operator>&lt;=</operator> <literal type="number">1024L</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>mem_wanted</name> <operator>=</operator> <literal type="number">1L</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>mem_wanted</name> <operator>=</operator> <name>mem_wanted</name> <operator>/</operator> <literal type="number">1024L</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Memory wanted:  %ldkB\n"</literal></expr></argument>, <argument><expr><name>mem_wanted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Memory wanted"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><name>mem_wanted</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Statement statistics"</literal></expr></argument>, <argument><expr><literal type="string">"Statement statistics"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbexplain_showExecStatsEnd */</comment>

<comment type="block">/*
 * Given a statistics context search for all the slice statistics
 * and format them to the correct layout
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gpexplain_formatSlicesOutput</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbExplain_ShowStatCtx</name></name> <modifier>*</modifier></type><name>showstatctx</name></decl></parameter>,
                             <parameter><decl><type><name><name>struct</name> <name>EState</name></name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                             <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>slice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sliceIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_memory_across_slices</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type>		<name><name>avgbuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>maxbuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>segbuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>showstatctx</name><operator>-&gt;</operator><name>nslice</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Slice statistics"</literal></expr></argument>, <argument><expr><literal type="string">"Slice statistics"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>sliceIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>sliceIndex</name> <operator>&lt;</operator> <name><name>showstatctx</name><operator>-&gt;</operator><name>nslice</name></name></expr>;</condition> <incr><expr><name>sliceIndex</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CdbExplain_SliceSummary</name> <modifier>*</modifier></type><name>ss</name> <init>= <expr><operator>&amp;</operator><name><name>showstatctx</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CdbExplain_DispatchSummary</name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>dispatchSummary</name></name></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>flag</name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
        <block>{<block_content>

            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"  (slice%d) "</literal></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>sliceIndex</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else 
        <block>{<block_content>
            <expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Slice"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Slice"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Worker counts */</comment>
        <expr_stmt><expr><name>slice</name> <operator>=</operator> <call><name>getCurrentSlice</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>slice</name> <operator>&amp;&amp;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>ss</name><operator>-&gt;</operator><name>dispatchSummary</name><operator>.</operator><name>nOk</name></name></expr>)</condition>
        <block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nNotDispatched</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>workersInformationText</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>nNotDispatched</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>ds</name><operator>-&gt;</operator><name>nResult</name></name> <operator>+</operator> <name><name>ds</name><operator>-&gt;</operator><name>nNotDispatched</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>flag</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>ss</name><operator>-&gt;</operator><name>dispatchSummary</name><operator>.</operator><name>nError</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'X'</literal></expr> </then><else>: <expr><literal type="char">'_'</literal></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workersInformationText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workersInformationText</name></expr></argument>, <argument><expr><literal type="string">"Workers:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>nError</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workersInformationText</name></expr></argument>,
                                     <argument><expr><literal type="string">" %d error;"</literal></expr></argument>,
                                     <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>nError</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>nError</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workersInformationText</name></expr></argument>,
                                     <argument><expr><literal type="string">" %d errors;"</literal></expr></argument>,
                                     <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>nError</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Workers"</literal></expr></argument>, <argument><expr><literal type="string">"Workers"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>nError</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Errors"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>nError</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>nCanceled</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workersInformationText</name></expr></argument>,
                                     <argument><expr><literal type="string">" %d canceled;"</literal></expr></argument>,
                                     <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>nCanceled</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Canceled"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>nCanceled</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>nNotDispatched</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workersInformationText</name></expr></argument>,
                                     <argument><expr><literal type="string">" %d not dispatched;"</literal></expr></argument>,
                                     <argument><expr><name>nNotDispatched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Not Dispatched"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nNotDispatched</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>nIgnorableError</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workersInformationText</name></expr></argument>,
                                     <argument><expr><literal type="string">" %d aborted;"</literal></expr></argument>,
                                     <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>nIgnorableError</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Aborted"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>nIgnorableError</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>nOk</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>workersInformationText</name></expr></argument>,
                                     <argument><expr><literal type="string">" %d ok;"</literal></expr></argument>,
                                     <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>nOk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Ok"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>nOk</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>workersInformationText</name><operator>.</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExplainPropertyStringInfo</name><argument_list>(<argument><expr><literal type="string">"Workers"</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><literal type="string">"%s.  "</literal></expr></argument>, <argument><expr><name><name>workersInformationText</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Workers"</literal></expr></argument>, <argument><expr><literal type="string">"Workers"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Executor memory high-water mark */</comment>
        <expr_stmt><expr><call><name>cdbexplain_formatMemory</name><argument_list>(<argument><expr><name>maxbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>maxbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name><operator>.</operator><name>vmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name><operator>.</operator><name>vcnt</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>seg</name> <init>= <expr><name>segbuf</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name><operator>.</operator><name>imax</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>cdbexplain_formatSeg</name><argument_list>(<argument><expr><name>segbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>segbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name><operator>.</operator><name>imax</name></name></expr></argument>, <argument><expr><literal type="number">999</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>slice</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>seg</name> <operator>=</operator> <literal type="string">" (entry db)"</literal></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>seg</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
                                 <argument><expr><literal type="string">"Executor memory: %s%s."</literal></expr></argument>,
                                 <argument><expr><name>maxbuf</name></expr></argument>,
                                 <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Executor Memory"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name><operator>.</operator><name>vmax</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name><operator>.</operator><name>vcnt</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>cdbexplain_formatMemory</name><argument_list>(<argument><expr><name>avgbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>avgbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>cdbexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>cdbexplain_formatSeg</name><argument_list>(<argument><expr><name>segbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>segbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name><operator>.</operator><name>imax</name></name></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>nworker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
                                 <argument><expr><literal type="string">"Executor memory: %s avg x %d workers, %s max%s."</literal></expr></argument>,
                                 <argument><expr><name>avgbuf</name></expr></argument>,
                                 <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name><operator>.</operator><name>vcnt</name></name></expr></argument>,
                                 <argument><expr><name>maxbuf</name></expr></argument>,
                                 <argument><expr><name>segbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Executor Memory"</literal></expr></argument>, <argument><expr><literal type="string">"Executor Memory"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Average"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><call><name>cdbexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Workers"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name><operator>.</operator><name>vcnt</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Maximum Memory Used"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>peakmemused</name><operator>.</operator><name>vmax</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Executor Memory"</literal></expr></argument>, <argument><expr><literal type="string">"Executor Memory"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>EXPLAIN_MEMORY_VERBOSITY_SUPPRESS</name> <operator>&lt;</operator> <name>explain_memory_verbosity</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Vmem reserved by QEs */</comment>
            <expr_stmt><expr><call><name>cdbexplain_formatMemory</name><argument_list>(<argument><expr><name>maxbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>maxbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name><operator>.</operator><name>vmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name><operator>.</operator><name>vcnt</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>

                <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>seg</name> <init>= <expr><name>segbuf</name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name><operator>.</operator><name>imax</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>cdbexplain_formatSeg</name><argument_list>(<argument><expr><name>segbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>segbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name><operator>.</operator><name>imax</name></name></expr></argument>, <argument><expr><literal type="number">999</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>slice</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>seg</name> <operator>=</operator> <literal type="string">" (entry db)"</literal></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>seg</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
                                     <argument><expr><literal type="string">"  Vmem reserved: %s%s."</literal></expr></argument>,
                                     <argument><expr><name>maxbuf</name></expr></argument>,
                                     <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Virtual Memory"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name><operator>.</operator><name>vmax</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name><operator>.</operator><name>vcnt</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>cdbexplain_formatMemory</name><argument_list>(<argument><expr><name>avgbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>avgbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>cdbexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>cdbexplain_formatSeg</name><argument_list>(<argument><expr><name>segbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>segbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name><operator>.</operator><name>imax</name></name></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>nworker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>,
                                     <argument><expr><literal type="string">"  Vmem reserved: %s avg x %d workers, %s max%s."</literal></expr></argument>,
                                     <argument><expr><name>avgbuf</name></expr></argument>,
                                     <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name><operator>.</operator><name>vcnt</name></name></expr></argument>,
                                     <argument><expr><name>maxbuf</name></expr></argument>,
                                     <argument><expr><name>segbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Virtual Memory"</literal></expr></argument>, <argument><expr><literal type="string">"Virtual Memory"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Average"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><call><name>cdbexplain_agg_avg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Workers"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name><operator>.</operator><name>vcnt</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Maximum Memory Used"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>vmem_reserved</name><operator>.</operator><name>vmax</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Virtual Memory"</literal></expr></argument>, <argument><expr><literal type="string">"Virtual Memory"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Work_mem used/wanted (max over all nodes and workers of slice) */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>ss</name><operator>-&gt;</operator><name>workmemused_max</name></name> <operator>+</operator> <name><name>ss</name><operator>-&gt;</operator><name>workmemwanted_max</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>cdbexplain_formatMemory</name><argument_list>(<argument><expr><name>maxbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>maxbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>workmemused_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"  Work_mem: %s max"</literal></expr></argument>, <argument><expr><name>maxbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>ss</name><operator>-&gt;</operator><name>workmemwanted_max</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>flag</name></expr>]</index></name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>	<comment type="block">/* draw attention to this slice */</comment>
                    <expr_stmt><expr><call><name>cdbexplain_formatMemory</name><argument_list>(<argument><expr><name>maxbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>maxbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>workmemwanted_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">", %s wanted"</literal></expr></argument>, <argument><expr><name>maxbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Work Maximum Memory"</literal></expr></argument>, <argument><expr><literal type="string">"kB"</literal></expr></argument>, <argument><expr><name><name>ss</name><operator>-&gt;</operator><name>workmemused_max</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Slice"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>showstatctx</name><operator>-&gt;</operator><name>nslice</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Slice statistics"</literal></expr></argument>, <argument><expr><literal type="string">"Slice statistics"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>total_memory_across_slices</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"Total memory used across slices: %.0fK bytes \n"</literal></expr></argument>, <argument><expr><name>total_memory_across_slices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Total memory used across slices"</literal></expr></argument>, <argument><expr><literal type="string">"bytes"</literal></expr></argument>, <argument><expr><name>total_memory_across_slices</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show the hash and merge keys for a Motion node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_motion_keys</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashExpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>keycols</name></decl></parameter>,
			     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exprstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useprefix</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nkeys</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hashExpr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Set up deparse context */</comment>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>set_deparse_context_planstate</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>deparse_cxt</name></name></expr></argument>,
											<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>,
											<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Merge Receive ordering key */</comment>
    <for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
	    <comment type="block">/* find key expression in tlist */</comment>
	    <decl_stmt><decl><type><name>AttrNumber</name></type>	<name>keyresno</name> <init>= <expr><name><name>keycols</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>keyresno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <comment type="block">/* Deparse the expression, showing any top-level cast */</comment>
	    <if_stmt><if>if <condition>(<expr><name>target</name></expr>)</condition><block type="pseudo"><block_content>
	        <expr_stmt><expr><name>exprstr</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
								         <argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Gather Motion %s error: no tlist item %d"</literal></expr></argument>,
                 <argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>keyresno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>exprstr</name> <operator>=</operator> <literal type="string">"*BOGUS*"</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>exprstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPropertyList</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Hashed repartitioning key */</comment>
    <if_stmt><if>if <condition>(<expr><name>hashExpr</name></expr>)</condition>
    <block>{<block_content>
	    <comment type="block">/* Deparse the expression */</comment>
	    <expr_stmt><expr><name>exprstr</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>hashExpr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>useprefix</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Hash Key"</literal></expr></argument>, <argument><expr><name>exprstr</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Explain a parallel retrieve cursor,
 * indicate the endpoints exist on entry DB, or on some segments,
 * or on all segments.
 */</comment>
<function><type><name>void</name></type> <name>ExplainParallelRetrieveCursor</name><parameter_list>(<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>QueryDesc</name><modifier>*</modifier></type> <name>queryDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name> <init>= <expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>            <name>endpointInfoStr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>enum</name> <name>EndPointExecPosition</name></name></type> <name>endPointExecPosition</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>endpointInfoStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>endPointExecPosition</name> <operator>=</operator> <call><name>GetParallelCursorEndpointPosition</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Cursor"</literal></expr></argument>, <argument><expr><literal type="string">"Cursor"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch<condition>(<expr><name>endPointExecPosition</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ENDPOINT_ON_ENTRY_DB</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>endpointInfoStr</name></expr></argument>, <argument><expr><literal type="string">"\"on coordinator\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>ENDPOINT_ON_SINGLE_QE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(
							 <argument><expr><operator>&amp;</operator><name>endpointInfoStr</name></expr></argument>, <argument><expr><literal type="string">"\"on segment: contentid [%d]\""</literal></expr></argument>,
							 <argument><expr><name>gp_session_id</name> <operator>%</operator> <name><name>plan</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>flow</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>ENDPOINT_ON_SOME_QE</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type> <name>cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>isFirst</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>endpointInfoStr</name></expr></argument>, <argument><expr><literal type="string">"on segments: contentid ["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>slice</name> <init>= <expr><operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>slice-&gt;segments</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>contentid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>endpointInfoStr</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>isFirst</name><operator>)</operator></expr>?</condition><then><expr><literal type="string">"%d"</literal></expr></then><else>:<expr><literal type="string">", %d"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>contentid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>isFirst</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>endpointInfoStr</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>ENDPOINT_ON_ALL_QE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>endpointInfoStr</name></expr></argument>, <argument><expr><literal type="string">"on all %d segments"</literal></expr></argument>, <argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid endpoint position : %d"</literal></expr></argument>, <argument><expr><name>endPointExecPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Endpoint"</literal></expr></argument>, <argument><expr><name><name>endpointInfoStr</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Cursor"</literal></expr></argument>, <argument><expr><literal type="string">"Cursor"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
