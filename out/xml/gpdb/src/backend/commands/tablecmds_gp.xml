<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/commands/tablecmds_gp.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tablecmds_gp.c
 *	  Greenplum extensions for ALTER TABLE.
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/commands/tablecmds_gp.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_partition_template.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute_encoding.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_partitioned_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/memquota.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execPartition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autostats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Build a datum according to tables partition key based on parse expr. Would
 * have been nice if FormPartitionKeyDatum() was generic and could have been
 * used instead.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FormPartitionKeyDatumFromExpr</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>partkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>num_expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partkey</name> <operator>=</operator> <call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>partkey</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_expr</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_expr</name> <operator>&gt;</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many columns in boundary specification (%d &gt; %d)"</literal></expr></argument>,
						<argument><expr><name>num_expr</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_expr</name> <operator>&gt;</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many columns in boundary specification (%d &gt; %d)"</literal></expr></argument>,
						<argument><expr><name>num_expr</name></expr></argument>, <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>(List *) expr</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>      <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>coltype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>coltypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>partcollation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Get column's name in case we need to output an error */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>partkey</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>deparse_context_for</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
															 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>coltype</name> <operator>=</operator> <call><name>get_partition_col_typid</name><argument_list>(<argument><expr><name>partkey</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>coltypmod</name> <operator>=</operator> <call><name>get_partition_col_typmod</name><argument_list>(<argument><expr><name>partkey</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partcollation</name> <operator>=</operator> <call><name>get_partition_col_collation</name><argument_list>(<argument><expr><name>partkey</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformPartitionBoundValue</name><argument_list>(<argument><expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n1</name></expr></argument>,
											  <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>coltype</name></expr></argument>, <argument><expr><name>coltypmod</name></expr></argument>,
											  <argument><expr><name>partcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>GpFindTargetPartition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>GpAlterPartitionId</name> <modifier>*</modifier></type><name>partid</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>target_relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>partid</name><operator>-&gt;</operator><name>idtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AT_AP_IDDefault</name></expr>:</case>
			<comment type="block">/* Find default partition */</comment>
			<expr_stmt><expr><name>target_relid</name> <operator>=</operator>
				<call><name>get_default_oid_from_partdesc</name><argument_list>(<argument><expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>target_relid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DEFAULT partition of relation \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>AT_AP_IDName</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * Find partition by name.
			 * After PG12 merge, users may use pg syntax to do the partition maintenance,
			 * like ALTER TABLE ... DETACH/ATTACH PARTITION.
			 * This may cause the partition table's name different from GPDB's partition
			 * table name pattern &lt;parentname&gt;_&lt;level&gt;_prt_&lt;partition_name&gt;.
			 * When this happens, it's not possible to find the target partition table based
			 * on the name specified by the user.
			 *
			 * And if user do use the GPDB's syntax, we still have cases that the partition
			 * table's namespace different from it's parent namespace. See issue:
			 * https://github.com/greenplum-db/gpdb/issues/9903.
			 * Users could always use PARTITION FOR or pg syntax instead.
			 */</comment>
			<decl_stmt><decl><type><name>RangeVar</name>	<modifier>*</modifier></type><name>partrv</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>partname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>partRel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type> <name><name>partsubstring</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ancestors</name> <init>= <expr><call><name>get_partition_ancestors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>level</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type> <name><name>levelStr</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>levelStr</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>partsubstring</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"prt_%s"</literal></expr></argument>,
					 <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>partid</name><operator>-&gt;</operator><name>partiddef</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>partname</name> <operator>=</operator> <call><name>makeObjectName</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>levelStr</name></expr></argument>, <argument><expr><name>partsubstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>schemaname</name>   <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partrv</name>       <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>partname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partRel</name>      <operator>=</operator> <call><name>table_openrv_extended</name><argument_list>(<argument><expr><name>partrv</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>partRel</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>partRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		    <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>PartitionDesc</name></type>   <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>target_relid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/*
					 * Make sure the result partition table is the right one.
					 * Here check whether the target_relid belong to the parent
					 * through the partdesc-&gt;oids instead of call get_partition_parent
					 * is because the get_partition_parent scan from the disk.
					 * In-memory check should be faster.
					 */</comment>
					<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>target_relid</name> <operator>==</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>target_relid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>partRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>target_relid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition \"%s\" of \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>partid</name><operator>-&gt;</operator><name>partiddef</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>AT_AP_IDValue</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>partidx</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FormPartitionKeyDatumFromExpr</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>partid</name><operator>-&gt;</operator><name>partiddef</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>partidx</name> <operator>=</operator> <call><name>get_partition_for_tuple</name><argument_list>(<argument><expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>partdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>partidx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition for specified value of %s does not exist"</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>partidx</name></expr>]</index></name> <operator>==</operator>
					<call><name>get_default_oid_from_partdesc</name><argument_list>(<argument><expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FOR expression matches DEFAULT partition for specified value of relation \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"FOR expression may only specify a non-default partition in this context."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>target_relid</name> <operator>=</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>partidx</name></expr>]</index></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>AT_AP_IDNone</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not expected value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>target_relid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate partition key specification of a partitioned table
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionSpec</name> <modifier>*</modifier></type>
<name>generatePartitionSpec</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>   <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_partitioned_table</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>opclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>collation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> 		<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionSpec</name><modifier>*</modifier></type> <name>subpart</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionSpec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We cannot get the opclass oids of the partition keys directly from
	 * rel-&gt;rd_partkey because it only stores opcfamily oids and opcintype oids,
	 * and there are no syscache entries exists to lookup pg_opclass with those
	 * two values. Therefore we need to lookup pg_partitioned_table to fetch
	 * the opclass names. Since we have just opened the relation and built the
	 * partition descriptor, changes are high we hit the cache.
	 *
	 * We choose to as well use Form_pg_partitioned_table to fetch the partition
	 * attributes, their collations and expressions, even though we do have
	 * access to the same from rel-&gt;rd_partkey.
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing partition key information for oid %d"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Fixed-length attributes */</comment>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_partitioned_table</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>form</name><operator>-&gt;</operator><name>partstrat</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<expr_stmt><expr><name><name>subpart</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<expr_stmt><expr><name><name>subpart</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<expr_stmt><expr><name><name>subpart</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"hash"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name><name>subpart</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can rely on the first variable-length attribute being mapped to the
	 * relevant field of the catalog's C struct, because all previous
	 * attributes are non-nullable and fixed-length.
	 */</comment>
	<expr_stmt><expr><name>attrs</name> <operator>=</operator> <name><name>form</name><operator>-&gt;</operator><name>partattrs</name><operator>.</operator><name>values</name></name></expr>;</expr_stmt>

	<comment type="block">/* But use the hard way to retrieve further variable-length attributes */</comment>
	<comment type="block">/* Operator class */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_partitioned_table_partclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Collation */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_partitioned_table_partcollation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collation</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Expression */</comment>
	<expr_stmt><expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_partitioned_table_partexprs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SUBPARTITION BY contain expressions. Cannot ADD PARTITION if expressions in partition key using legacy syntax"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Table was created using new partition syntax. Hence, use CREATE TABLE... PARTITION OF instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>subpart</name><operator>-&gt;</operator><name>partParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>form</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionElem</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>  <name>attno</name> <init>= <expr><name><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opclassform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>collationform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opclassname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>collationname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tmptuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attno</name> <operator>&lt;=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Collect opfamily information */</comment>
		<expr_stmt><expr><name>tmptuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>opclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tmptuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name><name>opclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>opclassform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tmptuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opclassname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>opclassform</name><operator>-&gt;</operator><name>opcname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>opclass</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>opclassname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tmptuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Collect collation information */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>collation</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tmptuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>collation</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tmptuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"collation with OID %u does not exist"</literal></expr></argument>, <argument><expr><name><name>collation</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>collationform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tmptuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>collationname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>collationform</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>collationname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tmptuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>subpart</name><operator>-&gt;</operator><name>partParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subpart</name><operator>-&gt;</operator><name>partParams</name></name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>subpart</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RenameStmt</name> <modifier>*</modifier></type>
<name>generateRenameStmt</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>rstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>rstmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rstmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>rv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rstmt</name><operator>-&gt;</operator><name>subname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rstmt</name><operator>-&gt;</operator><name>newname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rstmt</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>rstmt</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type>
<name>generateAlterSchema</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>shstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>shstmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shstmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>rv</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shstmt</name><operator>-&gt;</operator><name>newschema</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shstmt</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>shstmt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ------------------------------
 * Implementation for command:
 *
 * ALTER TABLE &lt;tab&gt; EXCHANGE PARTITION &lt;oldpart&gt; with table &lt;newpart&gt;
 *
 * Above alter is converted into following sequence of cmds on QD:
 *
 * 1. ALTER TABLE &lt;tab&gt; DETACH PARTITION &lt;oldpart&gt;;
 * 2. ALTER TABLE &lt;tab&gt; ATTACH PARTITION &lt;oldpart&gt;;
 * 3. ALTER TABLE &lt;oldpart&gt; RENAME TO tmp;
 * 4. if namespace differ between oldpart and newpart
 *      a. ALTER TABLE &lt;tmp&gt; SET SCHEMA &lt;newpart_schema&gt;
 *      b. ALTER TABLE &lt;newpart&gt; RENAME TO &lt;tmp2&gt;
 *      c. ALTER TABLE &lt;tmp2&gt; SET SCHEMA &lt;oldpart_schema&gt;
 * 5. ALTER TABLE &lt;newpart&gt; RENAME TO &lt;oldpart&gt;;
 * 6. ALTER TABLE tmp RENAME TO &lt;newpart&gt;
 * ------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>AtExecGPExchangePartition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpAlterPartitionCmd</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GpAlterPartitionCmd</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>newpartrv</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <name><name>pc</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>boundspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>oldpartrv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>tmprv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	 <modifier>*</modifier></type><name>stmts</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	 <modifier>*</modifier></type><name>newpartname</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newpartrv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	 <name><name>tmpname2</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* detach oldpart partition cmd construction */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>atstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GpAlterPartitionId</name> <modifier>*</modifier></type><name>pid</name> <init>= <expr><operator>(</operator><name>GpAlterPartitionId</name> <operator>*</operator><operator>)</operator> <name><name>pc</name><operator>-&gt;</operator><name>partid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>atcmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>pcmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>tmpname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>partrelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>partrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>partrelid</name> <operator>=</operator> <call><name>GpFindTargetPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>partrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot EXCHANGE PARTITION for relation \"%s\" -- partition has children"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>oldpartrv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmpname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_temp_%u"</literal></expr></argument>, <argument><expr><name>partrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmprv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>tmpname</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get the oldpart's boundspec which will be used for attaching
		 * newpart. Fetch the tuple from the catcache, for speed. Relcache
		 * doesn't store the part bound hence need to fetch from catalog.
		 */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>partrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
									<argument><expr><name>Anum_pg_class_relpartbound</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>boundspec</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>boundspec</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pg_class tuple not found for relation %s"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pcmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>oldpartrv</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcmd</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_DetachPartition</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>pcmd</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>atcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>is_internal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> <comment type="block">/* set this to avoid transform */</comment>

		<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>atstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* attach newpart partition cmd construction */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>atstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlterTableCmd</name>  <modifier>*</modifier></type><name>atcmd</name>  <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionCmd</name>   <modifier>*</modifier></type><name>pcmd</name>   <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Relation</name></type> <name>newpartrel</name> <init>= <expr><call><name>table_openrv</name><argument_list>(<argument><expr><name>newpartrv</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>newpartrv</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>newpartrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpname2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmpname2</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_temp_%u"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>newpartrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>newpartrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pcmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>newpartrv</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcmd</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name>boundspec</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AttachPartition</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>pcmd</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>atcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>is_internal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> <comment type="block">/* set this to avoid transform */</comment>

		<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>atstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* rename oldpart to tmp */</comment>
	<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>generateRenameStmt</name><argument_list>(<argument><expr><name>oldpartrv</name></expr></argument>, <argument><expr><name><name>tmprv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if schema is different for tables, need to swap the schema
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>oldpartrv</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name><name>newpartrv</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* change schema for tmp to newpart schema */</comment>
		<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>generateAlterSchema</name><argument_list>(<argument><expr><name>tmprv</name></expr></argument>, <argument><expr><name><name>newpartrv</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* reflect new reality in temprv for later use */</comment>
		<expr_stmt><expr><name>tmprv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newpartrv</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>tmprv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* rename newpart to tmp2 */</comment>
		<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>generateRenameStmt</name><argument_list>(<argument><expr><name>newpartrv</name></expr></argument>, <argument><expr><name>tmpname2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* change schema for temp2 to oldpart schema */</comment>
		<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>generateAlterSchema</name><argument_list>(
							<argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newpartrv</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>tmpname2</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>oldpartrv</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* reflect new reality in newpartrv for later use */</comment>
		<expr_stmt><expr><name>newpartrv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>oldpartrv</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>tmpname2</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* rename newpart to oldpart */</comment>
	<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>generateRenameStmt</name><argument_list>(<argument><expr><name>newpartrv</name></expr></argument>, <argument><expr><name><name>oldpartrv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* rename tmp to newpart */</comment>
	<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>generateRenameStmt</name><argument_list>(<argument><expr><name>tmprv</name></expr></argument>, <argument><expr><name>newpartname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stmts</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>AtExecGPSplitPartition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpSplitPartitionCmd</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GpSplitPartitionCmd</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>oldpartrv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>tmprv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>boundspec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p_tablespacename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p_accessMethod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>p_colencs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>p_reloptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>defaultpartname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>partrelid</name></decl>;</decl_stmt>

	<comment type="block">/* detach current partition */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GpAlterPartitionId</name> <modifier>*</modifier></type><name>pid</name> <init>= <expr><operator>(</operator><name>GpAlterPartitionId</name> <operator>*</operator><operator>)</operator> <name><name>pc</name><operator>-&gt;</operator><name>partid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>atstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>atcmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>pcmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>tmpname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>partrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>partrelid</name> <operator>=</operator> <call><name>GpFindTargetPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>partrelid</name> <operator>==</operator> <call><name>get_default_oid_from_partdesc</name><argument_list>(<argument><expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>defaultpartname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>defaultpartname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>partrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot SPLIT PARTITION for relation \"%s\" -- partition has children"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try splitting the child partitions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>oldpartrv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmpname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_temp_%u"</literal></expr></argument>, <argument><expr><name>partrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmprv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>tmpname</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get the part's boundspec. Fetch the tuple from the
		 * catcache, for speed. Relcache doesn't store the part bound
		 * hence need to fetch from catalog.
		 */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>partrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
									<argument><expr><name>Anum_pg_class_relpartbound</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>boundspec</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>boundspec</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
									<argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>p_reloptions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>p_reloptions</name> <operator>=</operator> <call><name>untransformRelOptions</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pg_class tuple not found for relation %s"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>p_tablespacename</name> <operator>=</operator> <call><name>get_tablespace_name</name><argument_list>(<argument><expr><name><name>partrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p_accessMethod</name> <operator>=</operator> <call><name>get_am_name</name><argument_list>(<argument><expr><name><name>partrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p_colencs</name> <operator>=</operator> <call><name>rel_get_column_encodings</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pcmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>oldpartrv</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcmd</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_DetachPartition</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>pcmd</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>atcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>atstmt</name><operator>-&gt;</operator><name>is_internal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> <comment type="block">/* set this to avoid transform */</comment>

		<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>atstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* rename old part to temp */</comment>
	<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>generateRenameStmt</name><argument_list>(<argument><expr><name>oldpartrv</name></expr></argument>, <argument><expr><name><name>tmprv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create new partitions */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>partname_comp</name></type>       <name>partcomp</name>    <init>= <expr><block>{<expr><operator>.</operator><name>tablename</name><operator>=</operator><name>NULL</name></expr>, <expr><operator>.</operator><name>level</name><operator>=</operator><literal type="number">0</literal></expr>, <expr><operator>.</operator><name>partnum</name><operator>=</operator><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>                <modifier>*</modifier></type><name>ancestors</name>  <init>= <expr><call><name>get_partition_ancestors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GpPartDefElem</name>       <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionBoundSpec</name>  <modifier>*</modifier></type><name>boundspec1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionBoundSpec</name>  <modifier>*</modifier></type><name>boundspec2</name> <init>= <expr><name>boundspec</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionKey</name></type>        <name>partkey</name>     <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParseState</name>          <modifier>*</modifier></type><name>pstate</name>     <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>                <modifier>*</modifier></type><name>part_col_name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>                 <name>part_col_typid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>               <name>part_col_typmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>                 <name>part_col_collation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GpAlterPartitionCmd</name> <modifier>*</modifier></type><name>into</name> <init>= <expr><operator>(</operator><name>GpAlterPartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>pc</name><operator>-&gt;</operator><name>arg2</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>			<modifier>*</modifier></type><name>partname1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>			<modifier>*</modifier></type><name>partname2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>queryString</name></name></expr>;</expr_stmt>

		<comment type="block">/* Extract the two partition names from the INTO (&lt;part1&gt;, &lt;part2&gt;) clause */</comment>
		<if_stmt><if>if <condition>(<expr><name>into</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GpAlterPartitionId</name> <modifier>*</modifier></type><name>partid1</name> <init>= <expr><name><name>into</name><operator>-&gt;</operator><name>partid</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GpAlterPartitionId</name> <modifier>*</modifier></type><name>partid2</name> <init>= <expr><operator>(</operator><name>GpAlterPartitionId</name> <operator>*</operator><operator>)</operator> <name><name>into</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Oid</name></type>			<name>intorel1</name> <init>= <expr><call><name>GpFindTargetPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>partid1</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>intorel2</name> <init>= <expr><call><name>GpFindTargetPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>partid2</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>intorel1</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name>intorel2</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"both INTO partitions already exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If we're splitting the default partition, the INTO clause must
			 * include the default partition. Either as DEFAULT PARTITION, or by name.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>defaultpartname</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>intorel1</name> <operator>==</operator> <name>partrelid</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>partid2</name><operator>-&gt;</operator><name>idtype</name></name> <operator>!=</operator> <name>AT_AP_IDName</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new partition in INTO clause must be given by name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>partid2</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>partname1</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name><name>partid2</name><operator>-&gt;</operator><name>partiddef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>intorel2</name> <operator>==</operator> <name>partrelid</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>partid1</name><operator>-&gt;</operator><name>idtype</name></name> <operator>!=</operator> <name>AT_AP_IDName</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new partition in INTO clause must be given by name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>partid1</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>partname1</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name><name>partid1</name><operator>-&gt;</operator><name>partiddef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"default partition name missing from INTO clause"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>partid1</name><operator>-&gt;</operator><name>idtype</name></name> <operator>!=</operator> <name>AT_AP_IDName</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INTO can only have first partition by name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>partid1</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>partid2</name><operator>-&gt;</operator><name>idtype</name></name> <operator>!=</operator> <name>AT_AP_IDName</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INTO can only have first partition by name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>partid1</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>partname1</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name><name>partid1</name><operator>-&gt;</operator><name>partiddef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>partname2</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name><name>partid2</name><operator>-&gt;</operator><name>partiddef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partcomp</name><operator>.</operator><name>level</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>part_col_name</name>      <operator>=</operator>
			<call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>part_col_typid</name>     <operator>=</operator> <call><name>get_partition_col_typid</name><argument_list>(<argument><expr><name>partkey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>part_col_typmod</name>    <operator>=</operator> <call><name>get_partition_col_typmod</name><argument_list>(<argument><expr><name>partkey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>part_col_collation</name> <operator>=</operator> <call><name>get_partition_col_collation</name><argument_list>(<argument><expr><name>partkey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>boundspec1</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundspec1</name><operator>-&gt;</operator><name>strategy</name></name>   <operator>=</operator> <name><name>boundspec</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundspec1</name><operator>-&gt;</operator><name>is_default</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>boundspec</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GpPartitionRangeItem</name> <modifier>*</modifier></type><name>startItem</name> <init>= <expr><name><name>pc</name><operator>-&gt;</operator><name>start</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>GpPartitionRangeItem</name> <modifier>*</modifier></type><name>endItem</name> 	<init>= <expr><name><name>pc</name><operator>-&gt;</operator><name>end</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name> 				 <modifier>*</modifier></type><name>at</name> <init>= <expr><name><name>pc</name><operator>-&gt;</operator><name>at</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name> 				 <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>				 <name>startExclusive</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name> 				 <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>				 <name>endInclusive</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>startItem</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>endItem</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>at</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
					   <operator>(</operator><name>startItem</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>endItem</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>at</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>start</name> <operator>=</operator> <ternary><condition><expr><name>startItem</name></expr> ?</condition><then> <expr><name><name>startItem</name><operator>-&gt;</operator><name>val</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
				<expr_stmt><expr><name>end</name> <operator>=</operator> <ternary><condition><expr><name>endItem</name></expr> ?</condition><then> <expr><name><name>endItem</name><operator>-&gt;</operator><name>val</name></name></expr> </then><else>: <expr><name>at</name></expr></else></ternary></expr>;</expr_stmt>
				<expr_stmt><expr><name>startExclusive</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>startItem</name> <operator>&amp;&amp;</operator> <name><name>startItem</name><operator>-&gt;</operator><name>edge</name></name> <operator>==</operator> <name>PART_EDGE_EXCLUSIVE</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
				<expr_stmt><expr><name>endInclusive</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>endItem</name> <operator>&amp;&amp;</operator> <name><name>endItem</name><operator>-&gt;</operator><name>edge</name></name> <operator>==</operator> <name>PART_EDGE_INCLUSIVE</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>endConst</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of END values should cover all partition key columns"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>end</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>endConst</name> <operator>=</operator> <call><name>transformPartitionBoundValue</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
															<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>,
															<argument><expr><name>part_col_name</name></expr></argument>,
															<argument><expr><name>part_col_typid</name></expr></argument>,
															<argument><expr><name>part_col_typmod</name></expr></argument>,
															<argument><expr><name>part_col_collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>endConst</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use NULL with range partition specification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,	<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>endInclusive</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>convert_exclusive_start_inclusive_end</name><argument_list>(<argument><expr><name>endConst</name></expr></argument>, <argument><expr><name>part_col_typid</name></expr></argument>, <argument><expr><name>part_col_typmod</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>endConst</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>boundspec1</name><operator>-&gt;</operator><name>upperdatums</name></name> <operator>=</operator>
							<call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeConst</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><call><name>datumCopy</name><argument_list>(<argument><expr><name><name>endConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
														   <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
														   <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>,
												 <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>endInclusive</name> <operator>==</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>maxvalue</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name><name>maxvalue</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"maxvalue"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>boundspec1</name><operator>-&gt;</operator><name>upperdatums</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>maxvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>start</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>startConst</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>partkey</name><operator>-&gt;</operator><name>partnatts</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of START values should cover all partition key columns"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>start</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>startConst</name> <operator>=</operator> <call><name>transformPartitionBoundValue</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
															  <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>,
															  <argument><expr><name>part_col_name</name></expr></argument>,
															  <argument><expr><name>part_col_typid</name></expr></argument>,
															  <argument><expr><name>part_col_typmod</name></expr></argument>,
															  <argument><expr><name>part_col_collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>startConst</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use NULL with range partition specification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>startExclusive</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>convert_exclusive_start_inclusive_end</name><argument_list>(<argument><expr><name>startConst</name></expr></argument>,
															  <argument><expr><name>part_col_typid</name></expr></argument>, <argument><expr><name>part_col_typmod</name></expr></argument>,
															  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>boundspec1</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>=</operator>
						<call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeConst</name><argument_list>(<argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
											 <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
											 <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
											 <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
											 <argument><expr><call><name>datumCopy</name><argument_list>(<argument><expr><name><name>startConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
													   <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
													   <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><name><name>partkey</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>defaultpartname</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"AT clause cannot be used when splitting a default RANGE partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Start not-specified means splitting non-default
					 * partition. Use existing partitions lowerdatum as start
					 * for this partition.
					 */</comment>
					<expr_stmt><expr><name><name>boundspec1</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>=</operator> <name><name>boundspec2</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>boundspec2</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>=</operator>
						<call><name>copyObject</name><argument_list>(<argument><expr><name><name>boundspec1</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

			<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	 <modifier>*</modifier></type><name>at</name> <init>= <expr><name><name>pc</name><operator>-&gt;</operator><name>at</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>boundspec_newvals</name> <init>= <expr><name>boundspec1</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>boundspec_remainingvals</name> <init>= <expr><name>boundspec2</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>pc</name><operator>-&gt;</operator><name>start</name></name> <operator>||</operator> <name><name>pc</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot SPLIT LIST PARTITION with START"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use SPLIT with the AT clause instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>partcomp</name><operator>.</operator><name>level</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SPLIT PARTITION is not currently supported when leaf partition is list partitioned in multi level partition table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>at</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>at</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>  <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>transformPartitionBoundValue</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
														 <argument><expr><name>expr</name></expr></argument>,
														 <argument><expr><name>part_col_name</name></expr></argument>,
														 <argument><expr><name>part_col_typid</name></expr></argument>,
														 <argument><expr><name>part_col_typmod</name></expr></argument>,
														 <argument><expr><name>part_col_collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Skip if the value is already moved to the new list */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name><name>boundspec_newvals</name><operator>-&gt;</operator><name>listdatums</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>boundspec_remainingvals</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><name><name>boundspec_remainingvals</name><operator>-&gt;</operator><name>listdatums</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"AT clause parameter is not a member of the target partition specification"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><name><name>boundspec_remainingvals</name><operator>-&gt;</operator><name>listdatums</name></name> <operator>=</operator>
							<call><name>list_delete</name><argument_list>(<argument><expr><name><name>boundspec_remainingvals</name><operator>-&gt;</operator><name>listdatums</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>boundspec_remainingvals</name><operator>-&gt;</operator><name>listdatums</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"AT clause cannot contain all values in the partition to be split"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name><name>boundspec_newvals</name><operator>-&gt;</operator><name>listdatums</name></name> <operator>=</operator>
						<call><name>lappend</name><argument_list>(<argument><expr><name><name>boundspec_newvals</name><operator>-&gt;</operator><name>listdatums</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* if splitting default partition, new partition is created first and default later */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>defaultpartname</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>boundspec1</name> <operator>=</operator> <name>boundspec_remainingvals</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>boundspec2</name> <operator>=</operator> <name>boundspec_newvals</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition strategy: %c not supported by SPLIT partition"</literal></expr></argument>,
								<argument><expr><name><name>boundspec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,	<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><name><name>boundspec1</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GpPartDefElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>tablespacename</name></name> <operator>=</operator> <name>p_tablespacename</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <name>p_accessMethod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>colencs</name></name> <operator>=</operator> <name>p_colencs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elem</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>p_reloptions</name></expr>;</expr_stmt>

		<comment type="block">/* create first partition stmt */</comment>
		<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><call><name>makePartitionCreateStmt</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>partname1</name></expr></argument>, <argument><expr><name>boundspec1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>partcomp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* create second partition stmt */</comment>
		<if_stmt><if>if <condition>(<expr><name>defaultpartname</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>partcomp</name><operator>.</operator><name>tablename</name></name> <operator>=</operator> <name>defaultpartname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>partname2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><call><name>makePartitionCreateStmt</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>partname2</name></expr></argument>, <argument><expr><name>boundspec2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>partcomp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>stmts</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* No planning needed, just make a wrapper PlannedStmt */</comment>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>,
					   <argument><expr><name>synthetic_sql</name></expr></argument>,
					   <argument><expr><name>PROCESS_UTILITY_SUBCOMMAND</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>,
					   <argument><expr><name>None_Receiver</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* insert into parent select * from tmp */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO %s.%s SELECT * FROM %s.%s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>tmprv</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>tmprv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>execute_sql_string</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* drop tmp table */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>DropStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>dropstmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(
			<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>tmprv</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>tmprv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dropstmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dropstmt</name><operator>-&gt;</operator><name>behavior</name></name> <operator>=</operator> <name>DROP_CASCADE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dropstmt</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>stmts</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>dropstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>stmts</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>GpAlterPartMetaTrackUpdObject</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AlterTableType</name></type> <name>subcmdtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>subtype</name></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name>subcmdtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AT_PartTruncate</name></expr>:</case>
			<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"TRUNCATE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_PartAdd</name></expr>:</case>
			<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"ADD"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_PartDrop</name></expr>:</case>
			<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"DROP"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_PartExchange</name></expr>:</case>
			<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"EXCHANGE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_PartSplit</name></expr>:</case>
			<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"SPLIT"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_SetDistributedBy</name></expr>:</case>
			<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"SET DISTRIBUTED BY"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>
			<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"SET TABLESPACE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_PartSetTemplate</name></expr>:</case>
			<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"SET TEMPLATE"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AT_PartRename</name></expr>:</case>
			<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"RENAME"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="string">"UNKNOWN ALTER PARTITION COMMAND"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>MetaTrackUpdObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
					   <argument><expr><name>relid</name></expr></argument>,
					   <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
					   <argument><expr><literal type="string">"PARTITION"</literal></expr></argument>,
					   <argument><expr><name>subtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ATExecGPPartCmds</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>origrel</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><name>origrel</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_PartAlter</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GpAlterPartitionCmd</name> <modifier>*</modifier></type><name>pc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GpAlterPartitionId</name>  <modifier>*</modifier></type><name>pid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>                 <name>partrelid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pc</name>  <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>GpAlterPartitionCmd</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pid</name> <operator>=</operator> <operator>(</operator><name>GpAlterPartitionId</name> <operator>*</operator><operator>)</operator> <name><name>pc</name><operator>-&gt;</operator><name>partid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <name><name>pc</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" is not partitioned"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>partrelid</name> <operator>=</operator> <call><name>GpFindTargetPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>origrel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Most ALTER PARTITION commands are to ADD/DROP subpartitions, and don't
	 * make sense unless the partition itself is a partitioned table. SET
	 * DISTRIBUTED BY and SET TABLESPACE are exceptions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>!=</operator> <name>AT_SetDistributedBy</name> <operator>&amp;&amp;</operator>
		<name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>!=</operator> <name>AT_SetTableSpace</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" is not partitioned"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AT_PartTruncate</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GpAlterPartitionCmd</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GpAlterPartitionCmd</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GpAlterPartitionId</name> <modifier>*</modifier></type><name>pid</name> <init>= <expr><operator>(</operator><name>GpAlterPartitionId</name> <operator>*</operator><operator>)</operator> <name><name>pc</name><operator>-&gt;</operator><name>partid</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TruncateStmt</name> <modifier>*</modifier></type><name>truncstmt</name> <init>= <expr><operator>(</operator><name>TruncateStmt</name> <operator>*</operator><operator>)</operator> <name><name>pc</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>partrelid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type> <name>partrel</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>partrelid</name> <operator>=</operator> <call><name>GpFindTargetPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>truncstmt</name><operator>-&gt;</operator><name>relations</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>truncstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<break>break;</break>

		<case>case <expr><name>AT_PartAdd</name></expr>:</case>			<comment type="block">/* Add */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GpAlterPartitionCmd</name>		<modifier>*</modifier></type><name>add_cmd</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GpAlterPartitionCmd</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GpPartitionDefinition</name>	<modifier>*</modifier></type><name>gpPartDef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GpPartitionDefinition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GpPartDefElem</name>			<modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GpPartDefElem</name></expr></argument>, <argument><expr><name><name>add_cmd</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionSpec</name>			<modifier>*</modifier></type><name>subpart</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type> 				<name>temprel</name> <init>= <expr><name>rel</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionSpec</name> 			<modifier>*</modifier></type><name>tempsubpart</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> 				<modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>					<modifier>*</modifier></type><name>ancestors</name> <init>= <expr><call><name>get_partition_ancestors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>						 <name>level</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>gpPartDef</name><operator>-&gt;</operator><name>partDefElems</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gpPartDef</name><operator>-&gt;</operator><name>fromCatalog</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Populate PARTITION BY spec for each level of the parents
			 * in the partitioning hierarchy. The PartitionSpec or a chain of
			 * PartitionSpecs if subpartitioning exists, are generated based on
			 * the first existing partition of each partition depth.
			 */</comment>
			<do>do
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionDesc</name></type>	<name>partdesc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PartitionSpec</name> <modifier>*</modifier></type><name>temptempsubpart</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>firstchildoid</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>temprel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>partdesc</name> <operator>=</operator> <call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>temprel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GPDB add partition syntax needs at least one sibling to exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>is_leaf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>temprel</name> <operator>!=</operator> <name>rel</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>temprel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>firstchildoid</name> <operator>=</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>temprel</name> <operator>!=</operator> <name>rel</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>temprel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>temprel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>firstchildoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>temptempsubpart</name> <operator>=</operator> <call><name>generatePartitionSpec</name><argument_list>(<argument><expr><name>temprel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>temptempsubpart</name><operator>-&gt;</operator><name>gpPartDef</name></name> <operator>=</operator> <call><name>GetGpPartitionTemplate</name><argument_list>(
					<argument><expr><ternary><condition><expr><name>ancestors</name></expr> ?</condition><then> <expr><call><name>llast_oid</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>tempsubpart</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>subpart</name> <operator>=</operator> <name>tempsubpart</name> <operator>=</operator> <name>temptempsubpart</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>tempsubpart</name><operator>-&gt;</operator><name>subPartSpec</name></name> <operator>=</operator> <name>temptempsubpart</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tempsubpart</name> <operator>=</operator> <name><name>tempsubpart</name><operator>-&gt;</operator><name>subPartSpec</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block> while <condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>gpPartDef</name><operator>-&gt;</operator><name>fromCatalog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>gpPartDef</name> <operator>=</operator> <call><name>transformGpPartitionDefinition</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>queryString</name></name></expr></argument>, <argument><expr><name>gpPartDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>gpPartDef</name><operator>-&gt;</operator><name>isTemplate</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>StoreGpPartitionTemplate</name><argument_list>(<argument><expr><ternary><condition><expr><name>ancestors</name></expr> ?</condition><then> <expr><call><name>llast_oid</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
										 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gpPartDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cstmts</name> <init>= <expr><call><name>generatePartitions</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>gpPartDef</name></expr></argument>, <argument><expr><name>subpart</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>queryString</name></name></expr></argument>,
											  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>cstmts</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block>
		<break>break;</break>

		<case>case <expr><name>AT_PartDrop</name></expr>:</case>			<comment type="block">/* Drop */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GpDropPartitionCmd</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GpDropPartitionCmd</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GpAlterPartitionId</name> <modifier>*</modifier></type><name>pid</name> <init>= <expr><operator>(</operator><name>GpAlterPartitionId</name> <operator>*</operator><operator>)</operator> <name><name>pc</name><operator>-&gt;</operator><name>partid</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>DropStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>partrelid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type> <name>partrel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>partrelid</name> <operator>=</operator> <call><name>GpFindTargetPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>pc</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>partrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partdesc</name> <operator>=</operator> <call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If two drop partition cmds are specified in same alter table stmt,
			 * the blow check still works to make sure the partitioned table at least
			 * have one partition table.
			 * When the first drop get executed, the catalog will have an update which make
			 * current Relation get invalid and call RelationClearRelation to refresh
			 * the Relation. After that the next drop cmd will have partdesc-&gt;nparts = 1,
			 * and raise error to abort.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop partition \"%s\" of \"%s\" -- only one remains"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use DROP TABLE \"%s\" to remove the table and the final partition "</literal></expr></argument>,
								 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>dropstmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(
				<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(
							   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dropstmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dropstmt</name><operator>-&gt;</operator><name>behavior</name></name> <operator>=</operator> <name><name>pc</name><operator>-&gt;</operator><name>behavior</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dropstmt</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name><name>pc</name><operator>-&gt;</operator><name>missing_ok</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>dropstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<break>break;</break>

		<case>case <expr><name>AT_PartExchange</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>returnstmt</name> <init>= <expr><call><name>AtExecGPExchangePartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>returnstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<break>break;</break>

		<case>case <expr><name>AT_PartSplit</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>returnstmt</name> <init>= <expr><call><name>AtExecGPSplitPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>returnstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<break>break;</break>

		<case>case <expr><name>AT_SetDistributedBy</name></expr>:</case>
		<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>newstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>newstmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newstmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newstmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newstmt</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>newstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<break>break;</break>

		<case>case <expr><name>AT_PartSetTemplate</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GpAlterPartitionCmd</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GpAlterPartitionCmd</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GpPartitionDefinition</name> <modifier>*</modifier></type><name>templateDef</name> <init>= <expr><operator>(</operator><name>GpPartitionDefinition</name> <operator>*</operator><operator>)</operator> <name><name>pc</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name> <init>= <expr><call><name>get_partition_ancestors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>topParentrelid</name> <init>= <expr><ternary><condition><expr><name>ancestors</name></expr> ?</condition><then> <expr><call><name>llast_oid</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>templateDef</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Relation</name></type> <name>firstrel</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>firstchildoid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GPDB SET SUBPARTITION TEMPLATE syntax needs at least one sibling to exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>firstchildoid</name> <operator>=</operator> <name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>firstrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>firstchildoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>firstrel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"level %d is not partitioned and hence can't set subpartition template for the same"</literal></expr></argument>,
									   <argument><expr><name>level</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>firstrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nparts</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GPDB SET SUBPARTITION TEMPLATE syntax needs at least one sibling to exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* if this is not leaf level partition then sub-partition must exist for next level */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>firstrel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>is_leaf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>GetGpPartitionTemplate</name><argument_list>(<argument><expr><name>topParentrelid</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can't add sub-partition template at level %d since next level template doesn't exist"</literal></expr></argument>,
										<argument><expr><name>level</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Add sub-partition template for next level."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * call generatePartitions() using first child's PartitionKey to
				 * add partitions, just to validate the subpartition template,
				 * if anything wrong it will error out.
				 */</comment>
				<expr_stmt><expr><name>templateDef</name> <operator>=</operator> <call><name>transformGpPartitionDefinition</name><argument_list>(<argument><expr><name>firstchildoid</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>queryString</name></name></expr></argument>, <argument><expr><name>templateDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>generatePartitions</name><argument_list>(<argument><expr><name>firstchildoid</name></expr></argument>, <argument><expr><name>templateDef</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>queryString</name></name></expr></argument>,
								   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>firstrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>StoreGpPartitionTemplate</name><argument_list>(<argument><expr><name>topParentrelid</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>templateDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>removed</name> <init>= <expr><call><name>RemoveGpPartitionTemplate</name><argument_list>(<argument><expr><name>topParentrelid</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>removed</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not have a level %d subpartition template specification"</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>origrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>origrel</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block>
		<break>break;</break>

		<case>case <expr><name>AT_PartRename</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GpAlterPartitionCmd</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GpAlterPartitionCmd</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GpAlterPartitionId</name> <modifier>*</modifier></type><name>pid</name> <init>= <expr><operator>(</operator><name>GpAlterPartitionId</name> <operator>*</operator><operator>)</operator> <name><name>pc</name><operator>-&gt;</operator><name>partid</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newpartname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>pc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>renStmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>namespaceId</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newrelname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type> <name><name>targetrelname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name> <init>= <expr><call><name>get_partition_ancestors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>partrelid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type> <name>targetrelation</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>partrelid</name> <operator>=</operator> <call><name>GpFindTargetPartition</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>targetrelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>partrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>targetrelname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* the "label" portion of the new relation is prt_`newpartname',
			 * and makeObjectName won't truncate this portion of the partition
			 * name -- it will assert instead.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>newpartname</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <operator>(</operator><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">8</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"name \"%s\" for child partition is too long"</literal></expr></argument>,
								<argument><expr><name>newpartname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>newrelname</name> <operator>=</operator> <call><name>ChoosePartitionName</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>,
											 <argument><expr><name>newpartname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>renStmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>renStmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>targetrelname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>renStmt</name><operator>-&gt;</operator><name>newname</name></name> <operator>=</operator> <name>newrelname</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * rename stmt is only constructed for specified table here. If it
			 * happens to be Partitioned Table, then RenameRelationInternal()
			 * will recurse to its child partitions and perform renames.
			 */</comment>
			<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>renStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>origrel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>stmts</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* No planning needed, just make a wrapper PlannedStmt */</comment>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ProcessUtility</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>,
					   <argument><expr><name>synthetic_sql</name></expr></argument>,
					   <argument><expr><name>PROCESS_UTILITY_SUBCOMMAND</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>,
					   <argument><expr><name>None_Receiver</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* 
	 * The pg_stat_last_operation table contains metadata tracking 
	 * information about operations on database objects. Greenplum 
	 * Database updates this table when a database object is 
	 * created, altered, truncated, vacuumed, analyzed, or 
	 * partitioned, and when privileges are granted to an object.
	 * GpAlterPartMetaTrackUpdObject() will update 
	 * pg_stat_last_operation for GPDB specific alter partition 
	 * commands. 
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>GpAlterPartMetaTrackUpdObject</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This function calls RenameRelationInternal() for all child partitions of
 * the targetrelation. This function should only be called for
 * RELKIND_PARTITIONED_TABLE. Rename is performed only if child partition name
 * contains oldparentrelname as prefix else skipped.
 *
 * This function is called on QD and QE to recurse and perform renamaes,
 * instead of constructing RenameStmt on QD and dispatching stmt via
 * ProcessUtility().
 */</comment>
<function><type><name>void</name></type>
<name>GpRenameChildPartitions</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>targetrelation</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldparentrelname</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newparentrelname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>skipped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>renamed</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>oids</name> <init>= <expr><call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>targetrelation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* remove parent from the list */</comment>
	<expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>oids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>part_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>newpartname</name><index>[<expr><name>NAMEDATALEN</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>partrel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>part_oid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* don't release the lock till end of transaction */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>partrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The child name should contain the old parent name as a prefix - check
		 * the length and compare to make sure.
		 *
		 * To build the new child name, just use the new name as a prefix, and use
		 * the remainder of the child name (the part after the old parent name
		 * prefix) as the suffix.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>oldparentrelname</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator>
			<operator>&amp;&amp;</operator> <operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>oldparentrelname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>oldparentrelname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>newpartname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>newpartname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
					 <argument><expr><name>newparentrelname</name></expr></argument>, <argument><expr><name>relname</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>oldparentrelname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>newpartname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>NAMEDATALEN</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RenameRelationInternal</name><argument_list>(<argument><expr><name>part_oid</name></expr></argument>, <argument><expr><name>newpartname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>renamed</name><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>skipped</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>skipped</name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"renamed %d relations, skipped %d child partitions as old parent name is not part of partition name"</literal></expr></argument>,
			 <argument><expr><name>renamed</name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
